// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_LIVE20161101_H_
#define ALIBABACLOUD_LIVE20161101_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Live20161101 {
class AddCasterComponentRequest : public Darabonba::Model {
public:
  shared_ptr<string> captionLayerContent{};
  shared_ptr<string> casterId{};
  shared_ptr<string> componentLayer{};
  shared_ptr<string> componentName{};
  shared_ptr<string> componentType{};
  shared_ptr<string> effect{};
  shared_ptr<string> htmlLayerContent{};
  shared_ptr<string> imageLayerContent{};
  shared_ptr<string> layerOrder{};
  shared_ptr<string> locationId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> textLayerContent{};

  AddCasterComponentRequest() {}

  explicit AddCasterComponentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (captionLayerContent) {
      res["CaptionLayerContent"] = boost::any(*captionLayerContent);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentLayer) {
      res["ComponentLayer"] = boost::any(*componentLayer);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (componentType) {
      res["ComponentType"] = boost::any(*componentType);
    }
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (htmlLayerContent) {
      res["HtmlLayerContent"] = boost::any(*htmlLayerContent);
    }
    if (imageLayerContent) {
      res["ImageLayerContent"] = boost::any(*imageLayerContent);
    }
    if (layerOrder) {
      res["LayerOrder"] = boost::any(*layerOrder);
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (textLayerContent) {
      res["TextLayerContent"] = boost::any(*textLayerContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaptionLayerContent") != m.end() && !m["CaptionLayerContent"].empty()) {
      captionLayerContent = make_shared<string>(boost::any_cast<string>(m["CaptionLayerContent"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentLayer") != m.end() && !m["ComponentLayer"].empty()) {
      componentLayer = make_shared<string>(boost::any_cast<string>(m["ComponentLayer"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("ComponentType") != m.end() && !m["ComponentType"].empty()) {
      componentType = make_shared<string>(boost::any_cast<string>(m["ComponentType"]));
    }
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("HtmlLayerContent") != m.end() && !m["HtmlLayerContent"].empty()) {
      htmlLayerContent = make_shared<string>(boost::any_cast<string>(m["HtmlLayerContent"]));
    }
    if (m.find("ImageLayerContent") != m.end() && !m["ImageLayerContent"].empty()) {
      imageLayerContent = make_shared<string>(boost::any_cast<string>(m["ImageLayerContent"]));
    }
    if (m.find("LayerOrder") != m.end() && !m["LayerOrder"].empty()) {
      layerOrder = make_shared<string>(boost::any_cast<string>(m["LayerOrder"]));
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("TextLayerContent") != m.end() && !m["TextLayerContent"].empty()) {
      textLayerContent = make_shared<string>(boost::any_cast<string>(m["TextLayerContent"]));
    }
  }


  virtual ~AddCasterComponentRequest() = default;
};
class AddCasterComponentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> componentId{};
  shared_ptr<string> requestId{};

  AddCasterComponentResponseBody() {}

  explicit AddCasterComponentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterComponentResponseBody() = default;
};
class AddCasterComponentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterComponentResponseBody> body{};

  AddCasterComponentResponse() {}

  explicit AddCasterComponentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterComponentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterComponentResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterComponentResponse() = default;
};
class AddCasterEpisodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeName{};
  shared_ptr<string> episodeType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> switchType{};

  AddCasterEpisodeRequest() {}

  explicit AddCasterEpisodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeName) {
      res["EpisodeName"] = boost::any(*episodeName);
    }
    if (episodeType) {
      res["EpisodeType"] = boost::any(*episodeType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (switchType) {
      res["SwitchType"] = boost::any(*switchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeName") != m.end() && !m["EpisodeName"].empty()) {
      episodeName = make_shared<string>(boost::any_cast<string>(m["EpisodeName"]));
    }
    if (m.find("EpisodeType") != m.end() && !m["EpisodeType"].empty()) {
      episodeType = make_shared<string>(boost::any_cast<string>(m["EpisodeType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SwitchType") != m.end() && !m["SwitchType"].empty()) {
      switchType = make_shared<string>(boost::any_cast<string>(m["SwitchType"]));
    }
  }


  virtual ~AddCasterEpisodeRequest() = default;
};
class AddCasterEpisodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> episodeId{};
  shared_ptr<string> requestId{};

  AddCasterEpisodeResponseBody() {}

  explicit AddCasterEpisodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterEpisodeResponseBody() = default;
};
class AddCasterEpisodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterEpisodeResponseBody> body{};

  AddCasterEpisodeResponse() {}

  explicit AddCasterEpisodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterEpisodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterEpisodeResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterEpisodeResponse() = default;
};
class AddCasterEpisodeGroupRequestItem : public Darabonba::Model {
public:
  shared_ptr<string> itemName{};
  shared_ptr<string> vodUrl{};

  AddCasterEpisodeGroupRequestItem() {}

  explicit AddCasterEpisodeGroupRequestItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (vodUrl) {
      res["VodUrl"] = boost::any(*vodUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("VodUrl") != m.end() && !m["VodUrl"].empty()) {
      vodUrl = make_shared<string>(boost::any_cast<string>(m["VodUrl"]));
    }
  }


  virtual ~AddCasterEpisodeGroupRequestItem() = default;
};
class AddCasterEpisodeGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> domainName{};
  shared_ptr<vector<AddCasterEpisodeGroupRequestItem>> item{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> repeatNum{};
  shared_ptr<string> sideOutputUrl{};
  shared_ptr<string> startTime{};

  AddCasterEpisodeGroupRequest() {}

  explicit AddCasterEpisodeGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (repeatNum) {
      res["RepeatNum"] = boost::any(*repeatNum);
    }
    if (sideOutputUrl) {
      res["SideOutputUrl"] = boost::any(*sideOutputUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<AddCasterEpisodeGroupRequestItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasterEpisodeGroupRequestItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<AddCasterEpisodeGroupRequestItem>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RepeatNum") != m.end() && !m["RepeatNum"].empty()) {
      repeatNum = make_shared<long>(boost::any_cast<long>(m["RepeatNum"]));
    }
    if (m.find("SideOutputUrl") != m.end() && !m["SideOutputUrl"].empty()) {
      sideOutputUrl = make_shared<string>(boost::any_cast<string>(m["SideOutputUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~AddCasterEpisodeGroupRequest() = default;
};
class AddCasterEpisodeGroupResponseBodyItemIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> itemId{};

  AddCasterEpisodeGroupResponseBodyItemIds() {}

  explicit AddCasterEpisodeGroupResponseBodyItemIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ItemId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      itemId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddCasterEpisodeGroupResponseBodyItemIds() = default;
};
class AddCasterEpisodeGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddCasterEpisodeGroupResponseBodyItemIds> itemIds{};
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  AddCasterEpisodeGroupResponseBody() {}

  explicit AddCasterEpisodeGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemIds) {
      res["ItemIds"] = itemIds ? boost::any(itemIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemIds"].type()) {
        AddCasterEpisodeGroupResponseBodyItemIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemIds"]));
        itemIds = make_shared<AddCasterEpisodeGroupResponseBodyItemIds>(model1);
      }
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterEpisodeGroupResponseBody() = default;
};
class AddCasterEpisodeGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterEpisodeGroupResponseBody> body{};

  AddCasterEpisodeGroupResponse() {}

  explicit AddCasterEpisodeGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterEpisodeGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterEpisodeGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterEpisodeGroupResponse() = default;
};
class AddCasterEpisodeGroupContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> content{};
  shared_ptr<long> ownerId{};

  AddCasterEpisodeGroupContentRequest() {}

  explicit AddCasterEpisodeGroupContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~AddCasterEpisodeGroupContentRequest() = default;
};
class AddCasterEpisodeGroupContentResponseBodyItemIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> itemId{};

  AddCasterEpisodeGroupContentResponseBodyItemIds() {}

  explicit AddCasterEpisodeGroupContentResponseBodyItemIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ItemId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      itemId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddCasterEpisodeGroupContentResponseBodyItemIds() = default;
};
class AddCasterEpisodeGroupContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddCasterEpisodeGroupContentResponseBodyItemIds> itemIds{};
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  AddCasterEpisodeGroupContentResponseBody() {}

  explicit AddCasterEpisodeGroupContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemIds) {
      res["ItemIds"] = itemIds ? boost::any(itemIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemIds"].type()) {
        AddCasterEpisodeGroupContentResponseBodyItemIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemIds"]));
        itemIds = make_shared<AddCasterEpisodeGroupContentResponseBodyItemIds>(model1);
      }
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterEpisodeGroupContentResponseBody() = default;
};
class AddCasterEpisodeGroupContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterEpisodeGroupContentResponseBody> body{};

  AddCasterEpisodeGroupContentResponse() {}

  explicit AddCasterEpisodeGroupContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterEpisodeGroupContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterEpisodeGroupContentResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterEpisodeGroupContentResponse() = default;
};
class AddCasterLayoutRequestAudioLayer : public Darabonba::Model {
public:
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  AddCasterLayoutRequestAudioLayer() {}

  explicit AddCasterLayoutRequestAudioLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~AddCasterLayoutRequestAudioLayer() = default;
};
class AddCasterLayoutRequestVideoLayer : public Darabonba::Model {
public:
  shared_ptr<string> fillMode{};
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<double> heightNormalized{};
  shared_ptr<vector<double>> positionNormalized{};
  shared_ptr<string> positionRefer{};
  shared_ptr<double> widthNormalized{};

  AddCasterLayoutRequestVideoLayer() {}

  explicit AddCasterLayoutRequestVideoLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fillMode) {
      res["FillMode"] = boost::any(*fillMode);
    }
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionNormalized) {
      res["PositionNormalized"] = boost::any(*positionNormalized);
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (widthNormalized) {
      res["WidthNormalized"] = boost::any(*widthNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FillMode") != m.end() && !m["FillMode"].empty()) {
      fillMode = make_shared<string>(boost::any_cast<string>(m["FillMode"]));
    }
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["PositionNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PositionNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      positionNormalized = make_shared<vector<double>>(toVec1);
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("WidthNormalized") != m.end() && !m["WidthNormalized"].empty()) {
      widthNormalized = make_shared<double>(boost::any_cast<double>(m["WidthNormalized"]));
    }
  }


  virtual ~AddCasterLayoutRequestVideoLayer() = default;
};
class AddCasterLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddCasterLayoutRequestAudioLayer>> audioLayer{};
  shared_ptr<vector<string>> blendList{};
  shared_ptr<string> casterId{};
  shared_ptr<vector<string>> mixList{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<AddCasterLayoutRequestVideoLayer>> videoLayer{};

  AddCasterLayoutRequest() {}

  explicit AddCasterLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayer) {
      vector<boost::any> temp1;
      for(auto item1:*audioLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioLayer"] = boost::any(temp1);
    }
    if (blendList) {
      res["BlendList"] = boost::any(*blendList);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (mixList) {
      res["MixList"] = boost::any(*mixList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (videoLayer) {
      vector<boost::any> temp1;
      for(auto item1:*videoLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayer") != m.end() && !m["AudioLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioLayer"].type()) {
        vector<AddCasterLayoutRequestAudioLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasterLayoutRequestAudioLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioLayer = make_shared<vector<AddCasterLayoutRequestAudioLayer>>(expect1);
      }
    }
    if (m.find("BlendList") != m.end() && !m["BlendList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BlendList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BlendList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      blendList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("MixList") != m.end() && !m["MixList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MixList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MixList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mixList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("VideoLayer") != m.end() && !m["VideoLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoLayer"].type()) {
        vector<AddCasterLayoutRequestVideoLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasterLayoutRequestVideoLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoLayer = make_shared<vector<AddCasterLayoutRequestVideoLayer>>(expect1);
      }
    }
  }


  virtual ~AddCasterLayoutRequest() = default;
};
class AddCasterLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> layoutId{};
  shared_ptr<string> requestId{};

  AddCasterLayoutResponseBody() {}

  explicit AddCasterLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterLayoutResponseBody() = default;
};
class AddCasterLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterLayoutResponseBody> body{};

  AddCasterLayoutResponse() {}

  explicit AddCasterLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterLayoutResponse() = default;
};
class AddCasterProgramRequestEpisode : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeName{};
  shared_ptr<string> episodeType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> switchType{};

  AddCasterProgramRequestEpisode() {}

  explicit AddCasterProgramRequestEpisode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeName) {
      res["EpisodeName"] = boost::any(*episodeName);
    }
    if (episodeType) {
      res["EpisodeType"] = boost::any(*episodeType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (switchType) {
      res["SwitchType"] = boost::any(*switchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeName") != m.end() && !m["EpisodeName"].empty()) {
      episodeName = make_shared<string>(boost::any_cast<string>(m["EpisodeName"]));
    }
    if (m.find("EpisodeType") != m.end() && !m["EpisodeType"].empty()) {
      episodeType = make_shared<string>(boost::any_cast<string>(m["EpisodeType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SwitchType") != m.end() && !m["SwitchType"].empty()) {
      switchType = make_shared<string>(boost::any_cast<string>(m["SwitchType"]));
    }
  }


  virtual ~AddCasterProgramRequestEpisode() = default;
};
class AddCasterProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<AddCasterProgramRequestEpisode>> episode{};
  shared_ptr<long> ownerId{};

  AddCasterProgramRequest() {}

  explicit AddCasterProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episode) {
      vector<boost::any> temp1;
      for(auto item1:*episode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Episode"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("Episode") != m.end() && !m["Episode"].empty()) {
      if (typeid(vector<boost::any>) == m["Episode"].type()) {
        vector<AddCasterProgramRequestEpisode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Episode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasterProgramRequestEpisode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        episode = make_shared<vector<AddCasterProgramRequestEpisode>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~AddCasterProgramRequest() = default;
};
class AddCasterProgramResponseBodyEpisodeIdsEpisodeId : public Darabonba::Model {
public:
  shared_ptr<string> episodeId{};

  AddCasterProgramResponseBodyEpisodeIdsEpisodeId() {}

  explicit AddCasterProgramResponseBodyEpisodeIdsEpisodeId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
  }


  virtual ~AddCasterProgramResponseBodyEpisodeIdsEpisodeId() = default;
};
class AddCasterProgramResponseBodyEpisodeIds : public Darabonba::Model {
public:
  shared_ptr<vector<AddCasterProgramResponseBodyEpisodeIdsEpisodeId>> episodeId{};

  AddCasterProgramResponseBodyEpisodeIds() {}

  explicit AddCasterProgramResponseBodyEpisodeIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (episodeId) {
      vector<boost::any> temp1;
      for(auto item1:*episodeId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EpisodeId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      if (typeid(vector<boost::any>) == m["EpisodeId"].type()) {
        vector<AddCasterProgramResponseBodyEpisodeIdsEpisodeId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EpisodeId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasterProgramResponseBodyEpisodeIdsEpisodeId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        episodeId = make_shared<vector<AddCasterProgramResponseBodyEpisodeIdsEpisodeId>>(expect1);
      }
    }
  }


  virtual ~AddCasterProgramResponseBodyEpisodeIds() = default;
};
class AddCasterProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddCasterProgramResponseBodyEpisodeIds> episodeIds{};
  shared_ptr<string> requestId{};

  AddCasterProgramResponseBody() {}

  explicit AddCasterProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (episodeIds) {
      res["EpisodeIds"] = episodeIds ? boost::any(episodeIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EpisodeIds") != m.end() && !m["EpisodeIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["EpisodeIds"].type()) {
        AddCasterProgramResponseBodyEpisodeIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EpisodeIds"]));
        episodeIds = make_shared<AddCasterProgramResponseBodyEpisodeIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterProgramResponseBody() = default;
};
class AddCasterProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterProgramResponseBody> body{};

  AddCasterProgramResponse() {}

  explicit AddCasterProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterProgramResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterProgramResponse() = default;
};
class AddCasterVideoResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginOffset{};
  shared_ptr<string> casterId{};
  shared_ptr<long> endOffset{};
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> liveStreamUrl{};
  shared_ptr<string> locationId{};
  shared_ptr<string> materialId{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> ptsCallbackInterval{};
  shared_ptr<long> repeatNum{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> streamId{};
  shared_ptr<string> vodUrl{};

  AddCasterVideoResourceRequest() {}

  explicit AddCasterVideoResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginOffset) {
      res["BeginOffset"] = boost::any(*beginOffset);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (endOffset) {
      res["EndOffset"] = boost::any(*endOffset);
    }
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (liveStreamUrl) {
      res["LiveStreamUrl"] = boost::any(*liveStreamUrl);
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ptsCallbackInterval) {
      res["PtsCallbackInterval"] = boost::any(*ptsCallbackInterval);
    }
    if (repeatNum) {
      res["RepeatNum"] = boost::any(*repeatNum);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (streamId) {
      res["StreamId"] = boost::any(*streamId);
    }
    if (vodUrl) {
      res["VodUrl"] = boost::any(*vodUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginOffset") != m.end() && !m["BeginOffset"].empty()) {
      beginOffset = make_shared<long>(boost::any_cast<long>(m["BeginOffset"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EndOffset") != m.end() && !m["EndOffset"].empty()) {
      endOffset = make_shared<long>(boost::any_cast<long>(m["EndOffset"]));
    }
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("LiveStreamUrl") != m.end() && !m["LiveStreamUrl"].empty()) {
      liveStreamUrl = make_shared<string>(boost::any_cast<string>(m["LiveStreamUrl"]));
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PtsCallbackInterval") != m.end() && !m["PtsCallbackInterval"].empty()) {
      ptsCallbackInterval = make_shared<long>(boost::any_cast<long>(m["PtsCallbackInterval"]));
    }
    if (m.find("RepeatNum") != m.end() && !m["RepeatNum"].empty()) {
      repeatNum = make_shared<long>(boost::any_cast<long>(m["RepeatNum"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("StreamId") != m.end() && !m["StreamId"].empty()) {
      streamId = make_shared<string>(boost::any_cast<string>(m["StreamId"]));
    }
    if (m.find("VodUrl") != m.end() && !m["VodUrl"].empty()) {
      vodUrl = make_shared<string>(boost::any_cast<string>(m["VodUrl"]));
    }
  }


  virtual ~AddCasterVideoResourceRequest() = default;
};
class AddCasterVideoResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceId{};

  AddCasterVideoResourceResponseBody() {}

  explicit AddCasterVideoResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~AddCasterVideoResourceResponseBody() = default;
};
class AddCasterVideoResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterVideoResourceResponseBody> body{};

  AddCasterVideoResourceResponse() {}

  explicit AddCasterVideoResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterVideoResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterVideoResourceResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterVideoResourceResponse() = default;
};
class AddCustomLiveStreamTranscodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<long> audioBitrate{};
  shared_ptr<long> audioChannelNum{};
  shared_ptr<string> audioCodec{};
  shared_ptr<string> audioProfile{};
  shared_ptr<long> audioRate{};
  shared_ptr<string> domain{};
  shared_ptr<string> encryptParameters{};
  shared_ptr<long> FPS{};
  shared_ptr<string> gop{};
  shared_ptr<long> height{};
  shared_ptr<string> kmsKeyExpireInterval{};
  shared_ptr<string> kmsKeyID{};
  shared_ptr<string> kmsUID{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> profile{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<long> width{};

  AddCustomLiveStreamTranscodeRequest() {}

  explicit AddCustomLiveStreamTranscodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannelNum) {
      res["AudioChannelNum"] = boost::any(*audioChannelNum);
    }
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioProfile) {
      res["AudioProfile"] = boost::any(*audioProfile);
    }
    if (audioRate) {
      res["AudioRate"] = boost::any(*audioRate);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (encryptParameters) {
      res["EncryptParameters"] = boost::any(*encryptParameters);
    }
    if (FPS) {
      res["FPS"] = boost::any(*FPS);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (kmsKeyExpireInterval) {
      res["KmsKeyExpireInterval"] = boost::any(*kmsKeyExpireInterval);
    }
    if (kmsKeyID) {
      res["KmsKeyID"] = boost::any(*kmsKeyID);
    }
    if (kmsUID) {
      res["KmsUID"] = boost::any(*kmsUID);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<long>(boost::any_cast<long>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannelNum") != m.end() && !m["AudioChannelNum"].empty()) {
      audioChannelNum = make_shared<long>(boost::any_cast<long>(m["AudioChannelNum"]));
    }
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioProfile") != m.end() && !m["AudioProfile"].empty()) {
      audioProfile = make_shared<string>(boost::any_cast<string>(m["AudioProfile"]));
    }
    if (m.find("AudioRate") != m.end() && !m["AudioRate"].empty()) {
      audioRate = make_shared<long>(boost::any_cast<long>(m["AudioRate"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EncryptParameters") != m.end() && !m["EncryptParameters"].empty()) {
      encryptParameters = make_shared<string>(boost::any_cast<string>(m["EncryptParameters"]));
    }
    if (m.find("FPS") != m.end() && !m["FPS"].empty()) {
      FPS = make_shared<long>(boost::any_cast<long>(m["FPS"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("KmsKeyExpireInterval") != m.end() && !m["KmsKeyExpireInterval"].empty()) {
      kmsKeyExpireInterval = make_shared<string>(boost::any_cast<string>(m["KmsKeyExpireInterval"]));
    }
    if (m.find("KmsKeyID") != m.end() && !m["KmsKeyID"].empty()) {
      kmsKeyID = make_shared<string>(boost::any_cast<string>(m["KmsKeyID"]));
    }
    if (m.find("KmsUID") != m.end() && !m["KmsUID"].empty()) {
      kmsUID = make_shared<string>(boost::any_cast<string>(m["KmsUID"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<long>(boost::any_cast<long>(m["Profile"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~AddCustomLiveStreamTranscodeRequest() = default;
};
class AddCustomLiveStreamTranscodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddCustomLiveStreamTranscodeResponseBody() {}

  explicit AddCustomLiveStreamTranscodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCustomLiveStreamTranscodeResponseBody() = default;
};
class AddCustomLiveStreamTranscodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCustomLiveStreamTranscodeResponseBody> body{};

  AddCustomLiveStreamTranscodeResponse() {}

  explicit AddCustomLiveStreamTranscodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCustomLiveStreamTranscodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCustomLiveStreamTranscodeResponseBody>(model1);
      }
    }
  }


  virtual ~AddCustomLiveStreamTranscodeResponse() = default;
};
class AddLiveAppRecordConfigRequestRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  AddLiveAppRecordConfigRequestRecordFormat() {}

  explicit AddLiveAppRecordConfigRequestRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~AddLiveAppRecordConfigRequestRecordFormat() = default;
};
class AddLiveAppRecordConfigRequestTranscodeRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  AddLiveAppRecordConfigRequestTranscodeRecordFormat() {}

  explicit AddLiveAppRecordConfigRequestTranscodeRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~AddLiveAppRecordConfigRequestTranscodeRecordFormat() = default;
};
class AddLiveAppRecordConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> onDemand{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<AddLiveAppRecordConfigRequestRecordFormat>> recordFormat{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<vector<AddLiveAppRecordConfigRequestTranscodeRecordFormat>> transcodeRecordFormat{};
  shared_ptr<vector<string>> transcodeTemplates{};

  AddLiveAppRecordConfigRequest() {}

  explicit AddLiveAppRecordConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (onDemand) {
      res["OnDemand"] = boost::any(*onDemand);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transcodeRecordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeRecordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeRecordFormat"] = boost::any(temp1);
    }
    if (transcodeTemplates) {
      res["TranscodeTemplates"] = boost::any(*transcodeTemplates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OnDemand") != m.end() && !m["OnDemand"].empty()) {
      onDemand = make_shared<long>(boost::any_cast<long>(m["OnDemand"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<AddLiveAppRecordConfigRequestRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddLiveAppRecordConfigRequestRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<AddLiveAppRecordConfigRequestRecordFormat>>(expect1);
      }
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TranscodeRecordFormat") != m.end() && !m["TranscodeRecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeRecordFormat"].type()) {
        vector<AddLiveAppRecordConfigRequestTranscodeRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeRecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddLiveAppRecordConfigRequestTranscodeRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeRecordFormat = make_shared<vector<AddLiveAppRecordConfigRequestTranscodeRecordFormat>>(expect1);
      }
    }
    if (m.find("TranscodeTemplates") != m.end() && !m["TranscodeTemplates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TranscodeTemplates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TranscodeTemplates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      transcodeTemplates = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddLiveAppRecordConfigRequest() = default;
};
class AddLiveAppRecordConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveAppRecordConfigResponseBody() {}

  explicit AddLiveAppRecordConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveAppRecordConfigResponseBody() = default;
};
class AddLiveAppRecordConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveAppRecordConfigResponseBody> body{};

  AddLiveAppRecordConfigResponse() {}

  explicit AddLiveAppRecordConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveAppRecordConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveAppRecordConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveAppRecordConfigResponse() = default;
};
class AddLiveAppSnapshotConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> callback{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> overwriteOssObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sequenceOssObject{};
  shared_ptr<long> timeInterval{};

  AddLiveAppSnapshotConfigRequest() {}

  explicit AddLiveAppSnapshotConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (overwriteOssObject) {
      res["OverwriteOssObject"] = boost::any(*overwriteOssObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sequenceOssObject) {
      res["SequenceOssObject"] = boost::any(*sequenceOssObject);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OverwriteOssObject") != m.end() && !m["OverwriteOssObject"].empty()) {
      overwriteOssObject = make_shared<string>(boost::any_cast<string>(m["OverwriteOssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SequenceOssObject") != m.end() && !m["SequenceOssObject"].empty()) {
      sequenceOssObject = make_shared<string>(boost::any_cast<string>(m["SequenceOssObject"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~AddLiveAppSnapshotConfigRequest() = default;
};
class AddLiveAppSnapshotConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveAppSnapshotConfigResponseBody() {}

  explicit AddLiveAppSnapshotConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveAppSnapshotConfigResponseBody() = default;
};
class AddLiveAppSnapshotConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveAppSnapshotConfigResponseBody> body{};

  AddLiveAppSnapshotConfigResponse() {}

  explicit AddLiveAppSnapshotConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveAppSnapshotConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveAppSnapshotConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveAppSnapshotConfigResponse() = default;
};
class AddLiveAudioAuditConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> bizType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  AddLiveAudioAuditConfigRequest() {}

  explicit AddLiveAudioAuditConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~AddLiveAudioAuditConfigRequest() = default;
};
class AddLiveAudioAuditConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveAudioAuditConfigResponseBody() {}

  explicit AddLiveAudioAuditConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveAudioAuditConfigResponseBody() = default;
};
class AddLiveAudioAuditConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveAudioAuditConfigResponseBody> body{};

  AddLiveAudioAuditConfigResponse() {}

  explicit AddLiveAudioAuditConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveAudioAuditConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveAudioAuditConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveAudioAuditConfigResponse() = default;
};
class AddLiveAudioAuditNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> callback{};
  shared_ptr<string> callbackTemplate{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  AddLiveAudioAuditNotifyConfigRequest() {}

  explicit AddLiveAudioAuditNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (callbackTemplate) {
      res["CallbackTemplate"] = boost::any(*callbackTemplate);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CallbackTemplate") != m.end() && !m["CallbackTemplate"].empty()) {
      callbackTemplate = make_shared<string>(boost::any_cast<string>(m["CallbackTemplate"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~AddLiveAudioAuditNotifyConfigRequest() = default;
};
class AddLiveAudioAuditNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveAudioAuditNotifyConfigResponseBody() {}

  explicit AddLiveAudioAuditNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveAudioAuditNotifyConfigResponseBody() = default;
};
class AddLiveAudioAuditNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveAudioAuditNotifyConfigResponseBody> body{};

  AddLiveAudioAuditNotifyConfigResponse() {}

  explicit AddLiveAudioAuditNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveAudioAuditNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveAudioAuditNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveAudioAuditNotifyConfigResponse() = default;
};
class AddLiveDetectNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  AddLiveDetectNotifyConfigRequest() {}

  explicit AddLiveDetectNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddLiveDetectNotifyConfigRequest() = default;
};
class AddLiveDetectNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveDetectNotifyConfigResponseBody() {}

  explicit AddLiveDetectNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveDetectNotifyConfigResponseBody() = default;
};
class AddLiveDetectNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveDetectNotifyConfigResponseBody> body{};

  AddLiveDetectNotifyConfigResponse() {}

  explicit AddLiveDetectNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveDetectNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveDetectNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveDetectNotifyConfigResponse() = default;
};
class AddLiveDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkUrl{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveDomainType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> scope{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> topLevelDomain{};

  AddLiveDomainRequest() {}

  explicit AddLiveDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkUrl) {
      res["CheckUrl"] = boost::any(*checkUrl);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveDomainType) {
      res["LiveDomainType"] = boost::any(*liveDomainType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckUrl") != m.end() && !m["CheckUrl"].empty()) {
      checkUrl = make_shared<string>(boost::any_cast<string>(m["CheckUrl"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveDomainType") != m.end() && !m["LiveDomainType"].empty()) {
      liveDomainType = make_shared<string>(boost::any_cast<string>(m["LiveDomainType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~AddLiveDomainRequest() = default;
};
class AddLiveDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveDomainResponseBody() {}

  explicit AddLiveDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveDomainResponseBody() = default;
};
class AddLiveDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveDomainResponseBody> body{};

  AddLiveDomainResponse() {}

  explicit AddLiveDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveDomainResponse() = default;
};
class AddLiveDomainMappingRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> pullDomain{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> securityToken{};

  AddLiveDomainMappingRequest() {}

  explicit AddLiveDomainMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pullDomain) {
      res["PullDomain"] = boost::any(*pullDomain);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PullDomain") != m.end() && !m["PullDomain"].empty()) {
      pullDomain = make_shared<string>(boost::any_cast<string>(m["PullDomain"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddLiveDomainMappingRequest() = default;
};
class AddLiveDomainMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveDomainMappingResponseBody() {}

  explicit AddLiveDomainMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveDomainMappingResponseBody() = default;
};
class AddLiveDomainMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveDomainMappingResponseBody> body{};

  AddLiveDomainMappingResponse() {}

  explicit AddLiveDomainMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveDomainMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveDomainMappingResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveDomainMappingResponse() = default;
};
class AddLiveDomainPlayMappingRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> playDomain{};
  shared_ptr<string> pullDomain{};

  AddLiveDomainPlayMappingRequest() {}

  explicit AddLiveDomainPlayMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    if (pullDomain) {
      res["PullDomain"] = boost::any(*pullDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
    if (m.find("PullDomain") != m.end() && !m["PullDomain"].empty()) {
      pullDomain = make_shared<string>(boost::any_cast<string>(m["PullDomain"]));
    }
  }


  virtual ~AddLiveDomainPlayMappingRequest() = default;
};
class AddLiveDomainPlayMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveDomainPlayMappingResponseBody() {}

  explicit AddLiveDomainPlayMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveDomainPlayMappingResponseBody() = default;
};
class AddLiveDomainPlayMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveDomainPlayMappingResponseBody> body{};

  AddLiveDomainPlayMappingResponse() {}

  explicit AddLiveDomainPlayMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveDomainPlayMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveDomainPlayMappingResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveDomainPlayMappingResponse() = default;
};
class AddLivePullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  AddLivePullStreamInfoConfigRequest() {}

  explicit AddLivePullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~AddLivePullStreamInfoConfigRequest() = default;
};
class AddLivePullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLivePullStreamInfoConfigResponseBody() {}

  explicit AddLivePullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLivePullStreamInfoConfigResponseBody() = default;
};
class AddLivePullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLivePullStreamInfoConfigResponseBody> body{};

  AddLivePullStreamInfoConfigResponse() {}

  explicit AddLivePullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLivePullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLivePullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLivePullStreamInfoConfigResponse() = default;
};
class AddLiveRecordNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<bool> needStatusNotify{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> onDemandUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  AddLiveRecordNotifyConfigRequest() {}

  explicit AddLiveRecordNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (needStatusNotify) {
      res["NeedStatusNotify"] = boost::any(*needStatusNotify);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (onDemandUrl) {
      res["OnDemandUrl"] = boost::any(*onDemandUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NeedStatusNotify") != m.end() && !m["NeedStatusNotify"].empty()) {
      needStatusNotify = make_shared<bool>(boost::any_cast<bool>(m["NeedStatusNotify"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OnDemandUrl") != m.end() && !m["OnDemandUrl"].empty()) {
      onDemandUrl = make_shared<string>(boost::any_cast<string>(m["OnDemandUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddLiveRecordNotifyConfigRequest() = default;
};
class AddLiveRecordNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveRecordNotifyConfigResponseBody() {}

  explicit AddLiveRecordNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveRecordNotifyConfigResponseBody() = default;
};
class AddLiveRecordNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveRecordNotifyConfigResponseBody> body{};

  AddLiveRecordNotifyConfigResponse() {}

  explicit AddLiveRecordNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveRecordNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveRecordNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveRecordNotifyConfigResponse() = default;
};
class AddLiveRecordVodConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> autoCompose{};
  shared_ptr<string> composeVodTranscodeGroupId{};
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> streamName{};
  shared_ptr<string> vodTranscodeGroupId{};

  AddLiveRecordVodConfigRequest() {}

  explicit AddLiveRecordVodConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (autoCompose) {
      res["AutoCompose"] = boost::any(*autoCompose);
    }
    if (composeVodTranscodeGroupId) {
      res["ComposeVodTranscodeGroupId"] = boost::any(*composeVodTranscodeGroupId);
    }
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (vodTranscodeGroupId) {
      res["VodTranscodeGroupId"] = boost::any(*vodTranscodeGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AutoCompose") != m.end() && !m["AutoCompose"].empty()) {
      autoCompose = make_shared<string>(boost::any_cast<string>(m["AutoCompose"]));
    }
    if (m.find("ComposeVodTranscodeGroupId") != m.end() && !m["ComposeVodTranscodeGroupId"].empty()) {
      composeVodTranscodeGroupId = make_shared<string>(boost::any_cast<string>(m["ComposeVodTranscodeGroupId"]));
    }
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("VodTranscodeGroupId") != m.end() && !m["VodTranscodeGroupId"].empty()) {
      vodTranscodeGroupId = make_shared<string>(boost::any_cast<string>(m["VodTranscodeGroupId"]));
    }
  }


  virtual ~AddLiveRecordVodConfigRequest() = default;
};
class AddLiveRecordVodConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveRecordVodConfigResponseBody() {}

  explicit AddLiveRecordVodConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveRecordVodConfigResponseBody() = default;
};
class AddLiveRecordVodConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveRecordVodConfigResponseBody> body{};

  AddLiveRecordVodConfigResponse() {}

  explicit AddLiveRecordVodConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveRecordVodConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveRecordVodConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveRecordVodConfigResponse() = default;
};
class AddLiveSnapshotDetectPornConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> interval{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> scene{};
  shared_ptr<string> securityToken{};

  AddLiveSnapshotDetectPornConfigRequest() {}

  explicit AddLiveSnapshotDetectPornConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Scene"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Scene"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scene = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddLiveSnapshotDetectPornConfigRequest() = default;
};
class AddLiveSnapshotDetectPornConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveSnapshotDetectPornConfigResponseBody() {}

  explicit AddLiveSnapshotDetectPornConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveSnapshotDetectPornConfigResponseBody() = default;
};
class AddLiveSnapshotDetectPornConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveSnapshotDetectPornConfigResponseBody> body{};

  AddLiveSnapshotDetectPornConfigResponse() {}

  explicit AddLiveSnapshotDetectPornConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveSnapshotDetectPornConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveSnapshotDetectPornConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveSnapshotDetectPornConfigResponse() = default;
};
class AddLiveSnapshotNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyAuthKey{};
  shared_ptr<string> notifyReqAuth{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<long> ownerId{};

  AddLiveSnapshotNotifyConfigRequest() {}

  explicit AddLiveSnapshotNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyAuthKey) {
      res["NotifyAuthKey"] = boost::any(*notifyAuthKey);
    }
    if (notifyReqAuth) {
      res["NotifyReqAuth"] = boost::any(*notifyReqAuth);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyAuthKey") != m.end() && !m["NotifyAuthKey"].empty()) {
      notifyAuthKey = make_shared<string>(boost::any_cast<string>(m["NotifyAuthKey"]));
    }
    if (m.find("NotifyReqAuth") != m.end() && !m["NotifyReqAuth"].empty()) {
      notifyReqAuth = make_shared<string>(boost::any_cast<string>(m["NotifyReqAuth"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~AddLiveSnapshotNotifyConfigRequest() = default;
};
class AddLiveSnapshotNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveSnapshotNotifyConfigResponseBody() {}

  explicit AddLiveSnapshotNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveSnapshotNotifyConfigResponseBody() = default;
};
class AddLiveSnapshotNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveSnapshotNotifyConfigResponseBody> body{};

  AddLiveSnapshotNotifyConfigResponse() {}

  explicit AddLiveSnapshotNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveSnapshotNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveSnapshotNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveSnapshotNotifyConfigResponse() = default;
};
class AddLiveStreamTranscodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<string> encryptParameters{};
  shared_ptr<string> lazy{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> template_{};

  AddLiveStreamTranscodeRequest() {}

  explicit AddLiveStreamTranscodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (encryptParameters) {
      res["EncryptParameters"] = boost::any(*encryptParameters);
    }
    if (lazy) {
      res["Lazy"] = boost::any(*lazy);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EncryptParameters") != m.end() && !m["EncryptParameters"].empty()) {
      encryptParameters = make_shared<string>(boost::any_cast<string>(m["EncryptParameters"]));
    }
    if (m.find("Lazy") != m.end() && !m["Lazy"].empty()) {
      lazy = make_shared<string>(boost::any_cast<string>(m["Lazy"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~AddLiveStreamTranscodeRequest() = default;
};
class AddLiveStreamTranscodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveStreamTranscodeResponseBody() {}

  explicit AddLiveStreamTranscodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveStreamTranscodeResponseBody() = default;
};
class AddLiveStreamTranscodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveStreamTranscodeResponseBody> body{};

  AddLiveStreamTranscodeResponse() {}

  explicit AddLiveStreamTranscodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveStreamTranscodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveStreamTranscodeResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveStreamTranscodeResponse() = default;
};
class AddLiveStreamWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> height{};
  shared_ptr<string> name{};
  shared_ptr<string> offsetCorner{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pictureUrl{};
  shared_ptr<long> refHeight{};
  shared_ptr<long> refWidth{};
  shared_ptr<long> transparency{};
  shared_ptr<long> type{};
  shared_ptr<double> XOffset{};
  shared_ptr<double> YOffset{};

  AddLiveStreamWatermarkRequest() {}

  explicit AddLiveStreamWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (offsetCorner) {
      res["OffsetCorner"] = boost::any(*offsetCorner);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pictureUrl) {
      res["PictureUrl"] = boost::any(*pictureUrl);
    }
    if (refHeight) {
      res["RefHeight"] = boost::any(*refHeight);
    }
    if (refWidth) {
      res["RefWidth"] = boost::any(*refWidth);
    }
    if (transparency) {
      res["Transparency"] = boost::any(*transparency);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (XOffset) {
      res["XOffset"] = boost::any(*XOffset);
    }
    if (YOffset) {
      res["YOffset"] = boost::any(*YOffset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OffsetCorner") != m.end() && !m["OffsetCorner"].empty()) {
      offsetCorner = make_shared<string>(boost::any_cast<string>(m["OffsetCorner"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PictureUrl") != m.end() && !m["PictureUrl"].empty()) {
      pictureUrl = make_shared<string>(boost::any_cast<string>(m["PictureUrl"]));
    }
    if (m.find("RefHeight") != m.end() && !m["RefHeight"].empty()) {
      refHeight = make_shared<long>(boost::any_cast<long>(m["RefHeight"]));
    }
    if (m.find("RefWidth") != m.end() && !m["RefWidth"].empty()) {
      refWidth = make_shared<long>(boost::any_cast<long>(m["RefWidth"]));
    }
    if (m.find("Transparency") != m.end() && !m["Transparency"].empty()) {
      transparency = make_shared<long>(boost::any_cast<long>(m["Transparency"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("XOffset") != m.end() && !m["XOffset"].empty()) {
      XOffset = make_shared<double>(boost::any_cast<double>(m["XOffset"]));
    }
    if (m.find("YOffset") != m.end() && !m["YOffset"].empty()) {
      YOffset = make_shared<double>(boost::any_cast<double>(m["YOffset"]));
    }
  }


  virtual ~AddLiveStreamWatermarkRequest() = default;
};
class AddLiveStreamWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  AddLiveStreamWatermarkResponseBody() {}

  explicit AddLiveStreamWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~AddLiveStreamWatermarkResponseBody() = default;
};
class AddLiveStreamWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveStreamWatermarkResponseBody> body{};

  AddLiveStreamWatermarkResponse() {}

  explicit AddLiveStreamWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveStreamWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveStreamWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveStreamWatermarkResponse() = default;
};
class AddLiveStreamWatermarkRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> stream{};
  shared_ptr<string> templateId{};

  AddLiveStreamWatermarkRuleRequest() {}

  explicit AddLiveStreamWatermarkRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~AddLiveStreamWatermarkRuleRequest() = default;
};
class AddLiveStreamWatermarkRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleId{};

  AddLiveStreamWatermarkRuleResponseBody() {}

  explicit AddLiveStreamWatermarkRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~AddLiveStreamWatermarkRuleResponseBody() = default;
};
class AddLiveStreamWatermarkRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveStreamWatermarkRuleResponseBody> body{};

  AddLiveStreamWatermarkRuleResponse() {}

  explicit AddLiveStreamWatermarkRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveStreamWatermarkRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveStreamWatermarkRuleResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveStreamWatermarkRuleResponse() = default;
};
class AddMultiRateConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> avFormat{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> isLazy{};
  shared_ptr<string> isTimeAlign{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> templates{};

  AddMultiRateConfigRequest() {}

  explicit AddMultiRateConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (avFormat) {
      res["AvFormat"] = boost::any(*avFormat);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isLazy) {
      res["IsLazy"] = boost::any(*isLazy);
    }
    if (isTimeAlign) {
      res["IsTimeAlign"] = boost::any(*isTimeAlign);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (templates) {
      res["Templates"] = boost::any(*templates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("AvFormat") != m.end() && !m["AvFormat"].empty()) {
      avFormat = make_shared<string>(boost::any_cast<string>(m["AvFormat"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsLazy") != m.end() && !m["IsLazy"].empty()) {
      isLazy = make_shared<string>(boost::any_cast<string>(m["IsLazy"]));
    }
    if (m.find("IsTimeAlign") != m.end() && !m["IsTimeAlign"].empty()) {
      isTimeAlign = make_shared<string>(boost::any_cast<string>(m["IsTimeAlign"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      templates = make_shared<string>(boost::any_cast<string>(m["Templates"]));
    }
  }


  virtual ~AddMultiRateConfigRequest() = default;
};
class AddMultiRateConfigResponseBodyBodyFailedTemplates : public Darabonba::Model {
public:
  shared_ptr<long> audioBitrate{};
  shared_ptr<long> audioChannelNum{};
  shared_ptr<string> audioCodec{};
  shared_ptr<string> audioProfile{};
  shared_ptr<long> audioRate{};
  shared_ptr<long> bandWidth{};
  shared_ptr<long> fps{};
  shared_ptr<string> gop{};
  shared_ptr<long> height{};
  shared_ptr<long> profile{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<long> width{};

  AddMultiRateConfigResponseBodyBodyFailedTemplates() {}

  explicit AddMultiRateConfigResponseBodyBodyFailedTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannelNum) {
      res["AudioChannelNum"] = boost::any(*audioChannelNum);
    }
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioProfile) {
      res["AudioProfile"] = boost::any(*audioProfile);
    }
    if (audioRate) {
      res["AudioRate"] = boost::any(*audioRate);
    }
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<long>(boost::any_cast<long>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannelNum") != m.end() && !m["AudioChannelNum"].empty()) {
      audioChannelNum = make_shared<long>(boost::any_cast<long>(m["AudioChannelNum"]));
    }
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioProfile") != m.end() && !m["AudioProfile"].empty()) {
      audioProfile = make_shared<string>(boost::any_cast<string>(m["AudioProfile"]));
    }
    if (m.find("AudioRate") != m.end() && !m["AudioRate"].empty()) {
      audioRate = make_shared<long>(boost::any_cast<long>(m["AudioRate"]));
    }
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<long>(boost::any_cast<long>(m["BandWidth"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<long>(boost::any_cast<long>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<long>(boost::any_cast<long>(m["Profile"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~AddMultiRateConfigResponseBodyBodyFailedTemplates() = default;
};
class AddMultiRateConfigResponseBodyBody : public Darabonba::Model {
public:
  shared_ptr<vector<AddMultiRateConfigResponseBodyBodyFailedTemplates>> failedTemplates{};

  AddMultiRateConfigResponseBodyBody() {}

  explicit AddMultiRateConfigResponseBodyBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*failedTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedTemplates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedTemplates") != m.end() && !m["FailedTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedTemplates"].type()) {
        vector<AddMultiRateConfigResponseBodyBodyFailedTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddMultiRateConfigResponseBodyBodyFailedTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedTemplates = make_shared<vector<AddMultiRateConfigResponseBodyBodyFailedTemplates>>(expect1);
      }
    }
  }


  virtual ~AddMultiRateConfigResponseBodyBody() = default;
};
class AddMultiRateConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddMultiRateConfigResponseBodyBody> body{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddMultiRateConfigResponseBody() {}

  explicit AddMultiRateConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      if (typeid(map<string, boost::any>) == m["Body"].type()) {
        AddMultiRateConfigResponseBodyBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Body"]));
        body = make_shared<AddMultiRateConfigResponseBodyBody>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddMultiRateConfigResponseBody() = default;
};
class AddMultiRateConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMultiRateConfigResponseBody> body{};

  AddMultiRateConfigResponse() {}

  explicit AddMultiRateConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMultiRateConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMultiRateConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddMultiRateConfigResponse() = default;
};
class AddPlaylistItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> programConfig{};
  shared_ptr<string> programId{};
  shared_ptr<string> programItems{};

  AddPlaylistItemsRequest() {}

  explicit AddPlaylistItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programConfig) {
      res["ProgramConfig"] = boost::any(*programConfig);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programItems) {
      res["ProgramItems"] = boost::any(*programItems);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramConfig") != m.end() && !m["ProgramConfig"].empty()) {
      programConfig = make_shared<string>(boost::any_cast<string>(m["ProgramConfig"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramItems") != m.end() && !m["ProgramItems"].empty()) {
      programItems = make_shared<string>(boost::any_cast<string>(m["ProgramItems"]));
    }
  }


  virtual ~AddPlaylistItemsRequest() = default;
};
class AddPlaylistItemsResponseBodyItemsFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};

  AddPlaylistItemsResponseBodyItemsFailedItems() {}

  explicit AddPlaylistItemsResponseBodyItemsFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
  }


  virtual ~AddPlaylistItemsResponseBodyItemsFailedItems() = default;
};
class AddPlaylistItemsResponseBodyItemsSuccessItems : public Darabonba::Model {
public:
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};

  AddPlaylistItemsResponseBodyItemsSuccessItems() {}

  explicit AddPlaylistItemsResponseBodyItemsSuccessItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
  }


  virtual ~AddPlaylistItemsResponseBodyItemsSuccessItems() = default;
};
class AddPlaylistItemsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<AddPlaylistItemsResponseBodyItemsFailedItems>> failedItems{};
  shared_ptr<vector<AddPlaylistItemsResponseBodyItemsSuccessItems>> successItems{};

  AddPlaylistItemsResponseBodyItems() {}

  explicit AddPlaylistItemsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successItems) {
      vector<boost::any> temp1;
      for(auto item1:*successItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuccessItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<AddPlaylistItemsResponseBodyItemsFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddPlaylistItemsResponseBodyItemsFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<AddPlaylistItemsResponseBodyItemsFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessItems") != m.end() && !m["SuccessItems"].empty()) {
      if (typeid(vector<boost::any>) == m["SuccessItems"].type()) {
        vector<AddPlaylistItemsResponseBodyItemsSuccessItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuccessItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddPlaylistItemsResponseBodyItemsSuccessItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        successItems = make_shared<vector<AddPlaylistItemsResponseBodyItemsSuccessItems>>(expect1);
      }
    }
  }


  virtual ~AddPlaylistItemsResponseBodyItems() = default;
};
class AddPlaylistItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddPlaylistItemsResponseBodyItems> items{};
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  AddPlaylistItemsResponseBody() {}

  explicit AddPlaylistItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        AddPlaylistItemsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<AddPlaylistItemsResponseBodyItems>(model1);
      }
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPlaylistItemsResponseBody() = default;
};
class AddPlaylistItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPlaylistItemsResponseBody> body{};

  AddPlaylistItemsResponse() {}

  explicit AddPlaylistItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPlaylistItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPlaylistItemsResponseBody>(model1);
      }
    }
  }


  virtual ~AddPlaylistItemsResponse() = default;
};
class AddRtsLiveStreamTranscodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<long> audioBitrate{};
  shared_ptr<long> audioChannelNum{};
  shared_ptr<string> audioCodec{};
  shared_ptr<string> audioProfile{};
  shared_ptr<long> audioRate{};
  shared_ptr<bool> deleteBframes{};
  shared_ptr<string> domain{};
  shared_ptr<long> FPS{};
  shared_ptr<string> gop{};
  shared_ptr<long> height{};
  shared_ptr<string> lazy{};
  shared_ptr<bool> opus{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> profile{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<long> width{};

  AddRtsLiveStreamTranscodeRequest() {}

  explicit AddRtsLiveStreamTranscodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannelNum) {
      res["AudioChannelNum"] = boost::any(*audioChannelNum);
    }
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioProfile) {
      res["AudioProfile"] = boost::any(*audioProfile);
    }
    if (audioRate) {
      res["AudioRate"] = boost::any(*audioRate);
    }
    if (deleteBframes) {
      res["DeleteBframes"] = boost::any(*deleteBframes);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (FPS) {
      res["FPS"] = boost::any(*FPS);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (lazy) {
      res["Lazy"] = boost::any(*lazy);
    }
    if (opus) {
      res["Opus"] = boost::any(*opus);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<long>(boost::any_cast<long>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannelNum") != m.end() && !m["AudioChannelNum"].empty()) {
      audioChannelNum = make_shared<long>(boost::any_cast<long>(m["AudioChannelNum"]));
    }
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioProfile") != m.end() && !m["AudioProfile"].empty()) {
      audioProfile = make_shared<string>(boost::any_cast<string>(m["AudioProfile"]));
    }
    if (m.find("AudioRate") != m.end() && !m["AudioRate"].empty()) {
      audioRate = make_shared<long>(boost::any_cast<long>(m["AudioRate"]));
    }
    if (m.find("DeleteBframes") != m.end() && !m["DeleteBframes"].empty()) {
      deleteBframes = make_shared<bool>(boost::any_cast<bool>(m["DeleteBframes"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("FPS") != m.end() && !m["FPS"].empty()) {
      FPS = make_shared<long>(boost::any_cast<long>(m["FPS"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Lazy") != m.end() && !m["Lazy"].empty()) {
      lazy = make_shared<string>(boost::any_cast<string>(m["Lazy"]));
    }
    if (m.find("Opus") != m.end() && !m["Opus"].empty()) {
      opus = make_shared<bool>(boost::any_cast<bool>(m["Opus"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<long>(boost::any_cast<long>(m["Profile"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~AddRtsLiveStreamTranscodeRequest() = default;
};
class AddRtsLiveStreamTranscodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddRtsLiveStreamTranscodeResponseBody() {}

  explicit AddRtsLiveStreamTranscodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddRtsLiveStreamTranscodeResponseBody() = default;
};
class AddRtsLiveStreamTranscodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddRtsLiveStreamTranscodeResponseBody> body{};

  AddRtsLiveStreamTranscodeResponse() {}

  explicit AddRtsLiveStreamTranscodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddRtsLiveStreamTranscodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddRtsLiveStreamTranscodeResponseBody>(model1);
      }
    }
  }


  virtual ~AddRtsLiveStreamTranscodeResponse() = default;
};
class AddShowIntoShowListRequestShowList : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> liveInputType{};
  shared_ptr<long> repeatTimes{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceUrl{};
  shared_ptr<string> showName{};

  AddShowIntoShowListRequestShowList() {}

  explicit AddShowIntoShowListRequestShowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (liveInputType) {
      res["liveInputType"] = boost::any(*liveInputType);
    }
    if (repeatTimes) {
      res["repeatTimes"] = boost::any(*repeatTimes);
    }
    if (resourceId) {
      res["resourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    if (resourceUrl) {
      res["resourceUrl"] = boost::any(*resourceUrl);
    }
    if (showName) {
      res["showName"] = boost::any(*showName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("liveInputType") != m.end() && !m["liveInputType"].empty()) {
      liveInputType = make_shared<long>(boost::any_cast<long>(m["liveInputType"]));
    }
    if (m.find("repeatTimes") != m.end() && !m["repeatTimes"].empty()) {
      repeatTimes = make_shared<long>(boost::any_cast<long>(m["repeatTimes"]));
    }
    if (m.find("resourceId") != m.end() && !m["resourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["resourceId"]));
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
    if (m.find("resourceUrl") != m.end() && !m["resourceUrl"].empty()) {
      resourceUrl = make_shared<string>(boost::any_cast<string>(m["resourceUrl"]));
    }
    if (m.find("showName") != m.end() && !m["showName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["showName"]));
    }
  }


  virtual ~AddShowIntoShowListRequestShowList() = default;
};
class AddShowIntoShowListRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> duration{};
  shared_ptr<long> liveInputType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> repeatTimes{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceUrl{};
  shared_ptr<string> showName{};
  shared_ptr<long> spot{};
  shared_ptr<bool> isBatchMode{};
  shared_ptr<vector<AddShowIntoShowListRequestShowList>> showList{};

  AddShowIntoShowListRequest() {}

  explicit AddShowIntoShowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (liveInputType) {
      res["LiveInputType"] = boost::any(*liveInputType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (repeatTimes) {
      res["RepeatTimes"] = boost::any(*repeatTimes);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceUrl) {
      res["ResourceUrl"] = boost::any(*resourceUrl);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (spot) {
      res["Spot"] = boost::any(*spot);
    }
    if (isBatchMode) {
      res["isBatchMode"] = boost::any(*isBatchMode);
    }
    if (showList) {
      vector<boost::any> temp1;
      for(auto item1:*showList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["showList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("LiveInputType") != m.end() && !m["LiveInputType"].empty()) {
      liveInputType = make_shared<long>(boost::any_cast<long>(m["LiveInputType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RepeatTimes") != m.end() && !m["RepeatTimes"].empty()) {
      repeatTimes = make_shared<long>(boost::any_cast<long>(m["RepeatTimes"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceUrl") != m.end() && !m["ResourceUrl"].empty()) {
      resourceUrl = make_shared<string>(boost::any_cast<string>(m["ResourceUrl"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("Spot") != m.end() && !m["Spot"].empty()) {
      spot = make_shared<long>(boost::any_cast<long>(m["Spot"]));
    }
    if (m.find("isBatchMode") != m.end() && !m["isBatchMode"].empty()) {
      isBatchMode = make_shared<bool>(boost::any_cast<bool>(m["isBatchMode"]));
    }
    if (m.find("showList") != m.end() && !m["showList"].empty()) {
      if (typeid(vector<boost::any>) == m["showList"].type()) {
        vector<AddShowIntoShowListRequestShowList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["showList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddShowIntoShowListRequestShowList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        showList = make_shared<vector<AddShowIntoShowListRequestShowList>>(expect1);
      }
    }
  }


  virtual ~AddShowIntoShowListRequest() = default;
};
class AddShowIntoShowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> showId{};
  shared_ptr<string> failedList{};
  shared_ptr<string> successfulShowIds{};

  AddShowIntoShowListResponseBody() {}

  explicit AddShowIntoShowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (failedList) {
      res["failedList"] = boost::any(*failedList);
    }
    if (successfulShowIds) {
      res["successfulShowIds"] = boost::any(*successfulShowIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("failedList") != m.end() && !m["failedList"].empty()) {
      failedList = make_shared<string>(boost::any_cast<string>(m["failedList"]));
    }
    if (m.find("successfulShowIds") != m.end() && !m["successfulShowIds"].empty()) {
      successfulShowIds = make_shared<string>(boost::any_cast<string>(m["successfulShowIds"]));
    }
  }


  virtual ~AddShowIntoShowListResponseBody() = default;
};
class AddShowIntoShowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddShowIntoShowListResponseBody> body{};

  AddShowIntoShowListResponse() {}

  explicit AddShowIntoShowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddShowIntoShowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddShowIntoShowListResponseBody>(model1);
      }
    }
  }


  virtual ~AddShowIntoShowListResponse() = default;
};
class AddStudioLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgImageConfig{};
  shared_ptr<string> casterId{};
  shared_ptr<string> commonConfig{};
  shared_ptr<string> layerOrderConfigList{};
  shared_ptr<string> layoutName{};
  shared_ptr<string> layoutType{};
  shared_ptr<string> mediaInputConfigList{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> screenInputConfigList{};

  AddStudioLayoutRequest() {}

  explicit AddStudioLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgImageConfig) {
      res["BgImageConfig"] = boost::any(*bgImageConfig);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (commonConfig) {
      res["CommonConfig"] = boost::any(*commonConfig);
    }
    if (layerOrderConfigList) {
      res["LayerOrderConfigList"] = boost::any(*layerOrderConfigList);
    }
    if (layoutName) {
      res["LayoutName"] = boost::any(*layoutName);
    }
    if (layoutType) {
      res["LayoutType"] = boost::any(*layoutType);
    }
    if (mediaInputConfigList) {
      res["MediaInputConfigList"] = boost::any(*mediaInputConfigList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (screenInputConfigList) {
      res["ScreenInputConfigList"] = boost::any(*screenInputConfigList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgImageConfig") != m.end() && !m["BgImageConfig"].empty()) {
      bgImageConfig = make_shared<string>(boost::any_cast<string>(m["BgImageConfig"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CommonConfig") != m.end() && !m["CommonConfig"].empty()) {
      commonConfig = make_shared<string>(boost::any_cast<string>(m["CommonConfig"]));
    }
    if (m.find("LayerOrderConfigList") != m.end() && !m["LayerOrderConfigList"].empty()) {
      layerOrderConfigList = make_shared<string>(boost::any_cast<string>(m["LayerOrderConfigList"]));
    }
    if (m.find("LayoutName") != m.end() && !m["LayoutName"].empty()) {
      layoutName = make_shared<string>(boost::any_cast<string>(m["LayoutName"]));
    }
    if (m.find("LayoutType") != m.end() && !m["LayoutType"].empty()) {
      layoutType = make_shared<string>(boost::any_cast<string>(m["LayoutType"]));
    }
    if (m.find("MediaInputConfigList") != m.end() && !m["MediaInputConfigList"].empty()) {
      mediaInputConfigList = make_shared<string>(boost::any_cast<string>(m["MediaInputConfigList"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ScreenInputConfigList") != m.end() && !m["ScreenInputConfigList"].empty()) {
      screenInputConfigList = make_shared<string>(boost::any_cast<string>(m["ScreenInputConfigList"]));
    }
  }


  virtual ~AddStudioLayoutRequest() = default;
};
class AddStudioLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> layoutId{};
  shared_ptr<string> requestId{};

  AddStudioLayoutResponseBody() {}

  explicit AddStudioLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddStudioLayoutResponseBody() = default;
};
class AddStudioLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddStudioLayoutResponseBody> body{};

  AddStudioLayoutResponse() {}

  explicit AddStudioLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddStudioLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddStudioLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~AddStudioLayoutResponse() = default;
};
class AddTrancodeSEIRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> delay{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pattern{};
  shared_ptr<long> repeat{};
  shared_ptr<string> streamName{};
  shared_ptr<string> text{};

  AddTrancodeSEIRequest() {}

  explicit AddTrancodeSEIRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (repeat) {
      res["Repeat"] = boost::any(*repeat);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("Repeat") != m.end() && !m["Repeat"].empty()) {
      repeat = make_shared<long>(boost::any_cast<long>(m["Repeat"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~AddTrancodeSEIRequest() = default;
};
class AddTrancodeSEIResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddTrancodeSEIResponseBody() {}

  explicit AddTrancodeSEIResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddTrancodeSEIResponseBody() = default;
};
class AddTrancodeSEIResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTrancodeSEIResponseBody> body{};

  AddTrancodeSEIResponse() {}

  explicit AddTrancodeSEIResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTrancodeSEIResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTrancodeSEIResponseBody>(model1);
      }
    }
  }


  virtual ~AddTrancodeSEIResponse() = default;
};
class AllowPushStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> roomId{};

  AllowPushStreamRequest() {}

  explicit AllowPushStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~AllowPushStreamRequest() = default;
};
class AllowPushStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AllowPushStreamResponseBody() {}

  explicit AllowPushStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AllowPushStreamResponseBody() = default;
};
class AllowPushStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AllowPushStreamResponseBody> body{};

  AllowPushStreamResponse() {}

  explicit AllowPushStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllowPushStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllowPushStreamResponseBody>(model1);
      }
    }
  }


  virtual ~AllowPushStreamResponse() = default;
};
class BatchDeleteLiveDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functionNames{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchDeleteLiveDomainConfigsRequest() {}

  explicit BatchDeleteLiveDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchDeleteLiveDomainConfigsRequest() = default;
};
class BatchDeleteLiveDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchDeleteLiveDomainConfigsResponseBody() {}

  explicit BatchDeleteLiveDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchDeleteLiveDomainConfigsResponseBody() = default;
};
class BatchDeleteLiveDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteLiveDomainConfigsResponseBody> body{};

  BatchDeleteLiveDomainConfigsResponse() {}

  explicit BatchDeleteLiveDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteLiveDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteLiveDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteLiveDomainConfigsResponse() = default;
};
class BatchSetLiveDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functions{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchSetLiveDomainConfigsRequest() {}

  explicit BatchSetLiveDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchSetLiveDomainConfigsRequest() = default;
};
class BatchSetLiveDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetLiveDomainConfigsResponseBody() {}

  explicit BatchSetLiveDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetLiveDomainConfigsResponseBody() = default;
};
class BatchSetLiveDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetLiveDomainConfigsResponseBody> body{};

  BatchSetLiveDomainConfigsResponse() {}

  explicit BatchSetLiveDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetLiveDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetLiveDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetLiveDomainConfigsResponse() = default;
};
class CancelMuteAllGroupUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};

  CancelMuteAllGroupUserRequest() {}

  explicit CancelMuteAllGroupUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
  }


  virtual ~CancelMuteAllGroupUserRequest() = default;
};
class CancelMuteAllGroupUserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  CancelMuteAllGroupUserResponseBodyResult() {}

  explicit CancelMuteAllGroupUserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelMuteAllGroupUserResponseBodyResult() = default;
};
class CancelMuteAllGroupUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CancelMuteAllGroupUserResponseBodyResult> result{};

  CancelMuteAllGroupUserResponseBody() {}

  explicit CancelMuteAllGroupUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CancelMuteAllGroupUserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CancelMuteAllGroupUserResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CancelMuteAllGroupUserResponseBody() = default;
};
class CancelMuteAllGroupUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelMuteAllGroupUserResponseBody> body{};

  CancelMuteAllGroupUserResponse() {}

  explicit CancelMuteAllGroupUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelMuteAllGroupUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelMuteAllGroupUserResponseBody>(model1);
      }
    }
  }


  virtual ~CancelMuteAllGroupUserResponse() = default;
};
class CloseLiveShiftRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  CloseLiveShiftRequest() {}

  explicit CloseLiveShiftRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~CloseLiveShiftRequest() = default;
};
class CloseLiveShiftResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CloseLiveShiftResponseBody() {}

  explicit CloseLiveShiftResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CloseLiveShiftResponseBody() = default;
};
class CloseLiveShiftResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseLiveShiftResponseBody> body{};

  CloseLiveShiftResponse() {}

  explicit CloseLiveShiftResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseLiveShiftResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseLiveShiftResponseBody>(model1);
      }
    }
  }


  virtual ~CloseLiveShiftResponse() = default;
};
class CopyCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterName{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> srcCasterId{};

  CopyCasterRequest() {}

  explicit CopyCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (srcCasterId) {
      res["SrcCasterId"] = boost::any(*srcCasterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SrcCasterId") != m.end() && !m["SrcCasterId"].empty()) {
      srcCasterId = make_shared<string>(boost::any_cast<string>(m["SrcCasterId"]));
    }
  }


  virtual ~CopyCasterRequest() = default;
};
class CopyCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  CopyCasterResponseBody() {}

  explicit CopyCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyCasterResponseBody() = default;
};
class CopyCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyCasterResponseBody> body{};

  CopyCasterResponse() {}

  explicit CopyCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyCasterResponseBody>(model1);
      }
    }
  }


  virtual ~CopyCasterResponse() = default;
};
class CopyCasterSceneConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> fromSceneId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> toSceneId{};

  CopyCasterSceneConfigRequest() {}

  explicit CopyCasterSceneConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (fromSceneId) {
      res["FromSceneId"] = boost::any(*fromSceneId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (toSceneId) {
      res["ToSceneId"] = boost::any(*toSceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("FromSceneId") != m.end() && !m["FromSceneId"].empty()) {
      fromSceneId = make_shared<string>(boost::any_cast<string>(m["FromSceneId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ToSceneId") != m.end() && !m["ToSceneId"].empty()) {
      toSceneId = make_shared<string>(boost::any_cast<string>(m["ToSceneId"]));
    }
  }


  virtual ~CopyCasterSceneConfigRequest() = default;
};
class CopyCasterSceneConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CopyCasterSceneConfigResponseBody() {}

  explicit CopyCasterSceneConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyCasterSceneConfigResponseBody() = default;
};
class CopyCasterSceneConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyCasterSceneConfigResponseBody> body{};

  CopyCasterSceneConfigResponse() {}

  explicit CopyCasterSceneConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyCasterSceneConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyCasterSceneConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CopyCasterSceneConfigResponse() = default;
};
class CreateCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterName{};
  shared_ptr<string> casterTemplate{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> normType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> purchaseTime{};

  CreateCasterRequest() {}

  explicit CreateCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (casterTemplate) {
      res["CasterTemplate"] = boost::any(*casterTemplate);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (normType) {
      res["NormType"] = boost::any(*normType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (purchaseTime) {
      res["PurchaseTime"] = boost::any(*purchaseTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("CasterTemplate") != m.end() && !m["CasterTemplate"].empty()) {
      casterTemplate = make_shared<string>(boost::any_cast<string>(m["CasterTemplate"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("NormType") != m.end() && !m["NormType"].empty()) {
      normType = make_shared<long>(boost::any_cast<long>(m["NormType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PurchaseTime") != m.end() && !m["PurchaseTime"].empty()) {
      purchaseTime = make_shared<string>(boost::any_cast<string>(m["PurchaseTime"]));
    }
  }


  virtual ~CreateCasterRequest() = default;
};
class CreateCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  CreateCasterResponseBody() {}

  explicit CreateCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCasterResponseBody() = default;
};
class CreateCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCasterResponseBody> body{};

  CreateCasterResponse() {}

  explicit CreateCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCasterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCasterResponse() = default;
};
class CreateCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> customTemplate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> template_{};

  CreateCustomTemplateRequest() {}

  explicit CreateCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplate) {
      res["CustomTemplate"] = boost::any(*customTemplate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplate") != m.end() && !m["CustomTemplate"].empty()) {
      customTemplate = make_shared<string>(boost::any_cast<string>(m["CustomTemplate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~CreateCustomTemplateRequest() = default;
};
class CreateCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateCustomTemplateResponseBody() {}

  explicit CreateCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomTemplateResponseBody() = default;
};
class CreateCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomTemplateResponseBody> body{};

  CreateCustomTemplateResponse() {}

  explicit CreateCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomTemplateResponse() = default;
};
class CreateLiveRealTimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> logstore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  CreateLiveRealTimeLogDeliveryRequest() {}

  explicit CreateLiveRealTimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~CreateLiveRealTimeLogDeliveryRequest() = default;
};
class CreateLiveRealTimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLiveRealTimeLogDeliveryResponseBody() {}

  explicit CreateLiveRealTimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLiveRealTimeLogDeliveryResponseBody() = default;
};
class CreateLiveRealTimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveRealTimeLogDeliveryResponseBody> body{};

  CreateLiveRealTimeLogDeliveryResponse() {}

  explicit CreateLiveRealTimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveRealTimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveRealTimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveRealTimeLogDeliveryResponse() = default;
};
class CreateLiveStreamMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<string> inputList{};
  shared_ptr<string> monitorName{};
  shared_ptr<string> outputTemplate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> stream{};

  CreateLiveStreamMonitorRequest() {}

  explicit CreateLiveStreamMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (inputList) {
      res["InputList"] = boost::any(*inputList);
    }
    if (monitorName) {
      res["MonitorName"] = boost::any(*monitorName);
    }
    if (outputTemplate) {
      res["OutputTemplate"] = boost::any(*outputTemplate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      inputList = make_shared<string>(boost::any_cast<string>(m["InputList"]));
    }
    if (m.find("MonitorName") != m.end() && !m["MonitorName"].empty()) {
      monitorName = make_shared<string>(boost::any_cast<string>(m["MonitorName"]));
    }
    if (m.find("OutputTemplate") != m.end() && !m["OutputTemplate"].empty()) {
      outputTemplate = make_shared<string>(boost::any_cast<string>(m["OutputTemplate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~CreateLiveStreamMonitorRequest() = default;
};
class CreateLiveStreamMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> monitorId{};
  shared_ptr<string> requestId{};

  CreateLiveStreamMonitorResponseBody() {}

  explicit CreateLiveStreamMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLiveStreamMonitorResponseBody() = default;
};
class CreateLiveStreamMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveStreamMonitorResponseBody> body{};

  CreateLiveStreamMonitorResponse() {}

  explicit CreateLiveStreamMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveStreamMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveStreamMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveStreamMonitorResponse() = default;
};
class CreateLiveStreamRecordIndexFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  CreateLiveStreamRecordIndexFilesRequest() {}

  explicit CreateLiveStreamRecordIndexFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~CreateLiveStreamRecordIndexFilesRequest() = default;
};
class CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainName{};
  shared_ptr<double> duration{};
  shared_ptr<string> endTime{};
  shared_ptr<long> height{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<string> recordId{};
  shared_ptr<string> recordUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<long> width{};

  CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo() {}

  explicit CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordUrl) {
      res["RecordUrl"] = boost::any(*recordUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RecordUrl") != m.end() && !m["RecordUrl"].empty()) {
      recordUrl = make_shared<string>(boost::any_cast<string>(m["RecordUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo() = default;
};
class CreateLiveStreamRecordIndexFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo> recordInfo{};
  shared_ptr<string> requestId{};

  CreateLiveStreamRecordIndexFilesResponseBody() {}

  explicit CreateLiveStreamRecordIndexFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordInfo) {
      res["RecordInfo"] = recordInfo ? boost::any(recordInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordInfo") != m.end() && !m["RecordInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordInfo"].type()) {
        CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordInfo"]));
        recordInfo = make_shared<CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLiveStreamRecordIndexFilesResponseBody() = default;
};
class CreateLiveStreamRecordIndexFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveStreamRecordIndexFilesResponseBody> body{};

  CreateLiveStreamRecordIndexFilesResponse() {}

  explicit CreateLiveStreamRecordIndexFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveStreamRecordIndexFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveStreamRecordIndexFilesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveStreamRecordIndexFilesResponse() = default;
};
class CreateLiveTranscodeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> type{};

  CreateLiveTranscodeTemplateRequest() {}

  explicit CreateLiveTranscodeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateRequest() = default;
};
class CreateLiveTranscodeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  CreateLiveTranscodeTemplateResponseBody() {}

  explicit CreateLiveTranscodeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateResponseBody() = default;
};
class CreateLiveTranscodeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveTranscodeTemplateResponseBody> body{};

  CreateLiveTranscodeTemplateResponse() {}

  explicit CreateLiveTranscodeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveTranscodeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveTranscodeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveTranscodeTemplateResponse() = default;
};
class CreateMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> appConfig{};
  shared_ptr<string> appName{};
  shared_ptr<map<string, string>> extension{};

  CreateMessageAppRequest() {}

  explicit CreateMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["AppConfig"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      appConfig = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~CreateMessageAppRequest() = default;
};
class CreateMessageAppShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appConfigShrink{};
  shared_ptr<string> appName{};
  shared_ptr<string> extensionShrink{};

  CreateMessageAppShrinkRequest() {}

  explicit CreateMessageAppShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfigShrink) {
      res["AppConfig"] = boost::any(*appConfigShrink);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (extensionShrink) {
      res["Extension"] = boost::any(*extensionShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      appConfigShrink = make_shared<string>(boost::any_cast<string>(m["AppConfig"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extensionShrink = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
  }


  virtual ~CreateMessageAppShrinkRequest() = default;
};
class CreateMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  CreateMessageAppResponseBodyResult() {}

  explicit CreateMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~CreateMessageAppResponseBodyResult() = default;
};
class CreateMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateMessageAppResponseBodyResult> result{};

  CreateMessageAppResponseBody() {}

  explicit CreateMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateMessageAppResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateMessageAppResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateMessageAppResponseBody() = default;
};
class CreateMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMessageAppResponseBody> body{};

  CreateMessageAppResponse() {}

  explicit CreateMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMessageAppResponse() = default;
};
class CreateMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> creatorId{};
  shared_ptr<map<string, string>> extension{};

  CreateMessageGroupRequest() {}

  explicit CreateMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~CreateMessageGroupRequest() = default;
};
class CreateMessageGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extensionShrink{};

  CreateMessageGroupShrinkRequest() {}

  explicit CreateMessageGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extensionShrink) {
      res["Extension"] = boost::any(*extensionShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extensionShrink = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
  }


  virtual ~CreateMessageGroupShrinkRequest() = default;
};
class CreateMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> extension{};
  shared_ptr<string> groupId{};

  CreateMessageGroupResponseBodyResult() {}

  explicit CreateMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Extension"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~CreateMessageGroupResponseBodyResult() = default;
};
class CreateMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateMessageGroupResponseBodyResult> result{};

  CreateMessageGroupResponseBody() {}

  explicit CreateMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateMessageGroupResponseBody() = default;
};
class CreateMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMessageGroupResponseBody> body{};

  CreateMessageGroupResponse() {}

  explicit CreateMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMessageGroupResponse() = default;
};
class CreateMixStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackConfig{};
  shared_ptr<string> domainName{};
  shared_ptr<string> inputStreamList{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> outputConfig{};
  shared_ptr<long> ownerId{};

  CreateMixStreamRequest() {}

  explicit CreateMixStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackConfig) {
      res["CallbackConfig"] = boost::any(*callbackConfig);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (inputStreamList) {
      res["InputStreamList"] = boost::any(*inputStreamList);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackConfig") != m.end() && !m["CallbackConfig"].empty()) {
      callbackConfig = make_shared<string>(boost::any_cast<string>(m["CallbackConfig"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InputStreamList") != m.end() && !m["InputStreamList"].empty()) {
      inputStreamList = make_shared<string>(boost::any_cast<string>(m["InputStreamList"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~CreateMixStreamRequest() = default;
};
class CreateMixStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mixStreamId{};
  shared_ptr<string> requestId{};

  CreateMixStreamResponseBody() {}

  explicit CreateMixStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMixStreamResponseBody() = default;
};
class CreateMixStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMixStreamResponseBody> body{};

  CreateMixStreamResponse() {}

  explicit CreateMixStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMixStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMixStreamResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMixStreamResponse() = default;
};
class DeleteCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  DeleteCasterRequest() {}

  explicit DeleteCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteCasterRequest() = default;
};
class DeleteCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  DeleteCasterResponseBody() {}

  explicit DeleteCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterResponseBody() = default;
};
class DeleteCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterResponseBody> body{};

  DeleteCasterResponse() {}

  explicit DeleteCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterResponse() = default;
};
class DeleteCasterComponentRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> componentId{};
  shared_ptr<long> ownerId{};

  DeleteCasterComponentRequest() {}

  explicit DeleteCasterComponentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteCasterComponentRequest() = default;
};
class DeleteCasterComponentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> componentId{};
  shared_ptr<string> requestId{};

  DeleteCasterComponentResponseBody() {}

  explicit DeleteCasterComponentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterComponentResponseBody() = default;
};
class DeleteCasterComponentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterComponentResponseBody> body{};

  DeleteCasterComponentResponse() {}

  explicit DeleteCasterComponentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterComponentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterComponentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterComponentResponse() = default;
};
class DeleteCasterEpisodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> episodeId{};
  shared_ptr<long> ownerId{};

  DeleteCasterEpisodeRequest() {}

  explicit DeleteCasterEpisodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteCasterEpisodeRequest() = default;
};
class DeleteCasterEpisodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> requestId{};

  DeleteCasterEpisodeResponseBody() {}

  explicit DeleteCasterEpisodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterEpisodeResponseBody() = default;
};
class DeleteCasterEpisodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterEpisodeResponseBody> body{};

  DeleteCasterEpisodeResponse() {}

  explicit DeleteCasterEpisodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterEpisodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterEpisodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterEpisodeResponse() = default;
};
class DeleteCasterEpisodeGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};

  DeleteCasterEpisodeGroupRequest() {}

  explicit DeleteCasterEpisodeGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
  }


  virtual ~DeleteCasterEpisodeGroupRequest() = default;
};
class DeleteCasterEpisodeGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCasterEpisodeGroupResponseBody() {}

  explicit DeleteCasterEpisodeGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterEpisodeGroupResponseBody() = default;
};
class DeleteCasterEpisodeGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterEpisodeGroupResponseBody> body{};

  DeleteCasterEpisodeGroupResponse() {}

  explicit DeleteCasterEpisodeGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterEpisodeGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterEpisodeGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterEpisodeGroupResponse() = default;
};
class DeleteCasterLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};

  DeleteCasterLayoutRequest() {}

  explicit DeleteCasterLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteCasterLayoutRequest() = default;
};
class DeleteCasterLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> requestId{};

  DeleteCasterLayoutResponseBody() {}

  explicit DeleteCasterLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterLayoutResponseBody() = default;
};
class DeleteCasterLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterLayoutResponseBody> body{};

  DeleteCasterLayoutResponse() {}

  explicit DeleteCasterLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterLayoutResponse() = default;
};
class DeleteCasterProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  DeleteCasterProgramRequest() {}

  explicit DeleteCasterProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteCasterProgramRequest() = default;
};
class DeleteCasterProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  DeleteCasterProgramResponseBody() {}

  explicit DeleteCasterProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterProgramResponseBody() = default;
};
class DeleteCasterProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterProgramResponseBody> body{};

  DeleteCasterProgramResponse() {}

  explicit DeleteCasterProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterProgramResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterProgramResponse() = default;
};
class DeleteCasterSceneConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sceneId{};
  shared_ptr<string> type{};

  DeleteCasterSceneConfigRequest() {}

  explicit DeleteCasterSceneConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteCasterSceneConfigRequest() = default;
};
class DeleteCasterSceneConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCasterSceneConfigResponseBody() {}

  explicit DeleteCasterSceneConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterSceneConfigResponseBody() = default;
};
class DeleteCasterSceneConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterSceneConfigResponseBody> body{};

  DeleteCasterSceneConfigResponse() {}

  explicit DeleteCasterSceneConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterSceneConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterSceneConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterSceneConfigResponse() = default;
};
class DeleteCasterVideoResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceId{};

  DeleteCasterVideoResourceRequest() {}

  explicit DeleteCasterVideoResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~DeleteCasterVideoResourceRequest() = default;
};
class DeleteCasterVideoResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCasterVideoResourceResponseBody() {}

  explicit DeleteCasterVideoResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterVideoResourceResponseBody() = default;
};
class DeleteCasterVideoResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterVideoResourceResponseBody> body{};

  DeleteCasterVideoResourceResponse() {}

  explicit DeleteCasterVideoResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterVideoResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterVideoResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterVideoResourceResponse() = default;
};
class DeleteCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> template_{};

  DeleteCustomTemplateRequest() {}

  explicit DeleteCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~DeleteCustomTemplateRequest() = default;
};
class DeleteCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomTemplateResponseBody() {}

  explicit DeleteCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomTemplateResponseBody() = default;
};
class DeleteCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomTemplateResponseBody> body{};

  DeleteCustomTemplateResponse() {}

  explicit DeleteCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomTemplateResponse() = default;
};
class DeleteLiveAppRecordConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> streamName{};

  DeleteLiveAppRecordConfigRequest() {}

  explicit DeleteLiveAppRecordConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLiveAppRecordConfigRequest() = default;
};
class DeleteLiveAppRecordConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveAppRecordConfigResponseBody() {}

  explicit DeleteLiveAppRecordConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveAppRecordConfigResponseBody() = default;
};
class DeleteLiveAppRecordConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveAppRecordConfigResponseBody> body{};

  DeleteLiveAppRecordConfigResponse() {}

  explicit DeleteLiveAppRecordConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveAppRecordConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveAppRecordConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveAppRecordConfigResponse() = default;
};
class DeleteLiveAppSnapshotConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveAppSnapshotConfigRequest() {}

  explicit DeleteLiveAppSnapshotConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveAppSnapshotConfigRequest() = default;
};
class DeleteLiveAppSnapshotConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveAppSnapshotConfigResponseBody() {}

  explicit DeleteLiveAppSnapshotConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveAppSnapshotConfigResponseBody() = default;
};
class DeleteLiveAppSnapshotConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveAppSnapshotConfigResponseBody> body{};

  DeleteLiveAppSnapshotConfigResponse() {}

  explicit DeleteLiveAppSnapshotConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveAppSnapshotConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveAppSnapshotConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveAppSnapshotConfigResponse() = default;
};
class DeleteLiveAudioAuditConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  DeleteLiveAudioAuditConfigRequest() {}

  explicit DeleteLiveAudioAuditConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLiveAudioAuditConfigRequest() = default;
};
class DeleteLiveAudioAuditConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveAudioAuditConfigResponseBody() {}

  explicit DeleteLiveAudioAuditConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveAudioAuditConfigResponseBody() = default;
};
class DeleteLiveAudioAuditConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveAudioAuditConfigResponseBody> body{};

  DeleteLiveAudioAuditConfigResponse() {}

  explicit DeleteLiveAudioAuditConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveAudioAuditConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveAudioAuditConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveAudioAuditConfigResponse() = default;
};
class DeleteLiveAudioAuditNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DeleteLiveAudioAuditNotifyConfigRequest() {}

  explicit DeleteLiveAudioAuditNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteLiveAudioAuditNotifyConfigRequest() = default;
};
class DeleteLiveAudioAuditNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveAudioAuditNotifyConfigResponseBody() {}

  explicit DeleteLiveAudioAuditNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveAudioAuditNotifyConfigResponseBody() = default;
};
class DeleteLiveAudioAuditNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveAudioAuditNotifyConfigResponseBody> body{};

  DeleteLiveAudioAuditNotifyConfigResponse() {}

  explicit DeleteLiveAudioAuditNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveAudioAuditNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveAudioAuditNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveAudioAuditNotifyConfigResponse() = default;
};
class DeleteLiveDetectNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveDetectNotifyConfigRequest() {}

  explicit DeleteLiveDetectNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveDetectNotifyConfigRequest() = default;
};
class DeleteLiveDetectNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveDetectNotifyConfigResponseBody() {}

  explicit DeleteLiveDetectNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveDetectNotifyConfigResponseBody() = default;
};
class DeleteLiveDetectNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveDetectNotifyConfigResponseBody> body{};

  DeleteLiveDetectNotifyConfigResponse() {}

  explicit DeleteLiveDetectNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveDetectNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveDetectNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveDetectNotifyConfigResponse() = default;
};
class DeleteLiveDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveDomainRequest() {}

  explicit DeleteLiveDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveDomainRequest() = default;
};
class DeleteLiveDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveDomainResponseBody() {}

  explicit DeleteLiveDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveDomainResponseBody() = default;
};
class DeleteLiveDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveDomainResponseBody> body{};

  DeleteLiveDomainResponse() {}

  explicit DeleteLiveDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveDomainResponse() = default;
};
class DeleteLiveDomainMappingRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> pullDomain{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> securityToken{};

  DeleteLiveDomainMappingRequest() {}

  explicit DeleteLiveDomainMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pullDomain) {
      res["PullDomain"] = boost::any(*pullDomain);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PullDomain") != m.end() && !m["PullDomain"].empty()) {
      pullDomain = make_shared<string>(boost::any_cast<string>(m["PullDomain"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveDomainMappingRequest() = default;
};
class DeleteLiveDomainMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveDomainMappingResponseBody() {}

  explicit DeleteLiveDomainMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveDomainMappingResponseBody() = default;
};
class DeleteLiveDomainMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveDomainMappingResponseBody> body{};

  DeleteLiveDomainMappingResponse() {}

  explicit DeleteLiveDomainMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveDomainMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveDomainMappingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveDomainMappingResponse() = default;
};
class DeleteLiveDomainPlayMappingRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> playDomain{};
  shared_ptr<string> pullDomain{};

  DeleteLiveDomainPlayMappingRequest() {}

  explicit DeleteLiveDomainPlayMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    if (pullDomain) {
      res["PullDomain"] = boost::any(*pullDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
    if (m.find("PullDomain") != m.end() && !m["PullDomain"].empty()) {
      pullDomain = make_shared<string>(boost::any_cast<string>(m["PullDomain"]));
    }
  }


  virtual ~DeleteLiveDomainPlayMappingRequest() = default;
};
class DeleteLiveDomainPlayMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveDomainPlayMappingResponseBody() {}

  explicit DeleteLiveDomainPlayMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveDomainPlayMappingResponseBody() = default;
};
class DeleteLiveDomainPlayMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveDomainPlayMappingResponseBody> body{};

  DeleteLiveDomainPlayMappingResponse() {}

  explicit DeleteLiveDomainPlayMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveDomainPlayMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveDomainPlayMappingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveDomainPlayMappingResponse() = default;
};
class DeleteLiveEdgeTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DeleteLiveEdgeTransferRequest() {}

  explicit DeleteLiveEdgeTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteLiveEdgeTransferRequest() = default;
};
class DeleteLiveEdgeTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveEdgeTransferResponseBody() {}

  explicit DeleteLiveEdgeTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveEdgeTransferResponseBody() = default;
};
class DeleteLiveEdgeTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveEdgeTransferResponseBody> body{};

  DeleteLiveEdgeTransferResponse() {}

  explicit DeleteLiveEdgeTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveEdgeTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveEdgeTransferResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveEdgeTransferResponse() = default;
};
class DeleteLiveLazyPullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DeleteLiveLazyPullStreamInfoConfigRequest() {}

  explicit DeleteLiveLazyPullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteLiveLazyPullStreamInfoConfigRequest() = default;
};
class DeleteLiveLazyPullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveLazyPullStreamInfoConfigResponseBody() {}

  explicit DeleteLiveLazyPullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveLazyPullStreamInfoConfigResponseBody() = default;
};
class DeleteLiveLazyPullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveLazyPullStreamInfoConfigResponseBody> body{};

  DeleteLiveLazyPullStreamInfoConfigResponse() {}

  explicit DeleteLiveLazyPullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveLazyPullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveLazyPullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveLazyPullStreamInfoConfigResponse() = default;
};
class DeleteLivePullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  DeleteLivePullStreamInfoConfigRequest() {}

  explicit DeleteLivePullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLivePullStreamInfoConfigRequest() = default;
};
class DeleteLivePullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLivePullStreamInfoConfigResponseBody() {}

  explicit DeleteLivePullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLivePullStreamInfoConfigResponseBody() = default;
};
class DeleteLivePullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLivePullStreamInfoConfigResponseBody> body{};

  DeleteLivePullStreamInfoConfigResponse() {}

  explicit DeleteLivePullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLivePullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLivePullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLivePullStreamInfoConfigResponse() = default;
};
class DeleteLiveRealTimeLogLogstoreRequest : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  DeleteLiveRealTimeLogLogstoreRequest() {}

  explicit DeleteLiveRealTimeLogLogstoreRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DeleteLiveRealTimeLogLogstoreRequest() = default;
};
class DeleteLiveRealTimeLogLogstoreResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveRealTimeLogLogstoreResponseBody() {}

  explicit DeleteLiveRealTimeLogLogstoreResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRealTimeLogLogstoreResponseBody() = default;
};
class DeleteLiveRealTimeLogLogstoreResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRealTimeLogLogstoreResponseBody> body{};

  DeleteLiveRealTimeLogLogstoreResponse() {}

  explicit DeleteLiveRealTimeLogLogstoreResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRealTimeLogLogstoreResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRealTimeLogLogstoreResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRealTimeLogLogstoreResponse() = default;
};
class DeleteLiveRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> logstore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  DeleteLiveRealtimeLogDeliveryRequest() {}

  explicit DeleteLiveRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DeleteLiveRealtimeLogDeliveryRequest() = default;
};
class DeleteLiveRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveRealtimeLogDeliveryResponseBody() {}

  explicit DeleteLiveRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRealtimeLogDeliveryResponseBody() = default;
};
class DeleteLiveRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRealtimeLogDeliveryResponseBody> body{};

  DeleteLiveRealtimeLogDeliveryResponse() {}

  explicit DeleteLiveRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRealtimeLogDeliveryResponse() = default;
};
class DeleteLiveRecordNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveRecordNotifyConfigRequest() {}

  explicit DeleteLiveRecordNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveRecordNotifyConfigRequest() = default;
};
class DeleteLiveRecordNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveRecordNotifyConfigResponseBody() {}

  explicit DeleteLiveRecordNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRecordNotifyConfigResponseBody() = default;
};
class DeleteLiveRecordNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRecordNotifyConfigResponseBody> body{};

  DeleteLiveRecordNotifyConfigResponse() {}

  explicit DeleteLiveRecordNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRecordNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRecordNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRecordNotifyConfigResponse() = default;
};
class DeleteLiveRecordVodConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  DeleteLiveRecordVodConfigRequest() {}

  explicit DeleteLiveRecordVodConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLiveRecordVodConfigRequest() = default;
};
class DeleteLiveRecordVodConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveRecordVodConfigResponseBody() {}

  explicit DeleteLiveRecordVodConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRecordVodConfigResponseBody() = default;
};
class DeleteLiveRecordVodConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRecordVodConfigResponseBody> body{};

  DeleteLiveRecordVodConfigResponse() {}

  explicit DeleteLiveRecordVodConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRecordVodConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRecordVodConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRecordVodConfigResponse() = default;
};
class DeleteLiveSnapshotDetectPornConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveSnapshotDetectPornConfigRequest() {}

  explicit DeleteLiveSnapshotDetectPornConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveSnapshotDetectPornConfigRequest() = default;
};
class DeleteLiveSnapshotDetectPornConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveSnapshotDetectPornConfigResponseBody() {}

  explicit DeleteLiveSnapshotDetectPornConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveSnapshotDetectPornConfigResponseBody() = default;
};
class DeleteLiveSnapshotDetectPornConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveSnapshotDetectPornConfigResponseBody> body{};

  DeleteLiveSnapshotDetectPornConfigResponse() {}

  explicit DeleteLiveSnapshotDetectPornConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveSnapshotDetectPornConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveSnapshotDetectPornConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveSnapshotDetectPornConfigResponse() = default;
};
class DeleteLiveSnapshotNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DeleteLiveSnapshotNotifyConfigRequest() {}

  explicit DeleteLiveSnapshotNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteLiveSnapshotNotifyConfigRequest() = default;
};
class DeleteLiveSnapshotNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveSnapshotNotifyConfigResponseBody() {}

  explicit DeleteLiveSnapshotNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveSnapshotNotifyConfigResponseBody() = default;
};
class DeleteLiveSnapshotNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveSnapshotNotifyConfigResponseBody> body{};

  DeleteLiveSnapshotNotifyConfigResponse() {}

  explicit DeleteLiveSnapshotNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveSnapshotNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveSnapshotNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveSnapshotNotifyConfigResponse() = default;
};
class DeleteLiveSpecificStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveSpecificStagingConfigRequest() {}

  explicit DeleteLiveSpecificStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveSpecificStagingConfigRequest() = default;
};
class DeleteLiveSpecificStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveSpecificStagingConfigResponseBody() {}

  explicit DeleteLiveSpecificStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveSpecificStagingConfigResponseBody() = default;
};
class DeleteLiveSpecificStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveSpecificStagingConfigResponseBody> body{};

  DeleteLiveSpecificStagingConfigResponse() {}

  explicit DeleteLiveSpecificStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveSpecificStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveSpecificStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveSpecificStagingConfigResponse() = default;
};
class DeleteLiveStreamMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> monitorId{};
  shared_ptr<long> ownerId{};

  DeleteLiveStreamMonitorRequest() {}

  explicit DeleteLiveStreamMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteLiveStreamMonitorRequest() = default;
};
class DeleteLiveStreamMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveStreamMonitorResponseBody() {}

  explicit DeleteLiveStreamMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamMonitorResponseBody() = default;
};
class DeleteLiveStreamMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamMonitorResponseBody> body{};

  DeleteLiveStreamMonitorResponse() {}

  explicit DeleteLiveStreamMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamMonitorResponse() = default;
};
class DeleteLiveStreamRecordIndexFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> recordId{};
  shared_ptr<string> removeFile{};
  shared_ptr<string> streamName{};

  DeleteLiveStreamRecordIndexFilesRequest() {}

  explicit DeleteLiveStreamRecordIndexFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (removeFile) {
      res["RemoveFile"] = boost::any(*removeFile);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RemoveFile") != m.end() && !m["RemoveFile"].empty()) {
      removeFile = make_shared<string>(boost::any_cast<string>(m["RemoveFile"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLiveStreamRecordIndexFilesRequest() = default;
};
class DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> recordId{};

  DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo() {}

  explicit DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
  }


  virtual ~DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo() = default;
};
class DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo>> recordDeleteInfo{};

  DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList() {}

  explicit DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordDeleteInfo) {
      vector<boost::any> temp1;
      for(auto item1:*recordDeleteInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordDeleteInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordDeleteInfo") != m.end() && !m["RecordDeleteInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordDeleteInfo"].type()) {
        vector<DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordDeleteInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordDeleteInfo = make_shared<vector<DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo>>(expect1);
      }
    }
  }


  virtual ~DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList() = default;
};
class DeleteLiveStreamRecordIndexFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList> recordDeleteInfoList{};
  shared_ptr<string> requestId{};

  DeleteLiveStreamRecordIndexFilesResponseBody() {}

  explicit DeleteLiveStreamRecordIndexFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (recordDeleteInfoList) {
      res["RecordDeleteInfoList"] = recordDeleteInfoList ? boost::any(recordDeleteInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RecordDeleteInfoList") != m.end() && !m["RecordDeleteInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordDeleteInfoList"].type()) {
        DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordDeleteInfoList"]));
        recordDeleteInfoList = make_shared<DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamRecordIndexFilesResponseBody() = default;
};
class DeleteLiveStreamRecordIndexFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamRecordIndexFilesResponseBody> body{};

  DeleteLiveStreamRecordIndexFilesResponse() {}

  explicit DeleteLiveStreamRecordIndexFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamRecordIndexFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamRecordIndexFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamRecordIndexFilesResponse() = default;
};
class DeleteLiveStreamTranscodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> template_{};

  DeleteLiveStreamTranscodeRequest() {}

  explicit DeleteLiveStreamTranscodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~DeleteLiveStreamTranscodeRequest() = default;
};
class DeleteLiveStreamTranscodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveStreamTranscodeResponseBody() {}

  explicit DeleteLiveStreamTranscodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamTranscodeResponseBody() = default;
};
class DeleteLiveStreamTranscodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamTranscodeResponseBody> body{};

  DeleteLiveStreamTranscodeResponse() {}

  explicit DeleteLiveStreamTranscodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamTranscodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamTranscodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamTranscodeResponse() = default;
};
class DeleteLiveStreamWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> templateId{};

  DeleteLiveStreamWatermarkRequest() {}

  explicit DeleteLiveStreamWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteLiveStreamWatermarkRequest() = default;
};
class DeleteLiveStreamWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveStreamWatermarkResponseBody() {}

  explicit DeleteLiveStreamWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamWatermarkResponseBody() = default;
};
class DeleteLiveStreamWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamWatermarkResponseBody> body{};

  DeleteLiveStreamWatermarkResponse() {}

  explicit DeleteLiveStreamWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamWatermarkResponse() = default;
};
class DeleteLiveStreamWatermarkRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> stream{};

  DeleteLiveStreamWatermarkRuleRequest() {}

  explicit DeleteLiveStreamWatermarkRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~DeleteLiveStreamWatermarkRuleRequest() = default;
};
class DeleteLiveStreamWatermarkRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveStreamWatermarkRuleResponseBody() {}

  explicit DeleteLiveStreamWatermarkRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamWatermarkRuleResponseBody() = default;
};
class DeleteLiveStreamWatermarkRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamWatermarkRuleResponseBody> body{};

  DeleteLiveStreamWatermarkRuleResponse() {}

  explicit DeleteLiveStreamWatermarkRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamWatermarkRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamWatermarkRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamWatermarkRuleResponse() = default;
};
class DeleteLiveStreamsNotifyUrlConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DeleteLiveStreamsNotifyUrlConfigRequest() {}

  explicit DeleteLiveStreamsNotifyUrlConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteLiveStreamsNotifyUrlConfigRequest() = default;
};
class DeleteLiveStreamsNotifyUrlConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveStreamsNotifyUrlConfigResponseBody() {}

  explicit DeleteLiveStreamsNotifyUrlConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamsNotifyUrlConfigResponseBody() = default;
};
class DeleteLiveStreamsNotifyUrlConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamsNotifyUrlConfigResponseBody> body{};

  DeleteLiveStreamsNotifyUrlConfigResponse() {}

  explicit DeleteLiveStreamsNotifyUrlConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamsNotifyUrlConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamsNotifyUrlConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamsNotifyUrlConfigResponse() = default;
};
class DeleteMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DeleteMessageAppRequest() {}

  explicit DeleteMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteMessageAppRequest() = default;
};
class DeleteMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  DeleteMessageAppResponseBodyResult() {}

  explicit DeleteMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMessageAppResponseBodyResult() = default;
};
class DeleteMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteMessageAppResponseBodyResult> result{};

  DeleteMessageAppResponseBody() {}

  explicit DeleteMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DeleteMessageAppResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DeleteMessageAppResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DeleteMessageAppResponseBody() = default;
};
class DeleteMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMessageAppResponseBody> body{};

  DeleteMessageAppResponse() {}

  explicit DeleteMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMessageAppResponse() = default;
};
class DeleteMixStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> mixStreamId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  DeleteMixStreamRequest() {}

  explicit DeleteMixStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteMixStreamRequest() = default;
};
class DeleteMixStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mixStreamId{};
  shared_ptr<string> requestId{};

  DeleteMixStreamResponseBody() {}

  explicit DeleteMixStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMixStreamResponseBody() = default;
};
class DeleteMixStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMixStreamResponseBody> body{};

  DeleteMixStreamResponse() {}

  explicit DeleteMixStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMixStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMixStreamResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMixStreamResponse() = default;
};
class DeleteMultiRateConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> deleteAll{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> templates{};

  DeleteMultiRateConfigRequest() {}

  explicit DeleteMultiRateConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (deleteAll) {
      res["DeleteAll"] = boost::any(*deleteAll);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (templates) {
      res["Templates"] = boost::any(*templates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("DeleteAll") != m.end() && !m["DeleteAll"].empty()) {
      deleteAll = make_shared<string>(boost::any_cast<string>(m["DeleteAll"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      templates = make_shared<string>(boost::any_cast<string>(m["Templates"]));
    }
  }


  virtual ~DeleteMultiRateConfigRequest() = default;
};
class DeleteMultiRateConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteMultiRateConfigResponseBody() {}

  explicit DeleteMultiRateConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMultiRateConfigResponseBody() = default;
};
class DeleteMultiRateConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMultiRateConfigResponseBody> body{};

  DeleteMultiRateConfigResponse() {}

  explicit DeleteMultiRateConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMultiRateConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMultiRateConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMultiRateConfigResponse() = default;
};
class DeletePlaylistRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};

  DeletePlaylistRequest() {}

  explicit DeletePlaylistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
  }


  virtual ~DeletePlaylistRequest() = default;
};
class DeletePlaylistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  DeletePlaylistResponseBody() {}

  explicit DeletePlaylistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePlaylistResponseBody() = default;
};
class DeletePlaylistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePlaylistResponseBody> body{};

  DeletePlaylistResponse() {}

  explicit DeletePlaylistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePlaylistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePlaylistResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePlaylistResponse() = default;
};
class DeletePlaylistItemsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};
  shared_ptr<string> programItemIds{};

  DeletePlaylistItemsRequest() {}

  explicit DeletePlaylistItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programItemIds) {
      res["ProgramItemIds"] = boost::any(*programItemIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramItemIds") != m.end() && !m["ProgramItemIds"].empty()) {
      programItemIds = make_shared<string>(boost::any_cast<string>(m["ProgramItemIds"]));
    }
  }


  virtual ~DeletePlaylistItemsRequest() = default;
};
class DeletePlaylistItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  DeletePlaylistItemsResponseBody() {}

  explicit DeletePlaylistItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePlaylistItemsResponseBody() = default;
};
class DeletePlaylistItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePlaylistItemsResponseBody> body{};

  DeletePlaylistItemsResponse() {}

  explicit DeletePlaylistItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePlaylistItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePlaylistItemsResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePlaylistItemsResponse() = default;
};
class DeleteRoomRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> roomId{};

  DeleteRoomRequest() {}

  explicit DeleteRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~DeleteRoomRequest() = default;
};
class DeleteRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRoomResponseBody() {}

  explicit DeleteRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRoomResponseBody() = default;
};
class DeleteRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRoomResponseBody> body{};

  DeleteRoomResponse() {}

  explicit DeleteRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoomResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoomResponse() = default;
};
class DeleteSnapshotCallbackAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DeleteSnapshotCallbackAuthRequest() {}

  explicit DeleteSnapshotCallbackAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteSnapshotCallbackAuthRequest() = default;
};
class DeleteSnapshotCallbackAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSnapshotCallbackAuthResponseBody() {}

  explicit DeleteSnapshotCallbackAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSnapshotCallbackAuthResponseBody() = default;
};
class DeleteSnapshotCallbackAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSnapshotCallbackAuthResponseBody> body{};

  DeleteSnapshotCallbackAuthResponse() {}

  explicit DeleteSnapshotCallbackAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnapshotCallbackAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnapshotCallbackAuthResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnapshotCallbackAuthResponse() = default;
};
class DeleteSnapshotFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<vector<long>> createTimestampList{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> removeFile{};
  shared_ptr<string> streamName{};

  DeleteSnapshotFilesRequest() {}

  explicit DeleteSnapshotFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTimestampList) {
      res["CreateTimestampList"] = boost::any(*createTimestampList);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (removeFile) {
      res["RemoveFile"] = boost::any(*removeFile);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTimestampList") != m.end() && !m["CreateTimestampList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateTimestampList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateTimestampList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createTimestampList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RemoveFile") != m.end() && !m["RemoveFile"].empty()) {
      removeFile = make_shared<bool>(boost::any_cast<bool>(m["RemoveFile"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteSnapshotFilesRequest() = default;
};
class DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo : public Darabonba::Model {
public:
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> message{};

  DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo() {}

  explicit DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo() = default;
};
class DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo>> snapshotDeleteInfo{};

  DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList() {}

  explicit DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotDeleteInfo) {
      vector<boost::any> temp1;
      for(auto item1:*snapshotDeleteInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnapshotDeleteInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotDeleteInfo") != m.end() && !m["SnapshotDeleteInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SnapshotDeleteInfo"].type()) {
        vector<DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnapshotDeleteInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshotDeleteInfo = make_shared<vector<DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo>>(expect1);
      }
    }
  }


  virtual ~DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList() = default;
};
class DeleteSnapshotFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> failureCount{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList> snapshotDeleteInfoList{};
  shared_ptr<long> successCount{};

  DeleteSnapshotFilesResponseBody() {}

  explicit DeleteSnapshotFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failureCount) {
      res["FailureCount"] = boost::any(*failureCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotDeleteInfoList) {
      res["SnapshotDeleteInfoList"] = snapshotDeleteInfoList ? boost::any(snapshotDeleteInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailureCount") != m.end() && !m["FailureCount"].empty()) {
      failureCount = make_shared<long>(boost::any_cast<long>(m["FailureCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotDeleteInfoList") != m.end() && !m["SnapshotDeleteInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotDeleteInfoList"].type()) {
        DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotDeleteInfoList"]));
        snapshotDeleteInfoList = make_shared<DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList>(model1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~DeleteSnapshotFilesResponseBody() = default;
};
class DeleteSnapshotFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSnapshotFilesResponseBody> body{};

  DeleteSnapshotFilesResponse() {}

  explicit DeleteSnapshotFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnapshotFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnapshotFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnapshotFilesResponse() = default;
};
class DeleteStudioLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};

  DeleteStudioLayoutRequest() {}

  explicit DeleteStudioLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteStudioLayoutRequest() = default;
};
class DeleteStudioLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteStudioLayoutResponseBody() {}

  explicit DeleteStudioLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteStudioLayoutResponseBody() = default;
};
class DeleteStudioLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteStudioLayoutResponseBody> body{};

  DeleteStudioLayoutResponse() {}

  explicit DeleteStudioLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStudioLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStudioLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStudioLayoutResponse() = default;
};
class DescribeAutoShowListTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  DescribeAutoShowListTasksRequest() {}

  explicit DescribeAutoShowListTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeAutoShowListTasksRequest() = default;
};
class DescribeAutoShowListTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> autoShowListTasks{};
  shared_ptr<string> requestId{};

  DescribeAutoShowListTasksResponseBody() {}

  explicit DescribeAutoShowListTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoShowListTasks) {
      res["AutoShowListTasks"] = boost::any(*autoShowListTasks);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoShowListTasks") != m.end() && !m["AutoShowListTasks"].empty()) {
      autoShowListTasks = make_shared<string>(boost::any_cast<string>(m["AutoShowListTasks"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAutoShowListTasksResponseBody() = default;
};
class DescribeAutoShowListTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAutoShowListTasksResponseBody> body{};

  DescribeAutoShowListTasksResponse() {}

  explicit DescribeAutoShowListTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoShowListTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoShowListTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoShowListTasksResponse() = default;
};
class DescribeCasterChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  DescribeCasterChannelsRequest() {}

  explicit DescribeCasterChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeCasterChannelsRequest() = default;
};
class DescribeCasterChannelsResponseBodyChannelsChannel : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> faceBeauty{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> rtmpUrl{};
  shared_ptr<string> streamUrl{};

  DescribeCasterChannelsResponseBodyChannelsChannel() {}

  explicit DescribeCasterChannelsResponseBodyChannelsChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (faceBeauty) {
      res["FaceBeauty"] = boost::any(*faceBeauty);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (rtmpUrl) {
      res["RtmpUrl"] = boost::any(*rtmpUrl);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("FaceBeauty") != m.end() && !m["FaceBeauty"].empty()) {
      faceBeauty = make_shared<string>(boost::any_cast<string>(m["FaceBeauty"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("RtmpUrl") != m.end() && !m["RtmpUrl"].empty()) {
      rtmpUrl = make_shared<string>(boost::any_cast<string>(m["RtmpUrl"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~DescribeCasterChannelsResponseBodyChannelsChannel() = default;
};
class DescribeCasterChannelsResponseBodyChannels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterChannelsResponseBodyChannelsChannel>> channel{};

  DescribeCasterChannelsResponseBodyChannels() {}

  explicit DescribeCasterChannelsResponseBodyChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      vector<boost::any> temp1;
      for(auto item1:*channel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Channel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(vector<boost::any>) == m["Channel"].type()) {
        vector<DescribeCasterChannelsResponseBodyChannelsChannel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Channel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterChannelsResponseBodyChannelsChannel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channel = make_shared<vector<DescribeCasterChannelsResponseBodyChannelsChannel>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterChannelsResponseBodyChannels() = default;
};
class DescribeCasterChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterChannelsResponseBodyChannels> channels{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCasterChannelsResponseBody() {}

  explicit DescribeCasterChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = channels ? boost::any(channels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      if (typeid(map<string, boost::any>) == m["Channels"].type()) {
        DescribeCasterChannelsResponseBodyChannels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Channels"]));
        channels = make_shared<DescribeCasterChannelsResponseBodyChannels>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterChannelsResponseBody() = default;
};
class DescribeCasterChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterChannelsResponseBody> body{};

  DescribeCasterChannelsResponse() {}

  explicit DescribeCasterChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterChannelsResponse() = default;
};
class DescribeCasterComponentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> componentId{};
  shared_ptr<long> ownerId{};

  DescribeCasterComponentsRequest() {}

  explicit DescribeCasterComponentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeCasterComponentsRequest() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent : public Darabonba::Model {
public:
  shared_ptr<string> borderColor{};
  shared_ptr<double> borderWidthNormalized{};
  shared_ptr<string> color{};
  shared_ptr<string> fontName{};
  shared_ptr<double> lineSpaceNormalized{};
  shared_ptr<string> locationId{};
  shared_ptr<long> ptsOffset{};
  shared_ptr<bool> showSourceLan{};
  shared_ptr<double> sizeNormalized{};
  shared_ptr<string> sourceLan{};
  shared_ptr<string> targetLan{};
  shared_ptr<long> wordCountPerLine{};
  shared_ptr<double> wordSpaceNormalized{};
  shared_ptr<long> wordsCount{};

  DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidthNormalized) {
      res["BorderWidthNormalized"] = boost::any(*borderWidthNormalized);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (lineSpaceNormalized) {
      res["LineSpaceNormalized"] = boost::any(*lineSpaceNormalized);
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (ptsOffset) {
      res["PtsOffset"] = boost::any(*ptsOffset);
    }
    if (showSourceLan) {
      res["ShowSourceLan"] = boost::any(*showSourceLan);
    }
    if (sizeNormalized) {
      res["SizeNormalized"] = boost::any(*sizeNormalized);
    }
    if (sourceLan) {
      res["SourceLan"] = boost::any(*sourceLan);
    }
    if (targetLan) {
      res["TargetLan"] = boost::any(*targetLan);
    }
    if (wordCountPerLine) {
      res["WordCountPerLine"] = boost::any(*wordCountPerLine);
    }
    if (wordSpaceNormalized) {
      res["WordSpaceNormalized"] = boost::any(*wordSpaceNormalized);
    }
    if (wordsCount) {
      res["WordsCount"] = boost::any(*wordsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidthNormalized") != m.end() && !m["BorderWidthNormalized"].empty()) {
      borderWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BorderWidthNormalized"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("LineSpaceNormalized") != m.end() && !m["LineSpaceNormalized"].empty()) {
      lineSpaceNormalized = make_shared<double>(boost::any_cast<double>(m["LineSpaceNormalized"]));
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("PtsOffset") != m.end() && !m["PtsOffset"].empty()) {
      ptsOffset = make_shared<long>(boost::any_cast<long>(m["PtsOffset"]));
    }
    if (m.find("ShowSourceLan") != m.end() && !m["ShowSourceLan"].empty()) {
      showSourceLan = make_shared<bool>(boost::any_cast<bool>(m["ShowSourceLan"]));
    }
    if (m.find("SizeNormalized") != m.end() && !m["SizeNormalized"].empty()) {
      sizeNormalized = make_shared<double>(boost::any_cast<double>(m["SizeNormalized"]));
    }
    if (m.find("SourceLan") != m.end() && !m["SourceLan"].empty()) {
      sourceLan = make_shared<string>(boost::any_cast<string>(m["SourceLan"]));
    }
    if (m.find("TargetLan") != m.end() && !m["TargetLan"].empty()) {
      targetLan = make_shared<string>(boost::any_cast<string>(m["TargetLan"]));
    }
    if (m.find("WordCountPerLine") != m.end() && !m["WordCountPerLine"].empty()) {
      wordCountPerLine = make_shared<long>(boost::any_cast<long>(m["WordCountPerLine"]));
    }
    if (m.find("WordSpaceNormalized") != m.end() && !m["WordSpaceNormalized"].empty()) {
      wordSpaceNormalized = make_shared<double>(boost::any_cast<double>(m["WordSpaceNormalized"]));
    }
    if (m.find("WordsCount") != m.end() && !m["WordsCount"].empty()) {
      wordsCount = make_shared<long>(boost::any_cast<long>(m["WordsCount"]));
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds : public Darabonba::Model {
public:
  shared_ptr<vector<double>> position{};

  DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (position) {
      res["Position"] = boost::any(*position);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["Position"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Position"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      position = make_shared<vector<double>>(toVec1);
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer : public Darabonba::Model {
public:
  shared_ptr<double> heightNormalized{};
  shared_ptr<DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds> positionNormalizeds{};
  shared_ptr<string> positionRefer{};
  shared_ptr<long> transparency{};
  shared_ptr<double> widthNormalized{};

  DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionNormalizeds) {
      res["PositionNormalizeds"] = positionNormalizeds ? boost::any(positionNormalizeds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (transparency) {
      res["Transparency"] = boost::any(*transparency);
    }
    if (widthNormalized) {
      res["WidthNormalized"] = boost::any(*widthNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionNormalizeds") != m.end() && !m["PositionNormalizeds"].empty()) {
      if (typeid(map<string, boost::any>) == m["PositionNormalizeds"].type()) {
        DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PositionNormalizeds"]));
        positionNormalizeds = make_shared<DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds>(model1);
      }
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("Transparency") != m.end() && !m["Transparency"].empty()) {
      transparency = make_shared<long>(boost::any_cast<long>(m["Transparency"]));
    }
    if (m.find("WidthNormalized") != m.end() && !m["WidthNormalized"].empty()) {
      widthNormalized = make_shared<double>(boost::any_cast<double>(m["WidthNormalized"]));
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent : public Darabonba::Model {
public:
  shared_ptr<string> materialId{};

  DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent : public Darabonba::Model {
public:
  shared_ptr<string> borderColor{};
  shared_ptr<double> borderWidthNormalized{};
  shared_ptr<string> color{};
  shared_ptr<string> fontName{};
  shared_ptr<double> sizeNormalized{};
  shared_ptr<string> text{};

  DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidthNormalized) {
      res["BorderWidthNormalized"] = boost::any(*borderWidthNormalized);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (sizeNormalized) {
      res["SizeNormalized"] = boost::any(*sizeNormalized);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidthNormalized") != m.end() && !m["BorderWidthNormalized"].empty()) {
      borderWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BorderWidthNormalized"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("SizeNormalized") != m.end() && !m["SizeNormalized"].empty()) {
      sizeNormalized = make_shared<double>(boost::any_cast<double>(m["SizeNormalized"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponent : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent> captionLayerContent{};
  shared_ptr<string> componentId{};
  shared_ptr<DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer> componentLayer{};
  shared_ptr<string> componentName{};
  shared_ptr<string> componentType{};
  shared_ptr<string> effect{};
  shared_ptr<DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent> imageLayerContent{};
  shared_ptr<string> locationId{};
  shared_ptr<DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent> textLayerContent{};

  DescribeCasterComponentsResponseBodyComponentsComponent() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (captionLayerContent) {
      res["CaptionLayerContent"] = captionLayerContent ? boost::any(captionLayerContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (componentLayer) {
      res["ComponentLayer"] = componentLayer ? boost::any(componentLayer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (componentType) {
      res["ComponentType"] = boost::any(*componentType);
    }
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (imageLayerContent) {
      res["ImageLayerContent"] = imageLayerContent ? boost::any(imageLayerContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (textLayerContent) {
      res["TextLayerContent"] = textLayerContent ? boost::any(textLayerContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaptionLayerContent") != m.end() && !m["CaptionLayerContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["CaptionLayerContent"].type()) {
        DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CaptionLayerContent"]));
        captionLayerContent = make_shared<DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent>(model1);
      }
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("ComponentLayer") != m.end() && !m["ComponentLayer"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentLayer"].type()) {
        DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentLayer"]));
        componentLayer = make_shared<DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer>(model1);
      }
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("ComponentType") != m.end() && !m["ComponentType"].empty()) {
      componentType = make_shared<string>(boost::any_cast<string>(m["ComponentType"]));
    }
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("ImageLayerContent") != m.end() && !m["ImageLayerContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageLayerContent"].type()) {
        DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageLayerContent"]));
        imageLayerContent = make_shared<DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent>(model1);
      }
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("TextLayerContent") != m.end() && !m["TextLayerContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["TextLayerContent"].type()) {
        DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TextLayerContent"]));
        textLayerContent = make_shared<DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent>(model1);
      }
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponent() = default;
};
class DescribeCasterComponentsResponseBodyComponents : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterComponentsResponseBodyComponentsComponent>> component{};

  DescribeCasterComponentsResponseBodyComponents() {}

  explicit DescribeCasterComponentsResponseBodyComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (component) {
      vector<boost::any> temp1;
      for(auto item1:*component){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Component"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Component") != m.end() && !m["Component"].empty()) {
      if (typeid(vector<boost::any>) == m["Component"].type()) {
        vector<DescribeCasterComponentsResponseBodyComponentsComponent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Component"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterComponentsResponseBodyComponentsComponent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        component = make_shared<vector<DescribeCasterComponentsResponseBodyComponentsComponent>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponents() = default;
};
class DescribeCasterComponentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterComponentsResponseBodyComponents> components{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCasterComponentsResponseBody() {}

  explicit DescribeCasterComponentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (components) {
      res["Components"] = components ? boost::any(components->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Components") != m.end() && !m["Components"].empty()) {
      if (typeid(map<string, boost::any>) == m["Components"].type()) {
        DescribeCasterComponentsResponseBodyComponents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Components"]));
        components = make_shared<DescribeCasterComponentsResponseBodyComponents>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterComponentsResponseBody() = default;
};
class DescribeCasterComponentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterComponentsResponseBody> body{};

  DescribeCasterComponentsResponse() {}

  explicit DescribeCasterComponentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterComponentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterComponentsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterComponentsResponse() = default;
};
class DescribeCasterConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  DescribeCasterConfigRequest() {}

  explicit DescribeCasterConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeCasterConfigRequest() = default;
};
class DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<string> sliceOssObjectPrefix{};

  DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat() {}

  explicit DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat() = default;
};
class DescribeCasterConfigResponseBodyRecordConfigRecordFormat : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat>> recordFormat{};

  DescribeCasterConfigResponseBodyRecordConfigRecordFormat() {}

  explicit DescribeCasterConfigResponseBodyRecordConfigRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponseBodyRecordConfigRecordFormat() = default;
};
class DescribeCasterConfigResponseBodyRecordConfig : public Darabonba::Model {
public:
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<DescribeCasterConfigResponseBodyRecordConfigRecordFormat> recordFormat{};

  DescribeCasterConfigResponseBodyRecordConfig() {}

  explicit DescribeCasterConfigResponseBodyRecordConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (recordFormat) {
      res["RecordFormat"] = recordFormat ? boost::any(recordFormat->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordFormat"].type()) {
        DescribeCasterConfigResponseBodyRecordConfigRecordFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordFormat"]));
        recordFormat = make_shared<DescribeCasterConfigResponseBodyRecordConfigRecordFormat>(model1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponseBodyRecordConfig() = default;
};
class DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};

  DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds() {}

  explicit DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds() = default;
};
class DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup : public Darabonba::Model {
public:
  shared_ptr<string> hostResourceId{};
  shared_ptr<long> mode{};
  shared_ptr<DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds> resourceIds{};

  DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup() {}

  explicit DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostResourceId) {
      res["HostResourceId"] = boost::any(*hostResourceId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (resourceIds) {
      res["ResourceIds"] = resourceIds ? boost::any(resourceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostResourceId") != m.end() && !m["HostResourceId"].empty()) {
      hostResourceId = make_shared<string>(boost::any_cast<string>(m["HostResourceId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceIds"].type()) {
        DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceIds"]));
        resourceIds = make_shared<DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds>(model1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup() = default;
};
class DescribeCasterConfigResponseBodySyncGroupsConfig : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup>> syncGroup{};

  DescribeCasterConfigResponseBodySyncGroupsConfig() {}

  explicit DescribeCasterConfigResponseBodySyncGroupsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (syncGroup) {
      vector<boost::any> temp1;
      for(auto item1:*syncGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SyncGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SyncGroup") != m.end() && !m["SyncGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SyncGroup"].type()) {
        vector<DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SyncGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        syncGroup = make_shared<vector<DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponseBodySyncGroupsConfig() = default;
};
class DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> locationId{};

  DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds() {}

  explicit DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LocationId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LocationId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locationId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds() = default;
};
class DescribeCasterConfigResponseBodyTranscodeConfig : public Darabonba::Model {
public:
  shared_ptr<string> casterTemplate{};
  shared_ptr<DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds> liveTemplateIds{};

  DescribeCasterConfigResponseBodyTranscodeConfig() {}

  explicit DescribeCasterConfigResponseBodyTranscodeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterTemplate) {
      res["CasterTemplate"] = boost::any(*casterTemplate);
    }
    if (liveTemplateIds) {
      res["LiveTemplateIds"] = liveTemplateIds ? boost::any(liveTemplateIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterTemplate") != m.end() && !m["CasterTemplate"].empty()) {
      casterTemplate = make_shared<string>(boost::any_cast<string>(m["CasterTemplate"]));
    }
    if (m.find("LiveTemplateIds") != m.end() && !m["LiveTemplateIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveTemplateIds"].type()) {
        DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveTemplateIds"]));
        liveTemplateIds = make_shared<DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds>(model1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponseBodyTranscodeConfig() = default;
};
class DescribeCasterConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> casterId{};
  shared_ptr<string> casterName{};
  shared_ptr<long> channelEnable{};
  shared_ptr<double> delay{};
  shared_ptr<string> domainName{};
  shared_ptr<long> programEffect{};
  shared_ptr<string> programName{};
  shared_ptr<DescribeCasterConfigResponseBodyRecordConfig> recordConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sideOutputUrl{};
  shared_ptr<string> sideOutputUrlList{};
  shared_ptr<DescribeCasterConfigResponseBodySyncGroupsConfig> syncGroupsConfig{};
  shared_ptr<DescribeCasterConfigResponseBodyTranscodeConfig> transcodeConfig{};
  shared_ptr<string> urgentLiveStreamUrl{};
  shared_ptr<string> urgentMaterialId{};

  DescribeCasterConfigResponseBody() {}

  explicit DescribeCasterConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (channelEnable) {
      res["ChannelEnable"] = boost::any(*channelEnable);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (programEffect) {
      res["ProgramEffect"] = boost::any(*programEffect);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (recordConfig) {
      res["RecordConfig"] = recordConfig ? boost::any(recordConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sideOutputUrl) {
      res["SideOutputUrl"] = boost::any(*sideOutputUrl);
    }
    if (sideOutputUrlList) {
      res["SideOutputUrlList"] = boost::any(*sideOutputUrlList);
    }
    if (syncGroupsConfig) {
      res["SyncGroupsConfig"] = syncGroupsConfig ? boost::any(syncGroupsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transcodeConfig) {
      res["TranscodeConfig"] = transcodeConfig ? boost::any(transcodeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (urgentLiveStreamUrl) {
      res["UrgentLiveStreamUrl"] = boost::any(*urgentLiveStreamUrl);
    }
    if (urgentMaterialId) {
      res["UrgentMaterialId"] = boost::any(*urgentMaterialId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("ChannelEnable") != m.end() && !m["ChannelEnable"].empty()) {
      channelEnable = make_shared<long>(boost::any_cast<long>(m["ChannelEnable"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<double>(boost::any_cast<double>(m["Delay"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ProgramEffect") != m.end() && !m["ProgramEffect"].empty()) {
      programEffect = make_shared<long>(boost::any_cast<long>(m["ProgramEffect"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("RecordConfig") != m.end() && !m["RecordConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordConfig"].type()) {
        DescribeCasterConfigResponseBodyRecordConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordConfig"]));
        recordConfig = make_shared<DescribeCasterConfigResponseBodyRecordConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SideOutputUrl") != m.end() && !m["SideOutputUrl"].empty()) {
      sideOutputUrl = make_shared<string>(boost::any_cast<string>(m["SideOutputUrl"]));
    }
    if (m.find("SideOutputUrlList") != m.end() && !m["SideOutputUrlList"].empty()) {
      sideOutputUrlList = make_shared<string>(boost::any_cast<string>(m["SideOutputUrlList"]));
    }
    if (m.find("SyncGroupsConfig") != m.end() && !m["SyncGroupsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SyncGroupsConfig"].type()) {
        DescribeCasterConfigResponseBodySyncGroupsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SyncGroupsConfig"]));
        syncGroupsConfig = make_shared<DescribeCasterConfigResponseBodySyncGroupsConfig>(model1);
      }
    }
    if (m.find("TranscodeConfig") != m.end() && !m["TranscodeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeConfig"].type()) {
        DescribeCasterConfigResponseBodyTranscodeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeConfig"]));
        transcodeConfig = make_shared<DescribeCasterConfigResponseBodyTranscodeConfig>(model1);
      }
    }
    if (m.find("UrgentLiveStreamUrl") != m.end() && !m["UrgentLiveStreamUrl"].empty()) {
      urgentLiveStreamUrl = make_shared<string>(boost::any_cast<string>(m["UrgentLiveStreamUrl"]));
    }
    if (m.find("UrgentMaterialId") != m.end() && !m["UrgentMaterialId"].empty()) {
      urgentMaterialId = make_shared<string>(boost::any_cast<string>(m["UrgentMaterialId"]));
    }
  }


  virtual ~DescribeCasterConfigResponseBody() = default;
};
class DescribeCasterConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterConfigResponseBody> body{};

  DescribeCasterConfigResponse() {}

  explicit DescribeCasterConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponse() = default;
};
class DescribeCasterLayoutsRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};

  DescribeCasterLayoutsRequest() {}

  explicit DescribeCasterLayoutsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeCasterLayoutsRequest() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer : public Darabonba::Model {
public:
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer>> audioLayer{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayer) {
      vector<boost::any> temp1;
      for(auto item1:*audioLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayer") != m.end() && !m["AudioLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioLayer"].type()) {
        vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioLayer = make_shared<vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> locationId{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LocationId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LocationId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locationId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> locationId{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LocationId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LocationId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locationId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds : public Darabonba::Model {
public:
  shared_ptr<vector<double>> position{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (position) {
      res["Position"] = boost::any(*position);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["Position"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Position"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      position = make_shared<vector<double>>(toVec1);
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer : public Darabonba::Model {
public:
  shared_ptr<string> fillMode{};
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<double> heightNormalized{};
  shared_ptr<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds> positionNormalizeds{};
  shared_ptr<string> positionRefer{};
  shared_ptr<double> widthNormalized{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fillMode) {
      res["FillMode"] = boost::any(*fillMode);
    }
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionNormalizeds) {
      res["PositionNormalizeds"] = positionNormalizeds ? boost::any(positionNormalizeds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (widthNormalized) {
      res["WidthNormalized"] = boost::any(*widthNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FillMode") != m.end() && !m["FillMode"].empty()) {
      fillMode = make_shared<string>(boost::any_cast<string>(m["FillMode"]));
    }
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionNormalizeds") != m.end() && !m["PositionNormalizeds"].empty()) {
      if (typeid(map<string, boost::any>) == m["PositionNormalizeds"].type()) {
        DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PositionNormalizeds"]));
        positionNormalizeds = make_shared<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds>(model1);
      }
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("WidthNormalized") != m.end() && !m["WidthNormalized"].empty()) {
      widthNormalized = make_shared<double>(boost::any_cast<double>(m["WidthNormalized"]));
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer>> videoLayer{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoLayer) {
      vector<boost::any> temp1;
      for(auto item1:*videoLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoLayer") != m.end() && !m["VideoLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoLayer"].type()) {
        vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoLayer = make_shared<vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayout : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers> audioLayers{};
  shared_ptr<DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList> blendList{};
  shared_ptr<string> layoutId{};
  shared_ptr<DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList> mixList{};
  shared_ptr<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers> videoLayers{};

  DescribeCasterLayoutsResponseBodyLayoutsLayout() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayers) {
      res["AudioLayers"] = audioLayers ? boost::any(audioLayers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (blendList) {
      res["BlendList"] = blendList ? boost::any(blendList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (mixList) {
      res["MixList"] = mixList ? boost::any(mixList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoLayers) {
      res["VideoLayers"] = videoLayers ? boost::any(videoLayers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayers") != m.end() && !m["AudioLayers"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioLayers"].type()) {
        DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioLayers"]));
        audioLayers = make_shared<DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers>(model1);
      }
    }
    if (m.find("BlendList") != m.end() && !m["BlendList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BlendList"].type()) {
        DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BlendList"]));
        blendList = make_shared<DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList>(model1);
      }
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("MixList") != m.end() && !m["MixList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MixList"].type()) {
        DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MixList"]));
        mixList = make_shared<DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList>(model1);
      }
    }
    if (m.find("VideoLayers") != m.end() && !m["VideoLayers"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoLayers"].type()) {
        DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoLayers"]));
        videoLayers = make_shared<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers>(model1);
      }
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayout() = default;
};
class DescribeCasterLayoutsResponseBodyLayouts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterLayoutsResponseBodyLayoutsLayout>> layout{};

  DescribeCasterLayoutsResponseBodyLayouts() {}

  explicit DescribeCasterLayoutsResponseBodyLayouts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layout) {
      vector<boost::any> temp1;
      for(auto item1:*layout){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Layout"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Layout") != m.end() && !m["Layout"].empty()) {
      if (typeid(vector<boost::any>) == m["Layout"].type()) {
        vector<DescribeCasterLayoutsResponseBodyLayoutsLayout> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Layout"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterLayoutsResponseBodyLayoutsLayout model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        layout = make_shared<vector<DescribeCasterLayoutsResponseBodyLayoutsLayout>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayouts() = default;
};
class DescribeCasterLayoutsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterLayoutsResponseBodyLayouts> layouts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCasterLayoutsResponseBody() {}

  explicit DescribeCasterLayoutsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layouts) {
      res["Layouts"] = layouts ? boost::any(layouts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Layouts") != m.end() && !m["Layouts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Layouts"].type()) {
        DescribeCasterLayoutsResponseBodyLayouts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Layouts"]));
        layouts = make_shared<DescribeCasterLayoutsResponseBodyLayouts>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterLayoutsResponseBody() = default;
};
class DescribeCasterLayoutsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterLayoutsResponseBody> body{};

  DescribeCasterLayoutsResponse() {}

  explicit DescribeCasterLayoutsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterLayoutsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterLayoutsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterLayoutsResponse() = default;
};
class DescribeCasterProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> episodeType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<long> status{};

  DescribeCasterProgramRequest() {}

  explicit DescribeCasterProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (episodeType) {
      res["EpisodeType"] = boost::any(*episodeType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("EpisodeType") != m.end() && !m["EpisodeType"].empty()) {
      episodeType = make_shared<string>(boost::any_cast<string>(m["EpisodeType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeCasterProgramRequest() = default;
};
class DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentId{};

  DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds() {}

  explicit DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds() = default;
};
class DescribeCasterProgramResponseBodyEpisodesEpisode : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds> componentIds{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> episodeName{};
  shared_ptr<string> episodeType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> startTime{};
  shared_ptr<long> status{};
  shared_ptr<string> switchType{};

  DescribeCasterProgramResponseBodyEpisodesEpisode() {}

  explicit DescribeCasterProgramResponseBodyEpisodesEpisode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentIds) {
      res["ComponentIds"] = componentIds ? boost::any(componentIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (episodeName) {
      res["EpisodeName"] = boost::any(*episodeName);
    }
    if (episodeType) {
      res["EpisodeType"] = boost::any(*episodeType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (switchType) {
      res["SwitchType"] = boost::any(*switchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentIds") != m.end() && !m["ComponentIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentIds"].type()) {
        DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentIds"]));
        componentIds = make_shared<DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds>(model1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("EpisodeName") != m.end() && !m["EpisodeName"].empty()) {
      episodeName = make_shared<string>(boost::any_cast<string>(m["EpisodeName"]));
    }
    if (m.find("EpisodeType") != m.end() && !m["EpisodeType"].empty()) {
      episodeType = make_shared<string>(boost::any_cast<string>(m["EpisodeType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SwitchType") != m.end() && !m["SwitchType"].empty()) {
      switchType = make_shared<string>(boost::any_cast<string>(m["SwitchType"]));
    }
  }


  virtual ~DescribeCasterProgramResponseBodyEpisodesEpisode() = default;
};
class DescribeCasterProgramResponseBodyEpisodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterProgramResponseBodyEpisodesEpisode>> episode{};

  DescribeCasterProgramResponseBodyEpisodes() {}

  explicit DescribeCasterProgramResponseBodyEpisodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (episode) {
      vector<boost::any> temp1;
      for(auto item1:*episode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Episode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Episode") != m.end() && !m["Episode"].empty()) {
      if (typeid(vector<boost::any>) == m["Episode"].type()) {
        vector<DescribeCasterProgramResponseBodyEpisodesEpisode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Episode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterProgramResponseBodyEpisodesEpisode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        episode = make_shared<vector<DescribeCasterProgramResponseBodyEpisodesEpisode>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterProgramResponseBodyEpisodes() = default;
};
class DescribeCasterProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<DescribeCasterProgramResponseBodyEpisodes> episodes{};
  shared_ptr<long> programEffect{};
  shared_ptr<string> programName{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCasterProgramResponseBody() {}

  explicit DescribeCasterProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episodes) {
      res["Episodes"] = episodes ? boost::any(episodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programEffect) {
      res["ProgramEffect"] = boost::any(*programEffect);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("Episodes") != m.end() && !m["Episodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Episodes"].type()) {
        DescribeCasterProgramResponseBodyEpisodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Episodes"]));
        episodes = make_shared<DescribeCasterProgramResponseBodyEpisodes>(model1);
      }
    }
    if (m.find("ProgramEffect") != m.end() && !m["ProgramEffect"].empty()) {
      programEffect = make_shared<long>(boost::any_cast<long>(m["ProgramEffect"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterProgramResponseBody() = default;
};
class DescribeCasterProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterProgramResponseBody> body{};

  DescribeCasterProgramResponse() {}

  explicit DescribeCasterProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterProgramResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterProgramResponse() = default;
};
class DescribeCasterSceneAudioRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sceneId{};

  DescribeCasterSceneAudioRequest() {}

  explicit DescribeCasterSceneAudioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~DescribeCasterSceneAudioRequest() = default;
};
class DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer : public Darabonba::Model {
public:
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer() {}

  explicit DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer() = default;
};
class DescribeCasterSceneAudioResponseBodyAudioLayers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer>> audioLayer{};

  DescribeCasterSceneAudioResponseBodyAudioLayers() {}

  explicit DescribeCasterSceneAudioResponseBodyAudioLayers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayer) {
      vector<boost::any> temp1;
      for(auto item1:*audioLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayer") != m.end() && !m["AudioLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioLayer"].type()) {
        vector<DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioLayer = make_shared<vector<DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterSceneAudioResponseBodyAudioLayers() = default;
};
class DescribeCasterSceneAudioResponseBodyMixList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> locationId{};

  DescribeCasterSceneAudioResponseBodyMixList() {}

  explicit DescribeCasterSceneAudioResponseBodyMixList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LocationId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LocationId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locationId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterSceneAudioResponseBodyMixList() = default;
};
class DescribeCasterSceneAudioResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterSceneAudioResponseBodyAudioLayers> audioLayers{};
  shared_ptr<string> casterId{};
  shared_ptr<long> followEnable{};
  shared_ptr<DescribeCasterSceneAudioResponseBodyMixList> mixList{};
  shared_ptr<string> requestId{};

  DescribeCasterSceneAudioResponseBody() {}

  explicit DescribeCasterSceneAudioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayers) {
      res["AudioLayers"] = audioLayers ? boost::any(audioLayers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (followEnable) {
      res["FollowEnable"] = boost::any(*followEnable);
    }
    if (mixList) {
      res["MixList"] = mixList ? boost::any(mixList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayers") != m.end() && !m["AudioLayers"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioLayers"].type()) {
        DescribeCasterSceneAudioResponseBodyAudioLayers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioLayers"]));
        audioLayers = make_shared<DescribeCasterSceneAudioResponseBodyAudioLayers>(model1);
      }
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("FollowEnable") != m.end() && !m["FollowEnable"].empty()) {
      followEnable = make_shared<long>(boost::any_cast<long>(m["FollowEnable"]));
    }
    if (m.find("MixList") != m.end() && !m["MixList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MixList"].type()) {
        DescribeCasterSceneAudioResponseBodyMixList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MixList"]));
        mixList = make_shared<DescribeCasterSceneAudioResponseBodyMixList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCasterSceneAudioResponseBody() = default;
};
class DescribeCasterSceneAudioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterSceneAudioResponseBody> body{};

  DescribeCasterSceneAudioResponse() {}

  explicit DescribeCasterSceneAudioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterSceneAudioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterSceneAudioResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterSceneAudioResponse() = default;
};
class DescribeCasterScenesRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sceneId{};

  DescribeCasterScenesRequest() {}

  explicit DescribeCasterScenesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~DescribeCasterScenesRequest() = default;
};
class DescribeCasterScenesResponseBodySceneListSceneComponentIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentId{};

  DescribeCasterScenesResponseBodySceneListSceneComponentIds() {}

  explicit DescribeCasterScenesResponseBodySceneListSceneComponentIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["componentId"] = boost::any(*componentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("componentId") != m.end() && !m["componentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["componentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["componentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterScenesResponseBodySceneListSceneComponentIds() = default;
};
class DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo : public Darabonba::Model {
public:
  shared_ptr<string> outputStreamUrl{};
  shared_ptr<string> transcodeConfig{};
  shared_ptr<string> videoFormat{};

  DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo() {}

  explicit DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputStreamUrl) {
      res["OutputStreamUrl"] = boost::any(*outputStreamUrl);
    }
    if (transcodeConfig) {
      res["TranscodeConfig"] = boost::any(*transcodeConfig);
    }
    if (videoFormat) {
      res["VideoFormat"] = boost::any(*videoFormat);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputStreamUrl") != m.end() && !m["OutputStreamUrl"].empty()) {
      outputStreamUrl = make_shared<string>(boost::any_cast<string>(m["OutputStreamUrl"]));
    }
    if (m.find("TranscodeConfig") != m.end() && !m["TranscodeConfig"].empty()) {
      transcodeConfig = make_shared<string>(boost::any_cast<string>(m["TranscodeConfig"]));
    }
    if (m.find("VideoFormat") != m.end() && !m["VideoFormat"].empty()) {
      videoFormat = make_shared<string>(boost::any_cast<string>(m["VideoFormat"]));
    }
  }


  virtual ~DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo() = default;
};
class DescribeCasterScenesResponseBodySceneListSceneStreamInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo>> streamInfo{};

  DescribeCasterScenesResponseBodySceneListSceneStreamInfos() {}

  explicit DescribeCasterScenesResponseBodySceneListSceneStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamInfo) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamInfo") != m.end() && !m["StreamInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfo"].type()) {
        vector<DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfo = make_shared<vector<DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterScenesResponseBodySceneListSceneStreamInfos() = default;
};
class DescribeCasterScenesResponseBodySceneListScene : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterScenesResponseBodySceneListSceneComponentIds> componentIds{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> outputType{};
  shared_ptr<string> sceneId{};
  shared_ptr<string> sceneName{};
  shared_ptr<long> status{};
  shared_ptr<DescribeCasterScenesResponseBodySceneListSceneStreamInfos> streamInfos{};
  shared_ptr<string> streamUrl{};

  DescribeCasterScenesResponseBodySceneListScene() {}

  explicit DescribeCasterScenesResponseBodySceneListScene(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentIds) {
      res["ComponentIds"] = componentIds ? boost::any(componentIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    if (sceneName) {
      res["SceneName"] = boost::any(*sceneName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInfos) {
      res["StreamInfos"] = streamInfos ? boost::any(streamInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentIds") != m.end() && !m["ComponentIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentIds"].type()) {
        DescribeCasterScenesResponseBodySceneListSceneComponentIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentIds"]));
        componentIds = make_shared<DescribeCasterScenesResponseBodySceneListSceneComponentIds>(model1);
      }
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
    if (m.find("SceneName") != m.end() && !m["SceneName"].empty()) {
      sceneName = make_shared<string>(boost::any_cast<string>(m["SceneName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInfos"].type()) {
        DescribeCasterScenesResponseBodySceneListSceneStreamInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInfos"]));
        streamInfos = make_shared<DescribeCasterScenesResponseBodySceneListSceneStreamInfos>(model1);
      }
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~DescribeCasterScenesResponseBodySceneListScene() = default;
};
class DescribeCasterScenesResponseBodySceneList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterScenesResponseBodySceneListScene>> scene{};

  DescribeCasterScenesResponseBodySceneList() {}

  explicit DescribeCasterScenesResponseBodySceneList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scene) {
      vector<boost::any> temp1;
      for(auto item1:*scene){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Scene"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      if (typeid(vector<boost::any>) == m["Scene"].type()) {
        vector<DescribeCasterScenesResponseBodySceneListScene> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Scene"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterScenesResponseBodySceneListScene model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scene = make_shared<vector<DescribeCasterScenesResponseBodySceneListScene>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterScenesResponseBodySceneList() = default;
};
class DescribeCasterScenesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCasterScenesResponseBodySceneList> sceneList{};
  shared_ptr<long> total{};

  DescribeCasterScenesResponseBody() {}

  explicit DescribeCasterScenesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sceneList) {
      res["SceneList"] = sceneList ? boost::any(sceneList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SceneList") != m.end() && !m["SceneList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SceneList"].type()) {
        DescribeCasterScenesResponseBodySceneList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SceneList"]));
        sceneList = make_shared<DescribeCasterScenesResponseBodySceneList>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterScenesResponseBody() = default;
};
class DescribeCasterScenesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterScenesResponseBody> body{};

  DescribeCasterScenesResponse() {}

  explicit DescribeCasterScenesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterScenesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterScenesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterScenesResponse() = default;
};
class DescribeCasterStreamUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  DescribeCasterStreamUrlRequest() {}

  explicit DescribeCasterStreamUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeCasterStreamUrlRequest() = default;
};
class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo : public Darabonba::Model {
public:
  shared_ptr<string> outputStreamUrl{};
  shared_ptr<string> transcodeConfig{};
  shared_ptr<string> videoFormat{};

  DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo() {}

  explicit DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputStreamUrl) {
      res["OutputStreamUrl"] = boost::any(*outputStreamUrl);
    }
    if (transcodeConfig) {
      res["TranscodeConfig"] = boost::any(*transcodeConfig);
    }
    if (videoFormat) {
      res["VideoFormat"] = boost::any(*videoFormat);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputStreamUrl") != m.end() && !m["OutputStreamUrl"].empty()) {
      outputStreamUrl = make_shared<string>(boost::any_cast<string>(m["OutputStreamUrl"]));
    }
    if (m.find("TranscodeConfig") != m.end() && !m["TranscodeConfig"].empty()) {
      transcodeConfig = make_shared<string>(boost::any_cast<string>(m["TranscodeConfig"]));
    }
    if (m.find("VideoFormat") != m.end() && !m["VideoFormat"].empty()) {
      videoFormat = make_shared<string>(boost::any_cast<string>(m["VideoFormat"]));
    }
  }


  virtual ~DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo() = default;
};
class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo>> streamInfo{};

  DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos() {}

  explicit DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamInfo) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamInfo") != m.end() && !m["StreamInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfo"].type()) {
        vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfo = make_shared<vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos() = default;
};
class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream : public Darabonba::Model {
public:
  shared_ptr<long> outputType{};
  shared_ptr<string> rtmpUrl{};
  shared_ptr<string> sceneId{};
  shared_ptr<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos> streamInfos{};
  shared_ptr<string> streamUrl{};

  DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream() {}

  explicit DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (rtmpUrl) {
      res["RtmpUrl"] = boost::any(*rtmpUrl);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    if (streamInfos) {
      res["StreamInfos"] = streamInfos ? boost::any(streamInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<long>(boost::any_cast<long>(m["OutputType"]));
    }
    if (m.find("RtmpUrl") != m.end() && !m["RtmpUrl"].empty()) {
      rtmpUrl = make_shared<string>(boost::any_cast<string>(m["RtmpUrl"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInfos"].type()) {
        DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInfos"]));
        streamInfos = make_shared<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos>(model1);
      }
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream() = default;
};
class DescribeCasterStreamUrlResponseBodyCasterStreams : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream>> casterStream{};

  DescribeCasterStreamUrlResponseBodyCasterStreams() {}

  explicit DescribeCasterStreamUrlResponseBodyCasterStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterStream) {
      vector<boost::any> temp1;
      for(auto item1:*casterStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CasterStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterStream") != m.end() && !m["CasterStream"].empty()) {
      if (typeid(vector<boost::any>) == m["CasterStream"].type()) {
        vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CasterStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        casterStream = make_shared<vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterStreamUrlResponseBodyCasterStreams() = default;
};
class DescribeCasterStreamUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<DescribeCasterStreamUrlResponseBodyCasterStreams> casterStreams{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCasterStreamUrlResponseBody() {}

  explicit DescribeCasterStreamUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (casterStreams) {
      res["CasterStreams"] = casterStreams ? boost::any(casterStreams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CasterStreams") != m.end() && !m["CasterStreams"].empty()) {
      if (typeid(map<string, boost::any>) == m["CasterStreams"].type()) {
        DescribeCasterStreamUrlResponseBodyCasterStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CasterStreams"]));
        casterStreams = make_shared<DescribeCasterStreamUrlResponseBodyCasterStreams>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterStreamUrlResponseBody() = default;
};
class DescribeCasterStreamUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterStreamUrlResponseBody> body{};

  DescribeCasterStreamUrlResponse() {}

  explicit DescribeCasterStreamUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterStreamUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterStreamUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterStreamUrlResponse() = default;
};
class DescribeCasterSyncGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  DescribeCasterSyncGroupRequest() {}

  explicit DescribeCasterSyncGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeCasterSyncGroupRequest() = default;
};
class DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroupResourceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};

  DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroupResourceIds() {}

  explicit DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroupResourceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroupResourceIds() = default;
};
class DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroup : public Darabonba::Model {
public:
  shared_ptr<string> hostResourceId{};
  shared_ptr<long> mode{};
  shared_ptr<DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroupResourceIds> resourceIds{};

  DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroup() {}

  explicit DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostResourceId) {
      res["HostResourceId"] = boost::any(*hostResourceId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (resourceIds) {
      res["ResourceIds"] = resourceIds ? boost::any(resourceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostResourceId") != m.end() && !m["HostResourceId"].empty()) {
      hostResourceId = make_shared<string>(boost::any_cast<string>(m["HostResourceId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceIds"].type()) {
        DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroupResourceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceIds"]));
        resourceIds = make_shared<DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroupResourceIds>(model1);
      }
    }
  }


  virtual ~DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroup() = default;
};
class DescribeCasterSyncGroupResponseBodySyncGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroup>> syncGroup{};

  DescribeCasterSyncGroupResponseBodySyncGroups() {}

  explicit DescribeCasterSyncGroupResponseBodySyncGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (syncGroup) {
      vector<boost::any> temp1;
      for(auto item1:*syncGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SyncGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SyncGroup") != m.end() && !m["SyncGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SyncGroup"].type()) {
        vector<DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SyncGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        syncGroup = make_shared<vector<DescribeCasterSyncGroupResponseBodySyncGroupsSyncGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterSyncGroupResponseBodySyncGroups() = default;
};
class DescribeCasterSyncGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCasterSyncGroupResponseBodySyncGroups> syncGroups{};

  DescribeCasterSyncGroupResponseBody() {}

  explicit DescribeCasterSyncGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (syncGroups) {
      res["SyncGroups"] = syncGroups ? boost::any(syncGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SyncGroups") != m.end() && !m["SyncGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["SyncGroups"].type()) {
        DescribeCasterSyncGroupResponseBodySyncGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SyncGroups"]));
        syncGroups = make_shared<DescribeCasterSyncGroupResponseBodySyncGroups>(model1);
      }
    }
  }


  virtual ~DescribeCasterSyncGroupResponseBody() = default;
};
class DescribeCasterSyncGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterSyncGroupResponseBody> body{};

  DescribeCasterSyncGroupResponse() {}

  explicit DescribeCasterSyncGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterSyncGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterSyncGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterSyncGroupResponse() = default;
};
class DescribeCasterVideoResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  DescribeCasterVideoResourcesRequest() {}

  explicit DescribeCasterVideoResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeCasterVideoResourcesRequest() = default;
};
class DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource : public Darabonba::Model {
public:
  shared_ptr<long> beginOffset{};
  shared_ptr<long> endOffset{};
  shared_ptr<string> flvUrl{};
  shared_ptr<string> liveStreamUrl{};
  shared_ptr<string> locationId{};
  shared_ptr<string> materialId{};
  shared_ptr<long> ptsCallbackInterval{};
  shared_ptr<long> repeatNum{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> vodUrl{};

  DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource() {}

  explicit DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginOffset) {
      res["BeginOffset"] = boost::any(*beginOffset);
    }
    if (endOffset) {
      res["EndOffset"] = boost::any(*endOffset);
    }
    if (flvUrl) {
      res["FlvUrl"] = boost::any(*flvUrl);
    }
    if (liveStreamUrl) {
      res["LiveStreamUrl"] = boost::any(*liveStreamUrl);
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (ptsCallbackInterval) {
      res["PtsCallbackInterval"] = boost::any(*ptsCallbackInterval);
    }
    if (repeatNum) {
      res["RepeatNum"] = boost::any(*repeatNum);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (vodUrl) {
      res["VodUrl"] = boost::any(*vodUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginOffset") != m.end() && !m["BeginOffset"].empty()) {
      beginOffset = make_shared<long>(boost::any_cast<long>(m["BeginOffset"]));
    }
    if (m.find("EndOffset") != m.end() && !m["EndOffset"].empty()) {
      endOffset = make_shared<long>(boost::any_cast<long>(m["EndOffset"]));
    }
    if (m.find("FlvUrl") != m.end() && !m["FlvUrl"].empty()) {
      flvUrl = make_shared<string>(boost::any_cast<string>(m["FlvUrl"]));
    }
    if (m.find("LiveStreamUrl") != m.end() && !m["LiveStreamUrl"].empty()) {
      liveStreamUrl = make_shared<string>(boost::any_cast<string>(m["LiveStreamUrl"]));
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("PtsCallbackInterval") != m.end() && !m["PtsCallbackInterval"].empty()) {
      ptsCallbackInterval = make_shared<long>(boost::any_cast<long>(m["PtsCallbackInterval"]));
    }
    if (m.find("RepeatNum") != m.end() && !m["RepeatNum"].empty()) {
      repeatNum = make_shared<long>(boost::any_cast<long>(m["RepeatNum"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("VodUrl") != m.end() && !m["VodUrl"].empty()) {
      vodUrl = make_shared<string>(boost::any_cast<string>(m["VodUrl"]));
    }
  }


  virtual ~DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource() = default;
};
class DescribeCasterVideoResourcesResponseBodyVideoResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource>> videoResource{};

  DescribeCasterVideoResourcesResponseBodyVideoResources() {}

  explicit DescribeCasterVideoResourcesResponseBodyVideoResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoResource) {
      vector<boost::any> temp1;
      for(auto item1:*videoResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoResource") != m.end() && !m["VideoResource"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoResource"].type()) {
        vector<DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoResource = make_shared<vector<DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterVideoResourcesResponseBodyVideoResources() = default;
};
class DescribeCasterVideoResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<DescribeCasterVideoResourcesResponseBodyVideoResources> videoResources{};

  DescribeCasterVideoResourcesResponseBody() {}

  explicit DescribeCasterVideoResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (videoResources) {
      res["VideoResources"] = videoResources ? boost::any(videoResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("VideoResources") != m.end() && !m["VideoResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoResources"].type()) {
        DescribeCasterVideoResourcesResponseBodyVideoResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoResources"]));
        videoResources = make_shared<DescribeCasterVideoResourcesResponseBodyVideoResources>(model1);
      }
    }
  }


  virtual ~DescribeCasterVideoResourcesResponseBody() = default;
};
class DescribeCasterVideoResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterVideoResourcesResponseBody> body{};

  DescribeCasterVideoResourcesResponse() {}

  explicit DescribeCasterVideoResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterVideoResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterVideoResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterVideoResourcesResponse() = default;
};
class DescribeCastersRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> casterName{};
  shared_ptr<long> chargeType{};
  shared_ptr<string> endTime{};
  shared_ptr<string> normType{};
  shared_ptr<string> orderByModifyAsc{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<long> status{};

  DescribeCastersRequest() {}

  explicit DescribeCastersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (normType) {
      res["NormType"] = boost::any(*normType);
    }
    if (orderByModifyAsc) {
      res["OrderByModifyAsc"] = boost::any(*orderByModifyAsc);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<long>(boost::any_cast<long>(m["ChargeType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("NormType") != m.end() && !m["NormType"].empty()) {
      normType = make_shared<string>(boost::any_cast<string>(m["NormType"]));
    }
    if (m.find("OrderByModifyAsc") != m.end() && !m["OrderByModifyAsc"].empty()) {
      orderByModifyAsc = make_shared<string>(boost::any_cast<string>(m["OrderByModifyAsc"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeCastersRequest() = default;
};
class DescribeCastersResponseBodyCasterListCaster : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> casterName{};
  shared_ptr<string> casterTemplate{};
  shared_ptr<long> channelEnable{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<long> normType{};
  shared_ptr<string> purchaseTime{};
  shared_ptr<string> startTime{};
  shared_ptr<long> status{};

  DescribeCastersResponseBodyCasterListCaster() {}

  explicit DescribeCastersResponseBodyCasterListCaster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (casterTemplate) {
      res["CasterTemplate"] = boost::any(*casterTemplate);
    }
    if (channelEnable) {
      res["ChannelEnable"] = boost::any(*channelEnable);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (normType) {
      res["NormType"] = boost::any(*normType);
    }
    if (purchaseTime) {
      res["PurchaseTime"] = boost::any(*purchaseTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("CasterTemplate") != m.end() && !m["CasterTemplate"].empty()) {
      casterTemplate = make_shared<string>(boost::any_cast<string>(m["CasterTemplate"]));
    }
    if (m.find("ChannelEnable") != m.end() && !m["ChannelEnable"].empty()) {
      channelEnable = make_shared<long>(boost::any_cast<long>(m["ChannelEnable"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("NormType") != m.end() && !m["NormType"].empty()) {
      normType = make_shared<long>(boost::any_cast<long>(m["NormType"]));
    }
    if (m.find("PurchaseTime") != m.end() && !m["PurchaseTime"].empty()) {
      purchaseTime = make_shared<string>(boost::any_cast<string>(m["PurchaseTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeCastersResponseBodyCasterListCaster() = default;
};
class DescribeCastersResponseBodyCasterList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCastersResponseBodyCasterListCaster>> caster{};

  DescribeCastersResponseBodyCasterList() {}

  explicit DescribeCastersResponseBodyCasterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caster) {
      vector<boost::any> temp1;
      for(auto item1:*caster){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Caster"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Caster") != m.end() && !m["Caster"].empty()) {
      if (typeid(vector<boost::any>) == m["Caster"].type()) {
        vector<DescribeCastersResponseBodyCasterListCaster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Caster"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCastersResponseBodyCasterListCaster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        caster = make_shared<vector<DescribeCastersResponseBodyCasterListCaster>>(expect1);
      }
    }
  }


  virtual ~DescribeCastersResponseBodyCasterList() = default;
};
class DescribeCastersResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCastersResponseBodyCasterList> casterList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCastersResponseBody() {}

  explicit DescribeCastersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterList) {
      res["CasterList"] = casterList ? boost::any(casterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterList") != m.end() && !m["CasterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CasterList"].type()) {
        DescribeCastersResponseBodyCasterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CasterList"]));
        casterList = make_shared<DescribeCastersResponseBodyCasterList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCastersResponseBody() = default;
};
class DescribeCastersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCastersResponseBody> body{};

  DescribeCastersResponse() {}

  explicit DescribeCastersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCastersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCastersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCastersResponse() = default;
};
class DescribeDomainUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> dataProtocol{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> field{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  DescribeDomainUsageDataRequest() {}

  explicit DescribeDomainUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (dataProtocol) {
      res["DataProtocol"] = boost::any(*dataProtocol);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DataProtocol") != m.end() && !m["DataProtocol"].empty()) {
      dataProtocol = make_shared<string>(boost::any_cast<string>(m["DataProtocol"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDomainUsageDataRequest() = default;
};
class DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule() {}

  explicit DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule() = default;
};
class DescribeDomainUsageDataResponseBodyUsageDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule>> dataModule{};

  DescribeDomainUsageDataResponseBodyUsageDataPerInterval() {}

  explicit DescribeDomainUsageDataResponseBodyUsageDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainUsageDataResponseBodyUsageDataPerInterval() = default;
};
class DescribeDomainUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};
  shared_ptr<DescribeDomainUsageDataResponseBodyUsageDataPerInterval> usageDataPerInterval{};

  DescribeDomainUsageDataResponseBody() {}

  explicit DescribeDomainUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usageDataPerInterval) {
      res["UsageDataPerInterval"] = usageDataPerInterval ? boost::any(usageDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UsageDataPerInterval") != m.end() && !m["UsageDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["UsageDataPerInterval"].type()) {
        DescribeDomainUsageDataResponseBodyUsageDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UsageDataPerInterval"]));
        usageDataPerInterval = make_shared<DescribeDomainUsageDataResponseBodyUsageDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDomainUsageDataResponseBody() = default;
};
class DescribeDomainUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainUsageDataResponseBody> body{};

  DescribeDomainUsageDataResponse() {}

  explicit DescribeDomainUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainUsageDataResponse() = default;
};
class DescribeDomainWithIntegrityRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<double> integrity{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeDomainWithIntegrityRequest() {}

  explicit DescribeDomainWithIntegrityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (integrity) {
      res["Integrity"] = boost::any(*integrity);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Integrity") != m.end() && !m["Integrity"].empty()) {
      integrity = make_shared<double>(boost::any_cast<double>(m["Integrity"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainWithIntegrityRequest() = default;
};
class DescribeDomainWithIntegrityResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<string>> columns{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> points{};

  DescribeDomainWithIntegrityResponseBodyContent() {}

  explicit DescribeDomainWithIntegrityResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Columns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      columns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Points"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Points"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      points = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDomainWithIntegrityResponseBodyContent() = default;
};
class DescribeDomainWithIntegrityResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainWithIntegrityResponseBodyContent>> content{};
  shared_ptr<string> requestId{};

  DescribeDomainWithIntegrityResponseBody() {}

  explicit DescribeDomainWithIntegrityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeDomainWithIntegrityResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainWithIntegrityResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeDomainWithIntegrityResponseBodyContent>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainWithIntegrityResponseBody() = default;
};
class DescribeDomainWithIntegrityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainWithIntegrityResponseBody> body{};

  DescribeDomainWithIntegrityResponse() {}

  explicit DescribeDomainWithIntegrityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainWithIntegrityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainWithIntegrityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainWithIntegrityResponse() = default;
};
class DescribeForbidPushStreamRoomListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  DescribeForbidPushStreamRoomListRequest() {}

  explicit DescribeForbidPushStreamRoomListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeForbidPushStreamRoomListRequest() = default;
};
class DescribeForbidPushStreamRoomListResponseBodyRoomList : public Darabonba::Model {
public:
  shared_ptr<string> anchorId{};
  shared_ptr<string> opEndTime{};
  shared_ptr<string> opStartTime{};
  shared_ptr<string> roomId{};

  DescribeForbidPushStreamRoomListResponseBodyRoomList() {}

  explicit DescribeForbidPushStreamRoomListResponseBodyRoomList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorId) {
      res["AnchorId"] = boost::any(*anchorId);
    }
    if (opEndTime) {
      res["OpEndTime"] = boost::any(*opEndTime);
    }
    if (opStartTime) {
      res["OpStartTime"] = boost::any(*opStartTime);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorId") != m.end() && !m["AnchorId"].empty()) {
      anchorId = make_shared<string>(boost::any_cast<string>(m["AnchorId"]));
    }
    if (m.find("OpEndTime") != m.end() && !m["OpEndTime"].empty()) {
      opEndTime = make_shared<string>(boost::any_cast<string>(m["OpEndTime"]));
    }
    if (m.find("OpStartTime") != m.end() && !m["OpStartTime"].empty()) {
      opStartTime = make_shared<string>(boost::any_cast<string>(m["OpStartTime"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~DescribeForbidPushStreamRoomListResponseBodyRoomList() = default;
};
class DescribeForbidPushStreamRoomListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeForbidPushStreamRoomListResponseBodyRoomList>> roomList{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeForbidPushStreamRoomListResponseBody() {}

  explicit DescribeForbidPushStreamRoomListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (roomList) {
      vector<boost::any> temp1;
      for(auto item1:*roomList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RoomList"] = boost::any(temp1);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RoomList") != m.end() && !m["RoomList"].empty()) {
      if (typeid(vector<boost::any>) == m["RoomList"].type()) {
        vector<DescribeForbidPushStreamRoomListResponseBodyRoomList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RoomList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeForbidPushStreamRoomListResponseBodyRoomList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roomList = make_shared<vector<DescribeForbidPushStreamRoomListResponseBodyRoomList>>(expect1);
      }
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeForbidPushStreamRoomListResponseBody() = default;
};
class DescribeForbidPushStreamRoomListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeForbidPushStreamRoomListResponseBody> body{};

  DescribeForbidPushStreamRoomListResponse() {}

  explicit DescribeForbidPushStreamRoomListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeForbidPushStreamRoomListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeForbidPushStreamRoomListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeForbidPushStreamRoomListResponse() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> time{};

  DescribeHlsLiveStreamRealTimeBpsDataRequest() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataRequest() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos : public Darabonba::Model {
public:
  shared_ptr<double> downFlow{};
  shared_ptr<double> online{};
  shared_ptr<string> rate{};

  DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downFlow) {
      res["DownFlow"] = boost::any(*downFlow);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownFlow") != m.end() && !m["DownFlow"].empty()) {
      downFlow = make_shared<double>(boost::any_cast<double>(m["DownFlow"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<double>(boost::any_cast<double>(m["Online"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos>> infos{};
  shared_ptr<string> streamName{};

  DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infos) {
      vector<boost::any> temp1;
      for(auto item1:*infos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Infos"] = boost::any(temp1);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Infos") != m.end() && !m["Infos"].empty()) {
      if (typeid(vector<boost::any>) == m["Infos"].type()) {
        vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        infos = make_shared<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos>>(expect1);
      }
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos>> streamInfos{};

  DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (streamInfos) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfos"].type()) {
        vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfos = make_shared<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos>>(expect1);
      }
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> time{};
  shared_ptr<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData>> usageData{};

  DescribeHlsLiveStreamRealTimeBpsDataResponseBody() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataResponseBody() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHlsLiveStreamRealTimeBpsDataResponseBody> body{};

  DescribeHlsLiveStreamRealTimeBpsDataResponse() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHlsLiveStreamRealTimeBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHlsLiveStreamRealTimeBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataResponse() = default;
};
class DescribeLiveAudioAuditConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  DescribeLiveAudioAuditConfigRequest() {}

  explicit DescribeLiveAudioAuditConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveAudioAuditConfigRequest() = default;
};
class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> scene{};

  DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes() {}

  explicit DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["scene"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["scene"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scene = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes() = default;
};
class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> bizType{};
  shared_ptr<string> domainName{};
  shared_ptr<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes> scenes{};
  shared_ptr<string> streamName{};

  DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig() {}

  explicit DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (scenes) {
      res["Scenes"] = scenes ? boost::any(scenes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Scenes") != m.end() && !m["Scenes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scenes"].type()) {
        DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scenes"]));
        scenes = make_shared<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes>(model1);
      }
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig() = default;
};
class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig>> liveAudioAuditConfig{};

  DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList() {}

  explicit DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAudioAuditConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveAudioAuditConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveAudioAuditConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAudioAuditConfig") != m.end() && !m["LiveAudioAuditConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveAudioAuditConfig"].type()) {
        vector<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveAudioAuditConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveAudioAuditConfig = make_shared<vector<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList() = default;
};
class DescribeLiveAudioAuditConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList> liveAudioAuditConfigList{};
  shared_ptr<string> requestId{};

  DescribeLiveAudioAuditConfigResponseBody() {}

  explicit DescribeLiveAudioAuditConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAudioAuditConfigList) {
      res["LiveAudioAuditConfigList"] = liveAudioAuditConfigList ? boost::any(liveAudioAuditConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAudioAuditConfigList") != m.end() && !m["LiveAudioAuditConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveAudioAuditConfigList"].type()) {
        DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveAudioAuditConfigList"]));
        liveAudioAuditConfigList = make_shared<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveAudioAuditConfigResponseBody() = default;
};
class DescribeLiveAudioAuditConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveAudioAuditConfigResponseBody> body{};

  DescribeLiveAudioAuditConfigResponse() {}

  explicit DescribeLiveAudioAuditConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveAudioAuditConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveAudioAuditConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveAudioAuditConfigResponse() = default;
};
class DescribeLiveAudioAuditNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveAudioAuditNotifyConfigRequest() {}

  explicit DescribeLiveAudioAuditNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveAudioAuditNotifyConfigRequest() = default;
};
class DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> callback{};
  shared_ptr<string> callbackTemplate{};
  shared_ptr<string> domainName{};

  DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig() {}

  explicit DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (callbackTemplate) {
      res["CallbackTemplate"] = boost::any(*callbackTemplate);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CallbackTemplate") != m.end() && !m["CallbackTemplate"].empty()) {
      callbackTemplate = make_shared<string>(boost::any_cast<string>(m["CallbackTemplate"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig() = default;
};
class DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig>> liveAudioAuditNotifyConfig{};

  DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList() {}

  explicit DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAudioAuditNotifyConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveAudioAuditNotifyConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveAudioAuditNotifyConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAudioAuditNotifyConfig") != m.end() && !m["LiveAudioAuditNotifyConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveAudioAuditNotifyConfig"].type()) {
        vector<DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveAudioAuditNotifyConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveAudioAuditNotifyConfig = make_shared<vector<DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList() = default;
};
class DescribeLiveAudioAuditNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList> liveAudioAuditNotifyConfigList{};
  shared_ptr<string> requestId{};

  DescribeLiveAudioAuditNotifyConfigResponseBody() {}

  explicit DescribeLiveAudioAuditNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAudioAuditNotifyConfigList) {
      res["LiveAudioAuditNotifyConfigList"] = liveAudioAuditNotifyConfigList ? boost::any(liveAudioAuditNotifyConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAudioAuditNotifyConfigList") != m.end() && !m["LiveAudioAuditNotifyConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveAudioAuditNotifyConfigList"].type()) {
        DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveAudioAuditNotifyConfigList"]));
        liveAudioAuditNotifyConfigList = make_shared<DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveAudioAuditNotifyConfigResponseBody() = default;
};
class DescribeLiveAudioAuditNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveAudioAuditNotifyConfigResponseBody> body{};

  DescribeLiveAudioAuditNotifyConfigResponse() {}

  explicit DescribeLiveAudioAuditNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveAudioAuditNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveAudioAuditNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveAudioAuditNotifyConfigResponse() = default;
};
class DescribeLiveCertificateDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveCertificateDetailRequest() {}

  explicit DescribeLiveCertificateDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveCertificateDetailRequest() = default;
};
class DescribeLiveCertificateDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cert{};
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> requestId{};

  DescribeLiveCertificateDetailResponseBody() {}

  explicit DescribeLiveCertificateDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      res["Cert"] = boost::any(*cert);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      cert = make_shared<string>(boost::any_cast<string>(m["Cert"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveCertificateDetailResponseBody() = default;
};
class DescribeLiveCertificateDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveCertificateDetailResponseBody> body{};

  DescribeLiveCertificateDetailResponse() {}

  explicit DescribeLiveCertificateDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveCertificateDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveCertificateDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveCertificateDetailResponse() = default;
};
class DescribeLiveCertificateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveCertificateListRequest() {}

  explicit DescribeLiveCertificateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveCertificateListRequest() = default;
};
class DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert : public Darabonba::Model {
public:
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> common{};
  shared_ptr<string> fingerprint{};
  shared_ptr<string> issuer{};
  shared_ptr<long> lastTime{};

  DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert() {}

  explicit DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (common) {
      res["Common"] = boost::any(*common);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<string>(boost::any_cast<string>(m["Common"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
  }


  virtual ~DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert() = default;
};
class DescribeLiveCertificateListResponseBodyCertificateListModelCertList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert>> cert{};

  DescribeLiveCertificateListResponseBodyCertificateListModelCertList() {}

  explicit DescribeLiveCertificateListResponseBodyCertificateListModelCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      vector<boost::any> temp1;
      for(auto item1:*cert){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cert"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      if (typeid(vector<boost::any>) == m["Cert"].type()) {
        vector<DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cert"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cert = make_shared<vector<DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveCertificateListResponseBodyCertificateListModelCertList() = default;
};
class DescribeLiveCertificateListResponseBodyCertificateListModel : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveCertificateListResponseBodyCertificateListModelCertList> certList{};
  shared_ptr<long> count{};

  DescribeLiveCertificateListResponseBodyCertificateListModel() {}

  explicit DescribeLiveCertificateListResponseBodyCertificateListModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certList) {
      res["CertList"] = certList ? boost::any(certList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertList") != m.end() && !m["CertList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertList"].type()) {
        DescribeLiveCertificateListResponseBodyCertificateListModelCertList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertList"]));
        certList = make_shared<DescribeLiveCertificateListResponseBodyCertificateListModelCertList>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeLiveCertificateListResponseBodyCertificateListModel() = default;
};
class DescribeLiveCertificateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveCertificateListResponseBodyCertificateListModel> certificateListModel{};
  shared_ptr<string> requestId{};

  DescribeLiveCertificateListResponseBody() {}

  explicit DescribeLiveCertificateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateListModel) {
      res["CertificateListModel"] = certificateListModel ? boost::any(certificateListModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateListModel") != m.end() && !m["CertificateListModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertificateListModel"].type()) {
        DescribeLiveCertificateListResponseBodyCertificateListModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertificateListModel"]));
        certificateListModel = make_shared<DescribeLiveCertificateListResponseBodyCertificateListModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveCertificateListResponseBody() = default;
};
class DescribeLiveCertificateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveCertificateListResponseBody> body{};

  DescribeLiveCertificateListResponse() {}

  explicit DescribeLiveCertificateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveCertificateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveCertificateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveCertificateListResponse() = default;
};
class DescribeLiveDetectNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveDetectNotifyConfigRequest() {}

  explicit DescribeLiveDetectNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveDetectNotifyConfigRequest() = default;
};
class DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyUrl{};

  DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig() {}

  explicit DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
  }


  virtual ~DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig() = default;
};
class DescribeLiveDetectNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig> liveDetectNotifyConfig{};
  shared_ptr<string> requestId{};

  DescribeLiveDetectNotifyConfigResponseBody() {}

  explicit DescribeLiveDetectNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveDetectNotifyConfig) {
      res["LiveDetectNotifyConfig"] = liveDetectNotifyConfig ? boost::any(liveDetectNotifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveDetectNotifyConfig") != m.end() && !m["LiveDetectNotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveDetectNotifyConfig"].type()) {
        DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveDetectNotifyConfig"]));
        liveDetectNotifyConfig = make_shared<DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDetectNotifyConfigResponseBody() = default;
};
class DescribeLiveDetectNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDetectNotifyConfigResponseBody> body{};

  DescribeLiveDetectNotifyConfigResponse() {}

  explicit DescribeLiveDetectNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDetectNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDetectNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDetectNotifyConfigResponse() = default;
};
class DescribeLiveDetectPornDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> fee{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> scene{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> stream{};

  DescribeLiveDetectPornDataRequest() {}

  explicit DescribeLiveDetectPornDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fee) {
      res["Fee"] = boost::any(*fee);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Fee") != m.end() && !m["Fee"].empty()) {
      fee = make_shared<string>(boost::any_cast<string>(m["Fee"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~DescribeLiveDetectPornDataRequest() = default;
};
class DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<long> count{};
  shared_ptr<string> domain{};
  shared_ptr<string> fee{};
  shared_ptr<string> region{};
  shared_ptr<string> scene{};
  shared_ptr<string> stream{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule() {}

  explicit DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (fee) {
      res["Fee"] = boost::any(*fee);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Fee") != m.end() && !m["Fee"].empty()) {
      fee = make_shared<string>(boost::any_cast<string>(m["Fee"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule() = default;
};
class DescribeLiveDetectPornDataResponseBodyDetectPornData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule>> dataModule{};

  DescribeLiveDetectPornDataResponseBodyDetectPornData() {}

  explicit DescribeLiveDetectPornDataResponseBodyDetectPornData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDetectPornDataResponseBodyDetectPornData() = default;
};
class DescribeLiveDetectPornDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDetectPornDataResponseBodyDetectPornData> detectPornData{};
  shared_ptr<string> requestId{};

  DescribeLiveDetectPornDataResponseBody() {}

  explicit DescribeLiveDetectPornDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detectPornData) {
      res["DetectPornData"] = detectPornData ? boost::any(detectPornData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DetectPornData") != m.end() && !m["DetectPornData"].empty()) {
      if (typeid(map<string, boost::any>) == m["DetectPornData"].type()) {
        DescribeLiveDetectPornDataResponseBodyDetectPornData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DetectPornData"]));
        detectPornData = make_shared<DescribeLiveDetectPornDataResponseBodyDetectPornData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDetectPornDataResponseBody() = default;
};
class DescribeLiveDetectPornDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDetectPornDataResponseBody> body{};

  DescribeLiveDetectPornDataResponse() {}

  explicit DescribeLiveDetectPornDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDetectPornDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDetectPornDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDetectPornDataResponse() = default;
};
class DescribeLiveDomainBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainBpsDataRequest() {}

  explicit DescribeLiveDomainBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataRequest() = default;
};
class DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> bpsValue{};
  shared_ptr<string> httpBpsValue{};
  shared_ptr<string> httpsBpsValue{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsValue) {
      res["BpsValue"] = boost::any(*bpsValue);
    }
    if (httpBpsValue) {
      res["HttpBpsValue"] = boost::any(*httpBpsValue);
    }
    if (httpsBpsValue) {
      res["HttpsBpsValue"] = boost::any(*httpsBpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsValue") != m.end() && !m["BpsValue"].empty()) {
      bpsValue = make_shared<string>(boost::any_cast<string>(m["BpsValue"]));
    }
    if (m.find("HttpBpsValue") != m.end() && !m["HttpBpsValue"].empty()) {
      httpBpsValue = make_shared<string>(boost::any_cast<string>(m["HttpBpsValue"]));
    }
    if (m.find("HttpsBpsValue") != m.end() && !m["HttpsBpsValue"].empty()) {
      httpsBpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsBpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeLiveDomainBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainBpsDataResponseBody() {}

  explicit DescribeLiveDomainBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataResponseBody() = default;
};
class DescribeLiveDomainBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainBpsDataResponseBody> body{};

  DescribeLiveDomainBpsDataResponse() {}

  explicit DescribeLiveDomainBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainBpsDataResponse() = default;
};
class DescribeLiveDomainBpsDataByLayerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> layer{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainBpsDataByLayerRequest() {}

  explicit DescribeLiveDomainBpsDataByLayerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataByLayerRequest() = default;
};
class DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> trafficValue{};
  shared_ptr<string> value{};

  DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule() {}

  explicit DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<string>(boost::any_cast<string>(m["TrafficValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule() = default;
};
class DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule>> dataModule{};

  DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval() {}

  explicit DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval() = default;
};
class DescribeLiveDomainBpsDataByLayerResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval> bpsDataInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainBpsDataByLayerResponseBody() {}

  explicit DescribeLiveDomainBpsDataByLayerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataInterval) {
      res["BpsDataInterval"] = bpsDataInterval ? boost::any(bpsDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataInterval") != m.end() && !m["BpsDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataInterval"].type()) {
        DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataInterval"]));
        bpsDataInterval = make_shared<DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataByLayerResponseBody() = default;
};
class DescribeLiveDomainBpsDataByLayerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainBpsDataByLayerResponseBody> body{};

  DescribeLiveDomainBpsDataByLayerResponse() {}

  explicit DescribeLiveDomainBpsDataByLayerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainBpsDataByLayerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainBpsDataByLayerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainBpsDataByLayerResponse() = default;
};
class DescribeLiveDomainBpsDataByTimeStampRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> ispNames{};
  shared_ptr<string> locationNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> timePoint{};

  DescribeLiveDomainBpsDataByTimeStampRequest() {}

  explicit DescribeLiveDomainBpsDataByTimeStampRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ispNames) {
      res["IspNames"] = boost::any(*ispNames);
    }
    if (locationNames) {
      res["LocationNames"] = boost::any(*locationNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IspNames") != m.end() && !m["IspNames"].empty()) {
      ispNames = make_shared<string>(boost::any_cast<string>(m["IspNames"]));
    }
    if (m.find("LocationNames") != m.end() && !m["LocationNames"].empty()) {
      locationNames = make_shared<string>(boost::any_cast<string>(m["LocationNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataByTimeStampRequest() = default;
};
class DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel : public Darabonba::Model {
public:
  shared_ptr<long> bps{};
  shared_ptr<string> ispName{};
  shared_ptr<string> locationName{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel() {}

  explicit DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    if (locationName) {
      res["LocationName"] = boost::any(*locationName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<long>(boost::any_cast<long>(m["Bps"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
    if (m.find("LocationName") != m.end() && !m["LocationName"].empty()) {
      locationName = make_shared<string>(boost::any_cast<string>(m["LocationName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel() = default;
};
class DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel>> bpsDataModel{};

  DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataList() {}

  explicit DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataModel) {
      vector<boost::any> temp1;
      for(auto item1:*bpsDataModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BpsDataModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataModel") != m.end() && !m["BpsDataModel"].empty()) {
      if (typeid(vector<boost::any>) == m["BpsDataModel"].type()) {
        vector<DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BpsDataModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bpsDataModel = make_shared<vector<DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataList() = default;
};
class DescribeLiveDomainBpsDataByTimeStampResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataList> bpsDataList{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDomainBpsDataByTimeStampResponseBody() {}

  explicit DescribeLiveDomainBpsDataByTimeStampResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataList) {
      res["BpsDataList"] = bpsDataList ? boost::any(bpsDataList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataList") != m.end() && !m["BpsDataList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataList"].type()) {
        DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataList"]));
        bpsDataList = make_shared<DescribeLiveDomainBpsDataByTimeStampResponseBodyBpsDataList>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataByTimeStampResponseBody() = default;
};
class DescribeLiveDomainBpsDataByTimeStampResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainBpsDataByTimeStampResponseBody> body{};

  DescribeLiveDomainBpsDataByTimeStampResponse() {}

  explicit DescribeLiveDomainBpsDataByTimeStampResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainBpsDataByTimeStampResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainBpsDataByTimeStampResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainBpsDataByTimeStampResponse() = default;
};
class DescribeLiveDomainCertificateInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveDomainCertificateInfoRequest() {}

  explicit DescribeLiveDomainCertificateInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveDomainCertificateInfoRequest() = default;
};
class DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certDomainName{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certLife{};
  shared_ptr<string> certName{};
  shared_ptr<string> certOrg{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> status{};

  DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo() {}

  explicit DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certDomainName) {
      res["CertDomainName"] = boost::any(*certDomainName);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certLife) {
      res["CertLife"] = boost::any(*certLife);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certOrg) {
      res["CertOrg"] = boost::any(*certOrg);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertDomainName") != m.end() && !m["CertDomainName"].empty()) {
      certDomainName = make_shared<string>(boost::any_cast<string>(m["CertDomainName"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertLife") != m.end() && !m["CertLife"].empty()) {
      certLife = make_shared<string>(boost::any_cast<string>(m["CertLife"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertOrg") != m.end() && !m["CertOrg"].empty()) {
      certOrg = make_shared<string>(boost::any_cast<string>(m["CertOrg"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo() = default;
};
class DescribeLiveDomainCertificateInfoResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeLiveDomainCertificateInfoResponseBodyCertInfos() {}

  explicit DescribeLiveDomainCertificateInfoResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainCertificateInfoResponseBodyCertInfos() = default;
};
class DescribeLiveDomainCertificateInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainCertificateInfoResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainCertificateInfoResponseBody() {}

  explicit DescribeLiveDomainCertificateInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeLiveDomainCertificateInfoResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeLiveDomainCertificateInfoResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainCertificateInfoResponseBody() = default;
};
class DescribeLiveDomainCertificateInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainCertificateInfoResponseBody> body{};

  DescribeLiveDomainCertificateInfoResponse() {}

  explicit DescribeLiveDomainCertificateInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainCertificateInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainCertificateInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainCertificateInfoResponse() = default;
};
class DescribeLiveDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveDomainConfigsRequest() {}

  explicit DescribeLiveDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveDomainConfigsRequest() = default;
};
class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() {}

  explicit DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() = default;
};
class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>> functionArg{};

  DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() {}

  explicit DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionArg) {
      vector<boost::any> temp1;
      for(auto item1:*functionArg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArg"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionArg") != m.end() && !m["FunctionArg"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArg"].type()) {
        vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArg = make_shared<vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() = default;
};
class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> status{};

  DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig() {}

  explicit DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      res["FunctionArgs"] = functionArgs ? boost::any(functionArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionArgs"].type()) {
        DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionArgs"]));
        functionArgs = make_shared<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs>(model1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig() = default;
};
class DescribeLiveDomainConfigsResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig>> domainConfig{};

  DescribeLiveDomainConfigsResponseBodyDomainConfigs() {}

  explicit DescribeLiveDomainConfigsResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfig) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfig") != m.end() && !m["DomainConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfig"].type()) {
        vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfig = make_shared<vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainConfigsResponseBodyDomainConfigs() = default;
};
class DescribeLiveDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainConfigsResponseBodyDomainConfigs> domainConfigs{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainConfigsResponseBody() {}

  explicit DescribeLiveDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      res["DomainConfigs"] = domainConfigs ? boost::any(domainConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainConfigs"].type()) {
        DescribeLiveDomainConfigsResponseBodyDomainConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainConfigs"]));
        domainConfigs = make_shared<DescribeLiveDomainConfigsResponseBodyDomainConfigs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainConfigsResponseBody() = default;
};
class DescribeLiveDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainConfigsResponseBody> body{};

  DescribeLiveDomainConfigsResponse() {}

  explicit DescribeLiveDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainConfigsResponse() = default;
};
class DescribeLiveDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveDomainDetailRequest() {}

  explicit DescribeLiveDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveDomainDetailRequest() = default;
};
class DescribeLiveDomainDetailResponseBodyDomainDetail : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> liveDomainType{};
  shared_ptr<string> region{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> scope{};

  DescribeLiveDomainDetailResponseBodyDomainDetail() {}

  explicit DescribeLiveDomainDetailResponseBodyDomainDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (liveDomainType) {
      res["LiveDomainType"] = boost::any(*liveDomainType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("LiveDomainType") != m.end() && !m["LiveDomainType"].empty()) {
      liveDomainType = make_shared<string>(boost::any_cast<string>(m["LiveDomainType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~DescribeLiveDomainDetailResponseBodyDomainDetail() = default;
};
class DescribeLiveDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainDetailResponseBodyDomainDetail> domainDetail{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainDetailResponseBody() {}

  explicit DescribeLiveDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainDetail) {
      res["DomainDetail"] = domainDetail ? boost::any(domainDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainDetail") != m.end() && !m["DomainDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainDetail"].type()) {
        DescribeLiveDomainDetailResponseBodyDomainDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainDetail"]));
        domainDetail = make_shared<DescribeLiveDomainDetailResponseBodyDomainDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainDetailResponseBody() = default;
};
class DescribeLiveDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainDetailResponseBody> body{};

  DescribeLiveDomainDetailResponse() {}

  explicit DescribeLiveDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainDetailResponse() = default;
};
class DescribeLiveDomainFrameRateAndBitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> queryTime{};

  DescribeLiveDomainFrameRateAndBitRateDataRequest() {}

  explicit DescribeLiveDomainFrameRateAndBitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<string>(boost::any_cast<string>(m["QueryTime"]));
    }
  }


  virtual ~DescribeLiveDomainFrameRateAndBitRateDataRequest() = default;
};
class DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo : public Darabonba::Model {
public:
  shared_ptr<double> audioFrameRate{};
  shared_ptr<double> bitRate{};
  shared_ptr<string> streamUrl{};
  shared_ptr<double> videoFrameRate{};

  DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo() {}

  explicit DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFrameRate) {
      res["AudioFrameRate"] = boost::any(*audioFrameRate);
    }
    if (bitRate) {
      res["BitRate"] = boost::any(*bitRate);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    if (videoFrameRate) {
      res["VideoFrameRate"] = boost::any(*videoFrameRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFrameRate") != m.end() && !m["AudioFrameRate"].empty()) {
      audioFrameRate = make_shared<double>(boost::any_cast<double>(m["AudioFrameRate"]));
    }
    if (m.find("BitRate") != m.end() && !m["BitRate"].empty()) {
      bitRate = make_shared<double>(boost::any_cast<double>(m["BitRate"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
    if (m.find("VideoFrameRate") != m.end() && !m["VideoFrameRate"].empty()) {
      videoFrameRate = make_shared<double>(boost::any_cast<double>(m["VideoFrameRate"]));
    }
  }


  virtual ~DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo() = default;
};
class DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo>> frameRateAndBitRateInfo{};

  DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos() {}

  explicit DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameRateAndBitRateInfo) {
      vector<boost::any> temp1;
      for(auto item1:*frameRateAndBitRateInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrameRateAndBitRateInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameRateAndBitRateInfo") != m.end() && !m["FrameRateAndBitRateInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["FrameRateAndBitRateInfo"].type()) {
        vector<DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrameRateAndBitRateInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frameRateAndBitRateInfo = make_shared<vector<DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos() = default;
};
class DescribeLiveDomainFrameRateAndBitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos> frameRateAndBitRateInfos{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainFrameRateAndBitRateDataResponseBody() {}

  explicit DescribeLiveDomainFrameRateAndBitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameRateAndBitRateInfos) {
      res["FrameRateAndBitRateInfos"] = frameRateAndBitRateInfos ? boost::any(frameRateAndBitRateInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameRateAndBitRateInfos") != m.end() && !m["FrameRateAndBitRateInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["FrameRateAndBitRateInfos"].type()) {
        DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FrameRateAndBitRateInfos"]));
        frameRateAndBitRateInfos = make_shared<DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainFrameRateAndBitRateDataResponseBody() = default;
};
class DescribeLiveDomainFrameRateAndBitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainFrameRateAndBitRateDataResponseBody> body{};

  DescribeLiveDomainFrameRateAndBitRateDataResponse() {}

  explicit DescribeLiveDomainFrameRateAndBitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainFrameRateAndBitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainFrameRateAndBitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainFrameRateAndBitRateDataResponse() = default;
};
class DescribeLiveDomainLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveDomainLimitRequest() {}

  explicit DescribeLiveDomainLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveDomainLimitRequest() = default;
};
class DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> limitNum{};
  shared_ptr<long> limitTranscodeNum{};
  shared_ptr<long> limitTransferNum{};

  DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit() {}

  explicit DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (limitNum) {
      res["LimitNum"] = boost::any(*limitNum);
    }
    if (limitTranscodeNum) {
      res["LimitTranscodeNum"] = boost::any(*limitTranscodeNum);
    }
    if (limitTransferNum) {
      res["LimitTransferNum"] = boost::any(*limitTransferNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LimitNum") != m.end() && !m["LimitNum"].empty()) {
      limitNum = make_shared<long>(boost::any_cast<long>(m["LimitNum"]));
    }
    if (m.find("LimitTranscodeNum") != m.end() && !m["LimitTranscodeNum"].empty()) {
      limitTranscodeNum = make_shared<long>(boost::any_cast<long>(m["LimitTranscodeNum"]));
    }
    if (m.find("LimitTransferNum") != m.end() && !m["LimitTransferNum"].empty()) {
      limitTransferNum = make_shared<long>(boost::any_cast<long>(m["LimitTransferNum"]));
    }
  }


  virtual ~DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit() = default;
};
class DescribeLiveDomainLimitResponseBodyLiveDomainLimitList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit>> liveDomainLimit{};

  DescribeLiveDomainLimitResponseBodyLiveDomainLimitList() {}

  explicit DescribeLiveDomainLimitResponseBodyLiveDomainLimitList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveDomainLimit) {
      vector<boost::any> temp1;
      for(auto item1:*liveDomainLimit){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveDomainLimit"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveDomainLimit") != m.end() && !m["LiveDomainLimit"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveDomainLimit"].type()) {
        vector<DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveDomainLimit"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveDomainLimit = make_shared<vector<DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainLimitResponseBodyLiveDomainLimitList() = default;
};
class DescribeLiveDomainLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainLimitResponseBodyLiveDomainLimitList> liveDomainLimitList{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainLimitResponseBody() {}

  explicit DescribeLiveDomainLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveDomainLimitList) {
      res["LiveDomainLimitList"] = liveDomainLimitList ? boost::any(liveDomainLimitList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveDomainLimitList") != m.end() && !m["LiveDomainLimitList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveDomainLimitList"].type()) {
        DescribeLiveDomainLimitResponseBodyLiveDomainLimitList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveDomainLimitList"]));
        liveDomainLimitList = make_shared<DescribeLiveDomainLimitResponseBodyLiveDomainLimitList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainLimitResponseBody() = default;
};
class DescribeLiveDomainLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainLimitResponseBody> body{};

  DescribeLiveDomainLimitResponse() {}

  explicit DescribeLiveDomainLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainLimitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainLimitResponse() = default;
};
class DescribeLiveDomainLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainLogRequest() {}

  explicit DescribeLiveDomainLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainLogRequest() = default;
};
class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() {}

  explicit DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() = default;
};
class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>> logInfoDetail{};

  DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() {}

  explicit DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfoDetail) {
      vector<boost::any> temp1;
      for(auto item1:*logInfoDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfoDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfoDetail") != m.end() && !m["LogInfoDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfoDetail"].type()) {
        vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfoDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfoDetail = make_shared<vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() = default;
};
class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() {}

  explicit DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() = default;
};
class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail : public Darabonba::Model {
public:
  shared_ptr<long> logCount{};
  shared_ptr<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos> logInfos{};
  shared_ptr<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos> pageInfos{};

  DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail() {}

  explicit DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos>(model1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail() = default;
};
class DescribeLiveDomainLogResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail>> domainLogDetail{};

  DescribeLiveDomainLogResponseBodyDomainLogDetails() {}

  explicit DescribeLiveDomainLogResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetail") != m.end() && !m["DomainLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetail"].type()) {
        vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetail = make_shared<vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogResponseBodyDomainLogDetails() = default;
};
class DescribeLiveDomainLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainLogResponseBodyDomainLogDetails> domainLogDetails{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainLogResponseBody() {}

  explicit DescribeLiveDomainLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetails) {
      res["DomainLogDetails"] = domainLogDetails ? boost::any(domainLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogDetails"].type()) {
        DescribeLiveDomainLogResponseBodyDomainLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogDetails"]));
        domainLogDetails = make_shared<DescribeLiveDomainLogResponseBodyDomainLogDetails>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainLogResponseBody() = default;
};
class DescribeLiveDomainLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainLogResponseBody> body{};

  DescribeLiveDomainLogResponse() {}

  explicit DescribeLiveDomainLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogResponse() = default;
};
class DescribeLiveDomainMappingRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveDomainMappingRequest() {}

  explicit DescribeLiveDomainMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveDomainMappingRequest() = default;
};
class DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> type{};

  DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel() {}

  explicit DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel() = default;
};
class DescribeLiveDomainMappingResponseBodyLiveDomainModels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel>> liveDomainModel{};

  DescribeLiveDomainMappingResponseBodyLiveDomainModels() {}

  explicit DescribeLiveDomainMappingResponseBodyLiveDomainModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveDomainModel) {
      vector<boost::any> temp1;
      for(auto item1:*liveDomainModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveDomainModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveDomainModel") != m.end() && !m["LiveDomainModel"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveDomainModel"].type()) {
        vector<DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveDomainModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveDomainModel = make_shared<vector<DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainMappingResponseBodyLiveDomainModels() = default;
};
class DescribeLiveDomainMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainMappingResponseBodyLiveDomainModels> liveDomainModels{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainMappingResponseBody() {}

  explicit DescribeLiveDomainMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveDomainModels) {
      res["LiveDomainModels"] = liveDomainModels ? boost::any(liveDomainModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveDomainModels") != m.end() && !m["LiveDomainModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveDomainModels"].type()) {
        DescribeLiveDomainMappingResponseBodyLiveDomainModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveDomainModels"]));
        liveDomainModels = make_shared<DescribeLiveDomainMappingResponseBodyLiveDomainModels>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainMappingResponseBody() = default;
};
class DescribeLiveDomainMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainMappingResponseBody> body{};

  DescribeLiveDomainMappingResponse() {}

  explicit DescribeLiveDomainMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainMappingResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainMappingResponse() = default;
};
class DescribeLiveDomainOnlineUserNumRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> queryTime{};

  DescribeLiveDomainOnlineUserNumRequest() {}

  explicit DescribeLiveDomainOnlineUserNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<string>(boost::any_cast<string>(m["QueryTime"]));
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumRequest() = default;
};
class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo : public Darabonba::Model {
public:
  shared_ptr<string> transcodeTemplate{};
  shared_ptr<long> userNumber{};

  DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo() {}

  explicit DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeTemplate) {
      res["TranscodeTemplate"] = boost::any(*transcodeTemplate);
    }
    if (userNumber) {
      res["UserNumber"] = boost::any(*userNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeTemplate") != m.end() && !m["TranscodeTemplate"].empty()) {
      transcodeTemplate = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplate"]));
    }
    if (m.find("UserNumber") != m.end() && !m["UserNumber"].empty()) {
      userNumber = make_shared<long>(boost::any_cast<long>(m["UserNumber"]));
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo() = default;
};
class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo>> info{};

  DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos() {}

  explicit DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(vector<boost::any>) == m["Info"].type()) {
        vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos() = default;
};
class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos> infos{};
  shared_ptr<string> streamName{};

  DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo() {}

  explicit DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infos) {
      res["Infos"] = infos ? boost::any(infos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Infos") != m.end() && !m["Infos"].empty()) {
      if (typeid(map<string, boost::any>) == m["Infos"].type()) {
        DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Infos"]));
        infos = make_shared<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos>(model1);
      }
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo() = default;
};
class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo>> liveStreamOnlineUserNumInfo{};

  DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo() {}

  explicit DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamOnlineUserNumInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamOnlineUserNumInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamOnlineUserNumInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamOnlineUserNumInfo") != m.end() && !m["LiveStreamOnlineUserNumInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamOnlineUserNumInfo"].type()) {
        vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamOnlineUserNumInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamOnlineUserNumInfo = make_shared<vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo() = default;
};
class DescribeLiveDomainOnlineUserNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo> onlineUserInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<long> streamCount{};
  shared_ptr<long> userCount{};

  DescribeLiveDomainOnlineUserNumResponseBody() {}

  explicit DescribeLiveDomainOnlineUserNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onlineUserInfo) {
      res["OnlineUserInfo"] = onlineUserInfo ? boost::any(onlineUserInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamCount) {
      res["StreamCount"] = boost::any(*streamCount);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnlineUserInfo") != m.end() && !m["OnlineUserInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineUserInfo"].type()) {
        DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineUserInfo"]));
        onlineUserInfo = make_shared<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamCount") != m.end() && !m["StreamCount"].empty()) {
      streamCount = make_shared<long>(boost::any_cast<long>(m["StreamCount"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponseBody() = default;
};
class DescribeLiveDomainOnlineUserNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainOnlineUserNumResponseBody> body{};

  DescribeLiveDomainOnlineUserNumResponse() {}

  explicit DescribeLiveDomainOnlineUserNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainOnlineUserNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainOnlineUserNumResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponse() = default;
};
class DescribeLiveDomainPushBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPushBpsDataRequest() {}

  explicit DescribeLiveDomainPushBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPushBpsDataRequest() = default;
};
class DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> bpsValue{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsValue) {
      res["BpsValue"] = boost::any(*bpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsValue") != m.end() && !m["BpsValue"].empty()) {
      bpsValue = make_shared<string>(boost::any_cast<string>(m["BpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeLiveDomainPushBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPushBpsDataResponseBody() {}

  explicit DescribeLiveDomainPushBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPushBpsDataResponseBody() = default;
};
class DescribeLiveDomainPushBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainPushBpsDataResponseBody> body{};

  DescribeLiveDomainPushBpsDataResponse() {}

  explicit DescribeLiveDomainPushBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainPushBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainPushBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainPushBpsDataResponse() = default;
};
class DescribeLiveDomainPushTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPushTrafficDataRequest() {}

  explicit DescribeLiveDomainPushTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPushTrafficDataRequest() = default;
};
class DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> trafficValue{};

  DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<string>(boost::any_cast<string>(m["TrafficValue"]));
    }
  }


  virtual ~DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeLiveDomainPushTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeLiveDomainPushTrafficDataResponseBody() {}

  explicit DescribeLiveDomainPushTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainPushTrafficDataResponseBody() = default;
};
class DescribeLiveDomainPushTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainPushTrafficDataResponseBody> body{};

  DescribeLiveDomainPushTrafficDataResponse() {}

  explicit DescribeLiveDomainPushTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainPushTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainPushTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainPushTrafficDataResponse() = default;
};
class DescribeLiveDomainPvUvDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPvUvDataRequest() {}

  explicit DescribeLiveDomainPvUvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPvUvDataRequest() = default;
};
class DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> PV{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> UV{};

  DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo() {}

  explicit DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (PV) {
      res["PV"] = boost::any(*PV);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (UV) {
      res["UV"] = boost::any(*UV);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PV") != m.end() && !m["PV"].empty()) {
      PV = make_shared<string>(boost::any_cast<string>(m["PV"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("UV") != m.end() && !m["UV"].empty()) {
      UV = make_shared<string>(boost::any_cast<string>(m["UV"]));
    }
  }


  virtual ~DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo() = default;
};
class DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo>> pvUvDataInfo{};

  DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos() {}

  explicit DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pvUvDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*pvUvDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PvUvDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PvUvDataInfo") != m.end() && !m["PvUvDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PvUvDataInfo"].type()) {
        vector<DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PvUvDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pvUvDataInfo = make_shared<vector<DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos() = default;
};
class DescribeLiveDomainPvUvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos> pvUvDataInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPvUvDataResponseBody() {}

  explicit DescribeLiveDomainPvUvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pvUvDataInfos) {
      res["PvUvDataInfos"] = pvUvDataInfos ? boost::any(pvUvDataInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PvUvDataInfos") != m.end() && !m["PvUvDataInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PvUvDataInfos"].type()) {
        DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PvUvDataInfos"]));
        pvUvDataInfos = make_shared<DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPvUvDataResponseBody() = default;
};
class DescribeLiveDomainPvUvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainPvUvDataResponseBody> body{};

  DescribeLiveDomainPvUvDataResponse() {}

  explicit DescribeLiveDomainPvUvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainPvUvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainPvUvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainPvUvDataResponse() = default;
};
class DescribeLiveDomainRealTimeBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeBpsDataRequest() {}

  explicit DescribeLiveDomainRealTimeBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeBpsDataRequest() = default;
};
class DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval() {}

  explicit DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval() = default;
};
class DescribeLiveDomainRealTimeBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval> realTimeBpsDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeBpsDataResponseBody() {}

  explicit DescribeLiveDomainRealTimeBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeBpsDataPerInterval) {
      res["RealTimeBpsDataPerInterval"] = realTimeBpsDataPerInterval ? boost::any(realTimeBpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeBpsDataPerInterval") != m.end() && !m["RealTimeBpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeBpsDataPerInterval"].type()) {
        DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeBpsDataPerInterval"]));
        realTimeBpsDataPerInterval = make_shared<DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeBpsDataResponseBody() = default;
};
class DescribeLiveDomainRealTimeBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainRealTimeBpsDataResponseBody> body{};

  DescribeLiveDomainRealTimeBpsDataResponse() {}

  explicit DescribeLiveDomainRealTimeBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainRealTimeBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainRealTimeBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeBpsDataResponse() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeHttpCodeDataRequest() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataRequest() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> proportion{};

  DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData>> realTimeCodeProportionData{};

  DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeCodeProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeCodeProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeCodeProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeCodeProportionData") != m.end() && !m["RealTimeCodeProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeCodeProportionData"].type()) {
        vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeCodeProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeCodeProportionData = make_shared<vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue> value{};

  DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData>> usageData{};

  DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData> realTimeHttpCodeData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeHttpCodeDataResponseBody() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeHttpCodeData) {
      res["RealTimeHttpCodeData"] = realTimeHttpCodeData ? boost::any(realTimeHttpCodeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeHttpCodeData") != m.end() && !m["RealTimeHttpCodeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeHttpCodeData"].type()) {
        DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeHttpCodeData"]));
        realTimeHttpCodeData = make_shared<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponseBody() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainRealTimeHttpCodeDataResponseBody> body{};

  DescribeLiveDomainRealTimeHttpCodeDataResponse() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainRealTimeHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainRealTimeHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponse() = default;
};
class DescribeLiveDomainRealTimeTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeTrafficDataRequest() {}

  explicit DescribeLiveDomainRealTimeTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeTrafficDataRequest() = default;
};
class DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval() {}

  explicit DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval() = default;
};
class DescribeLiveDomainRealTimeTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval> realTimeTrafficDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeTrafficDataResponseBody() {}

  explicit DescribeLiveDomainRealTimeTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeTrafficDataPerInterval) {
      res["RealTimeTrafficDataPerInterval"] = realTimeTrafficDataPerInterval ? boost::any(realTimeTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeTrafficDataPerInterval") != m.end() && !m["RealTimeTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeTrafficDataPerInterval"].type()) {
        DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeTrafficDataPerInterval"]));
        realTimeTrafficDataPerInterval = make_shared<DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeTrafficDataResponseBody() = default;
};
class DescribeLiveDomainRealTimeTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainRealTimeTrafficDataResponseBody> body{};

  DescribeLiveDomainRealTimeTrafficDataResponse() {}

  explicit DescribeLiveDomainRealTimeTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainRealTimeTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainRealTimeTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeTrafficDataResponse() = default;
};
class DescribeLiveDomainRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveDomainRealtimeLogDeliveryRequest() {}

  explicit DescribeLiveDomainRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveDomainRealtimeLogDeliveryRequest() = default;
};
class DescribeLiveDomainRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeLiveDomainRealtimeLogDeliveryResponseBody() {}

  explicit DescribeLiveDomainRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeLiveDomainRealtimeLogDeliveryResponseBody() = default;
};
class DescribeLiveDomainRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainRealtimeLogDeliveryResponseBody> body{};

  DescribeLiveDomainRealtimeLogDeliveryResponse() {}

  explicit DescribeLiveDomainRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealtimeLogDeliveryResponse() = default;
};
class DescribeLiveDomainRecordDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> recordType{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRecordDataRequest() {}

  explicit DescribeLiveDomainRecordDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (recordType) {
      res["RecordType"] = boost::any(*recordType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RecordType") != m.end() && !m["RecordType"].empty()) {
      recordType = make_shared<string>(boost::any_cast<string>(m["RecordType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRecordDataRequest() = default;
};
class DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfoDetail : public Darabonba::Model {
public:
  shared_ptr<long> FLV{};
  shared_ptr<long> MP4{};
  shared_ptr<long> TS{};

  DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfoDetail() {}

  explicit DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (FLV) {
      res["FLV"] = boost::any(*FLV);
    }
    if (MP4) {
      res["MP4"] = boost::any(*MP4);
    }
    if (TS) {
      res["TS"] = boost::any(*TS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FLV") != m.end() && !m["FLV"].empty()) {
      FLV = make_shared<long>(boost::any_cast<long>(m["FLV"]));
    }
    if (m.find("MP4") != m.end() && !m["MP4"].empty()) {
      MP4 = make_shared<long>(boost::any_cast<long>(m["MP4"]));
    }
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      TS = make_shared<long>(boost::any_cast<long>(m["TS"]));
    }
  }


  virtual ~DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfoDetail() = default;
};
class DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfoDetail> detail{};
  shared_ptr<long> total{};

  DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfo() {}

  explicit DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (detail) {
      res["Detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Detail"].type()) {
        DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfoDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Detail"]));
        detail = make_shared<DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfoDetail>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfo() = default;
};
class DescribeLiveDomainRecordDataResponseBodyRecordDataInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfo>> recordDataInfo{};

  DescribeLiveDomainRecordDataResponseBodyRecordDataInfos() {}

  explicit DescribeLiveDomainRecordDataResponseBodyRecordDataInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*recordDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordDataInfo") != m.end() && !m["RecordDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordDataInfo"].type()) {
        vector<DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordDataInfo = make_shared<vector<DescribeLiveDomainRecordDataResponseBodyRecordDataInfosRecordDataInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainRecordDataResponseBodyRecordDataInfos() = default;
};
class DescribeLiveDomainRecordDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainRecordDataResponseBodyRecordDataInfos> recordDataInfos{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainRecordDataResponseBody() {}

  explicit DescribeLiveDomainRecordDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordDataInfos) {
      res["RecordDataInfos"] = recordDataInfos ? boost::any(recordDataInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordDataInfos") != m.end() && !m["RecordDataInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordDataInfos"].type()) {
        DescribeLiveDomainRecordDataResponseBodyRecordDataInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordDataInfos"]));
        recordDataInfos = make_shared<DescribeLiveDomainRecordDataResponseBodyRecordDataInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainRecordDataResponseBody() = default;
};
class DescribeLiveDomainRecordDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainRecordDataResponseBody> body{};

  DescribeLiveDomainRecordDataResponse() {}

  explicit DescribeLiveDomainRecordDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainRecordDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainRecordDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRecordDataResponse() = default;
};
class DescribeLiveDomainRecordUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRecordUsageDataRequest() {}

  explicit DescribeLiveDomainRecordUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRecordUsageDataRequest() = default;
};
class DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> domain{};
  shared_ptr<long> duration{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> type{};

  DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule() {}

  explicit DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule() = default;
};
class DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule>> dataModule{};

  DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData() {}

  explicit DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData() = default;
};
class DescribeLiveDomainRecordUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData> recordUsageData{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainRecordUsageDataResponseBody() {}

  explicit DescribeLiveDomainRecordUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordUsageData) {
      res["RecordUsageData"] = recordUsageData ? boost::any(recordUsageData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordUsageData") != m.end() && !m["RecordUsageData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordUsageData"].type()) {
        DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordUsageData"]));
        recordUsageData = make_shared<DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainRecordUsageDataResponseBody() = default;
};
class DescribeLiveDomainRecordUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainRecordUsageDataResponseBody> body{};

  DescribeLiveDomainRecordUsageDataResponse() {}

  explicit DescribeLiveDomainRecordUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainRecordUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainRecordUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRecordUsageDataResponse() = default;
};
class DescribeLiveDomainSnapshotDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainSnapshotDataRequest() {}

  explicit DescribeLiveDomainSnapshotDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainSnapshotDataRequest() = default;
};
class DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<long> total{};

  DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo() {}

  explicit DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo() = default;
};
class DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo>> snapshotDataInfo{};

  DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos() {}

  explicit DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*snapshotDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnapshotDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotDataInfo") != m.end() && !m["SnapshotDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SnapshotDataInfo"].type()) {
        vector<DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnapshotDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshotDataInfo = make_shared<vector<DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos() = default;
};
class DescribeLiveDomainSnapshotDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos> snapshotDataInfos{};

  DescribeLiveDomainSnapshotDataResponseBody() {}

  explicit DescribeLiveDomainSnapshotDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotDataInfos) {
      res["SnapshotDataInfos"] = snapshotDataInfos ? boost::any(snapshotDataInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotDataInfos") != m.end() && !m["SnapshotDataInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotDataInfos"].type()) {
        DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotDataInfos"]));
        snapshotDataInfos = make_shared<DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainSnapshotDataResponseBody() = default;
};
class DescribeLiveDomainSnapshotDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainSnapshotDataResponseBody> body{};

  DescribeLiveDomainSnapshotDataResponse() {}

  explicit DescribeLiveDomainSnapshotDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainSnapshotDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainSnapshotDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainSnapshotDataResponse() = default;
};
class DescribeLiveDomainStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};
  shared_ptr<long> ownerId{};

  DescribeLiveDomainStagingConfigRequest() {}

  explicit DescribeLiveDomainStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveDomainStagingConfigRequest() = default;
};
class DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs() {}

  explicit DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs() = default;
};
class DescribeLiveDomainStagingConfigResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs>> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> status{};

  DescribeLiveDomainStagingConfigResponseBodyDomainConfigs() {}

  explicit DescribeLiveDomainStagingConfigResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      vector<boost::any> temp1;
      for(auto item1:*functionArgs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArgs"] = boost::any(temp1);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArgs"].type()) {
        vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArgs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArgs = make_shared<vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs>>(expect1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeLiveDomainStagingConfigResponseBodyDomainConfigs() = default;
};
class DescribeLiveDomainStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigs>> domainConfigs{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainStagingConfigResponseBody() {}

  explicit DescribeLiveDomainStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfigs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfigs"].type()) {
        vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainStagingConfigResponseBodyDomainConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfigs = make_shared<vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainStagingConfigResponseBody() = default;
};
class DescribeLiveDomainStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainStagingConfigResponseBody> body{};

  DescribeLiveDomainStagingConfigResponse() {}

  explicit DescribeLiveDomainStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainStagingConfigResponse() = default;
};
class DescribeLiveDomainStreamTranscodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> split{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainStreamTranscodeDataRequest() {}

  explicit DescribeLiveDomainStreamTranscodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (split) {
      res["Split"] = boost::any(*split);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Split") != m.end() && !m["Split"].empty()) {
      split = make_shared<string>(boost::any_cast<string>(m["Split"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainStreamTranscodeDataRequest() = default;
};
class DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> region{};
  shared_ptr<string> resolution{};
  shared_ptr<string> tanscodeType{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData() {}

  explicit DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resolution) {
      res["Resolution"] = boost::any(*resolution);
    }
    if (tanscodeType) {
      res["TanscodeType"] = boost::any(*tanscodeType);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Resolution") != m.end() && !m["Resolution"].empty()) {
      resolution = make_shared<string>(boost::any_cast<string>(m["Resolution"]));
    }
    if (m.find("TanscodeType") != m.end() && !m["TanscodeType"].empty()) {
      tanscodeType = make_shared<string>(boost::any_cast<string>(m["TanscodeType"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData() = default;
};
class DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData>> transcodeData{};

  DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList() {}

  explicit DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeData) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeData") != m.end() && !m["TranscodeData"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeData"].type()) {
        vector<DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeData = make_shared<vector<DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList() = default;
};
class DescribeLiveDomainStreamTranscodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList> transcodeDataList{};

  DescribeLiveDomainStreamTranscodeDataResponseBody() {}

  explicit DescribeLiveDomainStreamTranscodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeDataList) {
      res["TranscodeDataList"] = transcodeDataList ? boost::any(transcodeDataList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeDataList") != m.end() && !m["TranscodeDataList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeDataList"].type()) {
        DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeDataList"]));
        transcodeDataList = make_shared<DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainStreamTranscodeDataResponseBody() = default;
};
class DescribeLiveDomainStreamTranscodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainStreamTranscodeDataResponseBody> body{};

  DescribeLiveDomainStreamTranscodeDataResponse() {}

  explicit DescribeLiveDomainStreamTranscodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainStreamTranscodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainStreamTranscodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainStreamTranscodeDataResponse() = default;
};
class DescribeLiveDomainTimeShiftDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainTimeShiftDataRequest() {}

  explicit DescribeLiveDomainTimeShiftDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainTimeShiftDataRequest() = default;
};
class DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule : public Darabonba::Model {
public:
  shared_ptr<string> size{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> type{};

  DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule() {}

  explicit DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule() = default;
};
class DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule>> dataModule{};

  DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData() {}

  explicit DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData() = default;
};
class DescribeLiveDomainTimeShiftDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData> timeShiftData{};

  DescribeLiveDomainTimeShiftDataResponseBody() {}

  explicit DescribeLiveDomainTimeShiftDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeShiftData) {
      res["TimeShiftData"] = timeShiftData ? boost::any(timeShiftData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeShiftData") != m.end() && !m["TimeShiftData"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeShiftData"].type()) {
        DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeShiftData"]));
        timeShiftData = make_shared<DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainTimeShiftDataResponseBody() = default;
};
class DescribeLiveDomainTimeShiftDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainTimeShiftDataResponseBody> body{};

  DescribeLiveDomainTimeShiftDataResponse() {}

  explicit DescribeLiveDomainTimeShiftDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainTimeShiftDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainTimeShiftDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainTimeShiftDataResponse() = default;
};
class DescribeLiveDomainTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainTrafficDataRequest() {}

  explicit DescribeLiveDomainTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainTrafficDataRequest() = default;
};
class DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> httpTrafficValue{};
  shared_ptr<string> httpsTrafficValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> trafficValue{};

  DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpTrafficValue) {
      res["HttpTrafficValue"] = boost::any(*httpTrafficValue);
    }
    if (httpsTrafficValue) {
      res["HttpsTrafficValue"] = boost::any(*httpsTrafficValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpTrafficValue") != m.end() && !m["HttpTrafficValue"].empty()) {
      httpTrafficValue = make_shared<string>(boost::any_cast<string>(m["HttpTrafficValue"]));
    }
    if (m.find("HttpsTrafficValue") != m.end() && !m["HttpsTrafficValue"].empty()) {
      httpsTrafficValue = make_shared<string>(boost::any_cast<string>(m["HttpsTrafficValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<string>(boost::any_cast<string>(m["TrafficValue"]));
    }
  }


  virtual ~DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeLiveDomainTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeLiveDomainTrafficDataResponseBody() {}

  explicit DescribeLiveDomainTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainTrafficDataResponseBody() = default;
};
class DescribeLiveDomainTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainTrafficDataResponseBody> body{};

  DescribeLiveDomainTrafficDataResponse() {}

  explicit DescribeLiveDomainTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainTrafficDataResponse() = default;
};
class DescribeLiveDomainTranscodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainTranscodeDataRequest() {}

  explicit DescribeLiveDomainTranscodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainTranscodeDataRequest() = default;
};
class DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfosTranscodeDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> detail{};
  shared_ptr<long> total{};

  DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfosTranscodeDataInfo() {}

  explicit DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfosTranscodeDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfosTranscodeDataInfo() = default;
};
class DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfosTranscodeDataInfo>> transcodeDataInfo{};

  DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfos() {}

  explicit DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeDataInfo") != m.end() && !m["TranscodeDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeDataInfo"].type()) {
        vector<DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfosTranscodeDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfosTranscodeDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeDataInfo = make_shared<vector<DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfosTranscodeDataInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfos() = default;
};
class DescribeLiveDomainTranscodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfos> transcodeDataInfos{};

  DescribeLiveDomainTranscodeDataResponseBody() {}

  explicit DescribeLiveDomainTranscodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeDataInfos) {
      res["TranscodeDataInfos"] = transcodeDataInfos ? boost::any(transcodeDataInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeDataInfos") != m.end() && !m["TranscodeDataInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeDataInfos"].type()) {
        DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeDataInfos"]));
        transcodeDataInfos = make_shared<DescribeLiveDomainTranscodeDataResponseBodyTranscodeDataInfos>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainTranscodeDataResponseBody() = default;
};
class DescribeLiveDomainTranscodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainTranscodeDataResponseBody> body{};

  DescribeLiveDomainTranscodeDataResponse() {}

  explicit DescribeLiveDomainTranscodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainTranscodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainTranscodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainTranscodeDataResponse() = default;
};
class DescribeLiveDrmUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};

  DescribeLiveDrmUsageDataRequest() {}

  explicit DescribeLiveDrmUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDrmUsageDataRequest() = default;
};
class DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> domain{};
  shared_ptr<string> drmType{};
  shared_ptr<string> region{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule() {}

  explicit DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (drmType) {
      res["DrmType"] = boost::any(*drmType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DrmType") != m.end() && !m["DrmType"].empty()) {
      drmType = make_shared<string>(boost::any_cast<string>(m["DrmType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule() = default;
};
class DescribeLiveDrmUsageDataResponseBodyDrmUsageData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule>> dataModule{};

  DescribeLiveDrmUsageDataResponseBodyDrmUsageData() {}

  explicit DescribeLiveDrmUsageDataResponseBodyDrmUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDrmUsageDataResponseBodyDrmUsageData() = default;
};
class DescribeLiveDrmUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDrmUsageDataResponseBodyDrmUsageData> drmUsageData{};
  shared_ptr<string> requestId{};

  DescribeLiveDrmUsageDataResponseBody() {}

  explicit DescribeLiveDrmUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (drmUsageData) {
      res["DrmUsageData"] = drmUsageData ? boost::any(drmUsageData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DrmUsageData") != m.end() && !m["DrmUsageData"].empty()) {
      if (typeid(map<string, boost::any>) == m["DrmUsageData"].type()) {
        DescribeLiveDrmUsageDataResponseBodyDrmUsageData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DrmUsageData"]));
        drmUsageData = make_shared<DescribeLiveDrmUsageDataResponseBodyDrmUsageData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDrmUsageDataResponseBody() = default;
};
class DescribeLiveDrmUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDrmUsageDataResponseBody> body{};

  DescribeLiveDrmUsageDataResponse() {}

  explicit DescribeLiveDrmUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDrmUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDrmUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDrmUsageDataResponse() = default;
};
class DescribeLiveEdgeTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveEdgeTransferRequest() {}

  explicit DescribeLiveEdgeTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveEdgeTransferRequest() = default;
};
class DescribeLiveEdgeTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> httpDns{};
  shared_ptr<string> requestId{};
  shared_ptr<string> streamName{};
  shared_ptr<string> targetDomainList{};
  shared_ptr<string> transferArgs{};

  DescribeLiveEdgeTransferResponseBody() {}

  explicit DescribeLiveEdgeTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (httpDns) {
      res["HttpDns"] = boost::any(*httpDns);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (targetDomainList) {
      res["TargetDomainList"] = boost::any(*targetDomainList);
    }
    if (transferArgs) {
      res["TransferArgs"] = boost::any(*transferArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("HttpDns") != m.end() && !m["HttpDns"].empty()) {
      httpDns = make_shared<string>(boost::any_cast<string>(m["HttpDns"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TargetDomainList") != m.end() && !m["TargetDomainList"].empty()) {
      targetDomainList = make_shared<string>(boost::any_cast<string>(m["TargetDomainList"]));
    }
    if (m.find("TransferArgs") != m.end() && !m["TransferArgs"].empty()) {
      transferArgs = make_shared<string>(boost::any_cast<string>(m["TransferArgs"]));
    }
  }


  virtual ~DescribeLiveEdgeTransferResponseBody() = default;
};
class DescribeLiveEdgeTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveEdgeTransferResponseBody> body{};

  DescribeLiveEdgeTransferResponse() {}

  explicit DescribeLiveEdgeTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveEdgeTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveEdgeTransferResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveEdgeTransferResponse() = default;
};
class DescribeLiveLazyPullStreamConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveLazyPullStreamConfigRequest() {}

  explicit DescribeLiveLazyPullStreamConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveLazyPullStreamConfigRequest() = default;
};
class DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> pullAppName{};
  shared_ptr<string> pullDomainName{};
  shared_ptr<string> pullProtocol{};

  DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig() {}

  explicit DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (pullAppName) {
      res["PullAppName"] = boost::any(*pullAppName);
    }
    if (pullDomainName) {
      res["PullDomainName"] = boost::any(*pullDomainName);
    }
    if (pullProtocol) {
      res["PullProtocol"] = boost::any(*pullProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("PullAppName") != m.end() && !m["PullAppName"].empty()) {
      pullAppName = make_shared<string>(boost::any_cast<string>(m["PullAppName"]));
    }
    if (m.find("PullDomainName") != m.end() && !m["PullDomainName"].empty()) {
      pullDomainName = make_shared<string>(boost::any_cast<string>(m["PullDomainName"]));
    }
    if (m.find("PullProtocol") != m.end() && !m["PullProtocol"].empty()) {
      pullProtocol = make_shared<string>(boost::any_cast<string>(m["PullProtocol"]));
    }
  }


  virtual ~DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig() = default;
};
class DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig>> liveLazyPullConfig{};

  DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList() {}

  explicit DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveLazyPullConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveLazyPullConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveLazyPullConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveLazyPullConfig") != m.end() && !m["LiveLazyPullConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveLazyPullConfig"].type()) {
        vector<DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveLazyPullConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveLazyPullConfig = make_shared<vector<DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList() = default;
};
class DescribeLiveLazyPullStreamConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList> liveLazyPullConfigList{};
  shared_ptr<string> requestId{};

  DescribeLiveLazyPullStreamConfigResponseBody() {}

  explicit DescribeLiveLazyPullStreamConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveLazyPullConfigList) {
      res["LiveLazyPullConfigList"] = liveLazyPullConfigList ? boost::any(liveLazyPullConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveLazyPullConfigList") != m.end() && !m["LiveLazyPullConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveLazyPullConfigList"].type()) {
        DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveLazyPullConfigList"]));
        liveLazyPullConfigList = make_shared<DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveLazyPullStreamConfigResponseBody() = default;
};
class DescribeLiveLazyPullStreamConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveLazyPullStreamConfigResponseBody> body{};

  DescribeLiveLazyPullStreamConfigResponse() {}

  explicit DescribeLiveLazyPullStreamConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveLazyPullStreamConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveLazyPullStreamConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveLazyPullStreamConfigResponse() = default;
};
class DescribeLiveProducerUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instance{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};
  shared_ptr<string> app{};

  DescribeLiveProducerUsageDataRequest() {}

  explicit DescribeLiveProducerUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (app) {
      res["app"] = boost::any(*app);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("app") != m.end() && !m["app"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["app"]));
    }
  }


  virtual ~DescribeLiveProducerUsageDataRequest() = default;
};
class DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> instance{};
  shared_ptr<long> outputHdDuration{};
  shared_ptr<long> outputLdDuration{};
  shared_ptr<long> outputSdDuration{};
  shared_ptr<string> region{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> tranHdDuration{};
  shared_ptr<long> tranLdDuration{};
  shared_ptr<long> tranSdDuration{};
  shared_ptr<string> type{};

  DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem() {}

  explicit DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (outputHdDuration) {
      res["OutputHdDuration"] = boost::any(*outputHdDuration);
    }
    if (outputLdDuration) {
      res["OutputLdDuration"] = boost::any(*outputLdDuration);
    }
    if (outputSdDuration) {
      res["OutputSdDuration"] = boost::any(*outputSdDuration);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (tranHdDuration) {
      res["TranHdDuration"] = boost::any(*tranHdDuration);
    }
    if (tranLdDuration) {
      res["TranLdDuration"] = boost::any(*tranLdDuration);
    }
    if (tranSdDuration) {
      res["TranSdDuration"] = boost::any(*tranSdDuration);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("OutputHdDuration") != m.end() && !m["OutputHdDuration"].empty()) {
      outputHdDuration = make_shared<long>(boost::any_cast<long>(m["OutputHdDuration"]));
    }
    if (m.find("OutputLdDuration") != m.end() && !m["OutputLdDuration"].empty()) {
      outputLdDuration = make_shared<long>(boost::any_cast<long>(m["OutputLdDuration"]));
    }
    if (m.find("OutputSdDuration") != m.end() && !m["OutputSdDuration"].empty()) {
      outputSdDuration = make_shared<long>(boost::any_cast<long>(m["OutputSdDuration"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TranHdDuration") != m.end() && !m["TranHdDuration"].empty()) {
      tranHdDuration = make_shared<long>(boost::any_cast<long>(m["TranHdDuration"]));
    }
    if (m.find("TranLdDuration") != m.end() && !m["TranLdDuration"].empty()) {
      tranLdDuration = make_shared<long>(boost::any_cast<long>(m["TranLdDuration"]));
    }
    if (m.find("TranSdDuration") != m.end() && !m["TranSdDuration"].empty()) {
      tranSdDuration = make_shared<long>(boost::any_cast<long>(m["TranSdDuration"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem() = default;
};
class DescribeLiveProducerUsageDataResponseBodyBillProducerData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem>> billProducerDataItem{};

  DescribeLiveProducerUsageDataResponseBodyBillProducerData() {}

  explicit DescribeLiveProducerUsageDataResponseBodyBillProducerData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billProducerDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billProducerDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillProducerDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillProducerDataItem") != m.end() && !m["BillProducerDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillProducerDataItem"].type()) {
        vector<DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillProducerDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billProducerDataItem = make_shared<vector<DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveProducerUsageDataResponseBodyBillProducerData() = default;
};
class DescribeLiveProducerUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveProducerUsageDataResponseBodyBillProducerData> billProducerData{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveProducerUsageDataResponseBody() {}

  explicit DescribeLiveProducerUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billProducerData) {
      res["BillProducerData"] = billProducerData ? boost::any(billProducerData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillProducerData") != m.end() && !m["BillProducerData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillProducerData"].type()) {
        DescribeLiveProducerUsageDataResponseBodyBillProducerData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillProducerData"]));
        billProducerData = make_shared<DescribeLiveProducerUsageDataResponseBodyBillProducerData>(model1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveProducerUsageDataResponseBody() = default;
};
class DescribeLiveProducerUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveProducerUsageDataResponseBody> body{};

  DescribeLiveProducerUsageDataResponse() {}

  explicit DescribeLiveProducerUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveProducerUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveProducerUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveProducerUsageDataResponse() = default;
};
class DescribeLivePullStreamConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLivePullStreamConfigRequest() {}

  explicit DescribeLivePullStreamConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLivePullStreamConfigRequest() = default;
};
class DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> sourceUsing{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord() {}

  explicit DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (sourceUsing) {
      res["SourceUsing"] = boost::any(*sourceUsing);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("SourceUsing") != m.end() && !m["SourceUsing"].empty()) {
      sourceUsing = make_shared<string>(boost::any_cast<string>(m["SourceUsing"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord() = default;
};
class DescribeLivePullStreamConfigResponseBodyLiveAppRecordList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord>> liveAppRecord{};

  DescribeLivePullStreamConfigResponseBodyLiveAppRecordList() {}

  explicit DescribeLivePullStreamConfigResponseBodyLiveAppRecordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAppRecord) {
      vector<boost::any> temp1;
      for(auto item1:*liveAppRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveAppRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAppRecord") != m.end() && !m["LiveAppRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveAppRecord"].type()) {
        vector<DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveAppRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveAppRecord = make_shared<vector<DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord>>(expect1);
      }
    }
  }


  virtual ~DescribeLivePullStreamConfigResponseBodyLiveAppRecordList() = default;
};
class DescribeLivePullStreamConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLivePullStreamConfigResponseBodyLiveAppRecordList> liveAppRecordList{};
  shared_ptr<string> requestId{};

  DescribeLivePullStreamConfigResponseBody() {}

  explicit DescribeLivePullStreamConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAppRecordList) {
      res["LiveAppRecordList"] = liveAppRecordList ? boost::any(liveAppRecordList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAppRecordList") != m.end() && !m["LiveAppRecordList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveAppRecordList"].type()) {
        DescribeLivePullStreamConfigResponseBodyLiveAppRecordList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveAppRecordList"]));
        liveAppRecordList = make_shared<DescribeLivePullStreamConfigResponseBodyLiveAppRecordList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLivePullStreamConfigResponseBody() = default;
};
class DescribeLivePullStreamConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLivePullStreamConfigResponseBody> body{};

  DescribeLivePullStreamConfigResponse() {}

  explicit DescribeLivePullStreamConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLivePullStreamConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLivePullStreamConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLivePullStreamConfigResponse() = default;
};
class DescribeLiveRealtimeDeliveryAccRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> logStore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> startTime{};

  DescribeLiveRealtimeDeliveryAccRequest() {}

  explicit DescribeLiveRealtimeDeliveryAccRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (logStore) {
      res["LogStore"] = boost::any(*logStore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("LogStore") != m.end() && !m["LogStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["LogStore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveRealtimeDeliveryAccRequest() = default;
};
class DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData : public Darabonba::Model {
public:
  shared_ptr<long> failedNum{};
  shared_ptr<long> successNum{};
  shared_ptr<string> timeStamp{};

  DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData() {}

  explicit DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedNum) {
      res["FailedNum"] = boost::any(*failedNum);
    }
    if (successNum) {
      res["SuccessNum"] = boost::any(*successNum);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedNum") != m.end() && !m["FailedNum"].empty()) {
      failedNum = make_shared<long>(boost::any_cast<long>(m["FailedNum"]));
    }
    if (m.find("SuccessNum") != m.end() && !m["SuccessNum"].empty()) {
      successNum = make_shared<long>(boost::any_cast<long>(m["SuccessNum"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData() = default;
};
class DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData>> accData{};

  DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData() {}

  explicit DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accData) {
      vector<boost::any> temp1;
      for(auto item1:*accData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccData") != m.end() && !m["AccData"].empty()) {
      if (typeid(vector<boost::any>) == m["AccData"].type()) {
        vector<DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accData = make_shared<vector<DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData() = default;
};
class DescribeLiveRealtimeDeliveryAccResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData> realTimeDeliveryAccData{};
  shared_ptr<string> requestId{};

  DescribeLiveRealtimeDeliveryAccResponseBody() {}

  explicit DescribeLiveRealtimeDeliveryAccResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeDeliveryAccData) {
      res["RealTimeDeliveryAccData"] = realTimeDeliveryAccData ? boost::any(realTimeDeliveryAccData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeDeliveryAccData") != m.end() && !m["RealTimeDeliveryAccData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeDeliveryAccData"].type()) {
        DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeDeliveryAccData"]));
        realTimeDeliveryAccData = make_shared<DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveRealtimeDeliveryAccResponseBody() = default;
};
class DescribeLiveRealtimeDeliveryAccResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveRealtimeDeliveryAccResponseBody> body{};

  DescribeLiveRealtimeDeliveryAccResponse() {}

  explicit DescribeLiveRealtimeDeliveryAccResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveRealtimeDeliveryAccResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveRealtimeDeliveryAccResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveRealtimeDeliveryAccResponse() = default;
};
class DescribeLiveRealtimeLogAuthorizedRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveOpenapiReserve{};
  shared_ptr<long> ownerId{};

  DescribeLiveRealtimeLogAuthorizedRequest() {}

  explicit DescribeLiveRealtimeLogAuthorizedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveOpenapiReserve) {
      res["LiveOpenapiReserve"] = boost::any(*liveOpenapiReserve);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveOpenapiReserve") != m.end() && !m["LiveOpenapiReserve"].empty()) {
      liveOpenapiReserve = make_shared<string>(boost::any_cast<string>(m["LiveOpenapiReserve"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveRealtimeLogAuthorizedRequest() = default;
};
class DescribeLiveRealtimeLogAuthorizedResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> authorizedStatus{};
  shared_ptr<string> requestId{};

  DescribeLiveRealtimeLogAuthorizedResponseBody() {}

  explicit DescribeLiveRealtimeLogAuthorizedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedStatus) {
      res["AuthorizedStatus"] = boost::any(*authorizedStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedStatus") != m.end() && !m["AuthorizedStatus"].empty()) {
      authorizedStatus = make_shared<string>(boost::any_cast<string>(m["AuthorizedStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveRealtimeLogAuthorizedResponseBody() = default;
};
class DescribeLiveRealtimeLogAuthorizedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveRealtimeLogAuthorizedResponseBody> body{};

  DescribeLiveRealtimeLogAuthorizedResponse() {}

  explicit DescribeLiveRealtimeLogAuthorizedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveRealtimeLogAuthorizedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveRealtimeLogAuthorizedResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveRealtimeLogAuthorizedResponse() = default;
};
class DescribeLiveRecordConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> streamName{};

  DescribeLiveRecordConfigRequest() {}

  explicit DescribeLiveRecordConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveRecordConfigRequest() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat>> recordFormat{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat>> recordFormat{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<string>> templates{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templates) {
      res["Templates"] = boost::any(*templates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Templates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Templates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      templates = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> onDemond{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList> recordFormatList{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList> transcodeRecordFormatList{};
  shared_ptr<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates> transcodeTemplates{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (onDemond) {
      res["OnDemond"] = boost::any(*onDemond);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (recordFormatList) {
      res["RecordFormatList"] = recordFormatList ? boost::any(recordFormatList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transcodeRecordFormatList) {
      res["TranscodeRecordFormatList"] = transcodeRecordFormatList ? boost::any(transcodeRecordFormatList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transcodeTemplates) {
      res["TranscodeTemplates"] = transcodeTemplates ? boost::any(transcodeTemplates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OnDemond") != m.end() && !m["OnDemond"].empty()) {
      onDemond = make_shared<long>(boost::any_cast<long>(m["OnDemond"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("RecordFormatList") != m.end() && !m["RecordFormatList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordFormatList"].type()) {
        DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordFormatList"]));
        recordFormatList = make_shared<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TranscodeRecordFormatList") != m.end() && !m["TranscodeRecordFormatList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeRecordFormatList"].type()) {
        DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeRecordFormatList"]));
        transcodeRecordFormatList = make_shared<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList>(model1);
      }
    }
    if (m.find("TranscodeTemplates") != m.end() && !m["TranscodeTemplates"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeTemplates"].type()) {
        DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeTemplates"]));
        transcodeTemplates = make_shared<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates>(model1);
      }
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord>> liveAppRecord{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordList() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAppRecord) {
      vector<boost::any> temp1;
      for(auto item1:*liveAppRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveAppRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAppRecord") != m.end() && !m["LiveAppRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveAppRecord"].type()) {
        vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveAppRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveAppRecord = make_shared<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordList() = default;
};
class DescribeLiveRecordConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveRecordConfigResponseBodyLiveAppRecordList> liveAppRecordList{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveRecordConfigResponseBody() {}

  explicit DescribeLiveRecordConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAppRecordList) {
      res["LiveAppRecordList"] = liveAppRecordList ? boost::any(liveAppRecordList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAppRecordList") != m.end() && !m["LiveAppRecordList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveAppRecordList"].type()) {
        DescribeLiveRecordConfigResponseBodyLiveAppRecordList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveAppRecordList"]));
        liveAppRecordList = make_shared<DescribeLiveRecordConfigResponseBodyLiveAppRecordList>(model1);
      }
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBody() = default;
};
class DescribeLiveRecordConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveRecordConfigResponseBody> body{};

  DescribeLiveRecordConfigResponse() {}

  explicit DescribeLiveRecordConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveRecordConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveRecordConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveRecordConfigResponse() = default;
};
class DescribeLiveRecordNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveRecordNotifyConfigRequest() {}

  explicit DescribeLiveRecordNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveRecordNotifyConfigRequest() = default;
};
class DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<bool> needStatusNotify{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> onDemandUrl{};

  DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig() {}

  explicit DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (needStatusNotify) {
      res["NeedStatusNotify"] = boost::any(*needStatusNotify);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (onDemandUrl) {
      res["OnDemandUrl"] = boost::any(*onDemandUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NeedStatusNotify") != m.end() && !m["NeedStatusNotify"].empty()) {
      needStatusNotify = make_shared<bool>(boost::any_cast<bool>(m["NeedStatusNotify"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OnDemandUrl") != m.end() && !m["OnDemandUrl"].empty()) {
      onDemandUrl = make_shared<string>(boost::any_cast<string>(m["OnDemandUrl"]));
    }
  }


  virtual ~DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig() = default;
};
class DescribeLiveRecordNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig> liveRecordNotifyConfig{};
  shared_ptr<string> requestId{};

  DescribeLiveRecordNotifyConfigResponseBody() {}

  explicit DescribeLiveRecordNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveRecordNotifyConfig) {
      res["LiveRecordNotifyConfig"] = liveRecordNotifyConfig ? boost::any(liveRecordNotifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveRecordNotifyConfig") != m.end() && !m["LiveRecordNotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveRecordNotifyConfig"].type()) {
        DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveRecordNotifyConfig"]));
        liveRecordNotifyConfig = make_shared<DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveRecordNotifyConfigResponseBody() = default;
};
class DescribeLiveRecordNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveRecordNotifyConfigResponseBody> body{};

  DescribeLiveRecordNotifyConfigResponse() {}

  explicit DescribeLiveRecordNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveRecordNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveRecordNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveRecordNotifyConfigResponse() = default;
};
class DescribeLiveRecordVodConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> streamName{};

  DescribeLiveRecordVodConfigsRequest() {}

  explicit DescribeLiveRecordVodConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveRecordVodConfigsRequest() = default;
};
class DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> autoCompose{};
  shared_ptr<string> composeVodTranscodeGroupId{};
  shared_ptr<string> createTime{};
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> domainName{};
  shared_ptr<string> streamName{};
  shared_ptr<string> vodTranscodeGroupId{};

  DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig() {}

  explicit DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (autoCompose) {
      res["AutoCompose"] = boost::any(*autoCompose);
    }
    if (composeVodTranscodeGroupId) {
      res["ComposeVodTranscodeGroupId"] = boost::any(*composeVodTranscodeGroupId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (vodTranscodeGroupId) {
      res["VodTranscodeGroupId"] = boost::any(*vodTranscodeGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AutoCompose") != m.end() && !m["AutoCompose"].empty()) {
      autoCompose = make_shared<string>(boost::any_cast<string>(m["AutoCompose"]));
    }
    if (m.find("ComposeVodTranscodeGroupId") != m.end() && !m["ComposeVodTranscodeGroupId"].empty()) {
      composeVodTranscodeGroupId = make_shared<string>(boost::any_cast<string>(m["ComposeVodTranscodeGroupId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("VodTranscodeGroupId") != m.end() && !m["VodTranscodeGroupId"].empty()) {
      vodTranscodeGroupId = make_shared<string>(boost::any_cast<string>(m["VodTranscodeGroupId"]));
    }
  }


  virtual ~DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig() = default;
};
class DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig>> liveRecordVodConfig{};

  DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs() {}

  explicit DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveRecordVodConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveRecordVodConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveRecordVodConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveRecordVodConfig") != m.end() && !m["LiveRecordVodConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveRecordVodConfig"].type()) {
        vector<DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveRecordVodConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveRecordVodConfig = make_shared<vector<DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs() = default;
};
class DescribeLiveRecordVodConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs> liveRecordVodConfigs{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> total{};

  DescribeLiveRecordVodConfigsResponseBody() {}

  explicit DescribeLiveRecordVodConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveRecordVodConfigs) {
      res["LiveRecordVodConfigs"] = liveRecordVodConfigs ? boost::any(liveRecordVodConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveRecordVodConfigs") != m.end() && !m["LiveRecordVodConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveRecordVodConfigs"].type()) {
        DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveRecordVodConfigs"]));
        liveRecordVodConfigs = make_shared<DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs>(model1);
      }
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["Total"]));
    }
  }


  virtual ~DescribeLiveRecordVodConfigsResponseBody() = default;
};
class DescribeLiveRecordVodConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveRecordVodConfigsResponseBody> body{};

  DescribeLiveRecordVodConfigsResponse() {}

  explicit DescribeLiveRecordVodConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveRecordVodConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveRecordVodConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveRecordVodConfigsResponse() = default;
};
class DescribeLiveShiftConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveShiftConfigsRequest() {}

  explicit DescribeLiveShiftConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveShiftConfigsRequest() = default;
};
class DescribeLiveShiftConfigsResponseBodyContentConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<bool> ignoreTranscode{};
  shared_ptr<string> streamName{};
  shared_ptr<long> vision{};

  DescribeLiveShiftConfigsResponseBodyContentConfig() {}

  explicit DescribeLiveShiftConfigsResponseBodyContentConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ignoreTranscode) {
      res["IgnoreTranscode"] = boost::any(*ignoreTranscode);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (vision) {
      res["Vision"] = boost::any(*vision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IgnoreTranscode") != m.end() && !m["IgnoreTranscode"].empty()) {
      ignoreTranscode = make_shared<bool>(boost::any_cast<bool>(m["IgnoreTranscode"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Vision") != m.end() && !m["Vision"].empty()) {
      vision = make_shared<long>(boost::any_cast<long>(m["Vision"]));
    }
  }


  virtual ~DescribeLiveShiftConfigsResponseBodyContentConfig() = default;
};
class DescribeLiveShiftConfigsResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveShiftConfigsResponseBodyContentConfig>> config{};

  DescribeLiveShiftConfigsResponseBodyContent() {}

  explicit DescribeLiveShiftConfigsResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<DescribeLiveShiftConfigsResponseBodyContentConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveShiftConfigsResponseBodyContentConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<DescribeLiveShiftConfigsResponseBodyContentConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveShiftConfigsResponseBodyContent() = default;
};
class DescribeLiveShiftConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveShiftConfigsResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  DescribeLiveShiftConfigsResponseBody() {}

  explicit DescribeLiveShiftConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        DescribeLiveShiftConfigsResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<DescribeLiveShiftConfigsResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveShiftConfigsResponseBody() = default;
};
class DescribeLiveShiftConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveShiftConfigsResponseBody> body{};

  DescribeLiveShiftConfigsResponse() {}

  explicit DescribeLiveShiftConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveShiftConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveShiftConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveShiftConfigsResponse() = default;
};
class DescribeLiveSnapshotConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeLiveSnapshotConfigRequest() {}

  explicit DescribeLiveSnapshotConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveSnapshotConfigRequest() = default;
};
class DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> callback{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> overwriteOssObject{};
  shared_ptr<string> sequenceOssObject{};
  shared_ptr<long> timeInterval{};

  DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig() {}

  explicit DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (overwriteOssObject) {
      res["OverwriteOssObject"] = boost::any(*overwriteOssObject);
    }
    if (sequenceOssObject) {
      res["SequenceOssObject"] = boost::any(*sequenceOssObject);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OverwriteOssObject") != m.end() && !m["OverwriteOssObject"].empty()) {
      overwriteOssObject = make_shared<string>(boost::any_cast<string>(m["OverwriteOssObject"]));
    }
    if (m.find("SequenceOssObject") != m.end() && !m["SequenceOssObject"].empty()) {
      sequenceOssObject = make_shared<string>(boost::any_cast<string>(m["SequenceOssObject"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig() = default;
};
class DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig>> liveStreamSnapshotConfig{};

  DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList() {}

  explicit DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamSnapshotConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamSnapshotConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamSnapshotConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamSnapshotConfig") != m.end() && !m["LiveStreamSnapshotConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamSnapshotConfig"].type()) {
        vector<DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamSnapshotConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamSnapshotConfig = make_shared<vector<DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList() = default;
};
class DescribeLiveSnapshotConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList> liveStreamSnapshotConfigList{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveSnapshotConfigResponseBody() {}

  explicit DescribeLiveSnapshotConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamSnapshotConfigList) {
      res["LiveStreamSnapshotConfigList"] = liveStreamSnapshotConfigList ? boost::any(liveStreamSnapshotConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamSnapshotConfigList") != m.end() && !m["LiveStreamSnapshotConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamSnapshotConfigList"].type()) {
        DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamSnapshotConfigList"]));
        liveStreamSnapshotConfigList = make_shared<DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList>(model1);
      }
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveSnapshotConfigResponseBody() = default;
};
class DescribeLiveSnapshotConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveSnapshotConfigResponseBody> body{};

  DescribeLiveSnapshotConfigResponse() {}

  explicit DescribeLiveSnapshotConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveSnapshotConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveSnapshotConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotConfigResponse() = default;
};
class DescribeLiveSnapshotDetectPornConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeLiveSnapshotDetectPornConfigRequest() {}

  explicit DescribeLiveSnapshotDetectPornConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigRequest() = default;
};
class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> scene{};

  DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes() {}

  explicit DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["scene"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["scene"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scene = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes() = default;
};
class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> interval{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes> scenes{};

  DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig() {}

  explicit DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (scenes) {
      res["Scenes"] = scenes ? boost::any(scenes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("Scenes") != m.end() && !m["Scenes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scenes"].type()) {
        DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scenes"]));
        scenes = make_shared<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes>(model1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig() = default;
};
class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig>> liveSnapshotDetectPornConfig{};

  DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList() {}

  explicit DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveSnapshotDetectPornConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveSnapshotDetectPornConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveSnapshotDetectPornConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveSnapshotDetectPornConfig") != m.end() && !m["LiveSnapshotDetectPornConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveSnapshotDetectPornConfig"].type()) {
        vector<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveSnapshotDetectPornConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveSnapshotDetectPornConfig = make_shared<vector<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList() = default;
};
class DescribeLiveSnapshotDetectPornConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList> liveSnapshotDetectPornConfigList{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveSnapshotDetectPornConfigResponseBody() {}

  explicit DescribeLiveSnapshotDetectPornConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveSnapshotDetectPornConfigList) {
      res["LiveSnapshotDetectPornConfigList"] = liveSnapshotDetectPornConfigList ? boost::any(liveSnapshotDetectPornConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveSnapshotDetectPornConfigList") != m.end() && !m["LiveSnapshotDetectPornConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveSnapshotDetectPornConfigList"].type()) {
        DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveSnapshotDetectPornConfigList"]));
        liveSnapshotDetectPornConfigList = make_shared<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList>(model1);
      }
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigResponseBody() = default;
};
class DescribeLiveSnapshotDetectPornConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveSnapshotDetectPornConfigResponseBody> body{};

  DescribeLiveSnapshotDetectPornConfigResponse() {}

  explicit DescribeLiveSnapshotDetectPornConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveSnapshotDetectPornConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveSnapshotDetectPornConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigResponse() = default;
};
class DescribeLiveSnapshotNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveSnapshotNotifyConfigRequest() {}

  explicit DescribeLiveSnapshotNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveSnapshotNotifyConfigRequest() = default;
};
class DescribeLiveSnapshotNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyAuthKey{};
  shared_ptr<string> notifyReqAuth{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> requestId{};

  DescribeLiveSnapshotNotifyConfigResponseBody() {}

  explicit DescribeLiveSnapshotNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyAuthKey) {
      res["NotifyAuthKey"] = boost::any(*notifyAuthKey);
    }
    if (notifyReqAuth) {
      res["NotifyReqAuth"] = boost::any(*notifyReqAuth);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyAuthKey") != m.end() && !m["NotifyAuthKey"].empty()) {
      notifyAuthKey = make_shared<string>(boost::any_cast<string>(m["NotifyAuthKey"]));
    }
    if (m.find("NotifyReqAuth") != m.end() && !m["NotifyReqAuth"].empty()) {
      notifyReqAuth = make_shared<string>(boost::any_cast<string>(m["NotifyReqAuth"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveSnapshotNotifyConfigResponseBody() = default;
};
class DescribeLiveSnapshotNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveSnapshotNotifyConfigResponseBody> body{};

  DescribeLiveSnapshotNotifyConfigResponse() {}

  explicit DescribeLiveSnapshotNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveSnapshotNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveSnapshotNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotNotifyConfigResponse() = default;
};
class DescribeLiveStreamAuthCheckingRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> url{};

  DescribeLiveStreamAuthCheckingRequest() {}

  explicit DescribeLiveStreamAuthCheckingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeLiveStreamAuthCheckingRequest() = default;
};
class DescribeLiveStreamAuthCheckingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeLiveStreamAuthCheckingResponseBody() {}

  explicit DescribeLiveStreamAuthCheckingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeLiveStreamAuthCheckingResponseBody() = default;
};
class DescribeLiveStreamAuthCheckingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamAuthCheckingResponseBody> body{};

  DescribeLiveStreamAuthCheckingResponse() {}

  explicit DescribeLiveStreamAuthCheckingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamAuthCheckingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamAuthCheckingResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamAuthCheckingResponse() = default;
};
class DescribeLiveStreamBitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamBitRateDataRequest() {}

  explicit DescribeLiveStreamBitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamBitRateDataRequest() = default;
};
class DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo : public Darabonba::Model {
public:
  shared_ptr<double> audioFrameRate{};
  shared_ptr<double> bitRate{};
  shared_ptr<string> streamUrl{};
  shared_ptr<string> time{};
  shared_ptr<double> videoFrameRate{};

  DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo() {}

  explicit DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFrameRate) {
      res["AudioFrameRate"] = boost::any(*audioFrameRate);
    }
    if (bitRate) {
      res["BitRate"] = boost::any(*bitRate);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (videoFrameRate) {
      res["VideoFrameRate"] = boost::any(*videoFrameRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFrameRate") != m.end() && !m["AudioFrameRate"].empty()) {
      audioFrameRate = make_shared<double>(boost::any_cast<double>(m["AudioFrameRate"]));
    }
    if (m.find("BitRate") != m.end() && !m["BitRate"].empty()) {
      bitRate = make_shared<double>(boost::any_cast<double>(m["BitRate"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("VideoFrameRate") != m.end() && !m["VideoFrameRate"].empty()) {
      videoFrameRate = make_shared<double>(boost::any_cast<double>(m["VideoFrameRate"]));
    }
  }


  virtual ~DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo() = default;
};
class DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo>> frameRateAndBitRateInfo{};

  DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos() {}

  explicit DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameRateAndBitRateInfo) {
      vector<boost::any> temp1;
      for(auto item1:*frameRateAndBitRateInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrameRateAndBitRateInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameRateAndBitRateInfo") != m.end() && !m["FrameRateAndBitRateInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["FrameRateAndBitRateInfo"].type()) {
        vector<DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrameRateAndBitRateInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frameRateAndBitRateInfo = make_shared<vector<DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos() = default;
};
class DescribeLiveStreamBitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos> frameRateAndBitRateInfos{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamBitRateDataResponseBody() {}

  explicit DescribeLiveStreamBitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameRateAndBitRateInfos) {
      res["FrameRateAndBitRateInfos"] = frameRateAndBitRateInfos ? boost::any(frameRateAndBitRateInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameRateAndBitRateInfos") != m.end() && !m["FrameRateAndBitRateInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["FrameRateAndBitRateInfos"].type()) {
        DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FrameRateAndBitRateInfos"]));
        frameRateAndBitRateInfos = make_shared<DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamBitRateDataResponseBody() = default;
};
class DescribeLiveStreamBitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamBitRateDataResponseBody> body{};

  DescribeLiveStreamBitRateDataResponse() {}

  explicit DescribeLiveStreamBitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamBitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamBitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamBitRateDataResponse() = default;
};
class DescribeLiveStreamCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveStreamCountRequest() {}

  explicit DescribeLiveStreamCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveStreamCountRequest() = default;
};
class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> format{};
  shared_ptr<long> videoDataRate{};

  DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail() {}

  explicit DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (videoDataRate) {
      res["VideoDataRate"] = boost::any(*videoDataRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("VideoDataRate") != m.end() && !m["VideoDataRate"].empty()) {
      videoDataRate = make_shared<long>(boost::any_cast<long>(m["VideoDataRate"]));
    }
  }


  virtual ~DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail() = default;
};
class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail>> streamCountDetail{};

  DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails() {}

  explicit DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamCountDetail) {
      vector<boost::any> temp1;
      for(auto item1:*streamCountDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamCountDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamCountDetail") != m.end() && !m["StreamCountDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamCountDetail"].type()) {
        vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamCountDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamCountDetail = make_shared<vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails() = default;
};
class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> limit{};
  shared_ptr<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails> streamCountDetails{};
  shared_ptr<string> type{};

  DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo() {}

  explicit DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (streamCountDetails) {
      res["StreamCountDetails"] = streamCountDetails ? boost::any(streamCountDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("StreamCountDetails") != m.end() && !m["StreamCountDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamCountDetails"].type()) {
        DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamCountDetails"]));
        streamCountDetails = make_shared<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo() = default;
};
class DescribeLiveStreamCountResponseBodyStreamCountInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo>> streamCountInfo{};

  DescribeLiveStreamCountResponseBodyStreamCountInfos() {}

  explicit DescribeLiveStreamCountResponseBodyStreamCountInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamCountInfo) {
      vector<boost::any> temp1;
      for(auto item1:*streamCountInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamCountInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamCountInfo") != m.end() && !m["StreamCountInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamCountInfo"].type()) {
        vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamCountInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamCountInfo = make_shared<vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamCountResponseBodyStreamCountInfos() = default;
};
class DescribeLiveStreamCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveStreamCountResponseBodyStreamCountInfos> streamCountInfos{};

  DescribeLiveStreamCountResponseBody() {}

  explicit DescribeLiveStreamCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamCountInfos) {
      res["StreamCountInfos"] = streamCountInfos ? boost::any(streamCountInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamCountInfos") != m.end() && !m["StreamCountInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamCountInfos"].type()) {
        DescribeLiveStreamCountResponseBodyStreamCountInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamCountInfos"]));
        streamCountInfos = make_shared<DescribeLiveStreamCountResponseBodyStreamCountInfos>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamCountResponseBody() = default;
};
class DescribeLiveStreamCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamCountResponseBody> body{};

  DescribeLiveStreamCountResponse() {}

  explicit DescribeLiveStreamCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamCountResponse() = default;
};
class DescribeLiveStreamDelayConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveStreamDelayConfigRequest() {}

  explicit DescribeLiveStreamDelayConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveStreamDelayConfigRequest() = default;
};
class DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig : public Darabonba::Model {
public:
  shared_ptr<long> delay{};
  shared_ptr<string> level{};

  DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig() {}

  explicit DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig() = default;
};
class DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig : public Darabonba::Model {
public:
  shared_ptr<long> delay{};
  shared_ptr<string> level{};

  DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig() {}

  explicit DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig() = default;
};
class DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig : public Darabonba::Model {
public:
  shared_ptr<long> delay{};
  shared_ptr<string> level{};

  DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig() {}

  explicit DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig() = default;
};
class DescribeLiveStreamDelayConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig> liveStreamFlvDelayConfig{};
  shared_ptr<DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig> liveStreamHlsDelayConfig{};
  shared_ptr<DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig> liveStreamRtmpDelayConfig{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamDelayConfigResponseBody() {}

  explicit DescribeLiveStreamDelayConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamFlvDelayConfig) {
      res["LiveStreamFlvDelayConfig"] = liveStreamFlvDelayConfig ? boost::any(liveStreamFlvDelayConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (liveStreamHlsDelayConfig) {
      res["LiveStreamHlsDelayConfig"] = liveStreamHlsDelayConfig ? boost::any(liveStreamHlsDelayConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (liveStreamRtmpDelayConfig) {
      res["LiveStreamRtmpDelayConfig"] = liveStreamRtmpDelayConfig ? boost::any(liveStreamRtmpDelayConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamFlvDelayConfig") != m.end() && !m["LiveStreamFlvDelayConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamFlvDelayConfig"].type()) {
        DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamFlvDelayConfig"]));
        liveStreamFlvDelayConfig = make_shared<DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig>(model1);
      }
    }
    if (m.find("LiveStreamHlsDelayConfig") != m.end() && !m["LiveStreamHlsDelayConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamHlsDelayConfig"].type()) {
        DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamHlsDelayConfig"]));
        liveStreamHlsDelayConfig = make_shared<DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig>(model1);
      }
    }
    if (m.find("LiveStreamRtmpDelayConfig") != m.end() && !m["LiveStreamRtmpDelayConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamRtmpDelayConfig"].type()) {
        DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamRtmpDelayConfig"]));
        liveStreamRtmpDelayConfig = make_shared<DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamDelayConfigResponseBody() = default;
};
class DescribeLiveStreamDelayConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamDelayConfigResponseBody> body{};

  DescribeLiveStreamDelayConfigResponse() {}

  explicit DescribeLiveStreamDelayConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamDelayConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamDelayConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamDelayConfigResponse() = default;
};
class DescribeLiveStreamHistoryUserNumRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamHistoryUserNumRequest() {}

  explicit DescribeLiveStreamHistoryUserNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamHistoryUserNumRequest() = default;
};
class DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo : public Darabonba::Model {
public:
  shared_ptr<string> streamTime{};
  shared_ptr<string> userNum{};

  DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo() {}

  explicit DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamTime) {
      res["StreamTime"] = boost::any(*streamTime);
    }
    if (userNum) {
      res["UserNum"] = boost::any(*userNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamTime") != m.end() && !m["StreamTime"].empty()) {
      streamTime = make_shared<string>(boost::any_cast<string>(m["StreamTime"]));
    }
    if (m.find("UserNum") != m.end() && !m["UserNum"].empty()) {
      userNum = make_shared<string>(boost::any_cast<string>(m["UserNum"]));
    }
  }


  virtual ~DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo() = default;
};
class DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo>> liveStreamUserNumInfo{};

  DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos() {}

  explicit DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamUserNumInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamUserNumInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamUserNumInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamUserNumInfo") != m.end() && !m["LiveStreamUserNumInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamUserNumInfo"].type()) {
        vector<DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamUserNumInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamUserNumInfo = make_shared<vector<DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos() = default;
};
class DescribeLiveStreamHistoryUserNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos> liveStreamUserNumInfos{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamHistoryUserNumResponseBody() {}

  explicit DescribeLiveStreamHistoryUserNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamUserNumInfos) {
      res["LiveStreamUserNumInfos"] = liveStreamUserNumInfos ? boost::any(liveStreamUserNumInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamUserNumInfos") != m.end() && !m["LiveStreamUserNumInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamUserNumInfos"].type()) {
        DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamUserNumInfos"]));
        liveStreamUserNumInfos = make_shared<DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamHistoryUserNumResponseBody() = default;
};
class DescribeLiveStreamHistoryUserNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamHistoryUserNumResponseBody> body{};

  DescribeLiveStreamHistoryUserNumResponse() {}

  explicit DescribeLiveStreamHistoryUserNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamHistoryUserNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamHistoryUserNumResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamHistoryUserNumResponse() = default;
};
class DescribeLiveStreamMetricDetailDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamMetricDetailDataRequest() {}

  explicit DescribeLiveStreamMetricDetailDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamMetricDetailDataRequest() = default;
};
class DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<double> bps{};
  shared_ptr<long> count{};
  shared_ptr<double> flvBps{};
  shared_ptr<long> flvCount{};
  shared_ptr<long> flvTraffic{};
  shared_ptr<double> hlsBps{};
  shared_ptr<long> hlsCount{};
  shared_ptr<long> hlsTraffic{};
  shared_ptr<double> p2pBps{};
  shared_ptr<long> p2pCount{};
  shared_ptr<long> p2pTraffic{};
  shared_ptr<double> rtmpBps{};
  shared_ptr<long> rtmpCount{};
  shared_ptr<long> rtmpTraffic{};
  shared_ptr<double> rtsBps{};
  shared_ptr<long> rtsCount{};
  shared_ptr<long> rtsTraffic{};
  shared_ptr<string> streamName{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> traffic{};

  DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData() {}

  explicit DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (flvBps) {
      res["FlvBps"] = boost::any(*flvBps);
    }
    if (flvCount) {
      res["FlvCount"] = boost::any(*flvCount);
    }
    if (flvTraffic) {
      res["FlvTraffic"] = boost::any(*flvTraffic);
    }
    if (hlsBps) {
      res["HlsBps"] = boost::any(*hlsBps);
    }
    if (hlsCount) {
      res["HlsCount"] = boost::any(*hlsCount);
    }
    if (hlsTraffic) {
      res["HlsTraffic"] = boost::any(*hlsTraffic);
    }
    if (p2pBps) {
      res["P2pBps"] = boost::any(*p2pBps);
    }
    if (p2pCount) {
      res["P2pCount"] = boost::any(*p2pCount);
    }
    if (p2pTraffic) {
      res["P2pTraffic"] = boost::any(*p2pTraffic);
    }
    if (rtmpBps) {
      res["RtmpBps"] = boost::any(*rtmpBps);
    }
    if (rtmpCount) {
      res["RtmpCount"] = boost::any(*rtmpCount);
    }
    if (rtmpTraffic) {
      res["RtmpTraffic"] = boost::any(*rtmpTraffic);
    }
    if (rtsBps) {
      res["RtsBps"] = boost::any(*rtsBps);
    }
    if (rtsCount) {
      res["RtsCount"] = boost::any(*rtsCount);
    }
    if (rtsTraffic) {
      res["RtsTraffic"] = boost::any(*rtsTraffic);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (traffic) {
      res["Traffic"] = boost::any(*traffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("FlvBps") != m.end() && !m["FlvBps"].empty()) {
      flvBps = make_shared<double>(boost::any_cast<double>(m["FlvBps"]));
    }
    if (m.find("FlvCount") != m.end() && !m["FlvCount"].empty()) {
      flvCount = make_shared<long>(boost::any_cast<long>(m["FlvCount"]));
    }
    if (m.find("FlvTraffic") != m.end() && !m["FlvTraffic"].empty()) {
      flvTraffic = make_shared<long>(boost::any_cast<long>(m["FlvTraffic"]));
    }
    if (m.find("HlsBps") != m.end() && !m["HlsBps"].empty()) {
      hlsBps = make_shared<double>(boost::any_cast<double>(m["HlsBps"]));
    }
    if (m.find("HlsCount") != m.end() && !m["HlsCount"].empty()) {
      hlsCount = make_shared<long>(boost::any_cast<long>(m["HlsCount"]));
    }
    if (m.find("HlsTraffic") != m.end() && !m["HlsTraffic"].empty()) {
      hlsTraffic = make_shared<long>(boost::any_cast<long>(m["HlsTraffic"]));
    }
    if (m.find("P2pBps") != m.end() && !m["P2pBps"].empty()) {
      p2pBps = make_shared<double>(boost::any_cast<double>(m["P2pBps"]));
    }
    if (m.find("P2pCount") != m.end() && !m["P2pCount"].empty()) {
      p2pCount = make_shared<long>(boost::any_cast<long>(m["P2pCount"]));
    }
    if (m.find("P2pTraffic") != m.end() && !m["P2pTraffic"].empty()) {
      p2pTraffic = make_shared<long>(boost::any_cast<long>(m["P2pTraffic"]));
    }
    if (m.find("RtmpBps") != m.end() && !m["RtmpBps"].empty()) {
      rtmpBps = make_shared<double>(boost::any_cast<double>(m["RtmpBps"]));
    }
    if (m.find("RtmpCount") != m.end() && !m["RtmpCount"].empty()) {
      rtmpCount = make_shared<long>(boost::any_cast<long>(m["RtmpCount"]));
    }
    if (m.find("RtmpTraffic") != m.end() && !m["RtmpTraffic"].empty()) {
      rtmpTraffic = make_shared<long>(boost::any_cast<long>(m["RtmpTraffic"]));
    }
    if (m.find("RtsBps") != m.end() && !m["RtsBps"].empty()) {
      rtsBps = make_shared<double>(boost::any_cast<double>(m["RtsBps"]));
    }
    if (m.find("RtsCount") != m.end() && !m["RtsCount"].empty()) {
      rtsCount = make_shared<long>(boost::any_cast<long>(m["RtsCount"]));
    }
    if (m.find("RtsTraffic") != m.end() && !m["RtsTraffic"].empty()) {
      rtsTraffic = make_shared<long>(boost::any_cast<long>(m["RtsTraffic"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Traffic") != m.end() && !m["Traffic"].empty()) {
      traffic = make_shared<long>(boost::any_cast<long>(m["Traffic"]));
    }
  }


  virtual ~DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData() = default;
};
class DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData>> streamData{};

  DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData() {}

  explicit DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamData) {
      vector<boost::any> temp1;
      for(auto item1:*streamData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamData") != m.end() && !m["StreamData"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamData"].type()) {
        vector<DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamData = make_shared<vector<DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData() = default;
};
class DescribeLiveStreamMetricDetailDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData> streamDetailData{};

  DescribeLiveStreamMetricDetailDataResponseBody() {}

  explicit DescribeLiveStreamMetricDetailDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamDetailData) {
      res["StreamDetailData"] = streamDetailData ? boost::any(streamDetailData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamDetailData") != m.end() && !m["StreamDetailData"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamDetailData"].type()) {
        DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamDetailData"]));
        streamDetailData = make_shared<DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamMetricDetailDataResponseBody() = default;
};
class DescribeLiveStreamMetricDetailDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamMetricDetailDataResponseBody> body{};

  DescribeLiveStreamMetricDetailDataResponse() {}

  explicit DescribeLiveStreamMetricDetailDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamMetricDetailDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamMetricDetailDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamMetricDetailDataResponse() = default;
};
class DescribeLiveStreamMonitorListRequest : public Darabonba::Model {
public:
  shared_ptr<string> monitorId{};
  shared_ptr<long> orderRule{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> status{};

  DescribeLiveStreamMonitorListRequest() {}

  explicit DescribeLiveStreamMonitorListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (orderRule) {
      res["OrderRule"] = boost::any(*orderRule);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("OrderRule") != m.end() && !m["OrderRule"].empty()) {
      orderRule = make_shared<long>(boost::any_cast<long>(m["OrderRule"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListRequest() = default;
};
class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig : public Darabonba::Model {
public:
  shared_ptr<string> fillMode{};
  shared_ptr<vector<double>> positionNormalized{};
  shared_ptr<string> positionRefer{};
  shared_ptr<vector<double>> sizeNormalized{};

  DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig() {}

  explicit DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fillMode) {
      res["FillMode"] = boost::any(*fillMode);
    }
    if (positionNormalized) {
      res["PositionNormalized"] = boost::any(*positionNormalized);
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (sizeNormalized) {
      res["SizeNormalized"] = boost::any(*sizeNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FillMode") != m.end() && !m["FillMode"].empty()) {
      fillMode = make_shared<string>(boost::any_cast<string>(m["FillMode"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["PositionNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PositionNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      positionNormalized = make_shared<vector<double>>(toVec1);
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("SizeNormalized") != m.end() && !m["SizeNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["SizeNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SizeNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      sizeNormalized = make_shared<vector<double>>(toVec1);
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig() = default;
};
class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig : public Darabonba::Model {
public:
  shared_ptr<double> volumeRate{};

  DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig() {}

  explicit DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig() = default;
};
class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<string> inputUrl{};
  shared_ptr<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig> layoutConfig{};
  shared_ptr<long> layoutId{};
  shared_ptr<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig> playConfig{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList() {}

  explicit DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (layoutConfig) {
      res["LayoutConfig"] = layoutConfig ? boost::any(layoutConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (playConfig) {
      res["PlayConfig"] = playConfig ? boost::any(playConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("LayoutConfig") != m.end() && !m["LayoutConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LayoutConfig"].type()) {
        DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LayoutConfig"]));
        layoutConfig = make_shared<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig>(model1);
      }
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<long>(boost::any_cast<long>(m["LayoutId"]));
    }
    if (m.find("PlayConfig") != m.end() && !m["PlayConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlayConfig"].type()) {
        DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlayConfig"]));
        playConfig = make_shared<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig>(model1);
      }
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList() = default;
};
class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls : public Darabonba::Model {
public:
  shared_ptr<string> flvUrl{};
  shared_ptr<string> rtmpUrl{};

  DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls() {}

  explicit DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flvUrl) {
      res["FlvUrl"] = boost::any(*flvUrl);
    }
    if (rtmpUrl) {
      res["RtmpUrl"] = boost::any(*rtmpUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlvUrl") != m.end() && !m["FlvUrl"].empty()) {
      flvUrl = make_shared<string>(boost::any_cast<string>(m["FlvUrl"]));
    }
    if (m.find("RtmpUrl") != m.end() && !m["RtmpUrl"].empty()) {
      rtmpUrl = make_shared<string>(boost::any_cast<string>(m["RtmpUrl"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls() = default;
};
class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList : public Darabonba::Model {
public:
  shared_ptr<long> audioFrom{};
  shared_ptr<string> domain{};
  shared_ptr<vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList>> inputList{};
  shared_ptr<string> monitorId{};
  shared_ptr<string> monitorName{};
  shared_ptr<string> outputTemplate{};
  shared_ptr<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls> outputUrls{};
  shared_ptr<string> region{};
  shared_ptr<string> startTime{};
  shared_ptr<long> status{};
  shared_ptr<string> stopTime{};

  DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList() {}

  explicit DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFrom) {
      res["AudioFrom"] = boost::any(*audioFrom);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (inputList) {
      vector<boost::any> temp1;
      for(auto item1:*inputList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputList"] = boost::any(temp1);
    }
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (monitorName) {
      res["MonitorName"] = boost::any(*monitorName);
    }
    if (outputTemplate) {
      res["OutputTemplate"] = boost::any(*outputTemplate);
    }
    if (outputUrls) {
      res["OutputUrls"] = outputUrls ? boost::any(outputUrls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFrom") != m.end() && !m["AudioFrom"].empty()) {
      audioFrom = make_shared<long>(boost::any_cast<long>(m["AudioFrom"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      if (typeid(vector<boost::any>) == m["InputList"].type()) {
        vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputList = make_shared<vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList>>(expect1);
      }
    }
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("MonitorName") != m.end() && !m["MonitorName"].empty()) {
      monitorName = make_shared<string>(boost::any_cast<string>(m["MonitorName"]));
    }
    if (m.find("OutputTemplate") != m.end() && !m["OutputTemplate"].empty()) {
      outputTemplate = make_shared<string>(boost::any_cast<string>(m["OutputTemplate"]));
    }
    if (m.find("OutputUrls") != m.end() && !m["OutputUrls"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputUrls"].type()) {
        DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputUrls"]));
        outputUrls = make_shared<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls>(model1);
      }
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["StopTime"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList() = default;
};
class DescribeLiveStreamMonitorListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList>> liveStreamMonitorList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeLiveStreamMonitorListResponseBody() {}

  explicit DescribeLiveStreamMonitorListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamMonitorList) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamMonitorList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamMonitorList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamMonitorList") != m.end() && !m["LiveStreamMonitorList"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamMonitorList"].type()) {
        vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamMonitorList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamMonitorList = make_shared<vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBody() = default;
};
class DescribeLiveStreamMonitorListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamMonitorListResponseBody> body{};

  DescribeLiveStreamMonitorListResponse() {}

  explicit DescribeLiveStreamMonitorListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamMonitorListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamMonitorListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponse() = default;
};
class DescribeLiveStreamOptimizedFeatureConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveStreamOptimizedFeatureConfigRequest() {}

  explicit DescribeLiveStreamOptimizedFeatureConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configName) {
      res["ConfigName"] = boost::any(*configName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigName") != m.end() && !m["ConfigName"].empty()) {
      configName = make_shared<string>(boost::any_cast<string>(m["ConfigName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveStreamOptimizedFeatureConfigRequest() = default;
};
class DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigListLiveStreamOptimizedFeatureConfig : public Darabonba::Model {
public:
  shared_ptr<string> configName{};
  shared_ptr<string> configStatus{};
  shared_ptr<string> configValue{};
  shared_ptr<string> domainName{};

  DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigListLiveStreamOptimizedFeatureConfig() {}

  explicit DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigListLiveStreamOptimizedFeatureConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configName) {
      res["ConfigName"] = boost::any(*configName);
    }
    if (configStatus) {
      res["ConfigStatus"] = boost::any(*configStatus);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigName") != m.end() && !m["ConfigName"].empty()) {
      configName = make_shared<string>(boost::any_cast<string>(m["ConfigName"]));
    }
    if (m.find("ConfigStatus") != m.end() && !m["ConfigStatus"].empty()) {
      configStatus = make_shared<string>(boost::any_cast<string>(m["ConfigStatus"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigListLiveStreamOptimizedFeatureConfig() = default;
};
class DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigListLiveStreamOptimizedFeatureConfig>> liveStreamOptimizedFeatureConfig{};

  DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigList() {}

  explicit DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamOptimizedFeatureConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamOptimizedFeatureConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamOptimizedFeatureConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamOptimizedFeatureConfig") != m.end() && !m["LiveStreamOptimizedFeatureConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamOptimizedFeatureConfig"].type()) {
        vector<DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigListLiveStreamOptimizedFeatureConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamOptimizedFeatureConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigListLiveStreamOptimizedFeatureConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamOptimizedFeatureConfig = make_shared<vector<DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigListLiveStreamOptimizedFeatureConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigList() = default;
};
class DescribeLiveStreamOptimizedFeatureConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigList> liveStreamOptimizedFeatureConfigList{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamOptimizedFeatureConfigResponseBody() {}

  explicit DescribeLiveStreamOptimizedFeatureConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamOptimizedFeatureConfigList) {
      res["LiveStreamOptimizedFeatureConfigList"] = liveStreamOptimizedFeatureConfigList ? boost::any(liveStreamOptimizedFeatureConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamOptimizedFeatureConfigList") != m.end() && !m["LiveStreamOptimizedFeatureConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamOptimizedFeatureConfigList"].type()) {
        DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamOptimizedFeatureConfigList"]));
        liveStreamOptimizedFeatureConfigList = make_shared<DescribeLiveStreamOptimizedFeatureConfigResponseBodyLiveStreamOptimizedFeatureConfigList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamOptimizedFeatureConfigResponseBody() = default;
};
class DescribeLiveStreamOptimizedFeatureConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamOptimizedFeatureConfigResponseBody> body{};

  DescribeLiveStreamOptimizedFeatureConfigResponse() {}

  explicit DescribeLiveStreamOptimizedFeatureConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamOptimizedFeatureConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamOptimizedFeatureConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamOptimizedFeatureConfigResponse() = default;
};
class DescribeLiveStreamRecordContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamRecordContentRequest() {}

  explicit DescribeLiveStreamRecordContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamRecordContentRequest() = default;
};
class DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo : public Darabonba::Model {
public:
  shared_ptr<double> duration{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<string> startTime{};

  DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo() {}

  explicit DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo() = default;
};
class DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo>> recordContentInfo{};

  DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList() {}

  explicit DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordContentInfo) {
      vector<boost::any> temp1;
      for(auto item1:*recordContentInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordContentInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordContentInfo") != m.end() && !m["RecordContentInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordContentInfo"].type()) {
        vector<DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordContentInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordContentInfo = make_shared<vector<DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList() = default;
};
class DescribeLiveStreamRecordContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList> recordContentInfoList{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamRecordContentResponseBody() {}

  explicit DescribeLiveStreamRecordContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordContentInfoList) {
      res["RecordContentInfoList"] = recordContentInfoList ? boost::any(recordContentInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordContentInfoList") != m.end() && !m["RecordContentInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordContentInfoList"].type()) {
        DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordContentInfoList"]));
        recordContentInfoList = make_shared<DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamRecordContentResponseBody() = default;
};
class DescribeLiveStreamRecordContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamRecordContentResponseBody> body{};

  DescribeLiveStreamRecordContentResponse() {}

  explicit DescribeLiveStreamRecordContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamRecordContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamRecordContentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamRecordContentResponse() = default;
};
class DescribeLiveStreamRecordIndexFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> recordId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamRecordIndexFileRequest() {}

  explicit DescribeLiveStreamRecordIndexFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFileRequest() = default;
};
class DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainName{};
  shared_ptr<double> duration{};
  shared_ptr<string> endTime{};
  shared_ptr<long> height{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<string> recordId{};
  shared_ptr<string> recordUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<long> width{};

  DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo() {}

  explicit DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordUrl) {
      res["RecordUrl"] = boost::any(*recordUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RecordUrl") != m.end() && !m["RecordUrl"].empty()) {
      recordUrl = make_shared<string>(boost::any_cast<string>(m["RecordUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo() = default;
};
class DescribeLiveStreamRecordIndexFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo> recordIndexInfo{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamRecordIndexFileResponseBody() {}

  explicit DescribeLiveStreamRecordIndexFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordIndexInfo) {
      res["RecordIndexInfo"] = recordIndexInfo ? boost::any(recordIndexInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordIndexInfo") != m.end() && !m["RecordIndexInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordIndexInfo"].type()) {
        DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordIndexInfo"]));
        recordIndexInfo = make_shared<DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFileResponseBody() = default;
};
class DescribeLiveStreamRecordIndexFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamRecordIndexFileResponseBody> body{};

  DescribeLiveStreamRecordIndexFileResponse() {}

  explicit DescribeLiveStreamRecordIndexFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamRecordIndexFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamRecordIndexFileResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFileResponse() = default;
};
class DescribeLiveStreamRecordIndexFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamRecordIndexFilesRequest() {}

  explicit DescribeLiveStreamRecordIndexFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFilesRequest() = default;
};
class DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainName{};
  shared_ptr<double> duration{};
  shared_ptr<string> endTime{};
  shared_ptr<long> height{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<string> recordId{};
  shared_ptr<string> recordUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<long> width{};

  DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo() {}

  explicit DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordUrl) {
      res["RecordUrl"] = boost::any(*recordUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RecordUrl") != m.end() && !m["RecordUrl"].empty()) {
      recordUrl = make_shared<string>(boost::any_cast<string>(m["RecordUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo() = default;
};
class DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo>> recordIndexInfo{};

  DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList() {}

  explicit DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordIndexInfo) {
      vector<boost::any> temp1;
      for(auto item1:*recordIndexInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordIndexInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordIndexInfo") != m.end() && !m["RecordIndexInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordIndexInfo"].type()) {
        vector<DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordIndexInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordIndexInfo = make_shared<vector<DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList() = default;
};
class DescribeLiveStreamRecordIndexFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList> recordIndexInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveStreamRecordIndexFilesResponseBody() {}

  explicit DescribeLiveStreamRecordIndexFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordIndexInfoList) {
      res["RecordIndexInfoList"] = recordIndexInfoList ? boost::any(recordIndexInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordIndexInfoList") != m.end() && !m["RecordIndexInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordIndexInfoList"].type()) {
        DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordIndexInfoList"]));
        recordIndexInfoList = make_shared<DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFilesResponseBody() = default;
};
class DescribeLiveStreamRecordIndexFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamRecordIndexFilesResponseBody> body{};

  DescribeLiveStreamRecordIndexFilesResponse() {}

  explicit DescribeLiveStreamRecordIndexFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamRecordIndexFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamRecordIndexFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFilesResponse() = default;
};
class DescribeLiveStreamSnapshotInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> limit{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamSnapshotInfoRequest() {}

  explicit DescribeLiveStreamSnapshotInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamSnapshotInfoRequest() = default;
};
class DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<bool> isOverlay{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};

  DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo() {}

  explicit DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (isOverlay) {
      res["IsOverlay"] = boost::any(*isOverlay);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("IsOverlay") != m.end() && !m["IsOverlay"].empty()) {
      isOverlay = make_shared<bool>(boost::any_cast<bool>(m["IsOverlay"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
  }


  virtual ~DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo() = default;
};
class DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo>> liveStreamSnapshotInfo{};

  DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList() {}

  explicit DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamSnapshotInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamSnapshotInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamSnapshotInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamSnapshotInfo") != m.end() && !m["LiveStreamSnapshotInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamSnapshotInfo"].type()) {
        vector<DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamSnapshotInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamSnapshotInfo = make_shared<vector<DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList() = default;
};
class DescribeLiveStreamSnapshotInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList> liveStreamSnapshotInfoList{};
  shared_ptr<string> nextStartTime{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamSnapshotInfoResponseBody() {}

  explicit DescribeLiveStreamSnapshotInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamSnapshotInfoList) {
      res["LiveStreamSnapshotInfoList"] = liveStreamSnapshotInfoList ? boost::any(liveStreamSnapshotInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextStartTime) {
      res["NextStartTime"] = boost::any(*nextStartTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamSnapshotInfoList") != m.end() && !m["LiveStreamSnapshotInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamSnapshotInfoList"].type()) {
        DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamSnapshotInfoList"]));
        liveStreamSnapshotInfoList = make_shared<DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList>(model1);
      }
    }
    if (m.find("NextStartTime") != m.end() && !m["NextStartTime"].empty()) {
      nextStartTime = make_shared<string>(boost::any_cast<string>(m["NextStartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamSnapshotInfoResponseBody() = default;
};
class DescribeLiveStreamSnapshotInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamSnapshotInfoResponseBody> body{};

  DescribeLiveStreamSnapshotInfoResponse() {}

  explicit DescribeLiveStreamSnapshotInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamSnapshotInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamSnapshotInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamSnapshotInfoResponse() = default;
};
class DescribeLiveStreamStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamStateRequest() {}

  explicit DescribeLiveStreamStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamStateRequest() = default;
};
class DescribeLiveStreamStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> streamState{};
  shared_ptr<string> type{};

  DescribeLiveStreamStateResponseBody() {}

  explicit DescribeLiveStreamStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamState) {
      res["StreamState"] = boost::any(*streamState);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamState") != m.end() && !m["StreamState"].empty()) {
      streamState = make_shared<string>(boost::any_cast<string>(m["StreamState"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveStreamStateResponseBody() = default;
};
class DescribeLiveStreamStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamStateResponseBody> body{};

  DescribeLiveStreamStateResponse() {}

  explicit DescribeLiveStreamStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamStateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamStateResponse() = default;
};
class DescribeLiveStreamTranscodeInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainTranscodeName{};
  shared_ptr<long> ownerId{};

  DescribeLiveStreamTranscodeInfoRequest() {}

  explicit DescribeLiveStreamTranscodeInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainTranscodeName) {
      res["DomainTranscodeName"] = boost::any(*domainTranscodeName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainTranscodeName") != m.end() && !m["DomainTranscodeName"].empty()) {
      domainTranscodeName = make_shared<string>(boost::any_cast<string>(m["DomainTranscodeName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoRequest() = default;
};
class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters : public Darabonba::Model {
public:
  shared_ptr<long> audioBitrate{};
  shared_ptr<long> audioChannelNum{};
  shared_ptr<string> audioCodec{};
  shared_ptr<string> audioProfile{};
  shared_ptr<long> audioRate{};
  shared_ptr<string> bframes{};
  shared_ptr<long> FPS{};
  shared_ptr<string> gop{};
  shared_ptr<long> height{};
  shared_ptr<string> rtsFlag{};
  shared_ptr<string> templateType{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<string> videoProfile{};
  shared_ptr<long> width{};

  DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters() {}

  explicit DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannelNum) {
      res["AudioChannelNum"] = boost::any(*audioChannelNum);
    }
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioProfile) {
      res["AudioProfile"] = boost::any(*audioProfile);
    }
    if (audioRate) {
      res["AudioRate"] = boost::any(*audioRate);
    }
    if (bframes) {
      res["Bframes"] = boost::any(*bframes);
    }
    if (FPS) {
      res["FPS"] = boost::any(*FPS);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (rtsFlag) {
      res["RtsFlag"] = boost::any(*rtsFlag);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (videoProfile) {
      res["VideoProfile"] = boost::any(*videoProfile);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<long>(boost::any_cast<long>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannelNum") != m.end() && !m["AudioChannelNum"].empty()) {
      audioChannelNum = make_shared<long>(boost::any_cast<long>(m["AudioChannelNum"]));
    }
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioProfile") != m.end() && !m["AudioProfile"].empty()) {
      audioProfile = make_shared<string>(boost::any_cast<string>(m["AudioProfile"]));
    }
    if (m.find("AudioRate") != m.end() && !m["AudioRate"].empty()) {
      audioRate = make_shared<long>(boost::any_cast<long>(m["AudioRate"]));
    }
    if (m.find("Bframes") != m.end() && !m["Bframes"].empty()) {
      bframes = make_shared<string>(boost::any_cast<string>(m["Bframes"]));
    }
    if (m.find("FPS") != m.end() && !m["FPS"].empty()) {
      FPS = make_shared<long>(boost::any_cast<long>(m["FPS"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("RtsFlag") != m.end() && !m["RtsFlag"].empty()) {
      rtsFlag = make_shared<string>(boost::any_cast<string>(m["RtsFlag"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("VideoProfile") != m.end() && !m["VideoProfile"].empty()) {
      videoProfile = make_shared<string>(boost::any_cast<string>(m["VideoProfile"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters() = default;
};
class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters : public Darabonba::Model {
public:
  shared_ptr<string> encryptType{};
  shared_ptr<string> kmsKeyExpireInterval{};
  shared_ptr<string> kmsKeyID{};

  DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters() {}

  explicit DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (kmsKeyExpireInterval) {
      res["KmsKeyExpireInterval"] = boost::any(*kmsKeyExpireInterval);
    }
    if (kmsKeyID) {
      res["KmsKeyID"] = boost::any(*kmsKeyID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
    if (m.find("KmsKeyExpireInterval") != m.end() && !m["KmsKeyExpireInterval"].empty()) {
      kmsKeyExpireInterval = make_shared<string>(boost::any_cast<string>(m["KmsKeyExpireInterval"]));
    }
    if (m.find("KmsKeyID") != m.end() && !m["KmsKeyID"].empty()) {
      kmsKeyID = make_shared<string>(boost::any_cast<string>(m["KmsKeyID"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters() = default;
};
class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters> customTranscodeParameters{};
  shared_ptr<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters> encryptParameters{};
  shared_ptr<bool> isLazy{};
  shared_ptr<string> transcodeApp{};
  shared_ptr<string> transcodeName{};
  shared_ptr<string> transcodeTemplate{};

  DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo() {}

  explicit DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTranscodeParameters) {
      res["CustomTranscodeParameters"] = customTranscodeParameters ? boost::any(customTranscodeParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryptParameters) {
      res["EncryptParameters"] = encryptParameters ? boost::any(encryptParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isLazy) {
      res["IsLazy"] = boost::any(*isLazy);
    }
    if (transcodeApp) {
      res["TranscodeApp"] = boost::any(*transcodeApp);
    }
    if (transcodeName) {
      res["TranscodeName"] = boost::any(*transcodeName);
    }
    if (transcodeTemplate) {
      res["TranscodeTemplate"] = boost::any(*transcodeTemplate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTranscodeParameters") != m.end() && !m["CustomTranscodeParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomTranscodeParameters"].type()) {
        DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomTranscodeParameters"]));
        customTranscodeParameters = make_shared<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters>(model1);
      }
    }
    if (m.find("EncryptParameters") != m.end() && !m["EncryptParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["EncryptParameters"].type()) {
        DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EncryptParameters"]));
        encryptParameters = make_shared<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters>(model1);
      }
    }
    if (m.find("IsLazy") != m.end() && !m["IsLazy"].empty()) {
      isLazy = make_shared<bool>(boost::any_cast<bool>(m["IsLazy"]));
    }
    if (m.find("TranscodeApp") != m.end() && !m["TranscodeApp"].empty()) {
      transcodeApp = make_shared<string>(boost::any_cast<string>(m["TranscodeApp"]));
    }
    if (m.find("TranscodeName") != m.end() && !m["TranscodeName"].empty()) {
      transcodeName = make_shared<string>(boost::any_cast<string>(m["TranscodeName"]));
    }
    if (m.find("TranscodeTemplate") != m.end() && !m["TranscodeTemplate"].empty()) {
      transcodeTemplate = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplate"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo() = default;
};
class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo>> domainTranscodeInfo{};

  DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList() {}

  explicit DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainTranscodeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*domainTranscodeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainTranscodeInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainTranscodeInfo") != m.end() && !m["DomainTranscodeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainTranscodeInfo"].type()) {
        vector<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainTranscodeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainTranscodeInfo = make_shared<vector<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList() = default;
};
class DescribeLiveStreamTranscodeInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList> domainTranscodeList{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamTranscodeInfoResponseBody() {}

  explicit DescribeLiveStreamTranscodeInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainTranscodeList) {
      res["DomainTranscodeList"] = domainTranscodeList ? boost::any(domainTranscodeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainTranscodeList") != m.end() && !m["DomainTranscodeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainTranscodeList"].type()) {
        DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainTranscodeList"]));
        domainTranscodeList = make_shared<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponseBody() = default;
};
class DescribeLiveStreamTranscodeInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamTranscodeInfoResponseBody> body{};

  DescribeLiveStreamTranscodeInfoResponse() {}

  explicit DescribeLiveStreamTranscodeInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamTranscodeInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamTranscodeInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponse() = default;
};
class DescribeLiveStreamTranscodeStreamNumRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveStreamTranscodeStreamNumRequest() {}

  explicit DescribeLiveStreamTranscodeStreamNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeStreamNumRequest() = default;
};
class DescribeLiveStreamTranscodeStreamNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> lazyTranscodedNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<long> transcodedNumber{};
  shared_ptr<long> untranscodeNumber{};

  DescribeLiveStreamTranscodeStreamNumResponseBody() {}

  explicit DescribeLiveStreamTranscodeStreamNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lazyTranscodedNumber) {
      res["LazyTranscodedNumber"] = boost::any(*lazyTranscodedNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (transcodedNumber) {
      res["TranscodedNumber"] = boost::any(*transcodedNumber);
    }
    if (untranscodeNumber) {
      res["UntranscodeNumber"] = boost::any(*untranscodeNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LazyTranscodedNumber") != m.end() && !m["LazyTranscodedNumber"].empty()) {
      lazyTranscodedNumber = make_shared<long>(boost::any_cast<long>(m["LazyTranscodedNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TranscodedNumber") != m.end() && !m["TranscodedNumber"].empty()) {
      transcodedNumber = make_shared<long>(boost::any_cast<long>(m["TranscodedNumber"]));
    }
    if (m.find("UntranscodeNumber") != m.end() && !m["UntranscodeNumber"].empty()) {
      untranscodeNumber = make_shared<long>(boost::any_cast<long>(m["UntranscodeNumber"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeStreamNumResponseBody() = default;
};
class DescribeLiveStreamTranscodeStreamNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamTranscodeStreamNumResponseBody> body{};

  DescribeLiveStreamTranscodeStreamNumResponse() {}

  explicit DescribeLiveStreamTranscodeStreamNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamTranscodeStreamNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamTranscodeStreamNumResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamTranscodeStreamNumResponse() = default;
};
class DescribeLiveStreamWatermarkRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeLiveStreamWatermarkRulesRequest() {}

  explicit DescribeLiveStreamWatermarkRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeLiveStreamWatermarkRulesRequest() = default;
};
class DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> name{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> stream{};
  shared_ptr<string> templateId{};

  DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo() {}

  explicit DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo() = default;
};
class DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo>> ruleInfo{};

  DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList() {}

  explicit DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleInfo") != m.end() && !m["RuleInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleInfo"].type()) {
        vector<DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfo = make_shared<vector<DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList() = default;
};
class DescribeLiveStreamWatermarkRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList> ruleInfoList{};

  DescribeLiveStreamWatermarkRulesResponseBody() {}

  explicit DescribeLiveStreamWatermarkRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleInfoList) {
      res["RuleInfoList"] = ruleInfoList ? boost::any(ruleInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleInfoList") != m.end() && !m["RuleInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleInfoList"].type()) {
        DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleInfoList"]));
        ruleInfoList = make_shared<DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamWatermarkRulesResponseBody() = default;
};
class DescribeLiveStreamWatermarkRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamWatermarkRulesResponseBody> body{};

  DescribeLiveStreamWatermarkRulesResponse() {}

  explicit DescribeLiveStreamWatermarkRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamWatermarkRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamWatermarkRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamWatermarkRulesResponse() = default;
};
class DescribeLiveStreamWatermarksRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeLiveStreamWatermarksRequest() {}

  explicit DescribeLiveStreamWatermarksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeLiveStreamWatermarksRequest() = default;
};
class DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> height{};
  shared_ptr<string> name{};
  shared_ptr<string> offsetCorner{};
  shared_ptr<string> pictureUrl{};
  shared_ptr<long> refHeight{};
  shared_ptr<long> refWidth{};
  shared_ptr<string> templateId{};
  shared_ptr<long> transparency{};
  shared_ptr<long> type{};
  shared_ptr<double> XOffset{};
  shared_ptr<double> YOffset{};

  DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark() {}

  explicit DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (offsetCorner) {
      res["OffsetCorner"] = boost::any(*offsetCorner);
    }
    if (pictureUrl) {
      res["PictureUrl"] = boost::any(*pictureUrl);
    }
    if (refHeight) {
      res["RefHeight"] = boost::any(*refHeight);
    }
    if (refWidth) {
      res["RefWidth"] = boost::any(*refWidth);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transparency) {
      res["Transparency"] = boost::any(*transparency);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (XOffset) {
      res["XOffset"] = boost::any(*XOffset);
    }
    if (YOffset) {
      res["YOffset"] = boost::any(*YOffset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OffsetCorner") != m.end() && !m["OffsetCorner"].empty()) {
      offsetCorner = make_shared<string>(boost::any_cast<string>(m["OffsetCorner"]));
    }
    if (m.find("PictureUrl") != m.end() && !m["PictureUrl"].empty()) {
      pictureUrl = make_shared<string>(boost::any_cast<string>(m["PictureUrl"]));
    }
    if (m.find("RefHeight") != m.end() && !m["RefHeight"].empty()) {
      refHeight = make_shared<long>(boost::any_cast<long>(m["RefHeight"]));
    }
    if (m.find("RefWidth") != m.end() && !m["RefWidth"].empty()) {
      refWidth = make_shared<long>(boost::any_cast<long>(m["RefWidth"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Transparency") != m.end() && !m["Transparency"].empty()) {
      transparency = make_shared<long>(boost::any_cast<long>(m["Transparency"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("XOffset") != m.end() && !m["XOffset"].empty()) {
      XOffset = make_shared<double>(boost::any_cast<double>(m["XOffset"]));
    }
    if (m.find("YOffset") != m.end() && !m["YOffset"].empty()) {
      YOffset = make_shared<double>(boost::any_cast<double>(m["YOffset"]));
    }
  }


  virtual ~DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark() = default;
};
class DescribeLiveStreamWatermarksResponseBodyWatermarkList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark>> watermark{};

  DescribeLiveStreamWatermarksResponseBodyWatermarkList() {}

  explicit DescribeLiveStreamWatermarksResponseBodyWatermarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (watermark) {
      vector<boost::any> temp1;
      for(auto item1:*watermark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Watermark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Watermark") != m.end() && !m["Watermark"].empty()) {
      if (typeid(vector<boost::any>) == m["Watermark"].type()) {
        vector<DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Watermark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        watermark = make_shared<vector<DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamWatermarksResponseBodyWatermarkList() = default;
};
class DescribeLiveStreamWatermarksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveStreamWatermarksResponseBodyWatermarkList> watermarkList{};

  DescribeLiveStreamWatermarksResponseBody() {}

  explicit DescribeLiveStreamWatermarksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (watermarkList) {
      res["WatermarkList"] = watermarkList ? boost::any(watermarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WatermarkList") != m.end() && !m["WatermarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WatermarkList"].type()) {
        DescribeLiveStreamWatermarksResponseBodyWatermarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WatermarkList"]));
        watermarkList = make_shared<DescribeLiveStreamWatermarksResponseBodyWatermarkList>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamWatermarksResponseBody() = default;
};
class DescribeLiveStreamWatermarksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamWatermarksResponseBody> body{};

  DescribeLiveStreamWatermarksResponse() {}

  explicit DescribeLiveStreamWatermarksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamWatermarksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamWatermarksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamWatermarksResponse() = default;
};
class DescribeLiveStreamsBlockListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeLiveStreamsBlockListRequest() {}

  explicit DescribeLiveStreamsBlockListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveStreamsBlockListRequest() = default;
};
class DescribeLiveStreamsBlockListResponseBodyStreamUrls : public Darabonba::Model {
public:
  shared_ptr<vector<string>> streamUrl{};

  DescribeLiveStreamsBlockListResponseBodyStreamUrls() {}

  explicit DescribeLiveStreamsBlockListResponseBodyStreamUrls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StreamUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StreamUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      streamUrl = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveStreamsBlockListResponseBodyStreamUrls() = default;
};
class DescribeLiveStreamsBlockListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveStreamsBlockListResponseBodyStreamUrls> streamUrls{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveStreamsBlockListResponseBody() {}

  explicit DescribeLiveStreamsBlockListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamUrls) {
      res["StreamUrls"] = streamUrls ? boost::any(streamUrls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamUrls") != m.end() && !m["StreamUrls"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamUrls"].type()) {
        DescribeLiveStreamsBlockListResponseBodyStreamUrls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamUrls"]));
        streamUrls = make_shared<DescribeLiveStreamsBlockListResponseBodyStreamUrls>(model1);
      }
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveStreamsBlockListResponseBody() = default;
};
class DescribeLiveStreamsBlockListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsBlockListResponseBody> body{};

  DescribeLiveStreamsBlockListResponse() {}

  explicit DescribeLiveStreamsBlockListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsBlockListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsBlockListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsBlockListResponse() = default;
};
class DescribeLiveStreamsControlHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveStreamsControlHistoryRequest() {}

  explicit DescribeLiveStreamsControlHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveStreamsControlHistoryRequest() = default;
};
class DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> clientIP{};
  shared_ptr<string> streamName{};
  shared_ptr<string> timeStamp{};

  DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo() {}

  explicit DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (clientIP) {
      res["ClientIP"] = boost::any(*clientIP);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("ClientIP") != m.end() && !m["ClientIP"].empty()) {
      clientIP = make_shared<string>(boost::any_cast<string>(m["ClientIP"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo() = default;
};
class DescribeLiveStreamsControlHistoryResponseBodyControlInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo>> liveStreamControlInfo{};

  DescribeLiveStreamsControlHistoryResponseBodyControlInfo() {}

  explicit DescribeLiveStreamsControlHistoryResponseBodyControlInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamControlInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamControlInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamControlInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamControlInfo") != m.end() && !m["LiveStreamControlInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamControlInfo"].type()) {
        vector<DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamControlInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamControlInfo = make_shared<vector<DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamsControlHistoryResponseBodyControlInfo() = default;
};
class DescribeLiveStreamsControlHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamsControlHistoryResponseBodyControlInfo> controlInfo{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamsControlHistoryResponseBody() {}

  explicit DescribeLiveStreamsControlHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (controlInfo) {
      res["ControlInfo"] = controlInfo ? boost::any(controlInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ControlInfo") != m.end() && !m["ControlInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ControlInfo"].type()) {
        DescribeLiveStreamsControlHistoryResponseBodyControlInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ControlInfo"]));
        controlInfo = make_shared<DescribeLiveStreamsControlHistoryResponseBodyControlInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamsControlHistoryResponseBody() = default;
};
class DescribeLiveStreamsControlHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsControlHistoryResponseBody> body{};

  DescribeLiveStreamsControlHistoryResponse() {}

  explicit DescribeLiveStreamsControlHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsControlHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsControlHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsControlHistoryResponse() = default;
};
class DescribeLiveStreamsNotifyRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamsNotifyRecordsRequest() {}

  explicit DescribeLiveStreamsNotifyRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyRecordsRequest() = default;
};
class DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyContent{};
  shared_ptr<string> notifyResult{};
  shared_ptr<string> notifyTime{};
  shared_ptr<string> notifyType{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo() {}

  explicit DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyContent) {
      res["NotifyContent"] = boost::any(*notifyContent);
    }
    if (notifyResult) {
      res["NotifyResult"] = boost::any(*notifyResult);
    }
    if (notifyTime) {
      res["NotifyTime"] = boost::any(*notifyTime);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyContent") != m.end() && !m["NotifyContent"].empty()) {
      notifyContent = make_shared<string>(boost::any_cast<string>(m["NotifyContent"]));
    }
    if (m.find("NotifyResult") != m.end() && !m["NotifyResult"].empty()) {
      notifyResult = make_shared<string>(boost::any_cast<string>(m["NotifyResult"]));
    }
    if (m.find("NotifyTime") != m.end() && !m["NotifyTime"].empty()) {
      notifyTime = make_shared<string>(boost::any_cast<string>(m["NotifyTime"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo() = default;
};
class DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo>> liveStreamNotifyRecordsInfo{};

  DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo() {}

  explicit DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamNotifyRecordsInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamNotifyRecordsInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamNotifyRecordsInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamNotifyRecordsInfo") != m.end() && !m["LiveStreamNotifyRecordsInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamNotifyRecordsInfo"].type()) {
        vector<DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamNotifyRecordsInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamNotifyRecordsInfo = make_shared<vector<DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo() = default;
};
class DescribeLiveStreamsNotifyRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo> notifyRecordsInfo{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveStreamsNotifyRecordsResponseBody() {}

  explicit DescribeLiveStreamsNotifyRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyRecordsInfo) {
      res["NotifyRecordsInfo"] = notifyRecordsInfo ? boost::any(notifyRecordsInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyRecordsInfo") != m.end() && !m["NotifyRecordsInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyRecordsInfo"].type()) {
        DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyRecordsInfo"]));
        notifyRecordsInfo = make_shared<DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo>(model1);
      }
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyRecordsResponseBody() = default;
};
class DescribeLiveStreamsNotifyRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsNotifyRecordsResponseBody> body{};

  DescribeLiveStreamsNotifyRecordsResponse() {}

  explicit DescribeLiveStreamsNotifyRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsNotifyRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsNotifyRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsNotifyRecordsResponse() = default;
};
class DescribeLiveStreamsNotifyUrlConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeLiveStreamsNotifyUrlConfigRequest() {}

  explicit DescribeLiveStreamsNotifyUrlConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyUrlConfigRequest() = default;
};
class DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyAuthKey{};
  shared_ptr<string> notifyReqAuth{};
  shared_ptr<string> notifyUrl{};

  DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig() {}

  explicit DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyAuthKey) {
      res["NotifyAuthKey"] = boost::any(*notifyAuthKey);
    }
    if (notifyReqAuth) {
      res["NotifyReqAuth"] = boost::any(*notifyReqAuth);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyAuthKey") != m.end() && !m["NotifyAuthKey"].empty()) {
      notifyAuthKey = make_shared<string>(boost::any_cast<string>(m["NotifyAuthKey"]));
    }
    if (m.find("NotifyReqAuth") != m.end() && !m["NotifyReqAuth"].empty()) {
      notifyReqAuth = make_shared<string>(boost::any_cast<string>(m["NotifyReqAuth"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig() = default;
};
class DescribeLiveStreamsNotifyUrlConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig> liveStreamsNotifyConfig{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamsNotifyUrlConfigResponseBody() {}

  explicit DescribeLiveStreamsNotifyUrlConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamsNotifyConfig) {
      res["LiveStreamsNotifyConfig"] = liveStreamsNotifyConfig ? boost::any(liveStreamsNotifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamsNotifyConfig") != m.end() && !m["LiveStreamsNotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamsNotifyConfig"].type()) {
        DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamsNotifyConfig"]));
        liveStreamsNotifyConfig = make_shared<DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyUrlConfigResponseBody() = default;
};
class DescribeLiveStreamsNotifyUrlConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsNotifyUrlConfigResponseBody> body{};

  DescribeLiveStreamsNotifyUrlConfigResponse() {}

  explicit DescribeLiveStreamsNotifyUrlConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsNotifyUrlConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsNotifyUrlConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsNotifyUrlConfigResponse() = default;
};
class DescribeLiveStreamsOnlineListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> onlyStream{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryType{};
  shared_ptr<string> streamName{};
  shared_ptr<string> streamType{};

  DescribeLiveStreamsOnlineListRequest() {}

  explicit DescribeLiveStreamsOnlineListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (onlyStream) {
      res["OnlyStream"] = boost::any(*onlyStream);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OnlyStream") != m.end() && !m["OnlyStream"].empty()) {
      onlyStream = make_shared<string>(boost::any_cast<string>(m["OnlyStream"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
  }


  virtual ~DescribeLiveStreamsOnlineListRequest() = default;
};
class DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> audioCodecId{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> domainName{};
  shared_ptr<long> frameRate{};
  shared_ptr<long> height{};
  shared_ptr<string> publishDomain{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> publishType{};
  shared_ptr<string> publishUrl{};
  shared_ptr<string> serverIp{};
  shared_ptr<string> streamName{};
  shared_ptr<string> transcoded{};
  shared_ptr<long> videoCodecId{};
  shared_ptr<long> width{};

  DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo() {}

  explicit DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (audioCodecId) {
      res["AudioCodecId"] = boost::any(*audioCodecId);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (frameRate) {
      res["FrameRate"] = boost::any(*frameRate);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (publishDomain) {
      res["PublishDomain"] = boost::any(*publishDomain);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (publishUrl) {
      res["PublishUrl"] = boost::any(*publishUrl);
    }
    if (serverIp) {
      res["ServerIp"] = boost::any(*serverIp);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transcoded) {
      res["Transcoded"] = boost::any(*transcoded);
    }
    if (videoCodecId) {
      res["VideoCodecId"] = boost::any(*videoCodecId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AudioCodecId") != m.end() && !m["AudioCodecId"].empty()) {
      audioCodecId = make_shared<long>(boost::any_cast<long>(m["AudioCodecId"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FrameRate") != m.end() && !m["FrameRate"].empty()) {
      frameRate = make_shared<long>(boost::any_cast<long>(m["FrameRate"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("PublishDomain") != m.end() && !m["PublishDomain"].empty()) {
      publishDomain = make_shared<string>(boost::any_cast<string>(m["PublishDomain"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<string>(boost::any_cast<string>(m["PublishType"]));
    }
    if (m.find("PublishUrl") != m.end() && !m["PublishUrl"].empty()) {
      publishUrl = make_shared<string>(boost::any_cast<string>(m["PublishUrl"]));
    }
    if (m.find("ServerIp") != m.end() && !m["ServerIp"].empty()) {
      serverIp = make_shared<string>(boost::any_cast<string>(m["ServerIp"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Transcoded") != m.end() && !m["Transcoded"].empty()) {
      transcoded = make_shared<string>(boost::any_cast<string>(m["Transcoded"]));
    }
    if (m.find("VideoCodecId") != m.end() && !m["VideoCodecId"].empty()) {
      videoCodecId = make_shared<long>(boost::any_cast<long>(m["VideoCodecId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo() = default;
};
class DescribeLiveStreamsOnlineListResponseBodyOnlineInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo>> liveStreamOnlineInfo{};

  DescribeLiveStreamsOnlineListResponseBodyOnlineInfo() {}

  explicit DescribeLiveStreamsOnlineListResponseBodyOnlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamOnlineInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamOnlineInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamOnlineInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamOnlineInfo") != m.end() && !m["LiveStreamOnlineInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamOnlineInfo"].type()) {
        vector<DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamOnlineInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamOnlineInfo = make_shared<vector<DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamsOnlineListResponseBodyOnlineInfo() = default;
};
class DescribeLiveStreamsOnlineListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamsOnlineListResponseBodyOnlineInfo> onlineInfo{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveStreamsOnlineListResponseBody() {}

  explicit DescribeLiveStreamsOnlineListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onlineInfo) {
      res["OnlineInfo"] = onlineInfo ? boost::any(onlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnlineInfo") != m.end() && !m["OnlineInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineInfo"].type()) {
        DescribeLiveStreamsOnlineListResponseBodyOnlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineInfo"]));
        onlineInfo = make_shared<DescribeLiveStreamsOnlineListResponseBodyOnlineInfo>(model1);
      }
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveStreamsOnlineListResponseBody() = default;
};
class DescribeLiveStreamsOnlineListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsOnlineListResponseBody> body{};

  DescribeLiveStreamsOnlineListResponse() {}

  explicit DescribeLiveStreamsOnlineListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsOnlineListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsOnlineListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsOnlineListResponse() = default;
};
class DescribeLiveStreamsPublishListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> streamType{};

  DescribeLiveStreamsPublishListRequest() {}

  explicit DescribeLiveStreamsPublishListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
  }


  virtual ~DescribeLiveStreamsPublishListRequest() = default;
};
class DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clientAddr{};
  shared_ptr<string> domainName{};
  shared_ptr<string> edgeNodeAddr{};
  shared_ptr<string> publishDomain{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> publishType{};
  shared_ptr<string> publishUrl{};
  shared_ptr<string> stopTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> streamUrl{};
  shared_ptr<string> transcodeId{};
  shared_ptr<string> transcoded{};

  DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo() {}

  explicit DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clientAddr) {
      res["ClientAddr"] = boost::any(*clientAddr);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (edgeNodeAddr) {
      res["EdgeNodeAddr"] = boost::any(*edgeNodeAddr);
    }
    if (publishDomain) {
      res["PublishDomain"] = boost::any(*publishDomain);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (publishUrl) {
      res["PublishUrl"] = boost::any(*publishUrl);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    if (transcodeId) {
      res["TranscodeId"] = boost::any(*transcodeId);
    }
    if (transcoded) {
      res["Transcoded"] = boost::any(*transcoded);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClientAddr") != m.end() && !m["ClientAddr"].empty()) {
      clientAddr = make_shared<string>(boost::any_cast<string>(m["ClientAddr"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EdgeNodeAddr") != m.end() && !m["EdgeNodeAddr"].empty()) {
      edgeNodeAddr = make_shared<string>(boost::any_cast<string>(m["EdgeNodeAddr"]));
    }
    if (m.find("PublishDomain") != m.end() && !m["PublishDomain"].empty()) {
      publishDomain = make_shared<string>(boost::any_cast<string>(m["PublishDomain"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<string>(boost::any_cast<string>(m["PublishType"]));
    }
    if (m.find("PublishUrl") != m.end() && !m["PublishUrl"].empty()) {
      publishUrl = make_shared<string>(boost::any_cast<string>(m["PublishUrl"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["StopTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
    if (m.find("TranscodeId") != m.end() && !m["TranscodeId"].empty()) {
      transcodeId = make_shared<string>(boost::any_cast<string>(m["TranscodeId"]));
    }
    if (m.find("Transcoded") != m.end() && !m["Transcoded"].empty()) {
      transcoded = make_shared<string>(boost::any_cast<string>(m["Transcoded"]));
    }
  }


  virtual ~DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo() = default;
};
class DescribeLiveStreamsPublishListResponseBodyPublishInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo>> liveStreamPublishInfo{};

  DescribeLiveStreamsPublishListResponseBodyPublishInfo() {}

  explicit DescribeLiveStreamsPublishListResponseBodyPublishInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamPublishInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamPublishInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamPublishInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamPublishInfo") != m.end() && !m["LiveStreamPublishInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamPublishInfo"].type()) {
        vector<DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamPublishInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamPublishInfo = make_shared<vector<DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamsPublishListResponseBodyPublishInfo() = default;
};
class DescribeLiveStreamsPublishListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeLiveStreamsPublishListResponseBodyPublishInfo> publishInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveStreamsPublishListResponseBody() {}

  explicit DescribeLiveStreamsPublishListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (publishInfo) {
      res["PublishInfo"] = publishInfo ? boost::any(publishInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PublishInfo") != m.end() && !m["PublishInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublishInfo"].type()) {
        DescribeLiveStreamsPublishListResponseBodyPublishInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublishInfo"]));
        publishInfo = make_shared<DescribeLiveStreamsPublishListResponseBodyPublishInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveStreamsPublishListResponseBody() = default;
};
class DescribeLiveStreamsPublishListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsPublishListResponseBody> body{};

  DescribeLiveStreamsPublishListResponse() {}

  explicit DescribeLiveStreamsPublishListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsPublishListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsPublishListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsPublishListResponse() = default;
};
class DescribeLiveTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeLiveTagResourcesRequestTag() {}

  explicit DescribeLiveTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLiveTagResourcesRequestTag() = default;
};
class DescribeLiveTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<DescribeLiveTagResourcesRequestTag>> tag{};

  DescribeLiveTagResourcesRequest() {}

  explicit DescribeLiveTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeLiveTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeLiveTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveTagResourcesRequest() = default;
};
class DescribeLiveTagResourcesResponseBodyTagResourcesTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeLiveTagResourcesResponseBodyTagResourcesTag() {}

  explicit DescribeLiveTagResourcesResponseBodyTagResourcesTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLiveTagResourcesResponseBodyTagResourcesTag() = default;
};
class DescribeLiveTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<vector<DescribeLiveTagResourcesResponseBodyTagResourcesTag>> tag{};

  DescribeLiveTagResourcesResponseBodyTagResources() {}

  explicit DescribeLiveTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeLiveTagResourcesResponseBodyTagResourcesTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveTagResourcesResponseBodyTagResourcesTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeLiveTagResourcesResponseBodyTagResourcesTag>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveTagResourcesResponseBodyTagResources() = default;
};
class DescribeLiveTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeLiveTagResourcesResponseBodyTagResources>> tagResources{};

  DescribeLiveTagResourcesResponseBody() {}

  explicit DescribeLiveTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<DescribeLiveTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<DescribeLiveTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveTagResourcesResponseBody() = default;
};
class DescribeLiveTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveTagResourcesResponseBody> body{};

  DescribeLiveTagResourcesResponse() {}

  explicit DescribeLiveTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveTagResourcesResponse() = default;
};
class DescribeLiveTopDomainsByFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> limit{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveTopDomainsByFlowRequest() {}

  explicit DescribeLiveTopDomainsByFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveTopDomainsByFlowRequest() = default;
};
class DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> maxBps{};
  shared_ptr<string> maxBpsTime{};
  shared_ptr<long> rank{};
  shared_ptr<long> totalAccess{};
  shared_ptr<string> totalTraffic{};
  shared_ptr<string> trafficPercent{};

  DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain() {}

  explicit DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (maxBps) {
      res["MaxBps"] = boost::any(*maxBps);
    }
    if (maxBpsTime) {
      res["MaxBpsTime"] = boost::any(*maxBpsTime);
    }
    if (rank) {
      res["Rank"] = boost::any(*rank);
    }
    if (totalAccess) {
      res["TotalAccess"] = boost::any(*totalAccess);
    }
    if (totalTraffic) {
      res["TotalTraffic"] = boost::any(*totalTraffic);
    }
    if (trafficPercent) {
      res["TrafficPercent"] = boost::any(*trafficPercent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MaxBps") != m.end() && !m["MaxBps"].empty()) {
      maxBps = make_shared<long>(boost::any_cast<long>(m["MaxBps"]));
    }
    if (m.find("MaxBpsTime") != m.end() && !m["MaxBpsTime"].empty()) {
      maxBpsTime = make_shared<string>(boost::any_cast<string>(m["MaxBpsTime"]));
    }
    if (m.find("Rank") != m.end() && !m["Rank"].empty()) {
      rank = make_shared<long>(boost::any_cast<long>(m["Rank"]));
    }
    if (m.find("TotalAccess") != m.end() && !m["TotalAccess"].empty()) {
      totalAccess = make_shared<long>(boost::any_cast<long>(m["TotalAccess"]));
    }
    if (m.find("TotalTraffic") != m.end() && !m["TotalTraffic"].empty()) {
      totalTraffic = make_shared<string>(boost::any_cast<string>(m["TotalTraffic"]));
    }
    if (m.find("TrafficPercent") != m.end() && !m["TrafficPercent"].empty()) {
      trafficPercent = make_shared<string>(boost::any_cast<string>(m["TrafficPercent"]));
    }
  }


  virtual ~DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain() = default;
};
class DescribeLiveTopDomainsByFlowResponseBodyTopDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain>> topDomain{};

  DescribeLiveTopDomainsByFlowResponseBodyTopDomains() {}

  explicit DescribeLiveTopDomainsByFlowResponseBodyTopDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topDomain) {
      vector<boost::any> temp1;
      for(auto item1:*topDomain){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopDomain"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopDomain") != m.end() && !m["TopDomain"].empty()) {
      if (typeid(vector<boost::any>) == m["TopDomain"].type()) {
        vector<DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopDomain"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topDomain = make_shared<vector<DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveTopDomainsByFlowResponseBodyTopDomains() = default;
};
class DescribeLiveTopDomainsByFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> domainCount{};
  shared_ptr<long> domainOnlineCount{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeLiveTopDomainsByFlowResponseBodyTopDomains> topDomains{};

  DescribeLiveTopDomainsByFlowResponseBody() {}

  explicit DescribeLiveTopDomainsByFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (domainOnlineCount) {
      res["DomainOnlineCount"] = boost::any(*domainOnlineCount);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (topDomains) {
      res["TopDomains"] = topDomains ? boost::any(topDomains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("DomainOnlineCount") != m.end() && !m["DomainOnlineCount"].empty()) {
      domainOnlineCount = make_shared<long>(boost::any_cast<long>(m["DomainOnlineCount"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TopDomains") != m.end() && !m["TopDomains"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopDomains"].type()) {
        DescribeLiveTopDomainsByFlowResponseBodyTopDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopDomains"]));
        topDomains = make_shared<DescribeLiveTopDomainsByFlowResponseBodyTopDomains>(model1);
      }
    }
  }


  virtual ~DescribeLiveTopDomainsByFlowResponseBody() = default;
};
class DescribeLiveTopDomainsByFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveTopDomainsByFlowResponseBody> body{};

  DescribeLiveTopDomainsByFlowResponse() {}

  explicit DescribeLiveTopDomainsByFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveTopDomainsByFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveTopDomainsByFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveTopDomainsByFlowResponse() = default;
};
class DescribeLiveUserBillPredictionRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> dimension{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeLiveUserBillPredictionRequest() {}

  explicit DescribeLiveUserBillPredictionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveUserBillPredictionRequest() = default;
};
class DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> timeStp{};
  shared_ptr<double> value{};

  DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem() {}

  explicit DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (timeStp) {
      res["TimeStp"] = boost::any(*timeStp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("TimeStp") != m.end() && !m["TimeStp"].empty()) {
      timeStp = make_shared<string>(boost::any_cast<string>(m["TimeStp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem() = default;
};
class DescribeLiveUserBillPredictionResponseBodyBillPredictionData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem>> billPredictionDataItem{};

  DescribeLiveUserBillPredictionResponseBodyBillPredictionData() {}

  explicit DescribeLiveUserBillPredictionResponseBodyBillPredictionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billPredictionDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billPredictionDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillPredictionDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillPredictionDataItem") != m.end() && !m["BillPredictionDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillPredictionDataItem"].type()) {
        vector<DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillPredictionDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billPredictionDataItem = make_shared<vector<DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUserBillPredictionResponseBodyBillPredictionData() = default;
};
class DescribeLiveUserBillPredictionResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveUserBillPredictionResponseBodyBillPredictionData> billPredictionData{};
  shared_ptr<string> billType{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveUserBillPredictionResponseBody() {}

  explicit DescribeLiveUserBillPredictionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billPredictionData) {
      res["BillPredictionData"] = billPredictionData ? boost::any(billPredictionData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (billType) {
      res["BillType"] = boost::any(*billType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillPredictionData") != m.end() && !m["BillPredictionData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillPredictionData"].type()) {
        DescribeLiveUserBillPredictionResponseBodyBillPredictionData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillPredictionData"]));
        billPredictionData = make_shared<DescribeLiveUserBillPredictionResponseBodyBillPredictionData>(model1);
      }
    }
    if (m.find("BillType") != m.end() && !m["BillType"].empty()) {
      billType = make_shared<string>(boost::any_cast<string>(m["BillType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveUserBillPredictionResponseBody() = default;
};
class DescribeLiveUserBillPredictionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveUserBillPredictionResponseBody> body{};

  DescribeLiveUserBillPredictionResponse() {}

  explicit DescribeLiveUserBillPredictionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveUserBillPredictionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveUserBillPredictionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveUserBillPredictionResponse() = default;
};
class DescribeLiveUserDomainsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeLiveUserDomainsRequestTag() {}

  explicit DescribeLiveUserDomainsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUserDomainsRequestTag() = default;
};
class DescribeLiveUserDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSearchType{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> liveDomainType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionName{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeLiveUserDomainsRequestTag>> tag{};

  DescribeLiveUserDomainsRequest() {}

  explicit DescribeLiveUserDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSearchType) {
      res["DomainSearchType"] = boost::any(*domainSearchType);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (liveDomainType) {
      res["LiveDomainType"] = boost::any(*liveDomainType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSearchType") != m.end() && !m["DomainSearchType"].empty()) {
      domainSearchType = make_shared<string>(boost::any_cast<string>(m["DomainSearchType"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("LiveDomainType") != m.end() && !m["LiveDomainType"].empty()) {
      liveDomainType = make_shared<string>(boost::any_cast<string>(m["LiveDomainType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeLiveUserDomainsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUserDomainsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeLiveUserDomainsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUserDomainsRequest() = default;
};
class DescribeLiveUserDomainsResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> liveDomainStatus{};
  shared_ptr<string> liveDomainType{};
  shared_ptr<string> regionName{};

  DescribeLiveUserDomainsResponseBodyDomainsPageData() {}

  explicit DescribeLiveUserDomainsResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (liveDomainStatus) {
      res["LiveDomainStatus"] = boost::any(*liveDomainStatus);
    }
    if (liveDomainType) {
      res["LiveDomainType"] = boost::any(*liveDomainType);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("LiveDomainStatus") != m.end() && !m["LiveDomainStatus"].empty()) {
      liveDomainStatus = make_shared<string>(boost::any_cast<string>(m["LiveDomainStatus"]));
    }
    if (m.find("LiveDomainType") != m.end() && !m["LiveDomainType"].empty()) {
      liveDomainType = make_shared<string>(boost::any_cast<string>(m["LiveDomainType"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
  }


  virtual ~DescribeLiveUserDomainsResponseBodyDomainsPageData() = default;
};
class DescribeLiveUserDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUserDomainsResponseBodyDomainsPageData>> pageData{};

  DescribeLiveUserDomainsResponseBodyDomains() {}

  explicit DescribeLiveUserDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeLiveUserDomainsResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUserDomainsResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeLiveUserDomainsResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUserDomainsResponseBodyDomains() = default;
};
class DescribeLiveUserDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveUserDomainsResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLiveUserDomainsResponseBody() {}

  explicit DescribeLiveUserDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeLiveUserDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeLiveUserDomainsResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLiveUserDomainsResponseBody() = default;
};
class DescribeLiveUserDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveUserDomainsResponseBody> body{};

  DescribeLiveUserDomainsResponse() {}

  explicit DescribeLiveUserDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveUserDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveUserDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveUserDomainsResponse() = default;
};
class DescribeLiveUserTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeLiveUserTagsRequest() {}

  explicit DescribeLiveUserTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveUserTagsRequest() = default;
};
class DescribeLiveUserTagsResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeLiveUserTagsResponseBodyTags() {}

  explicit DescribeLiveUserTagsResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveUserTagsResponseBodyTags() = default;
};
class DescribeLiveUserTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeLiveUserTagsResponseBodyTags>> tags{};

  DescribeLiveUserTagsResponseBody() {}

  explicit DescribeLiveUserTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeLiveUserTagsResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUserTagsResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeLiveUserTagsResponseBodyTags>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUserTagsResponseBody() = default;
};
class DescribeLiveUserTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveUserTagsResponseBody> body{};

  DescribeLiveUserTagsResponse() {}

  explicit DescribeLiveUserTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveUserTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveUserTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveUserTagsResponse() = default;
};
class DescribeMeterLiveRtcDurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> serviceArea{};
  shared_ptr<string> startTime{};
  shared_ptr<string> appId{};

  DescribeMeterLiveRtcDurationRequest() {}

  explicit DescribeMeterLiveRtcDurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (serviceArea) {
      res["ServiceArea"] = boost::any(*serviceArea);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("ServiceArea") != m.end() && !m["ServiceArea"].empty()) {
      serviceArea = make_shared<string>(boost::any_cast<string>(m["ServiceArea"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
  }


  virtual ~DescribeMeterLiveRtcDurationRequest() = default;
};
class DescribeMeterLiveRtcDurationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> audioDuration{};
  shared_ptr<string> timestamp{};
  shared_ptr<long> totalDuration{};
  shared_ptr<long> v1080Duration{};
  shared_ptr<long> v480Duration{};
  shared_ptr<long> v720Duration{};

  DescribeMeterLiveRtcDurationResponseBodyData() {}

  explicit DescribeMeterLiveRtcDurationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioDuration) {
      res["AudioDuration"] = boost::any(*audioDuration);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (totalDuration) {
      res["TotalDuration"] = boost::any(*totalDuration);
    }
    if (v1080Duration) {
      res["V1080Duration"] = boost::any(*v1080Duration);
    }
    if (v480Duration) {
      res["V480Duration"] = boost::any(*v480Duration);
    }
    if (v720Duration) {
      res["V720Duration"] = boost::any(*v720Duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioDuration") != m.end() && !m["AudioDuration"].empty()) {
      audioDuration = make_shared<long>(boost::any_cast<long>(m["AudioDuration"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("TotalDuration") != m.end() && !m["TotalDuration"].empty()) {
      totalDuration = make_shared<long>(boost::any_cast<long>(m["TotalDuration"]));
    }
    if (m.find("V1080Duration") != m.end() && !m["V1080Duration"].empty()) {
      v1080Duration = make_shared<long>(boost::any_cast<long>(m["V1080Duration"]));
    }
    if (m.find("V480Duration") != m.end() && !m["V480Duration"].empty()) {
      v480Duration = make_shared<long>(boost::any_cast<long>(m["V480Duration"]));
    }
    if (m.find("V720Duration") != m.end() && !m["V720Duration"].empty()) {
      v720Duration = make_shared<long>(boost::any_cast<long>(m["V720Duration"]));
    }
  }


  virtual ~DescribeMeterLiveRtcDurationResponseBodyData() = default;
};
class DescribeMeterLiveRtcDurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> audioSummaryDuration{};
  shared_ptr<vector<DescribeMeterLiveRtcDurationResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalSummaryDuration{};
  shared_ptr<long> v1080SummaryDuration{};
  shared_ptr<long> v480SummaryDuration{};
  shared_ptr<long> v720SummaryDuration{};

  DescribeMeterLiveRtcDurationResponseBody() {}

  explicit DescribeMeterLiveRtcDurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSummaryDuration) {
      res["AudioSummaryDuration"] = boost::any(*audioSummaryDuration);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalSummaryDuration) {
      res["TotalSummaryDuration"] = boost::any(*totalSummaryDuration);
    }
    if (v1080SummaryDuration) {
      res["V1080SummaryDuration"] = boost::any(*v1080SummaryDuration);
    }
    if (v480SummaryDuration) {
      res["V480SummaryDuration"] = boost::any(*v480SummaryDuration);
    }
    if (v720SummaryDuration) {
      res["V720SummaryDuration"] = boost::any(*v720SummaryDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSummaryDuration") != m.end() && !m["AudioSummaryDuration"].empty()) {
      audioSummaryDuration = make_shared<long>(boost::any_cast<long>(m["AudioSummaryDuration"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterLiveRtcDurationResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterLiveRtcDurationResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterLiveRtcDurationResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalSummaryDuration") != m.end() && !m["TotalSummaryDuration"].empty()) {
      totalSummaryDuration = make_shared<long>(boost::any_cast<long>(m["TotalSummaryDuration"]));
    }
    if (m.find("V1080SummaryDuration") != m.end() && !m["V1080SummaryDuration"].empty()) {
      v1080SummaryDuration = make_shared<long>(boost::any_cast<long>(m["V1080SummaryDuration"]));
    }
    if (m.find("V480SummaryDuration") != m.end() && !m["V480SummaryDuration"].empty()) {
      v480SummaryDuration = make_shared<long>(boost::any_cast<long>(m["V480SummaryDuration"]));
    }
    if (m.find("V720SummaryDuration") != m.end() && !m["V720SummaryDuration"].empty()) {
      v720SummaryDuration = make_shared<long>(boost::any_cast<long>(m["V720SummaryDuration"]));
    }
  }


  virtual ~DescribeMeterLiveRtcDurationResponseBody() = default;
};
class DescribeMeterLiveRtcDurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterLiveRtcDurationResponseBody> body{};

  DescribeMeterLiveRtcDurationResponse() {}

  explicit DescribeMeterLiveRtcDurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterLiveRtcDurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterLiveRtcDurationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterLiveRtcDurationResponse() = default;
};
class DescribeMixStreamListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> mixStreamId{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeMixStreamListRequest() {}

  explicit DescribeMixStreamListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeMixStreamListRequest() = default;
};
class DescribeMixStreamListResponseBodyMixStreamList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> inputStreamNumber{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> mixStreamTemplate{};
  shared_ptr<string> mixstreamId{};
  shared_ptr<string> streamName{};

  DescribeMixStreamListResponseBodyMixStreamList() {}

  explicit DescribeMixStreamListResponseBodyMixStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (inputStreamNumber) {
      res["InputStreamNumber"] = boost::any(*inputStreamNumber);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (mixStreamTemplate) {
      res["MixStreamTemplate"] = boost::any(*mixStreamTemplate);
    }
    if (mixstreamId) {
      res["MixstreamId"] = boost::any(*mixstreamId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("InputStreamNumber") != m.end() && !m["InputStreamNumber"].empty()) {
      inputStreamNumber = make_shared<long>(boost::any_cast<long>(m["InputStreamNumber"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("MixStreamTemplate") != m.end() && !m["MixStreamTemplate"].empty()) {
      mixStreamTemplate = make_shared<string>(boost::any_cast<string>(m["MixStreamTemplate"]));
    }
    if (m.find("MixstreamId") != m.end() && !m["MixstreamId"].empty()) {
      mixstreamId = make_shared<string>(boost::any_cast<string>(m["MixstreamId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeMixStreamListResponseBodyMixStreamList() = default;
};
class DescribeMixStreamListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMixStreamListResponseBodyMixStreamList>> mixStreamList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeMixStreamListResponseBody() {}

  explicit DescribeMixStreamListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixStreamList) {
      vector<boost::any> temp1;
      for(auto item1:*mixStreamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MixStreamList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixStreamList") != m.end() && !m["MixStreamList"].empty()) {
      if (typeid(vector<boost::any>) == m["MixStreamList"].type()) {
        vector<DescribeMixStreamListResponseBodyMixStreamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MixStreamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMixStreamListResponseBodyMixStreamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mixStreamList = make_shared<vector<DescribeMixStreamListResponseBodyMixStreamList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeMixStreamListResponseBody() = default;
};
class DescribeMixStreamListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMixStreamListResponseBody> body{};

  DescribeMixStreamListResponse() {}

  explicit DescribeMixStreamListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMixStreamListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMixStreamListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMixStreamListResponse() = default;
};
class DescribeRTSNativeSDKFirstFrameCostRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameCostRequest() {}

  explicit DescribeRTSNativeSDKFirstFrameCostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameCostRequest() = default;
};
class DescribeRTSNativeSDKFirstFrameCostShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainNameListShrink{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameCostShrinkRequest() {}

  explicit DescribeRTSNativeSDKFirstFrameCostShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameListShrink) {
      res["DomainNameList"] = boost::any(*domainNameListShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      domainNameListShrink = make_shared<string>(boost::any_cast<string>(m["DomainNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameCostShrinkRequest() = default;
};
class DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData : public Darabonba::Model {
public:
  shared_ptr<string> connected{};
  shared_ptr<string> finishGetStreamInfo{};
  shared_ptr<string> firstFrameComplete{};
  shared_ptr<string> firstPacket{};
  shared_ptr<string> initialized{};
  shared_ptr<string> timeStamp{};

  DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData() {}

  explicit DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connected) {
      res["Connected"] = boost::any(*connected);
    }
    if (finishGetStreamInfo) {
      res["FinishGetStreamInfo"] = boost::any(*finishGetStreamInfo);
    }
    if (firstFrameComplete) {
      res["FirstFrameComplete"] = boost::any(*firstFrameComplete);
    }
    if (firstPacket) {
      res["FirstPacket"] = boost::any(*firstPacket);
    }
    if (initialized) {
      res["Initialized"] = boost::any(*initialized);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Connected") != m.end() && !m["Connected"].empty()) {
      connected = make_shared<string>(boost::any_cast<string>(m["Connected"]));
    }
    if (m.find("FinishGetStreamInfo") != m.end() && !m["FinishGetStreamInfo"].empty()) {
      finishGetStreamInfo = make_shared<string>(boost::any_cast<string>(m["FinishGetStreamInfo"]));
    }
    if (m.find("FirstFrameComplete") != m.end() && !m["FirstFrameComplete"].empty()) {
      firstFrameComplete = make_shared<string>(boost::any_cast<string>(m["FirstFrameComplete"]));
    }
    if (m.find("FirstPacket") != m.end() && !m["FirstPacket"].empty()) {
      firstPacket = make_shared<string>(boost::any_cast<string>(m["FirstPacket"]));
    }
    if (m.find("Initialized") != m.end() && !m["Initialized"].empty()) {
      initialized = make_shared<string>(boost::any_cast<string>(m["Initialized"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData() = default;
};
class DescribeRTSNativeSDKFirstFrameCostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<vector<DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData>> firstFrameCostData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameCostResponseBody() {}

  explicit DescribeRTSNativeSDKFirstFrameCostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (firstFrameCostData) {
      vector<boost::any> temp1;
      for(auto item1:*firstFrameCostData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FirstFrameCostData"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FirstFrameCostData") != m.end() && !m["FirstFrameCostData"].empty()) {
      if (typeid(vector<boost::any>) == m["FirstFrameCostData"].type()) {
        vector<DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FirstFrameCostData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        firstFrameCostData = make_shared<vector<DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameCostResponseBody() = default;
};
class DescribeRTSNativeSDKFirstFrameCostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRTSNativeSDKFirstFrameCostResponseBody> body{};

  DescribeRTSNativeSDKFirstFrameCostResponse() {}

  explicit DescribeRTSNativeSDKFirstFrameCostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRTSNativeSDKFirstFrameCostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRTSNativeSDKFirstFrameCostResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameCostResponse() = default;
};
class DescribeRTSNativeSDKFirstFrameDelayRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameDelayRequest() {}

  explicit DescribeRTSNativeSDKFirstFrameDelayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameDelayRequest() = default;
};
class DescribeRTSNativeSDKFirstFrameDelayShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainNameListShrink{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameDelayShrinkRequest() {}

  explicit DescribeRTSNativeSDKFirstFrameDelayShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameListShrink) {
      res["DomainNameList"] = boost::any(*domainNameListShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      domainNameListShrink = make_shared<string>(boost::any_cast<string>(m["DomainNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameDelayShrinkRequest() = default;
};
class DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData : public Darabonba::Model {
public:
  shared_ptr<string> frameDelay{};
  shared_ptr<string> timeStamp{};

  DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData() {}

  explicit DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameDelay) {
      res["FrameDelay"] = boost::any(*frameDelay);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameDelay") != m.end() && !m["FrameDelay"].empty()) {
      frameDelay = make_shared<string>(boost::any_cast<string>(m["FrameDelay"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData() = default;
};
class DescribeRTSNativeSDKFirstFrameDelayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<vector<DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData>> frameDelayData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameDelayResponseBody() {}

  explicit DescribeRTSNativeSDKFirstFrameDelayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (frameDelayData) {
      vector<boost::any> temp1;
      for(auto item1:*frameDelayData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrameDelayData"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FrameDelayData") != m.end() && !m["FrameDelayData"].empty()) {
      if (typeid(vector<boost::any>) == m["FrameDelayData"].type()) {
        vector<DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrameDelayData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frameDelayData = make_shared<vector<DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameDelayResponseBody() = default;
};
class DescribeRTSNativeSDKFirstFrameDelayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRTSNativeSDKFirstFrameDelayResponseBody> body{};

  DescribeRTSNativeSDKFirstFrameDelayResponse() {}

  explicit DescribeRTSNativeSDKFirstFrameDelayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRTSNativeSDKFirstFrameDelayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRTSNativeSDKFirstFrameDelayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameDelayResponse() = default;
};
class DescribeRTSNativeSDKPlayFailStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayFailStatusRequest() {}

  explicit DescribeRTSNativeSDKPlayFailStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayFailStatusRequest() = default;
};
class DescribeRTSNativeSDKPlayFailStatusShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainNameListShrink{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayFailStatusShrinkRequest() {}

  explicit DescribeRTSNativeSDKPlayFailStatusShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameListShrink) {
      res["DomainNameList"] = boost::any(*domainNameListShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      domainNameListShrink = make_shared<string>(boost::any_cast<string>(m["DomainNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayFailStatusShrinkRequest() = default;
};
class DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> v20001{};
  shared_ptr<string> v20002{};
  shared_ptr<string> v20011{};
  shared_ptr<string> v20012{};
  shared_ptr<string> v20013{};
  shared_ptr<string> v20052{};

  DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus() {}

  explicit DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (v20001) {
      res["V20001"] = boost::any(*v20001);
    }
    if (v20002) {
      res["V20002"] = boost::any(*v20002);
    }
    if (v20011) {
      res["V20011"] = boost::any(*v20011);
    }
    if (v20012) {
      res["V20012"] = boost::any(*v20012);
    }
    if (v20013) {
      res["V20013"] = boost::any(*v20013);
    }
    if (v20052) {
      res["V20052"] = boost::any(*v20052);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("V20001") != m.end() && !m["V20001"].empty()) {
      v20001 = make_shared<string>(boost::any_cast<string>(m["V20001"]));
    }
    if (m.find("V20002") != m.end() && !m["V20002"].empty()) {
      v20002 = make_shared<string>(boost::any_cast<string>(m["V20002"]));
    }
    if (m.find("V20011") != m.end() && !m["V20011"].empty()) {
      v20011 = make_shared<string>(boost::any_cast<string>(m["V20011"]));
    }
    if (m.find("V20012") != m.end() && !m["V20012"].empty()) {
      v20012 = make_shared<string>(boost::any_cast<string>(m["V20012"]));
    }
    if (m.find("V20013") != m.end() && !m["V20013"].empty()) {
      v20013 = make_shared<string>(boost::any_cast<string>(m["V20013"]));
    }
    if (m.find("V20052") != m.end() && !m["V20052"].empty()) {
      v20052 = make_shared<string>(boost::any_cast<string>(m["V20052"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus() = default;
};
class DescribeRTSNativeSDKPlayFailStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<vector<DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus>> playFailStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayFailStatusResponseBody() {}

  explicit DescribeRTSNativeSDKPlayFailStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (playFailStatus) {
      vector<boost::any> temp1;
      for(auto item1:*playFailStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlayFailStatus"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PlayFailStatus") != m.end() && !m["PlayFailStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["PlayFailStatus"].type()) {
        vector<DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlayFailStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        playFailStatus = make_shared<vector<DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayFailStatusResponseBody() = default;
};
class DescribeRTSNativeSDKPlayFailStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRTSNativeSDKPlayFailStatusResponseBody> body{};

  DescribeRTSNativeSDKPlayFailStatusResponse() {}

  explicit DescribeRTSNativeSDKPlayFailStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRTSNativeSDKPlayFailStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRTSNativeSDKPlayFailStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKPlayFailStatusResponse() = default;
};
class DescribeRTSNativeSDKPlayTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayTimeRequest() {}

  explicit DescribeRTSNativeSDKPlayTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayTimeRequest() = default;
};
class DescribeRTSNativeSDKPlayTimeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainNameListShrink{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayTimeShrinkRequest() {}

  explicit DescribeRTSNativeSDKPlayTimeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameListShrink) {
      res["DomainNameList"] = boost::any(*domainNameListShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      domainNameListShrink = make_shared<string>(boost::any_cast<string>(m["DomainNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayTimeShrinkRequest() = default;
};
class DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData : public Darabonba::Model {
public:
  shared_ptr<string> playTime{};
  shared_ptr<string> stallTime{};
  shared_ptr<string> timeStamp{};

  DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData() {}

  explicit DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (playTime) {
      res["PlayTime"] = boost::any(*playTime);
    }
    if (stallTime) {
      res["StallTime"] = boost::any(*stallTime);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlayTime") != m.end() && !m["PlayTime"].empty()) {
      playTime = make_shared<string>(boost::any_cast<string>(m["PlayTime"]));
    }
    if (m.find("StallTime") != m.end() && !m["StallTime"].empty()) {
      stallTime = make_shared<string>(boost::any_cast<string>(m["StallTime"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData() = default;
};
class DescribeRTSNativeSDKPlayTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<vector<DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData>> playTimeData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayTimeResponseBody() {}

  explicit DescribeRTSNativeSDKPlayTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (playTimeData) {
      vector<boost::any> temp1;
      for(auto item1:*playTimeData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlayTimeData"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PlayTimeData") != m.end() && !m["PlayTimeData"].empty()) {
      if (typeid(vector<boost::any>) == m["PlayTimeData"].type()) {
        vector<DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlayTimeData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        playTimeData = make_shared<vector<DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayTimeResponseBody() = default;
};
class DescribeRTSNativeSDKPlayTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRTSNativeSDKPlayTimeResponseBody> body{};

  DescribeRTSNativeSDKPlayTimeResponse() {}

  explicit DescribeRTSNativeSDKPlayTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRTSNativeSDKPlayTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRTSNativeSDKPlayTimeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKPlayTimeResponse() = default;
};
class DescribeRTSNativeSDKVvDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKVvDataRequest() {}

  explicit DescribeRTSNativeSDKVvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKVvDataRequest() = default;
};
class DescribeRTSNativeSDKVvDataShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainNameListShrink{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKVvDataShrinkRequest() {}

  explicit DescribeRTSNativeSDKVvDataShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameListShrink) {
      res["DomainNameList"] = boost::any(*domainNameListShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      domainNameListShrink = make_shared<string>(boost::any_cast<string>(m["DomainNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKVvDataShrinkRequest() = default;
};
class DescribeRTSNativeSDKVvDataResponseBodyVvData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> vvSuccess{};
  shared_ptr<string> vvTotal{};

  DescribeRTSNativeSDKVvDataResponseBodyVvData() {}

  explicit DescribeRTSNativeSDKVvDataResponseBodyVvData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (vvSuccess) {
      res["VvSuccess"] = boost::any(*vvSuccess);
    }
    if (vvTotal) {
      res["VvTotal"] = boost::any(*vvTotal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("VvSuccess") != m.end() && !m["VvSuccess"].empty()) {
      vvSuccess = make_shared<string>(boost::any_cast<string>(m["VvSuccess"]));
    }
    if (m.find("VvTotal") != m.end() && !m["VvTotal"].empty()) {
      vvTotal = make_shared<string>(boost::any_cast<string>(m["VvTotal"]));
    }
  }


  virtual ~DescribeRTSNativeSDKVvDataResponseBodyVvData() = default;
};
class DescribeRTSNativeSDKVvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<vector<DescribeRTSNativeSDKVvDataResponseBodyVvData>> vvData{};

  DescribeRTSNativeSDKVvDataResponseBody() {}

  explicit DescribeRTSNativeSDKVvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (vvData) {
      vector<boost::any> temp1;
      for(auto item1:*vvData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VvData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("VvData") != m.end() && !m["VvData"].empty()) {
      if (typeid(vector<boost::any>) == m["VvData"].type()) {
        vector<DescribeRTSNativeSDKVvDataResponseBodyVvData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VvData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRTSNativeSDKVvDataResponseBodyVvData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vvData = make_shared<vector<DescribeRTSNativeSDKVvDataResponseBodyVvData>>(expect1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKVvDataResponseBody() = default;
};
class DescribeRTSNativeSDKVvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRTSNativeSDKVvDataResponseBody> body{};

  DescribeRTSNativeSDKVvDataResponse() {}

  explicit DescribeRTSNativeSDKVvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRTSNativeSDKVvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRTSNativeSDKVvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKVvDataResponse() = default;
};
class DescribeRoomKickoutUserListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> roomId{};

  DescribeRoomKickoutUserListRequest() {}

  explicit DescribeRoomKickoutUserListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~DescribeRoomKickoutUserListRequest() = default;
};
class DescribeRoomKickoutUserListResponseBodyUserList : public Darabonba::Model {
public:
  shared_ptr<string> appUid{};
  shared_ptr<string> opEndTime{};
  shared_ptr<string> opStartTime{};

  DescribeRoomKickoutUserListResponseBodyUserList() {}

  explicit DescribeRoomKickoutUserListResponseBodyUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appUid) {
      res["AppUid"] = boost::any(*appUid);
    }
    if (opEndTime) {
      res["OpEndTime"] = boost::any(*opEndTime);
    }
    if (opStartTime) {
      res["OpStartTime"] = boost::any(*opStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppUid") != m.end() && !m["AppUid"].empty()) {
      appUid = make_shared<string>(boost::any_cast<string>(m["AppUid"]));
    }
    if (m.find("OpEndTime") != m.end() && !m["OpEndTime"].empty()) {
      opEndTime = make_shared<string>(boost::any_cast<string>(m["OpEndTime"]));
    }
    if (m.find("OpStartTime") != m.end() && !m["OpStartTime"].empty()) {
      opStartTime = make_shared<string>(boost::any_cast<string>(m["OpStartTime"]));
    }
  }


  virtual ~DescribeRoomKickoutUserListResponseBodyUserList() = default;
};
class DescribeRoomKickoutUserListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};
  shared_ptr<vector<DescribeRoomKickoutUserListResponseBodyUserList>> userList{};

  DescribeRoomKickoutUserListResponseBody() {}

  explicit DescribeRoomKickoutUserListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<DescribeRoomKickoutUserListResponseBodyUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRoomKickoutUserListResponseBodyUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<DescribeRoomKickoutUserListResponseBodyUserList>>(expect1);
      }
    }
  }


  virtual ~DescribeRoomKickoutUserListResponseBody() = default;
};
class DescribeRoomKickoutUserListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRoomKickoutUserListResponseBody> body{};

  DescribeRoomKickoutUserListResponse() {}

  explicit DescribeRoomKickoutUserListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoomKickoutUserListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoomKickoutUserListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoomKickoutUserListResponse() = default;
};
class DescribeRoomListRequest : public Darabonba::Model {
public:
  shared_ptr<string> anchorId{};
  shared_ptr<string> appId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> roomId{};
  shared_ptr<long> roomStatus{};
  shared_ptr<string> startTime{};

  DescribeRoomListRequest() {}

  explicit DescribeRoomListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorId) {
      res["AnchorId"] = boost::any(*anchorId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorId") != m.end() && !m["AnchorId"].empty()) {
      anchorId = make_shared<string>(boost::any_cast<string>(m["AnchorId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRoomListRequest() = default;
};
class DescribeRoomListResponseBodyRoomList : public Darabonba::Model {
public:
  shared_ptr<string> anchorId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> forbidStream{};
  shared_ptr<string> roomId{};
  shared_ptr<long> roomStatus{};

  DescribeRoomListResponseBodyRoomList() {}

  explicit DescribeRoomListResponseBodyRoomList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorId) {
      res["AnchorId"] = boost::any(*anchorId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (forbidStream) {
      res["ForbidStream"] = boost::any(*forbidStream);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorId") != m.end() && !m["AnchorId"].empty()) {
      anchorId = make_shared<string>(boost::any_cast<string>(m["AnchorId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ForbidStream") != m.end() && !m["ForbidStream"].empty()) {
      forbidStream = make_shared<string>(boost::any_cast<string>(m["ForbidStream"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
  }


  virtual ~DescribeRoomListResponseBodyRoomList() = default;
};
class DescribeRoomListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRoomListResponseBodyRoomList>> roomList{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeRoomListResponseBody() {}

  explicit DescribeRoomListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (roomList) {
      vector<boost::any> temp1;
      for(auto item1:*roomList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RoomList"] = boost::any(temp1);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RoomList") != m.end() && !m["RoomList"].empty()) {
      if (typeid(vector<boost::any>) == m["RoomList"].type()) {
        vector<DescribeRoomListResponseBodyRoomList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RoomList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRoomListResponseBodyRoomList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roomList = make_shared<vector<DescribeRoomListResponseBodyRoomList>>(expect1);
      }
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeRoomListResponseBody() = default;
};
class DescribeRoomListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRoomListResponseBody> body{};

  DescribeRoomListResponse() {}

  explicit DescribeRoomListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoomListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoomListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoomListResponse() = default;
};
class DescribeRoomStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> roomId{};

  DescribeRoomStatusRequest() {}

  explicit DescribeRoomStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~DescribeRoomStatusRequest() = default;
};
class DescribeRoomStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> roomStatus{};

  DescribeRoomStatusResponseBody() {}

  explicit DescribeRoomStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
  }


  virtual ~DescribeRoomStatusResponseBody() = default;
};
class DescribeRoomStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRoomStatusResponseBody> body{};

  DescribeRoomStatusResponse() {}

  explicit DescribeRoomStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoomStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoomStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoomStatusResponse() = default;
};
class DescribeShowListRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  DescribeShowListRequest() {}

  explicit DescribeShowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeShowListRequest() = default;
};
class DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo : public Darabonba::Model {
public:
  shared_ptr<long> liveInputType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceUrl{};

  DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo() {}

  explicit DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveInputType) {
      res["LiveInputType"] = boost::any(*liveInputType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceUrl) {
      res["ResourceUrl"] = boost::any(*resourceUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveInputType") != m.end() && !m["LiveInputType"].empty()) {
      liveInputType = make_shared<long>(boost::any_cast<long>(m["LiveInputType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceUrl") != m.end() && !m["ResourceUrl"].empty()) {
      resourceUrl = make_shared<string>(boost::any_cast<string>(m["ResourceUrl"]));
    }
  }


  virtual ~DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo() = default;
};
class DescribeShowListResponseBodyShowListInfoShowListShow : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> repeatTimes{};
  shared_ptr<DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo> resourceInfo{};
  shared_ptr<string> showId{};
  shared_ptr<string> showName{};

  DescribeShowListResponseBodyShowListInfoShowListShow() {}

  explicit DescribeShowListResponseBodyShowListInfoShowListShow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (repeatTimes) {
      res["RepeatTimes"] = boost::any(*repeatTimes);
    }
    if (resourceInfo) {
      res["ResourceInfo"] = resourceInfo ? boost::any(resourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("RepeatTimes") != m.end() && !m["RepeatTimes"].empty()) {
      repeatTimes = make_shared<long>(boost::any_cast<long>(m["RepeatTimes"]));
    }
    if (m.find("ResourceInfo") != m.end() && !m["ResourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceInfo"].type()) {
        DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceInfo"]));
        resourceInfo = make_shared<DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo>(model1);
      }
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
  }


  virtual ~DescribeShowListResponseBodyShowListInfoShowListShow() = default;
};
class DescribeShowListResponseBodyShowListInfoShowList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeShowListResponseBodyShowListInfoShowListShow>> show{};

  DescribeShowListResponseBodyShowListInfoShowList() {}

  explicit DescribeShowListResponseBodyShowListInfoShowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (show) {
      vector<boost::any> temp1;
      for(auto item1:*show){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Show"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      if (typeid(vector<boost::any>) == m["Show"].type()) {
        vector<DescribeShowListResponseBodyShowListInfoShowListShow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Show"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeShowListResponseBodyShowListInfoShowListShow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        show = make_shared<vector<DescribeShowListResponseBodyShowListInfoShowListShow>>(expect1);
      }
    }
  }


  virtual ~DescribeShowListResponseBodyShowListInfoShowList() = default;
};
class DescribeShowListResponseBodyShowListInfo : public Darabonba::Model {
public:
  shared_ptr<string> currentShowId{};
  shared_ptr<string> highPriorityShowId{};
  shared_ptr<string> highPriorityShowStartTime{};
  shared_ptr<DescribeShowListResponseBodyShowListInfoShowList> showList{};
  shared_ptr<long> showListRepeatTimes{};
  shared_ptr<long> totalShowListRepeatTimes{};

  DescribeShowListResponseBodyShowListInfo() {}

  explicit DescribeShowListResponseBodyShowListInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentShowId) {
      res["CurrentShowId"] = boost::any(*currentShowId);
    }
    if (highPriorityShowId) {
      res["HighPriorityShowId"] = boost::any(*highPriorityShowId);
    }
    if (highPriorityShowStartTime) {
      res["HighPriorityShowStartTime"] = boost::any(*highPriorityShowStartTime);
    }
    if (showList) {
      res["ShowList"] = showList ? boost::any(showList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (showListRepeatTimes) {
      res["ShowListRepeatTimes"] = boost::any(*showListRepeatTimes);
    }
    if (totalShowListRepeatTimes) {
      res["TotalShowListRepeatTimes"] = boost::any(*totalShowListRepeatTimes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentShowId") != m.end() && !m["CurrentShowId"].empty()) {
      currentShowId = make_shared<string>(boost::any_cast<string>(m["CurrentShowId"]));
    }
    if (m.find("HighPriorityShowId") != m.end() && !m["HighPriorityShowId"].empty()) {
      highPriorityShowId = make_shared<string>(boost::any_cast<string>(m["HighPriorityShowId"]));
    }
    if (m.find("HighPriorityShowStartTime") != m.end() && !m["HighPriorityShowStartTime"].empty()) {
      highPriorityShowStartTime = make_shared<string>(boost::any_cast<string>(m["HighPriorityShowStartTime"]));
    }
    if (m.find("ShowList") != m.end() && !m["ShowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ShowList"].type()) {
        DescribeShowListResponseBodyShowListInfoShowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ShowList"]));
        showList = make_shared<DescribeShowListResponseBodyShowListInfoShowList>(model1);
      }
    }
    if (m.find("ShowListRepeatTimes") != m.end() && !m["ShowListRepeatTimes"].empty()) {
      showListRepeatTimes = make_shared<long>(boost::any_cast<long>(m["ShowListRepeatTimes"]));
    }
    if (m.find("TotalShowListRepeatTimes") != m.end() && !m["TotalShowListRepeatTimes"].empty()) {
      totalShowListRepeatTimes = make_shared<long>(boost::any_cast<long>(m["TotalShowListRepeatTimes"]));
    }
  }


  virtual ~DescribeShowListResponseBodyShowListInfo() = default;
};
class DescribeShowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> showList{};
  shared_ptr<DescribeShowListResponseBodyShowListInfo> showListInfo{};

  DescribeShowListResponseBody() {}

  explicit DescribeShowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (showList) {
      res["ShowList"] = boost::any(*showList);
    }
    if (showListInfo) {
      res["ShowListInfo"] = showListInfo ? boost::any(showListInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShowList") != m.end() && !m["ShowList"].empty()) {
      showList = make_shared<string>(boost::any_cast<string>(m["ShowList"]));
    }
    if (m.find("ShowListInfo") != m.end() && !m["ShowListInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ShowListInfo"].type()) {
        DescribeShowListResponseBodyShowListInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ShowListInfo"]));
        showListInfo = make_shared<DescribeShowListResponseBodyShowListInfo>(model1);
      }
    }
  }


  virtual ~DescribeShowListResponseBody() = default;
};
class DescribeShowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeShowListResponseBody> body{};

  DescribeShowListResponse() {}

  explicit DescribeShowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeShowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeShowListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeShowListResponse() = default;
};
class DescribeStudioLayoutsRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};

  DescribeStudioLayoutsRequest() {}

  explicit DescribeStudioLayoutsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeStudioLayoutsRequest() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> locationId{};
  shared_ptr<string> materialId{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> videoResourceId{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (videoResourceId) {
      res["VideoResourceId"] = boost::any(*videoResourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("VideoResourceId") != m.end() && !m["VideoResourceId"].empty()) {
      videoResourceId = make_shared<string>(boost::any_cast<string>(m["VideoResourceId"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> fillMode{};
  shared_ptr<double> heightNormalized{};
  shared_ptr<string> id{};
  shared_ptr<string> imageMaterialId{};
  shared_ptr<long> index{};
  shared_ptr<vector<double>> positionNormalized{};
  shared_ptr<string> positionRefer{};
  shared_ptr<string> videoResourceId{};
  shared_ptr<double> widthNormalized{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (fillMode) {
      res["FillMode"] = boost::any(*fillMode);
    }
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (imageMaterialId) {
      res["ImageMaterialId"] = boost::any(*imageMaterialId);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (positionNormalized) {
      res["PositionNormalized"] = boost::any(*positionNormalized);
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (videoResourceId) {
      res["VideoResourceId"] = boost::any(*videoResourceId);
    }
    if (widthNormalized) {
      res["WidthNormalized"] = boost::any(*widthNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("FillMode") != m.end() && !m["FillMode"].empty()) {
      fillMode = make_shared<string>(boost::any_cast<string>(m["FillMode"]));
    }
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ImageMaterialId") != m.end() && !m["ImageMaterialId"].empty()) {
      imageMaterialId = make_shared<string>(boost::any_cast<string>(m["ImageMaterialId"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["PositionNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PositionNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      positionNormalized = make_shared<vector<double>>(toVec1);
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("VideoResourceId") != m.end() && !m["VideoResourceId"].empty()) {
      videoResourceId = make_shared<string>(boost::any_cast<string>(m["VideoResourceId"]));
    }
    if (m.find("WidthNormalized") != m.end() && !m["WidthNormalized"].empty()) {
      widthNormalized = make_shared<double>(boost::any_cast<double>(m["WidthNormalized"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig : public Darabonba::Model {
public:
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList : public Darabonba::Model {
public:
  shared_ptr<DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig> audioConfig{};
  shared_ptr<string> channelId{};
  shared_ptr<string> color{};
  shared_ptr<double> heightNormalized{};
  shared_ptr<string> id{};
  shared_ptr<long> index{};
  shared_ptr<bool> onlyAudio{};
  shared_ptr<long> portraitType{};
  shared_ptr<string> positionX{};
  shared_ptr<string> positionY{};
  shared_ptr<string> videoResourceId{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioConfig) {
      res["AudioConfig"] = audioConfig ? boost::any(audioConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (onlyAudio) {
      res["OnlyAudio"] = boost::any(*onlyAudio);
    }
    if (portraitType) {
      res["PortraitType"] = boost::any(*portraitType);
    }
    if (positionX) {
      res["PositionX"] = boost::any(*positionX);
    }
    if (positionY) {
      res["PositionY"] = boost::any(*positionY);
    }
    if (videoResourceId) {
      res["VideoResourceId"] = boost::any(*videoResourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioConfig") != m.end() && !m["AudioConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioConfig"].type()) {
        DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioConfig"]));
        audioConfig = make_shared<DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig>(model1);
      }
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("OnlyAudio") != m.end() && !m["OnlyAudio"].empty()) {
      onlyAudio = make_shared<bool>(boost::any_cast<bool>(m["OnlyAudio"]));
    }
    if (m.find("PortraitType") != m.end() && !m["PortraitType"].empty()) {
      portraitType = make_shared<long>(boost::any_cast<long>(m["PortraitType"]));
    }
    if (m.find("PositionX") != m.end() && !m["PositionX"].empty()) {
      positionX = make_shared<string>(boost::any_cast<string>(m["PositionX"]));
    }
    if (m.find("PositionY") != m.end() && !m["PositionY"].empty()) {
      positionY = make_shared<string>(boost::any_cast<string>(m["PositionY"]));
    }
    if (m.find("VideoResourceId") != m.end() && !m["VideoResourceId"].empty()) {
      videoResourceId = make_shared<string>(boost::any_cast<string>(m["VideoResourceId"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayouts : public Darabonba::Model {
public:
  shared_ptr<DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig> bgImageConfig{};
  shared_ptr<DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig> commonConfig{};
  shared_ptr<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList>> layerOrderConfigList{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> layoutName{};
  shared_ptr<string> layoutType{};
  shared_ptr<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList>> mediaInputConfigList{};
  shared_ptr<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList>> screenInputConfigList{};

  DescribeStudioLayoutsResponseBodyStudioLayouts() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayouts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgImageConfig) {
      res["BgImageConfig"] = bgImageConfig ? boost::any(bgImageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (commonConfig) {
      res["CommonConfig"] = commonConfig ? boost::any(commonConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (layerOrderConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*layerOrderConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LayerOrderConfigList"] = boost::any(temp1);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (layoutName) {
      res["LayoutName"] = boost::any(*layoutName);
    }
    if (layoutType) {
      res["LayoutType"] = boost::any(*layoutType);
    }
    if (mediaInputConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInputConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInputConfigList"] = boost::any(temp1);
    }
    if (screenInputConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*screenInputConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScreenInputConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgImageConfig") != m.end() && !m["BgImageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BgImageConfig"].type()) {
        DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BgImageConfig"]));
        bgImageConfig = make_shared<DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig>(model1);
      }
    }
    if (m.find("CommonConfig") != m.end() && !m["CommonConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonConfig"].type()) {
        DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonConfig"]));
        commonConfig = make_shared<DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig>(model1);
      }
    }
    if (m.find("LayerOrderConfigList") != m.end() && !m["LayerOrderConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["LayerOrderConfigList"].type()) {
        vector<DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LayerOrderConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        layerOrderConfigList = make_shared<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList>>(expect1);
      }
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("LayoutName") != m.end() && !m["LayoutName"].empty()) {
      layoutName = make_shared<string>(boost::any_cast<string>(m["LayoutName"]));
    }
    if (m.find("LayoutType") != m.end() && !m["LayoutType"].empty()) {
      layoutType = make_shared<string>(boost::any_cast<string>(m["LayoutType"]));
    }
    if (m.find("MediaInputConfigList") != m.end() && !m["MediaInputConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInputConfigList"].type()) {
        vector<DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInputConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInputConfigList = make_shared<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList>>(expect1);
      }
    }
    if (m.find("ScreenInputConfigList") != m.end() && !m["ScreenInputConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ScreenInputConfigList"].type()) {
        vector<DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScreenInputConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        screenInputConfigList = make_shared<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList>>(expect1);
      }
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayouts() = default;
};
class DescribeStudioLayoutsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeStudioLayoutsResponseBodyStudioLayouts>> studioLayouts{};
  shared_ptr<long> total{};

  DescribeStudioLayoutsResponseBody() {}

  explicit DescribeStudioLayoutsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (studioLayouts) {
      vector<boost::any> temp1;
      for(auto item1:*studioLayouts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StudioLayouts"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StudioLayouts") != m.end() && !m["StudioLayouts"].empty()) {
      if (typeid(vector<boost::any>) == m["StudioLayouts"].type()) {
        vector<DescribeStudioLayoutsResponseBodyStudioLayouts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StudioLayouts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStudioLayoutsResponseBodyStudioLayouts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        studioLayouts = make_shared<vector<DescribeStudioLayoutsResponseBodyStudioLayouts>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBody() = default;
};
class DescribeStudioLayoutsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStudioLayoutsResponseBody> body{};

  DescribeStudioLayoutsResponse() {}

  explicit DescribeStudioLayoutsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStudioLayoutsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStudioLayoutsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStudioLayoutsResponse() = default;
};
class DescribeToutiaoLivePlayRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> stream{};

  DescribeToutiaoLivePlayRequest() {}

  explicit DescribeToutiaoLivePlayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~DescribeToutiaoLivePlayRequest() = default;
};
class DescribeToutiaoLivePlayResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<double> bandwidth{};
  shared_ptr<string> cdnName{};
  shared_ptr<string> domain{};
  shared_ptr<long> playNum{};
  shared_ptr<string> streamName{};
  shared_ptr<long> timestamp{};

  DescribeToutiaoLivePlayResponseBodyContent() {}

  explicit DescribeToutiaoLivePlayResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (cdnName) {
      res["CdnName"] = boost::any(*cdnName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (playNum) {
      res["PlayNum"] = boost::any(*playNum);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<double>(boost::any_cast<double>(m["Bandwidth"]));
    }
    if (m.find("CdnName") != m.end() && !m["CdnName"].empty()) {
      cdnName = make_shared<string>(boost::any_cast<string>(m["CdnName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("PlayNum") != m.end() && !m["PlayNum"].empty()) {
      playNum = make_shared<long>(boost::any_cast<long>(m["PlayNum"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeToutiaoLivePlayResponseBodyContent() = default;
};
class DescribeToutiaoLivePlayResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeToutiaoLivePlayResponseBodyContent>> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};

  DescribeToutiaoLivePlayResponseBody() {}

  explicit DescribeToutiaoLivePlayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeToutiaoLivePlayResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeToutiaoLivePlayResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeToutiaoLivePlayResponseBodyContent>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeToutiaoLivePlayResponseBody() = default;
};
class DescribeToutiaoLivePlayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeToutiaoLivePlayResponseBody> body{};

  DescribeToutiaoLivePlayResponse() {}

  explicit DescribeToutiaoLivePlayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeToutiaoLivePlayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeToutiaoLivePlayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeToutiaoLivePlayResponse() = default;
};
class DescribeToutiaoLivePublishRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> stream{};

  DescribeToutiaoLivePublishRequest() {}

  explicit DescribeToutiaoLivePublishRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~DescribeToutiaoLivePublishRequest() = default;
};
class DescribeToutiaoLivePublishResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<double> bitrate{};
  shared_ptr<double> bwDiff{};
  shared_ptr<string> cdnName{};
  shared_ptr<string> domain{};
  shared_ptr<double> flr{};
  shared_ptr<double> fps{};
  shared_ptr<string> streamName{};
  shared_ptr<long> timestamp{};

  DescribeToutiaoLivePublishResponseBodyContent() {}

  explicit DescribeToutiaoLivePublishResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bwDiff) {
      res["BwDiff"] = boost::any(*bwDiff);
    }
    if (cdnName) {
      res["CdnName"] = boost::any(*cdnName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (flr) {
      res["Flr"] = boost::any(*flr);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<double>(boost::any_cast<double>(m["Bitrate"]));
    }
    if (m.find("BwDiff") != m.end() && !m["BwDiff"].empty()) {
      bwDiff = make_shared<double>(boost::any_cast<double>(m["BwDiff"]));
    }
    if (m.find("CdnName") != m.end() && !m["CdnName"].empty()) {
      cdnName = make_shared<string>(boost::any_cast<string>(m["CdnName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Flr") != m.end() && !m["Flr"].empty()) {
      flr = make_shared<double>(boost::any_cast<double>(m["Flr"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<double>(boost::any_cast<double>(m["Fps"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeToutiaoLivePublishResponseBodyContent() = default;
};
class DescribeToutiaoLivePublishResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeToutiaoLivePublishResponseBodyContent>> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};

  DescribeToutiaoLivePublishResponseBody() {}

  explicit DescribeToutiaoLivePublishResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeToutiaoLivePublishResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeToutiaoLivePublishResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeToutiaoLivePublishResponseBodyContent>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeToutiaoLivePublishResponseBody() = default;
};
class DescribeToutiaoLivePublishResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeToutiaoLivePublishResponseBody> body{};

  DescribeToutiaoLivePublishResponse() {}

  explicit DescribeToutiaoLivePublishResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeToutiaoLivePublishResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeToutiaoLivePublishResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeToutiaoLivePublishResponse() = default;
};
class DescribeUpBpsPeakDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSwitch{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeUpBpsPeakDataRequest() {}

  explicit DescribeUpBpsPeakDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSwitch) {
      res["DomainSwitch"] = boost::any(*domainSwitch);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSwitch") != m.end() && !m["DomainSwitch"].empty()) {
      domainSwitch = make_shared<string>(boost::any_cast<string>(m["DomainSwitch"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeUpBpsPeakDataRequest() = default;
};
class DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic : public Darabonba::Model {
public:
  shared_ptr<string> bandWidth{};
  shared_ptr<string> peakTime{};
  shared_ptr<string> queryTime{};
  shared_ptr<string> statName{};

  DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic() {}

  explicit DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (peakTime) {
      res["PeakTime"] = boost::any(*peakTime);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    if (statName) {
      res["StatName"] = boost::any(*statName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<string>(boost::any_cast<string>(m["BandWidth"]));
    }
    if (m.find("PeakTime") != m.end() && !m["PeakTime"].empty()) {
      peakTime = make_shared<string>(boost::any_cast<string>(m["PeakTime"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<string>(boost::any_cast<string>(m["QueryTime"]));
    }
    if (m.find("StatName") != m.end() && !m["StatName"].empty()) {
      statName = make_shared<string>(boost::any_cast<string>(m["StatName"]));
    }
  }


  virtual ~DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic() = default;
};
class DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic>> describeUpPeakTraffic{};

  DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics() {}

  explicit DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpPeakTraffic) {
      vector<boost::any> temp1;
      for(auto item1:*describeUpPeakTraffic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribeUpPeakTraffic"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpPeakTraffic") != m.end() && !m["DescribeUpPeakTraffic"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribeUpPeakTraffic"].type()) {
        vector<DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribeUpPeakTraffic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describeUpPeakTraffic = make_shared<vector<DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic>>(expect1);
      }
    }
  }


  virtual ~DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics() = default;
};
class DescribeUpBpsPeakDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics> describeUpPeakTraffics{};
  shared_ptr<string> requestId{};

  DescribeUpBpsPeakDataResponseBody() {}

  explicit DescribeUpBpsPeakDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpPeakTraffics) {
      res["DescribeUpPeakTraffics"] = describeUpPeakTraffics ? boost::any(describeUpPeakTraffics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpPeakTraffics") != m.end() && !m["DescribeUpPeakTraffics"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescribeUpPeakTraffics"].type()) {
        DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescribeUpPeakTraffics"]));
        describeUpPeakTraffics = make_shared<DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUpBpsPeakDataResponseBody() = default;
};
class DescribeUpBpsPeakDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUpBpsPeakDataResponseBody> body{};

  DescribeUpBpsPeakDataResponse() {}

  explicit DescribeUpBpsPeakDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUpBpsPeakDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUpBpsPeakDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUpBpsPeakDataResponse() = default;
};
class DescribeUpBpsPeakOfLineRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSwitch{};
  shared_ptr<string> endTime{};
  shared_ptr<string> line{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeUpBpsPeakOfLineRequest() {}

  explicit DescribeUpBpsPeakOfLineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSwitch) {
      res["DomainSwitch"] = boost::any(*domainSwitch);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSwitch") != m.end() && !m["DomainSwitch"].empty()) {
      domainSwitch = make_shared<string>(boost::any_cast<string>(m["DomainSwitch"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeUpBpsPeakOfLineRequest() = default;
};
class DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine : public Darabonba::Model {
public:
  shared_ptr<double> bandWidth{};
  shared_ptr<string> peakTime{};
  shared_ptr<string> queryTime{};
  shared_ptr<string> statName{};

  DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine() {}

  explicit DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (peakTime) {
      res["PeakTime"] = boost::any(*peakTime);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    if (statName) {
      res["StatName"] = boost::any(*statName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<double>(boost::any_cast<double>(m["BandWidth"]));
    }
    if (m.find("PeakTime") != m.end() && !m["PeakTime"].empty()) {
      peakTime = make_shared<string>(boost::any_cast<string>(m["PeakTime"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<string>(boost::any_cast<string>(m["QueryTime"]));
    }
    if (m.find("StatName") != m.end() && !m["StatName"].empty()) {
      statName = make_shared<string>(boost::any_cast<string>(m["StatName"]));
    }
  }


  virtual ~DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine() = default;
};
class DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine>> describeUpBpsPeakOfLine{};

  DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines() {}

  explicit DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpBpsPeakOfLine) {
      vector<boost::any> temp1;
      for(auto item1:*describeUpBpsPeakOfLine){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribeUpBpsPeakOfLine"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpBpsPeakOfLine") != m.end() && !m["DescribeUpBpsPeakOfLine"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribeUpBpsPeakOfLine"].type()) {
        vector<DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribeUpBpsPeakOfLine"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describeUpBpsPeakOfLine = make_shared<vector<DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine>>(expect1);
      }
    }
  }


  virtual ~DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines() = default;
};
class DescribeUpBpsPeakOfLineResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines> describeUpBpsPeakOfLines{};
  shared_ptr<string> requestId{};

  DescribeUpBpsPeakOfLineResponseBody() {}

  explicit DescribeUpBpsPeakOfLineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpBpsPeakOfLines) {
      res["DescribeUpBpsPeakOfLines"] = describeUpBpsPeakOfLines ? boost::any(describeUpBpsPeakOfLines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpBpsPeakOfLines") != m.end() && !m["DescribeUpBpsPeakOfLines"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescribeUpBpsPeakOfLines"].type()) {
        DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescribeUpBpsPeakOfLines"]));
        describeUpBpsPeakOfLines = make_shared<DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUpBpsPeakOfLineResponseBody() = default;
};
class DescribeUpBpsPeakOfLineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUpBpsPeakOfLineResponseBody> body{};

  DescribeUpBpsPeakOfLineResponse() {}

  explicit DescribeUpBpsPeakOfLineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUpBpsPeakOfLineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUpBpsPeakOfLineResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUpBpsPeakOfLineResponse() = default;
};
class DescribeUpPeakPublishStreamDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSwitch{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeUpPeakPublishStreamDataRequest() {}

  explicit DescribeUpPeakPublishStreamDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSwitch) {
      res["DomainSwitch"] = boost::any(*domainSwitch);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSwitch") != m.end() && !m["DomainSwitch"].empty()) {
      domainSwitch = make_shared<string>(boost::any_cast<string>(m["DomainSwitch"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeUpPeakPublishStreamDataRequest() = default;
};
class DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData : public Darabonba::Model {
public:
  shared_ptr<string> bandWidth{};
  shared_ptr<string> peakTime{};
  shared_ptr<long> publishStreamNum{};
  shared_ptr<string> queryTime{};
  shared_ptr<string> statName{};

  DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData() {}

  explicit DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (peakTime) {
      res["PeakTime"] = boost::any(*peakTime);
    }
    if (publishStreamNum) {
      res["PublishStreamNum"] = boost::any(*publishStreamNum);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    if (statName) {
      res["StatName"] = boost::any(*statName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<string>(boost::any_cast<string>(m["BandWidth"]));
    }
    if (m.find("PeakTime") != m.end() && !m["PeakTime"].empty()) {
      peakTime = make_shared<string>(boost::any_cast<string>(m["PeakTime"]));
    }
    if (m.find("PublishStreamNum") != m.end() && !m["PublishStreamNum"].empty()) {
      publishStreamNum = make_shared<long>(boost::any_cast<long>(m["PublishStreamNum"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<string>(boost::any_cast<string>(m["QueryTime"]));
    }
    if (m.find("StatName") != m.end() && !m["StatName"].empty()) {
      statName = make_shared<string>(boost::any_cast<string>(m["StatName"]));
    }
  }


  virtual ~DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData() = default;
};
class DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData>> describeUpPeakPublishStreamData{};

  DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas() {}

  explicit DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpPeakPublishStreamData) {
      vector<boost::any> temp1;
      for(auto item1:*describeUpPeakPublishStreamData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribeUpPeakPublishStreamData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpPeakPublishStreamData") != m.end() && !m["DescribeUpPeakPublishStreamData"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribeUpPeakPublishStreamData"].type()) {
        vector<DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribeUpPeakPublishStreamData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describeUpPeakPublishStreamData = make_shared<vector<DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData>>(expect1);
      }
    }
  }


  virtual ~DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas() = default;
};
class DescribeUpPeakPublishStreamDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas> describeUpPeakPublishStreamDatas{};
  shared_ptr<string> requestId{};

  DescribeUpPeakPublishStreamDataResponseBody() {}

  explicit DescribeUpPeakPublishStreamDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpPeakPublishStreamDatas) {
      res["DescribeUpPeakPublishStreamDatas"] = describeUpPeakPublishStreamDatas ? boost::any(describeUpPeakPublishStreamDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpPeakPublishStreamDatas") != m.end() && !m["DescribeUpPeakPublishStreamDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescribeUpPeakPublishStreamDatas"].type()) {
        DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescribeUpPeakPublishStreamDatas"]));
        describeUpPeakPublishStreamDatas = make_shared<DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUpPeakPublishStreamDataResponseBody() = default;
};
class DescribeUpPeakPublishStreamDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUpPeakPublishStreamDataResponseBody> body{};

  DescribeUpPeakPublishStreamDataResponse() {}

  explicit DescribeUpPeakPublishStreamDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUpPeakPublishStreamDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUpPeakPublishStreamDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUpPeakPublishStreamDataResponse() = default;
};
class DisableLiveRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DisableLiveRealtimeLogDeliveryRequest() {}

  explicit DisableLiveRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DisableLiveRealtimeLogDeliveryRequest() = default;
};
class DisableLiveRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableLiveRealtimeLogDeliveryResponseBody() {}

  explicit DisableLiveRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableLiveRealtimeLogDeliveryResponseBody() = default;
};
class DisableLiveRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableLiveRealtimeLogDeliveryResponseBody> body{};

  DisableLiveRealtimeLogDeliveryResponse() {}

  explicit DisableLiveRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableLiveRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableLiveRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DisableLiveRealtimeLogDeliveryResponse() = default;
};
class DynamicUpdateWaterMarkStreamRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> stream{};
  shared_ptr<string> templateId{};

  DynamicUpdateWaterMarkStreamRuleRequest() {}

  explicit DynamicUpdateWaterMarkStreamRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DynamicUpdateWaterMarkStreamRuleRequest() = default;
};
class DynamicUpdateWaterMarkStreamRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DynamicUpdateWaterMarkStreamRuleResponseBody() {}

  explicit DynamicUpdateWaterMarkStreamRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DynamicUpdateWaterMarkStreamRuleResponseBody() = default;
};
class DynamicUpdateWaterMarkStreamRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DynamicUpdateWaterMarkStreamRuleResponseBody> body{};

  DynamicUpdateWaterMarkStreamRuleResponse() {}

  explicit DynamicUpdateWaterMarkStreamRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DynamicUpdateWaterMarkStreamRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DynamicUpdateWaterMarkStreamRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DynamicUpdateWaterMarkStreamRuleResponse() = default;
};
class EditPlaylistRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programConfig{};
  shared_ptr<string> programId{};
  shared_ptr<string> programItems{};

  EditPlaylistRequest() {}

  explicit EditPlaylistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programConfig) {
      res["ProgramConfig"] = boost::any(*programConfig);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programItems) {
      res["ProgramItems"] = boost::any(*programItems);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramConfig") != m.end() && !m["ProgramConfig"].empty()) {
      programConfig = make_shared<string>(boost::any_cast<string>(m["ProgramConfig"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramItems") != m.end() && !m["ProgramItems"].empty()) {
      programItems = make_shared<string>(boost::any_cast<string>(m["ProgramItems"]));
    }
  }


  virtual ~EditPlaylistRequest() = default;
};
class EditPlaylistResponseBodyItemsFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};

  EditPlaylistResponseBodyItemsFailedItems() {}

  explicit EditPlaylistResponseBodyItemsFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
  }


  virtual ~EditPlaylistResponseBodyItemsFailedItems() = default;
};
class EditPlaylistResponseBodyItemsSuccessItems : public Darabonba::Model {
public:
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};

  EditPlaylistResponseBodyItemsSuccessItems() {}

  explicit EditPlaylistResponseBodyItemsSuccessItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
  }


  virtual ~EditPlaylistResponseBodyItemsSuccessItems() = default;
};
class EditPlaylistResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<EditPlaylistResponseBodyItemsFailedItems>> failedItems{};
  shared_ptr<vector<EditPlaylistResponseBodyItemsSuccessItems>> successItems{};

  EditPlaylistResponseBodyItems() {}

  explicit EditPlaylistResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successItems) {
      vector<boost::any> temp1;
      for(auto item1:*successItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuccessItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<EditPlaylistResponseBodyItemsFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EditPlaylistResponseBodyItemsFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<EditPlaylistResponseBodyItemsFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessItems") != m.end() && !m["SuccessItems"].empty()) {
      if (typeid(vector<boost::any>) == m["SuccessItems"].type()) {
        vector<EditPlaylistResponseBodyItemsSuccessItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuccessItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EditPlaylistResponseBodyItemsSuccessItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        successItems = make_shared<vector<EditPlaylistResponseBodyItemsSuccessItems>>(expect1);
      }
    }
  }


  virtual ~EditPlaylistResponseBodyItems() = default;
};
class EditPlaylistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<EditPlaylistResponseBodyItems> items{};
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  EditPlaylistResponseBody() {}

  explicit EditPlaylistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        EditPlaylistResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<EditPlaylistResponseBodyItems>(model1);
      }
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EditPlaylistResponseBody() = default;
};
class EditPlaylistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EditPlaylistResponseBody> body{};

  EditPlaylistResponse() {}

  explicit EditPlaylistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EditPlaylistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EditPlaylistResponseBody>(model1);
      }
    }
  }


  virtual ~EditPlaylistResponse() = default;
};
class EditShowAndReplaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<double> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> showId{};
  shared_ptr<double> startTime{};
  shared_ptr<string> storageInfo{};
  shared_ptr<string> userData{};

  EditShowAndReplaceRequest() {}

  explicit EditShowAndReplaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (storageInfo) {
      res["StorageInfo"] = boost::any(*storageInfo);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<double>(boost::any_cast<double>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("StorageInfo") != m.end() && !m["StorageInfo"].empty()) {
      storageInfo = make_shared<string>(boost::any_cast<string>(m["StorageInfo"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~EditShowAndReplaceRequest() = default;
};
class EditShowAndReplaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobInfo{};
  shared_ptr<string> requestId{};

  EditShowAndReplaceResponseBody() {}

  explicit EditShowAndReplaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobInfo) {
      res["JobInfo"] = boost::any(*jobInfo);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobInfo") != m.end() && !m["JobInfo"].empty()) {
      jobInfo = make_shared<string>(boost::any_cast<string>(m["JobInfo"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EditShowAndReplaceResponseBody() = default;
};
class EditShowAndReplaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EditShowAndReplaceResponseBody> body{};

  EditShowAndReplaceResponse() {}

  explicit EditShowAndReplaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EditShowAndReplaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EditShowAndReplaceResponseBody>(model1);
      }
    }
  }


  virtual ~EditShowAndReplaceResponse() = default;
};
class EffectCasterUrgentRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sceneId{};

  EffectCasterUrgentRequest() {}

  explicit EffectCasterUrgentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~EffectCasterUrgentRequest() = default;
};
class EffectCasterUrgentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EffectCasterUrgentResponseBody() {}

  explicit EffectCasterUrgentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EffectCasterUrgentResponseBody() = default;
};
class EffectCasterUrgentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EffectCasterUrgentResponseBody> body{};

  EffectCasterUrgentResponse() {}

  explicit EffectCasterUrgentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EffectCasterUrgentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EffectCasterUrgentResponseBody>(model1);
      }
    }
  }


  virtual ~EffectCasterUrgentResponse() = default;
};
class EffectCasterVideoResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> sceneId{};

  EffectCasterVideoResourceRequest() {}

  explicit EffectCasterVideoResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~EffectCasterVideoResourceRequest() = default;
};
class EffectCasterVideoResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EffectCasterVideoResourceResponseBody() {}

  explicit EffectCasterVideoResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EffectCasterVideoResourceResponseBody() = default;
};
class EffectCasterVideoResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EffectCasterVideoResourceResponseBody> body{};

  EffectCasterVideoResourceResponse() {}

  explicit EffectCasterVideoResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EffectCasterVideoResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EffectCasterVideoResourceResponseBody>(model1);
      }
    }
  }


  virtual ~EffectCasterVideoResourceResponse() = default;
};
class EnableLiveRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  EnableLiveRealtimeLogDeliveryRequest() {}

  explicit EnableLiveRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~EnableLiveRealtimeLogDeliveryRequest() = default;
};
class EnableLiveRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableLiveRealtimeLogDeliveryResponseBody() {}

  explicit EnableLiveRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableLiveRealtimeLogDeliveryResponseBody() = default;
};
class EnableLiveRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableLiveRealtimeLogDeliveryResponseBody> body{};

  EnableLiveRealtimeLogDeliveryResponse() {}

  explicit EnableLiveRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableLiveRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableLiveRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~EnableLiveRealtimeLogDeliveryResponse() = default;
};
class ForbidLiveStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveStreamType{};
  shared_ptr<string> oneshot{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resumeTime{};
  shared_ptr<string> streamName{};

  ForbidLiveStreamRequest() {}

  explicit ForbidLiveStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveStreamType) {
      res["LiveStreamType"] = boost::any(*liveStreamType);
    }
    if (oneshot) {
      res["Oneshot"] = boost::any(*oneshot);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resumeTime) {
      res["ResumeTime"] = boost::any(*resumeTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveStreamType") != m.end() && !m["LiveStreamType"].empty()) {
      liveStreamType = make_shared<string>(boost::any_cast<string>(m["LiveStreamType"]));
    }
    if (m.find("Oneshot") != m.end() && !m["Oneshot"].empty()) {
      oneshot = make_shared<string>(boost::any_cast<string>(m["Oneshot"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResumeTime") != m.end() && !m["ResumeTime"].empty()) {
      resumeTime = make_shared<string>(boost::any_cast<string>(m["ResumeTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~ForbidLiveStreamRequest() = default;
};
class ForbidLiveStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ForbidLiveStreamResponseBody() {}

  explicit ForbidLiveStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ForbidLiveStreamResponseBody() = default;
};
class ForbidLiveStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ForbidLiveStreamResponseBody> body{};

  ForbidLiveStreamResponse() {}

  explicit ForbidLiveStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ForbidLiveStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ForbidLiveStreamResponseBody>(model1);
      }
    }
  }


  virtual ~ForbidLiveStreamResponse() = default;
};
class ForbidPushStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> roomId{};
  shared_ptr<string> userData{};

  ForbidPushStreamRequest() {}

  explicit ForbidPushStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ForbidPushStreamRequest() = default;
};
class ForbidPushStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ForbidPushStreamResponseBody() {}

  explicit ForbidPushStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ForbidPushStreamResponseBody() = default;
};
class ForbidPushStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ForbidPushStreamResponseBody> body{};

  ForbidPushStreamResponse() {}

  explicit ForbidPushStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ForbidPushStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ForbidPushStreamResponseBody>(model1);
      }
    }
  }


  virtual ~ForbidPushStreamResponse() = default;
};
class GetAllCustomTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> userId{};

  GetAllCustomTemplatesRequest() {}

  explicit GetAllCustomTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetAllCustomTemplatesRequest() = default;
};
class GetAllCustomTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> customTemplates{};
  shared_ptr<string> requestId{};

  GetAllCustomTemplatesResponseBody() {}

  explicit GetAllCustomTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplates) {
      res["CustomTemplates"] = boost::any(*customTemplates);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplates") != m.end() && !m["CustomTemplates"].empty()) {
      customTemplates = make_shared<string>(boost::any_cast<string>(m["CustomTemplates"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAllCustomTemplatesResponseBody() = default;
};
class GetAllCustomTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAllCustomTemplatesResponseBody> body{};

  GetAllCustomTemplatesResponse() {}

  explicit GetAllCustomTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAllCustomTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAllCustomTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~GetAllCustomTemplatesResponse() = default;
};
class GetCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> template_{};

  GetCustomTemplateRequest() {}

  explicit GetCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~GetCustomTemplateRequest() = default;
};
class GetCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> customTemplate{};
  shared_ptr<string> requestId{};
  shared_ptr<string> template_{};

  GetCustomTemplateResponseBody() {}

  explicit GetCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplate) {
      res["CustomTemplate"] = boost::any(*customTemplate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplate") != m.end() && !m["CustomTemplate"].empty()) {
      customTemplate = make_shared<string>(boost::any_cast<string>(m["CustomTemplate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~GetCustomTemplateResponseBody() = default;
};
class GetCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomTemplateResponseBody> body{};

  GetCustomTemplateResponse() {}

  explicit GetCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomTemplateResponse() = default;
};
class GetEditingJobInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> showId{};

  GetEditingJobInfoRequest() {}

  explicit GetEditingJobInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
  }


  virtual ~GetEditingJobInfoRequest() = default;
};
class GetEditingJobInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> editingTasksInfo{};
  shared_ptr<string> requestId{};

  GetEditingJobInfoResponseBody() {}

  explicit GetEditingJobInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (editingTasksInfo) {
      res["EditingTasksInfo"] = boost::any(*editingTasksInfo);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EditingTasksInfo") != m.end() && !m["EditingTasksInfo"].empty()) {
      editingTasksInfo = make_shared<string>(boost::any_cast<string>(m["EditingTasksInfo"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEditingJobInfoResponseBody() = default;
};
class GetEditingJobInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEditingJobInfoResponseBody> body{};

  GetEditingJobInfoResponse() {}

  explicit GetEditingJobInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEditingJobInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEditingJobInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetEditingJobInfoResponse() = default;
};
class GetMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetMessageAppRequest() {}

  explicit GetMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetMessageAppRequest() = default;
};
class GetMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> appConfig{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<map<string, string>> extension{};
  shared_ptr<long> status{};

  GetMessageAppResponseBodyResult() {}

  explicit GetMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["AppConfig"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      appConfig = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetMessageAppResponseBodyResult() = default;
};
class GetMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMessageAppResponseBodyResult> result{};

  GetMessageAppResponseBody() {}

  explicit GetMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetMessageAppResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetMessageAppResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetMessageAppResponseBody() = default;
};
class GetMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMessageAppResponseBody> body{};

  GetMessageAppResponse() {}

  explicit GetMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~GetMessageAppResponse() = default;
};
class GetMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};

  GetMessageGroupRequest() {}

  explicit GetMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~GetMessageGroupRequest() = default;
};
class GetMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<map<string, boost::any>> extension{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> isMuteAll{};
  shared_ptr<long> status{};

  GetMessageGroupResponseBodyResult() {}

  explicit GetMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isMuteAll) {
      res["IsMuteAll"] = boost::any(*isMuteAll);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Extension"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsMuteAll") != m.end() && !m["IsMuteAll"].empty()) {
      isMuteAll = make_shared<bool>(boost::any_cast<bool>(m["IsMuteAll"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetMessageGroupResponseBodyResult() = default;
};
class GetMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMessageGroupResponseBodyResult> result{};

  GetMessageGroupResponseBody() {}

  explicit GetMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetMessageGroupResponseBody() = default;
};
class GetMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMessageGroupResponseBody> body{};

  GetMessageGroupResponse() {}

  explicit GetMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetMessageGroupResponse() = default;
};
class GetMessageTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> userId{};

  GetMessageTokenRequest() {}

  explicit GetMessageTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetMessageTokenRequest() = default;
};
class GetMessageTokenResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<long> accessTokenExpiredTime{};
  shared_ptr<string> refreshToken{};

  GetMessageTokenResponseBodyResult() {}

  explicit GetMessageTokenResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (accessTokenExpiredTime) {
      res["AccessTokenExpiredTime"] = boost::any(*accessTokenExpiredTime);
    }
    if (refreshToken) {
      res["RefreshToken"] = boost::any(*refreshToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("AccessTokenExpiredTime") != m.end() && !m["AccessTokenExpiredTime"].empty()) {
      accessTokenExpiredTime = make_shared<long>(boost::any_cast<long>(m["AccessTokenExpiredTime"]));
    }
    if (m.find("RefreshToken") != m.end() && !m["RefreshToken"].empty()) {
      refreshToken = make_shared<string>(boost::any_cast<string>(m["RefreshToken"]));
    }
  }


  virtual ~GetMessageTokenResponseBodyResult() = default;
};
class GetMessageTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMessageTokenResponseBodyResult> result{};

  GetMessageTokenResponseBody() {}

  explicit GetMessageTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetMessageTokenResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetMessageTokenResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetMessageTokenResponseBody() = default;
};
class GetMessageTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMessageTokenResponseBody> body{};

  GetMessageTokenResponse() {}

  explicit GetMessageTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMessageTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMessageTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GetMessageTokenResponse() = default;
};
class GetMultiRateConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> ownerId{};

  GetMultiRateConfigRequest() {}

  explicit GetMultiRateConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~GetMultiRateConfigRequest() = default;
};
class GetMultiRateConfigResponseBodyTemplatesInfoDetail : public Darabonba::Model {
public:
  shared_ptr<long> audioBitrate{};
  shared_ptr<long> audioChannelNum{};
  shared_ptr<string> audioCodec{};
  shared_ptr<string> audioProfile{};
  shared_ptr<long> audioRate{};
  shared_ptr<long> bandWidth{};
  shared_ptr<long> fps{};
  shared_ptr<string> gop{};
  shared_ptr<long> height{};
  shared_ptr<long> profile{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<long> width{};

  GetMultiRateConfigResponseBodyTemplatesInfoDetail() {}

  explicit GetMultiRateConfigResponseBodyTemplatesInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannelNum) {
      res["AudioChannelNum"] = boost::any(*audioChannelNum);
    }
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioProfile) {
      res["AudioProfile"] = boost::any(*audioProfile);
    }
    if (audioRate) {
      res["AudioRate"] = boost::any(*audioRate);
    }
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<long>(boost::any_cast<long>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannelNum") != m.end() && !m["AudioChannelNum"].empty()) {
      audioChannelNum = make_shared<long>(boost::any_cast<long>(m["AudioChannelNum"]));
    }
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioProfile") != m.end() && !m["AudioProfile"].empty()) {
      audioProfile = make_shared<string>(boost::any_cast<string>(m["AudioProfile"]));
    }
    if (m.find("AudioRate") != m.end() && !m["AudioRate"].empty()) {
      audioRate = make_shared<long>(boost::any_cast<long>(m["AudioRate"]));
    }
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<long>(boost::any_cast<long>(m["BandWidth"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<long>(boost::any_cast<long>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<long>(boost::any_cast<long>(m["Profile"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetMultiRateConfigResponseBodyTemplatesInfoDetail() = default;
};
class GetMultiRateConfigResponseBodyTemplatesInfo : public Darabonba::Model {
public:
  shared_ptr<vector<GetMultiRateConfigResponseBodyTemplatesInfoDetail>> detail{};

  GetMultiRateConfigResponseBodyTemplatesInfo() {}

  explicit GetMultiRateConfigResponseBodyTemplatesInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<GetMultiRateConfigResponseBodyTemplatesInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultiRateConfigResponseBodyTemplatesInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<GetMultiRateConfigResponseBodyTemplatesInfoDetail>>(expect1);
      }
    }
  }


  virtual ~GetMultiRateConfigResponseBodyTemplatesInfo() = default;
};
class GetMultiRateConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> avFormat{};
  shared_ptr<long> code{};
  shared_ptr<string> domain{};
  shared_ptr<string> groupId{};
  shared_ptr<string> isLazy{};
  shared_ptr<string> isTimeAlign{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> stream{};
  shared_ptr<GetMultiRateConfigResponseBodyTemplatesInfo> templatesInfo{};

  GetMultiRateConfigResponseBody() {}

  explicit GetMultiRateConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (avFormat) {
      res["AvFormat"] = boost::any(*avFormat);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isLazy) {
      res["IsLazy"] = boost::any(*isLazy);
    }
    if (isTimeAlign) {
      res["IsTimeAlign"] = boost::any(*isTimeAlign);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (templatesInfo) {
      res["TemplatesInfo"] = templatesInfo ? boost::any(templatesInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("AvFormat") != m.end() && !m["AvFormat"].empty()) {
      avFormat = make_shared<string>(boost::any_cast<string>(m["AvFormat"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsLazy") != m.end() && !m["IsLazy"].empty()) {
      isLazy = make_shared<string>(boost::any_cast<string>(m["IsLazy"]));
    }
    if (m.find("IsTimeAlign") != m.end() && !m["IsTimeAlign"].empty()) {
      isTimeAlign = make_shared<string>(boost::any_cast<string>(m["IsTimeAlign"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TemplatesInfo") != m.end() && !m["TemplatesInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplatesInfo"].type()) {
        GetMultiRateConfigResponseBodyTemplatesInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplatesInfo"]));
        templatesInfo = make_shared<GetMultiRateConfigResponseBodyTemplatesInfo>(model1);
      }
    }
  }


  virtual ~GetMultiRateConfigResponseBody() = default;
};
class GetMultiRateConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMultiRateConfigResponseBody> body{};

  GetMultiRateConfigResponse() {}

  explicit GetMultiRateConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMultiRateConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMultiRateConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetMultiRateConfigResponse() = default;
};
class GetMultiRateConfigListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  GetMultiRateConfigListRequest() {}

  explicit GetMultiRateConfigListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~GetMultiRateConfigListRequest() = default;
};
class GetMultiRateConfigListResponseBodyGroupInfoInfo : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> avFormat{};
  shared_ptr<long> count{};
  shared_ptr<string> groupId{};

  GetMultiRateConfigListResponseBodyGroupInfoInfo() {}

  explicit GetMultiRateConfigListResponseBodyGroupInfoInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (avFormat) {
      res["AvFormat"] = boost::any(*avFormat);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("AvFormat") != m.end() && !m["AvFormat"].empty()) {
      avFormat = make_shared<string>(boost::any_cast<string>(m["AvFormat"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~GetMultiRateConfigListResponseBodyGroupInfoInfo() = default;
};
class GetMultiRateConfigListResponseBodyGroupInfo : public Darabonba::Model {
public:
  shared_ptr<vector<GetMultiRateConfigListResponseBodyGroupInfoInfo>> info{};

  GetMultiRateConfigListResponseBodyGroupInfo() {}

  explicit GetMultiRateConfigListResponseBodyGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(vector<boost::any>) == m["Info"].type()) {
        vector<GetMultiRateConfigListResponseBodyGroupInfoInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultiRateConfigListResponseBodyGroupInfoInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<GetMultiRateConfigListResponseBodyGroupInfoInfo>>(expect1);
      }
    }
  }


  virtual ~GetMultiRateConfigListResponseBodyGroupInfo() = default;
};
class GetMultiRateConfigListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetMultiRateConfigListResponseBodyGroupInfo> groupInfo{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetMultiRateConfigListResponseBody() {}

  explicit GetMultiRateConfigListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (groupInfo) {
      res["GroupInfo"] = groupInfo ? boost::any(groupInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupInfo"].type()) {
        GetMultiRateConfigListResponseBodyGroupInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupInfo"]));
        groupInfo = make_shared<GetMultiRateConfigListResponseBodyGroupInfo>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMultiRateConfigListResponseBody() = default;
};
class GetMultiRateConfigListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMultiRateConfigListResponseBody> body{};

  GetMultiRateConfigListResponse() {}

  explicit GetMultiRateConfigListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMultiRateConfigListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMultiRateConfigListResponseBody>(model1);
      }
    }
  }


  virtual ~GetMultiRateConfigListResponse() = default;
};
class HotLiveRtcStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> audioMsid{};
  shared_ptr<string> connectionTimeout{};
  shared_ptr<string> domainName{};
  shared_ptr<string> mediaTimeout{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionCode{};
  shared_ptr<string> streamName{};
  shared_ptr<string> videoMsid{};

  HotLiveRtcStreamRequest() {}

  explicit HotLiveRtcStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (audioMsid) {
      res["AudioMsid"] = boost::any(*audioMsid);
    }
    if (connectionTimeout) {
      res["ConnectionTimeout"] = boost::any(*connectionTimeout);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (mediaTimeout) {
      res["MediaTimeout"] = boost::any(*mediaTimeout);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionCode) {
      res["RegionCode"] = boost::any(*regionCode);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (videoMsid) {
      res["VideoMsid"] = boost::any(*videoMsid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AudioMsid") != m.end() && !m["AudioMsid"].empty()) {
      audioMsid = make_shared<string>(boost::any_cast<string>(m["AudioMsid"]));
    }
    if (m.find("ConnectionTimeout") != m.end() && !m["ConnectionTimeout"].empty()) {
      connectionTimeout = make_shared<string>(boost::any_cast<string>(m["ConnectionTimeout"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MediaTimeout") != m.end() && !m["MediaTimeout"].empty()) {
      mediaTimeout = make_shared<string>(boost::any_cast<string>(m["MediaTimeout"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionCode") != m.end() && !m["RegionCode"].empty()) {
      regionCode = make_shared<string>(boost::any_cast<string>(m["RegionCode"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("VideoMsid") != m.end() && !m["VideoMsid"].empty()) {
      videoMsid = make_shared<string>(boost::any_cast<string>(m["VideoMsid"]));
    }
  }


  virtual ~HotLiveRtcStreamRequest() = default;
};
class HotLiveRtcStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  HotLiveRtcStreamResponseBody() {}

  explicit HotLiveRtcStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~HotLiveRtcStreamResponseBody() = default;
};
class HotLiveRtcStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotLiveRtcStreamResponseBody> body{};

  HotLiveRtcStreamResponse() {}

  explicit HotLiveRtcStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotLiveRtcStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotLiveRtcStreamResponseBody>(model1);
      }
    }
  }


  virtual ~HotLiveRtcStreamResponse() = default;
};
class InitializeAutoShowListTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> callBackUrl{};
  shared_ptr<string> casterConfig{};
  shared_ptr<string> domainName{};
  shared_ptr<long> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceIds{};
  shared_ptr<long> startTime{};

  InitializeAutoShowListTaskRequest() {}

  explicit InitializeAutoShowListTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callBackUrl) {
      res["CallBackUrl"] = boost::any(*callBackUrl);
    }
    if (casterConfig) {
      res["CasterConfig"] = boost::any(*casterConfig);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallBackUrl") != m.end() && !m["CallBackUrl"].empty()) {
      callBackUrl = make_shared<string>(boost::any_cast<string>(m["CallBackUrl"]));
    }
    if (m.find("CasterConfig") != m.end() && !m["CasterConfig"].empty()) {
      casterConfig = make_shared<string>(boost::any_cast<string>(m["CasterConfig"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~InitializeAutoShowListTaskRequest() = default;
};
class InitializeAutoShowListTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> streamList{};

  InitializeAutoShowListTaskResponseBody() {}

  explicit InitializeAutoShowListTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamList) {
      res["StreamList"] = boost::any(*streamList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamList") != m.end() && !m["StreamList"].empty()) {
      streamList = make_shared<string>(boost::any_cast<string>(m["StreamList"]));
    }
  }


  virtual ~InitializeAutoShowListTaskResponseBody() = default;
};
class InitializeAutoShowListTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitializeAutoShowListTaskResponseBody> body{};

  InitializeAutoShowListTaskResponse() {}

  explicit InitializeAutoShowListTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitializeAutoShowListTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitializeAutoShowListTaskResponseBody>(model1);
      }
    }
  }


  virtual ~InitializeAutoShowListTaskResponse() = default;
};
class JoinMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> broadCastStatistics{};
  shared_ptr<long> broadCastType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> userId{};

  JoinMessageGroupRequest() {}

  explicit JoinMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastStatistics) {
      res["BroadCastStatistics"] = boost::any(*broadCastStatistics);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastStatistics") != m.end() && !m["BroadCastStatistics"].empty()) {
      broadCastStatistics = make_shared<bool>(boost::any_cast<bool>(m["BroadCastStatistics"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~JoinMessageGroupRequest() = default;
};
class JoinMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  JoinMessageGroupResponseBodyResult() {}

  explicit JoinMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~JoinMessageGroupResponseBodyResult() = default;
};
class JoinMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<JoinMessageGroupResponseBodyResult> result{};

  JoinMessageGroupResponseBody() {}

  explicit JoinMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        JoinMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<JoinMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~JoinMessageGroupResponseBody() = default;
};
class JoinMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinMessageGroupResponseBody> body{};

  JoinMessageGroupResponse() {}

  explicit JoinMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~JoinMessageGroupResponse() = default;
};
class LeaveMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> broadCastStatistics{};
  shared_ptr<long> broadCastType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> userId{};

  LeaveMessageGroupRequest() {}

  explicit LeaveMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastStatistics) {
      res["BroadCastStatistics"] = boost::any(*broadCastStatistics);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastStatistics") != m.end() && !m["BroadCastStatistics"].empty()) {
      broadCastStatistics = make_shared<bool>(boost::any_cast<bool>(m["BroadCastStatistics"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~LeaveMessageGroupRequest() = default;
};
class LeaveMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  LeaveMessageGroupResponseBodyResult() {}

  explicit LeaveMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~LeaveMessageGroupResponseBodyResult() = default;
};
class LeaveMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<LeaveMessageGroupResponseBodyResult> result{};

  LeaveMessageGroupResponseBody() {}

  explicit LeaveMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        LeaveMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<LeaveMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~LeaveMessageGroupResponseBody() = default;
};
class LeaveMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LeaveMessageGroupResponseBody> body{};

  LeaveMessageGroupResponse() {}

  explicit LeaveMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LeaveMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LeaveMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~LeaveMessageGroupResponse() = default;
};
class ListLiveRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveOpenapiReserve{};
  shared_ptr<long> ownerId{};

  ListLiveRealtimeLogDeliveryRequest() {}

  explicit ListLiveRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveOpenapiReserve) {
      res["LiveOpenapiReserve"] = boost::any(*liveOpenapiReserve);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveOpenapiReserve") != m.end() && !m["LiveOpenapiReserve"].empty()) {
      liveOpenapiReserve = make_shared<string>(boost::any_cast<string>(m["LiveOpenapiReserve"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryRequest() = default;
};
class ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo : public Darabonba::Model {
public:
  shared_ptr<long> dmId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};

  ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo() {}

  explicit ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dmId) {
      res["DmId"] = boost::any(*dmId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DmId") != m.end() && !m["DmId"].empty()) {
      dmId = make_shared<long>(boost::any_cast<long>(m["DmId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo() = default;
};
class ListLiveRealtimeLogDeliveryResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo>> realtimeLogDeliveryInfo{};

  ListLiveRealtimeLogDeliveryResponseBodyContent() {}

  explicit ListLiveRealtimeLogDeliveryResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realtimeLogDeliveryInfo) {
      vector<boost::any> temp1;
      for(auto item1:*realtimeLogDeliveryInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealtimeLogDeliveryInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealtimeLogDeliveryInfo") != m.end() && !m["RealtimeLogDeliveryInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RealtimeLogDeliveryInfo"].type()) {
        vector<ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealtimeLogDeliveryInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realtimeLogDeliveryInfo = make_shared<vector<ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo>>(expect1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryResponseBodyContent() = default;
};
class ListLiveRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListLiveRealtimeLogDeliveryResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  ListLiveRealtimeLogDeliveryResponseBody() {}

  explicit ListLiveRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        ListLiveRealtimeLogDeliveryResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<ListLiveRealtimeLogDeliveryResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryResponseBody() = default;
};
class ListLiveRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRealtimeLogDeliveryResponseBody> body{};

  ListLiveRealtimeLogDeliveryResponse() {}

  explicit ListLiveRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryResponse() = default;
};
class ListLiveRealtimeLogDeliveryDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  ListLiveRealtimeLogDeliveryDomainsRequest() {}

  explicit ListLiveRealtimeLogDeliveryDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryDomainsRequest() = default;
};
class ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> status{};

  ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains() {}

  explicit ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains() = default;
};
class ListLiveRealtimeLogDeliveryDomainsResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains>> domains{};

  ListLiveRealtimeLogDeliveryDomainsResponseBodyContent() {}

  explicit ListLiveRealtimeLogDeliveryDomainsResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains>>(expect1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryDomainsResponseBodyContent() = default;
};
class ListLiveRealtimeLogDeliveryDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListLiveRealtimeLogDeliveryDomainsResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  ListLiveRealtimeLogDeliveryDomainsResponseBody() {}

  explicit ListLiveRealtimeLogDeliveryDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        ListLiveRealtimeLogDeliveryDomainsResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<ListLiveRealtimeLogDeliveryDomainsResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryDomainsResponseBody() = default;
};
class ListLiveRealtimeLogDeliveryDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRealtimeLogDeliveryDomainsResponseBody> body{};

  ListLiveRealtimeLogDeliveryDomainsResponse() {}

  explicit ListLiveRealtimeLogDeliveryDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRealtimeLogDeliveryDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRealtimeLogDeliveryDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryDomainsResponse() = default;
};
class ListLiveRealtimeLogDeliveryInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveOpenapiReserve{};
  shared_ptr<long> ownerId{};

  ListLiveRealtimeLogDeliveryInfosRequest() {}

  explicit ListLiveRealtimeLogDeliveryInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveOpenapiReserve) {
      res["LiveOpenapiReserve"] = boost::any(*liveOpenapiReserve);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveOpenapiReserve") != m.end() && !m["LiveOpenapiReserve"].empty()) {
      liveOpenapiReserve = make_shared<string>(boost::any_cast<string>(m["LiveOpenapiReserve"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryInfosRequest() = default;
};
class ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos() {}

  explicit ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos() = default;
};
class ListLiveRealtimeLogDeliveryInfosResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos>> realtimeLogDeliveryInfos{};

  ListLiveRealtimeLogDeliveryInfosResponseBodyContent() {}

  explicit ListLiveRealtimeLogDeliveryInfosResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realtimeLogDeliveryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*realtimeLogDeliveryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealtimeLogDeliveryInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealtimeLogDeliveryInfos") != m.end() && !m["RealtimeLogDeliveryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["RealtimeLogDeliveryInfos"].type()) {
        vector<ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealtimeLogDeliveryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realtimeLogDeliveryInfos = make_shared<vector<ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos>>(expect1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryInfosResponseBodyContent() = default;
};
class ListLiveRealtimeLogDeliveryInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListLiveRealtimeLogDeliveryInfosResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  ListLiveRealtimeLogDeliveryInfosResponseBody() {}

  explicit ListLiveRealtimeLogDeliveryInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        ListLiveRealtimeLogDeliveryInfosResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<ListLiveRealtimeLogDeliveryInfosResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryInfosResponseBody() = default;
};
class ListLiveRealtimeLogDeliveryInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRealtimeLogDeliveryInfosResponseBody> body{};

  ListLiveRealtimeLogDeliveryInfosResponse() {}

  explicit ListLiveRealtimeLogDeliveryInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRealtimeLogDeliveryInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRealtimeLogDeliveryInfosResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryInfosResponse() = default;
};
class ListMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};
  shared_ptr<long> type{};

  ListMessageRequest() {}

  explicit ListMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ListMessageRequest() = default;
};
class ListMessageResponseBodyResultMessageList : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> groupId{};
  shared_ptr<string> messageId{};
  shared_ptr<string> senderId{};
  shared_ptr<long> type{};

  ListMessageResponseBodyResultMessageList() {}

  explicit ListMessageResponseBodyResultMessageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (senderId) {
      res["SenderId"] = boost::any(*senderId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("SenderId") != m.end() && !m["SenderId"].empty()) {
      senderId = make_shared<string>(boost::any_cast<string>(m["SenderId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ListMessageResponseBodyResultMessageList() = default;
};
class ListMessageResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<ListMessageResponseBodyResultMessageList>> messageList{};

  ListMessageResponseBodyResult() {}

  explicit ListMessageResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (messageList) {
      vector<boost::any> temp1;
      for(auto item1:*messageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MessageList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("MessageList") != m.end() && !m["MessageList"].empty()) {
      if (typeid(vector<boost::any>) == m["MessageList"].type()) {
        vector<ListMessageResponseBodyResultMessageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MessageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageResponseBodyResultMessageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messageList = make_shared<vector<ListMessageResponseBodyResultMessageList>>(expect1);
      }
    }
  }


  virtual ~ListMessageResponseBodyResult() = default;
};
class ListMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMessageResponseBodyResult> result{};

  ListMessageResponseBody() {}

  explicit ListMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListMessageResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListMessageResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListMessageResponseBody() = default;
};
class ListMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMessageResponseBody> body{};

  ListMessageResponse() {}

  explicit ListMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageResponse() = default;
};
class ListMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};

  ListMessageAppRequest() {}

  explicit ListMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
  }


  virtual ~ListMessageAppRequest() = default;
};
class ListMessageAppResponseBodyResultAppList : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> appConfig{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<map<string, string>> extension{};
  shared_ptr<long> status{};

  ListMessageAppResponseBodyResultAppList() {}

  explicit ListMessageAppResponseBodyResultAppList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["AppConfig"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      appConfig = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListMessageAppResponseBodyResultAppList() = default;
};
class ListMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListMessageAppResponseBodyResultAppList>> appList{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> total{};

  ListMessageAppResponseBodyResult() {}

  explicit ListMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appList) {
      vector<boost::any> temp1;
      for(auto item1:*appList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppList"] = boost::any(temp1);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppList") != m.end() && !m["AppList"].empty()) {
      if (typeid(vector<boost::any>) == m["AppList"].type()) {
        vector<ListMessageAppResponseBodyResultAppList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageAppResponseBodyResultAppList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appList = make_shared<vector<ListMessageAppResponseBodyResultAppList>>(expect1);
      }
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListMessageAppResponseBodyResult() = default;
};
class ListMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMessageAppResponseBodyResult> result{};

  ListMessageAppResponseBody() {}

  explicit ListMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListMessageAppResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListMessageAppResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListMessageAppResponseBody() = default;
};
class ListMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMessageAppResponseBody> body{};

  ListMessageAppResponse() {}

  explicit ListMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageAppResponse() = default;
};
class ListMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};
  shared_ptr<string> userId{};

  ListMessageGroupRequest() {}

  explicit ListMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListMessageGroupRequest() = default;
};
class ListMessageGroupResponseBodyResultGroupList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<map<string, string>> extension{};
  shared_ptr<string> groupId{};
  shared_ptr<long> status{};

  ListMessageGroupResponseBodyResultGroupList() {}

  explicit ListMessageGroupResponseBodyResultGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListMessageGroupResponseBodyResultGroupList() = default;
};
class ListMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListMessageGroupResponseBodyResultGroupList>> groupList{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> total{};

  ListMessageGroupResponseBodyResult() {}

  explicit ListMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupList) {
      vector<boost::any> temp1;
      for(auto item1:*groupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupList"] = boost::any(temp1);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupList") != m.end() && !m["GroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupList"].type()) {
        vector<ListMessageGroupResponseBodyResultGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageGroupResponseBodyResultGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupList = make_shared<vector<ListMessageGroupResponseBodyResultGroupList>>(expect1);
      }
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListMessageGroupResponseBodyResult() = default;
};
class ListMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMessageGroupResponseBodyResult> result{};

  ListMessageGroupResponseBody() {}

  explicit ListMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListMessageGroupResponseBody() = default;
};
class ListMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMessageGroupResponseBody> body{};

  ListMessageGroupResponse() {}

  explicit ListMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageGroupResponse() = default;
};
class ListMessageGroupUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};

  ListMessageGroupUserRequest() {}

  explicit ListMessageGroupUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
  }


  virtual ~ListMessageGroupUserRequest() = default;
};
class ListMessageGroupUserResponseBodyResultUserList : public Darabonba::Model {
public:
  shared_ptr<long> joinTime{};
  shared_ptr<string> userId{};

  ListMessageGroupUserResponseBodyResultUserList() {}

  explicit ListMessageGroupUserResponseBodyResultUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinTime) {
      res["JoinTime"] = boost::any(*joinTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinTime") != m.end() && !m["JoinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["JoinTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListMessageGroupUserResponseBodyResultUserList() = default;
};
class ListMessageGroupUserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<long> total{};
  shared_ptr<vector<ListMessageGroupUserResponseBodyResultUserList>> userList{};

  ListMessageGroupUserResponseBodyResult() {}

  explicit ListMessageGroupUserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<ListMessageGroupUserResponseBodyResultUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageGroupUserResponseBodyResultUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<ListMessageGroupUserResponseBodyResultUserList>>(expect1);
      }
    }
  }


  virtual ~ListMessageGroupUserResponseBodyResult() = default;
};
class ListMessageGroupUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMessageGroupUserResponseBodyResult> result{};

  ListMessageGroupUserResponseBody() {}

  explicit ListMessageGroupUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListMessageGroupUserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListMessageGroupUserResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListMessageGroupUserResponseBody() = default;
};
class ListMessageGroupUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMessageGroupUserResponseBody> body{};

  ListMessageGroupUserResponse() {}

  explicit ListMessageGroupUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageGroupUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageGroupUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageGroupUserResponse() = default;
};
class ListMessageGroupUserByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<string>> userIdList{};

  ListMessageGroupUserByIdRequest() {}

  explicit ListMessageGroupUserByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListMessageGroupUserByIdRequest() = default;
};
class ListMessageGroupUserByIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> userIdListShrink{};

  ListMessageGroupUserByIdShrinkRequest() {}

  explicit ListMessageGroupUserByIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (userIdListShrink) {
      res["UserIdList"] = boost::any(*userIdListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      userIdListShrink = make_shared<string>(boost::any_cast<string>(m["UserIdList"]));
    }
  }


  virtual ~ListMessageGroupUserByIdShrinkRequest() = default;
};
class ListMessageGroupUserByIdResponseBodyResultUserList : public Darabonba::Model {
public:
  shared_ptr<bool> isMute{};
  shared_ptr<vector<string>> muteBy{};
  shared_ptr<string> userAvatar{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};
  shared_ptr<string> userNick{};

  ListMessageGroupUserByIdResponseBodyResultUserList() {}

  explicit ListMessageGroupUserByIdResponseBodyResultUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isMute) {
      res["IsMute"] = boost::any(*isMute);
    }
    if (muteBy) {
      res["MuteBy"] = boost::any(*muteBy);
    }
    if (userAvatar) {
      res["UserAvatar"] = boost::any(*userAvatar);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userNick) {
      res["UserNick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsMute") != m.end() && !m["IsMute"].empty()) {
      isMute = make_shared<bool>(boost::any_cast<bool>(m["IsMute"]));
    }
    if (m.find("MuteBy") != m.end() && !m["MuteBy"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MuteBy"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MuteBy"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      muteBy = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserAvatar") != m.end() && !m["UserAvatar"].empty()) {
      userAvatar = make_shared<string>(boost::any_cast<string>(m["UserAvatar"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserNick") != m.end() && !m["UserNick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["UserNick"]));
    }
  }


  virtual ~ListMessageGroupUserByIdResponseBodyResultUserList() = default;
};
class ListMessageGroupUserByIdResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<long> total{};
  shared_ptr<vector<ListMessageGroupUserByIdResponseBodyResultUserList>> userList{};

  ListMessageGroupUserByIdResponseBodyResult() {}

  explicit ListMessageGroupUserByIdResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<ListMessageGroupUserByIdResponseBodyResultUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageGroupUserByIdResponseBodyResultUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<ListMessageGroupUserByIdResponseBodyResultUserList>>(expect1);
      }
    }
  }


  virtual ~ListMessageGroupUserByIdResponseBodyResult() = default;
};
class ListMessageGroupUserByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMessageGroupUserByIdResponseBodyResult> result{};

  ListMessageGroupUserByIdResponseBody() {}

  explicit ListMessageGroupUserByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListMessageGroupUserByIdResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListMessageGroupUserByIdResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListMessageGroupUserByIdResponseBody() = default;
};
class ListMessageGroupUserByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMessageGroupUserByIdResponseBody> body{};

  ListMessageGroupUserByIdResponse() {}

  explicit ListMessageGroupUserByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageGroupUserByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageGroupUserByIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageGroupUserByIdResponse() = default;
};
class ListPlaylistRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> programId{};

  ListPlaylistRequest() {}

  explicit ListPlaylistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
  }


  virtual ~ListPlaylistRequest() = default;
};
class ListPlaylistResponseBodyProgramList : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> programId{};
  shared_ptr<string> programName{};
  shared_ptr<long> repeatNumber{};
  shared_ptr<long> status{};

  ListPlaylistResponseBodyProgramList() {}

  explicit ListPlaylistResponseBodyProgramList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (repeatNumber) {
      res["RepeatNumber"] = boost::any(*repeatNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("RepeatNumber") != m.end() && !m["RepeatNumber"].empty()) {
      repeatNumber = make_shared<long>(boost::any_cast<long>(m["RepeatNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListPlaylistResponseBodyProgramList() = default;
};
class ListPlaylistResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPlaylistResponseBodyProgramList>> programList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListPlaylistResponseBody() {}

  explicit ListPlaylistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programList) {
      vector<boost::any> temp1;
      for(auto item1:*programList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProgramList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramList") != m.end() && !m["ProgramList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProgramList"].type()) {
        vector<ListPlaylistResponseBodyProgramList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProgramList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPlaylistResponseBodyProgramList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programList = make_shared<vector<ListPlaylistResponseBodyProgramList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListPlaylistResponseBody() = default;
};
class ListPlaylistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPlaylistResponseBody> body{};

  ListPlaylistResponse() {}

  explicit ListPlaylistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPlaylistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPlaylistResponseBody>(model1);
      }
    }
  }


  virtual ~ListPlaylistResponse() = default;
};
class ListPlaylistItemsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};
  shared_ptr<string> programItemIds{};

  ListPlaylistItemsRequest() {}

  explicit ListPlaylistItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programItemIds) {
      res["ProgramItemIds"] = boost::any(*programItemIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramItemIds") != m.end() && !m["ProgramItemIds"].empty()) {
      programItemIds = make_shared<string>(boost::any_cast<string>(m["ProgramItemIds"]));
    }
  }


  virtual ~ListPlaylistItemsRequest() = default;
};
class ListPlaylistItemsResponseBodyProgramItems : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<string> programId{};
  shared_ptr<string> programItemId{};
  shared_ptr<string> programItemName{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceValue{};

  ListPlaylistItemsResponseBodyProgramItems() {}

  explicit ListPlaylistItemsResponseBodyProgramItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programItemId) {
      res["ProgramItemId"] = boost::any(*programItemId);
    }
    if (programItemName) {
      res["ProgramItemName"] = boost::any(*programItemName);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceValue) {
      res["ResourceValue"] = boost::any(*resourceValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramItemId") != m.end() && !m["ProgramItemId"].empty()) {
      programItemId = make_shared<string>(boost::any_cast<string>(m["ProgramItemId"]));
    }
    if (m.find("ProgramItemName") != m.end() && !m["ProgramItemName"].empty()) {
      programItemName = make_shared<string>(boost::any_cast<string>(m["ProgramItemName"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceValue") != m.end() && !m["ResourceValue"].empty()) {
      resourceValue = make_shared<string>(boost::any_cast<string>(m["ResourceValue"]));
    }
  }


  virtual ~ListPlaylistItemsResponseBodyProgramItems() = default;
};
class ListPlaylistItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPlaylistItemsResponseBodyProgramItems>> programItems{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListPlaylistItemsResponseBody() {}

  explicit ListPlaylistItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programItems) {
      vector<boost::any> temp1;
      for(auto item1:*programItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProgramItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramItems") != m.end() && !m["ProgramItems"].empty()) {
      if (typeid(vector<boost::any>) == m["ProgramItems"].type()) {
        vector<ListPlaylistItemsResponseBodyProgramItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProgramItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPlaylistItemsResponseBodyProgramItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programItems = make_shared<vector<ListPlaylistItemsResponseBodyProgramItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListPlaylistItemsResponseBody() = default;
};
class ListPlaylistItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPlaylistItemsResponseBody> body{};

  ListPlaylistItemsResponse() {}

  explicit ListPlaylistItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPlaylistItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPlaylistItemsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPlaylistItemsResponse() = default;
};
class ModifyCasterComponentRequest : public Darabonba::Model {
public:
  shared_ptr<string> captionLayerContent{};
  shared_ptr<string> casterId{};
  shared_ptr<string> componentId{};
  shared_ptr<string> componentLayer{};
  shared_ptr<string> componentName{};
  shared_ptr<string> componentType{};
  shared_ptr<string> effect{};
  shared_ptr<string> imageLayerContent{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> textLayerContent{};

  ModifyCasterComponentRequest() {}

  explicit ModifyCasterComponentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (captionLayerContent) {
      res["CaptionLayerContent"] = boost::any(*captionLayerContent);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (componentLayer) {
      res["ComponentLayer"] = boost::any(*componentLayer);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (componentType) {
      res["ComponentType"] = boost::any(*componentType);
    }
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (imageLayerContent) {
      res["ImageLayerContent"] = boost::any(*imageLayerContent);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (textLayerContent) {
      res["TextLayerContent"] = boost::any(*textLayerContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaptionLayerContent") != m.end() && !m["CaptionLayerContent"].empty()) {
      captionLayerContent = make_shared<string>(boost::any_cast<string>(m["CaptionLayerContent"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("ComponentLayer") != m.end() && !m["ComponentLayer"].empty()) {
      componentLayer = make_shared<string>(boost::any_cast<string>(m["ComponentLayer"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("ComponentType") != m.end() && !m["ComponentType"].empty()) {
      componentType = make_shared<string>(boost::any_cast<string>(m["ComponentType"]));
    }
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("ImageLayerContent") != m.end() && !m["ImageLayerContent"].empty()) {
      imageLayerContent = make_shared<string>(boost::any_cast<string>(m["ImageLayerContent"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("TextLayerContent") != m.end() && !m["TextLayerContent"].empty()) {
      textLayerContent = make_shared<string>(boost::any_cast<string>(m["TextLayerContent"]));
    }
  }


  virtual ~ModifyCasterComponentRequest() = default;
};
class ModifyCasterComponentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> componentId{};
  shared_ptr<string> requestId{};

  ModifyCasterComponentResponseBody() {}

  explicit ModifyCasterComponentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCasterComponentResponseBody() = default;
};
class ModifyCasterComponentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCasterComponentResponseBody> body{};

  ModifyCasterComponentResponse() {}

  explicit ModifyCasterComponentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCasterComponentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCasterComponentResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCasterComponentResponse() = default;
};
class ModifyCasterEpisodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> episodeName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> switchType{};

  ModifyCasterEpisodeRequest() {}

  explicit ModifyCasterEpisodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (episodeName) {
      res["EpisodeName"] = boost::any(*episodeName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (switchType) {
      res["SwitchType"] = boost::any(*switchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("EpisodeName") != m.end() && !m["EpisodeName"].empty()) {
      episodeName = make_shared<string>(boost::any_cast<string>(m["EpisodeName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SwitchType") != m.end() && !m["SwitchType"].empty()) {
      switchType = make_shared<string>(boost::any_cast<string>(m["SwitchType"]));
    }
  }


  virtual ~ModifyCasterEpisodeRequest() = default;
};
class ModifyCasterEpisodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> requestId{};

  ModifyCasterEpisodeResponseBody() {}

  explicit ModifyCasterEpisodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCasterEpisodeResponseBody() = default;
};
class ModifyCasterEpisodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCasterEpisodeResponseBody> body{};

  ModifyCasterEpisodeResponse() {}

  explicit ModifyCasterEpisodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCasterEpisodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCasterEpisodeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCasterEpisodeResponse() = default;
};
class ModifyCasterLayoutRequestAudioLayer : public Darabonba::Model {
public:
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  ModifyCasterLayoutRequestAudioLayer() {}

  explicit ModifyCasterLayoutRequestAudioLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~ModifyCasterLayoutRequestAudioLayer() = default;
};
class ModifyCasterLayoutRequestVideoLayer : public Darabonba::Model {
public:
  shared_ptr<string> fillMode{};
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<double> heightNormalized{};
  shared_ptr<vector<double>> positionNormalized{};
  shared_ptr<string> positionRefer{};
  shared_ptr<double> widthNormalized{};

  ModifyCasterLayoutRequestVideoLayer() {}

  explicit ModifyCasterLayoutRequestVideoLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fillMode) {
      res["FillMode"] = boost::any(*fillMode);
    }
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionNormalized) {
      res["PositionNormalized"] = boost::any(*positionNormalized);
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (widthNormalized) {
      res["WidthNormalized"] = boost::any(*widthNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FillMode") != m.end() && !m["FillMode"].empty()) {
      fillMode = make_shared<string>(boost::any_cast<string>(m["FillMode"]));
    }
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["PositionNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PositionNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      positionNormalized = make_shared<vector<double>>(toVec1);
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("WidthNormalized") != m.end() && !m["WidthNormalized"].empty()) {
      widthNormalized = make_shared<double>(boost::any_cast<double>(m["WidthNormalized"]));
    }
  }


  virtual ~ModifyCasterLayoutRequestVideoLayer() = default;
};
class ModifyCasterLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyCasterLayoutRequestAudioLayer>> audioLayer{};
  shared_ptr<vector<string>> blendList{};
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<vector<string>> mixList{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<ModifyCasterLayoutRequestVideoLayer>> videoLayer{};

  ModifyCasterLayoutRequest() {}

  explicit ModifyCasterLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayer) {
      vector<boost::any> temp1;
      for(auto item1:*audioLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioLayer"] = boost::any(temp1);
    }
    if (blendList) {
      res["BlendList"] = boost::any(*blendList);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (mixList) {
      res["MixList"] = boost::any(*mixList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (videoLayer) {
      vector<boost::any> temp1;
      for(auto item1:*videoLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayer") != m.end() && !m["AudioLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioLayer"].type()) {
        vector<ModifyCasterLayoutRequestAudioLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCasterLayoutRequestAudioLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioLayer = make_shared<vector<ModifyCasterLayoutRequestAudioLayer>>(expect1);
      }
    }
    if (m.find("BlendList") != m.end() && !m["BlendList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BlendList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BlendList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      blendList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("MixList") != m.end() && !m["MixList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MixList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MixList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mixList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("VideoLayer") != m.end() && !m["VideoLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoLayer"].type()) {
        vector<ModifyCasterLayoutRequestVideoLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCasterLayoutRequestVideoLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoLayer = make_shared<vector<ModifyCasterLayoutRequestVideoLayer>>(expect1);
      }
    }
  }


  virtual ~ModifyCasterLayoutRequest() = default;
};
class ModifyCasterLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> layoutId{};
  shared_ptr<string> requestId{};

  ModifyCasterLayoutResponseBody() {}

  explicit ModifyCasterLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCasterLayoutResponseBody() = default;
};
class ModifyCasterLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCasterLayoutResponseBody> body{};

  ModifyCasterLayoutResponse() {}

  explicit ModifyCasterLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCasterLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCasterLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCasterLayoutResponse() = default;
};
class ModifyCasterProgramRequestEpisode : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> episodeName{};
  shared_ptr<string> episodeType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> switchType{};

  ModifyCasterProgramRequestEpisode() {}

  explicit ModifyCasterProgramRequestEpisode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (episodeName) {
      res["EpisodeName"] = boost::any(*episodeName);
    }
    if (episodeType) {
      res["EpisodeType"] = boost::any(*episodeType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (switchType) {
      res["SwitchType"] = boost::any(*switchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("EpisodeName") != m.end() && !m["EpisodeName"].empty()) {
      episodeName = make_shared<string>(boost::any_cast<string>(m["EpisodeName"]));
    }
    if (m.find("EpisodeType") != m.end() && !m["EpisodeType"].empty()) {
      episodeType = make_shared<string>(boost::any_cast<string>(m["EpisodeType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SwitchType") != m.end() && !m["SwitchType"].empty()) {
      switchType = make_shared<string>(boost::any_cast<string>(m["SwitchType"]));
    }
  }


  virtual ~ModifyCasterProgramRequestEpisode() = default;
};
class ModifyCasterProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<ModifyCasterProgramRequestEpisode>> episode{};
  shared_ptr<long> ownerId{};

  ModifyCasterProgramRequest() {}

  explicit ModifyCasterProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episode) {
      vector<boost::any> temp1;
      for(auto item1:*episode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Episode"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("Episode") != m.end() && !m["Episode"].empty()) {
      if (typeid(vector<boost::any>) == m["Episode"].type()) {
        vector<ModifyCasterProgramRequestEpisode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Episode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCasterProgramRequestEpisode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        episode = make_shared<vector<ModifyCasterProgramRequestEpisode>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~ModifyCasterProgramRequest() = default;
};
class ModifyCasterProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  ModifyCasterProgramResponseBody() {}

  explicit ModifyCasterProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCasterProgramResponseBody() = default;
};
class ModifyCasterProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCasterProgramResponseBody> body{};

  ModifyCasterProgramResponse() {}

  explicit ModifyCasterProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCasterProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCasterProgramResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCasterProgramResponse() = default;
};
class ModifyCasterVideoResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginOffset{};
  shared_ptr<string> casterId{};
  shared_ptr<long> endOffset{};
  shared_ptr<string> liveStreamUrl{};
  shared_ptr<string> materialId{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> ptsCallbackInterval{};
  shared_ptr<long> repeatNum{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> vodUrl{};

  ModifyCasterVideoResourceRequest() {}

  explicit ModifyCasterVideoResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginOffset) {
      res["BeginOffset"] = boost::any(*beginOffset);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (endOffset) {
      res["EndOffset"] = boost::any(*endOffset);
    }
    if (liveStreamUrl) {
      res["LiveStreamUrl"] = boost::any(*liveStreamUrl);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ptsCallbackInterval) {
      res["PtsCallbackInterval"] = boost::any(*ptsCallbackInterval);
    }
    if (repeatNum) {
      res["RepeatNum"] = boost::any(*repeatNum);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (vodUrl) {
      res["VodUrl"] = boost::any(*vodUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginOffset") != m.end() && !m["BeginOffset"].empty()) {
      beginOffset = make_shared<long>(boost::any_cast<long>(m["BeginOffset"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EndOffset") != m.end() && !m["EndOffset"].empty()) {
      endOffset = make_shared<long>(boost::any_cast<long>(m["EndOffset"]));
    }
    if (m.find("LiveStreamUrl") != m.end() && !m["LiveStreamUrl"].empty()) {
      liveStreamUrl = make_shared<string>(boost::any_cast<string>(m["LiveStreamUrl"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PtsCallbackInterval") != m.end() && !m["PtsCallbackInterval"].empty()) {
      ptsCallbackInterval = make_shared<long>(boost::any_cast<long>(m["PtsCallbackInterval"]));
    }
    if (m.find("RepeatNum") != m.end() && !m["RepeatNum"].empty()) {
      repeatNum = make_shared<long>(boost::any_cast<long>(m["RepeatNum"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("VodUrl") != m.end() && !m["VodUrl"].empty()) {
      vodUrl = make_shared<string>(boost::any_cast<string>(m["VodUrl"]));
    }
  }


  virtual ~ModifyCasterVideoResourceRequest() = default;
};
class ModifyCasterVideoResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceId{};

  ModifyCasterVideoResourceResponseBody() {}

  explicit ModifyCasterVideoResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ModifyCasterVideoResourceResponseBody() = default;
};
class ModifyCasterVideoResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCasterVideoResourceResponseBody> body{};

  ModifyCasterVideoResourceResponse() {}

  explicit ModifyCasterVideoResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCasterVideoResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCasterVideoResourceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCasterVideoResourceResponse() = default;
};
class ModifyLiveDomainSchdmByPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> property{};

  ModifyLiveDomainSchdmByPropertyRequest() {}

  explicit ModifyLiveDomainSchdmByPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
  }


  virtual ~ModifyLiveDomainSchdmByPropertyRequest() = default;
};
class ModifyLiveDomainSchdmByPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLiveDomainSchdmByPropertyResponseBody() {}

  explicit ModifyLiveDomainSchdmByPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLiveDomainSchdmByPropertyResponseBody() = default;
};
class ModifyLiveDomainSchdmByPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLiveDomainSchdmByPropertyResponseBody> body{};

  ModifyLiveDomainSchdmByPropertyResponse() {}

  explicit ModifyLiveDomainSchdmByPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLiveDomainSchdmByPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLiveDomainSchdmByPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLiveDomainSchdmByPropertyResponse() = default;
};
class ModifyLiveRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> logstore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  ModifyLiveRealtimeLogDeliveryRequest() {}

  explicit ModifyLiveRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~ModifyLiveRealtimeLogDeliveryRequest() = default;
};
class ModifyLiveRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLiveRealtimeLogDeliveryResponseBody() {}

  explicit ModifyLiveRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLiveRealtimeLogDeliveryResponseBody() = default;
};
class ModifyLiveRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLiveRealtimeLogDeliveryResponseBody> body{};

  ModifyLiveRealtimeLogDeliveryResponse() {}

  explicit ModifyLiveRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLiveRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLiveRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLiveRealtimeLogDeliveryResponse() = default;
};
class ModifyShowListRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> highPriorityShowId{};
  shared_ptr<string> highPriorityShowStartTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> repeatTimes{};
  shared_ptr<string> showId{};
  shared_ptr<long> spot{};

  ModifyShowListRequest() {}

  explicit ModifyShowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (highPriorityShowId) {
      res["HighPriorityShowId"] = boost::any(*highPriorityShowId);
    }
    if (highPriorityShowStartTime) {
      res["HighPriorityShowStartTime"] = boost::any(*highPriorityShowStartTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (repeatTimes) {
      res["RepeatTimes"] = boost::any(*repeatTimes);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (spot) {
      res["Spot"] = boost::any(*spot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("HighPriorityShowId") != m.end() && !m["HighPriorityShowId"].empty()) {
      highPriorityShowId = make_shared<string>(boost::any_cast<string>(m["HighPriorityShowId"]));
    }
    if (m.find("HighPriorityShowStartTime") != m.end() && !m["HighPriorityShowStartTime"].empty()) {
      highPriorityShowStartTime = make_shared<string>(boost::any_cast<string>(m["HighPriorityShowStartTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RepeatTimes") != m.end() && !m["RepeatTimes"].empty()) {
      repeatTimes = make_shared<long>(boost::any_cast<long>(m["RepeatTimes"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("Spot") != m.end() && !m["Spot"].empty()) {
      spot = make_shared<long>(boost::any_cast<long>(m["Spot"]));
    }
  }


  virtual ~ModifyShowListRequest() = default;
};
class ModifyShowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyShowListResponseBody() {}

  explicit ModifyShowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyShowListResponseBody() = default;
};
class ModifyShowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyShowListResponseBody> body{};

  ModifyShowListResponse() {}

  explicit ModifyShowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyShowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyShowListResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyShowListResponse() = default;
};
class ModifyStudioLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgImageConfig{};
  shared_ptr<string> casterId{};
  shared_ptr<string> commonConfig{};
  shared_ptr<string> layerOrderConfigList{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> layoutName{};
  shared_ptr<string> mediaInputConfigList{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> screenInputConfigList{};

  ModifyStudioLayoutRequest() {}

  explicit ModifyStudioLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgImageConfig) {
      res["BgImageConfig"] = boost::any(*bgImageConfig);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (commonConfig) {
      res["CommonConfig"] = boost::any(*commonConfig);
    }
    if (layerOrderConfigList) {
      res["LayerOrderConfigList"] = boost::any(*layerOrderConfigList);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (layoutName) {
      res["LayoutName"] = boost::any(*layoutName);
    }
    if (mediaInputConfigList) {
      res["MediaInputConfigList"] = boost::any(*mediaInputConfigList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (screenInputConfigList) {
      res["ScreenInputConfigList"] = boost::any(*screenInputConfigList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgImageConfig") != m.end() && !m["BgImageConfig"].empty()) {
      bgImageConfig = make_shared<string>(boost::any_cast<string>(m["BgImageConfig"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CommonConfig") != m.end() && !m["CommonConfig"].empty()) {
      commonConfig = make_shared<string>(boost::any_cast<string>(m["CommonConfig"]));
    }
    if (m.find("LayerOrderConfigList") != m.end() && !m["LayerOrderConfigList"].empty()) {
      layerOrderConfigList = make_shared<string>(boost::any_cast<string>(m["LayerOrderConfigList"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("LayoutName") != m.end() && !m["LayoutName"].empty()) {
      layoutName = make_shared<string>(boost::any_cast<string>(m["LayoutName"]));
    }
    if (m.find("MediaInputConfigList") != m.end() && !m["MediaInputConfigList"].empty()) {
      mediaInputConfigList = make_shared<string>(boost::any_cast<string>(m["MediaInputConfigList"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ScreenInputConfigList") != m.end() && !m["ScreenInputConfigList"].empty()) {
      screenInputConfigList = make_shared<string>(boost::any_cast<string>(m["ScreenInputConfigList"]));
    }
  }


  virtual ~ModifyStudioLayoutRequest() = default;
};
class ModifyStudioLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyStudioLayoutResponseBody() {}

  explicit ModifyStudioLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyStudioLayoutResponseBody() = default;
};
class ModifyStudioLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyStudioLayoutResponseBody> body{};

  ModifyStudioLayoutResponse() {}

  explicit ModifyStudioLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyStudioLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyStudioLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyStudioLayoutResponse() = default;
};
class OpenLiveShiftRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> duration{};
  shared_ptr<bool> ignoreTranscode{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};
  shared_ptr<long> vision{};

  OpenLiveShiftRequest() {}

  explicit OpenLiveShiftRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (ignoreTranscode) {
      res["IgnoreTranscode"] = boost::any(*ignoreTranscode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (vision) {
      res["Vision"] = boost::any(*vision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("IgnoreTranscode") != m.end() && !m["IgnoreTranscode"].empty()) {
      ignoreTranscode = make_shared<bool>(boost::any_cast<bool>(m["IgnoreTranscode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Vision") != m.end() && !m["Vision"].empty()) {
      vision = make_shared<long>(boost::any_cast<long>(m["Vision"]));
    }
  }


  virtual ~OpenLiveShiftRequest() = default;
};
class OpenLiveShiftResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OpenLiveShiftResponseBody() {}

  explicit OpenLiveShiftResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenLiveShiftResponseBody() = default;
};
class OpenLiveShiftResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenLiveShiftResponseBody> body{};

  OpenLiveShiftResponse() {}

  explicit OpenLiveShiftResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenLiveShiftResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenLiveShiftResponseBody>(model1);
      }
    }
  }


  virtual ~OpenLiveShiftResponse() = default;
};
class PlayChoosenShowRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> showId{};

  PlayChoosenShowRequest() {}

  explicit PlayChoosenShowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
  }


  virtual ~PlayChoosenShowRequest() = default;
};
class PlayChoosenShowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> showId{};

  PlayChoosenShowResponseBody() {}

  explicit PlayChoosenShowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
  }


  virtual ~PlayChoosenShowResponseBody() = default;
};
class PlayChoosenShowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PlayChoosenShowResponseBody> body{};

  PlayChoosenShowResponse() {}

  explicit PlayChoosenShowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PlayChoosenShowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PlayChoosenShowResponseBody>(model1);
      }
    }
  }


  virtual ~PlayChoosenShowResponse() = default;
};
class PublishLiveStagingConfigToProductionRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionName{};
  shared_ptr<long> ownerId{};

  PublishLiveStagingConfigToProductionRequest() {}

  explicit PublishLiveStagingConfigToProductionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~PublishLiveStagingConfigToProductionRequest() = default;
};
class PublishLiveStagingConfigToProductionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PublishLiveStagingConfigToProductionResponseBody() {}

  explicit PublishLiveStagingConfigToProductionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishLiveStagingConfigToProductionResponseBody() = default;
};
class PublishLiveStagingConfigToProductionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishLiveStagingConfigToProductionResponseBody> body{};

  PublishLiveStagingConfigToProductionResponse() {}

  explicit PublishLiveStagingConfigToProductionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishLiveStagingConfigToProductionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishLiveStagingConfigToProductionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishLiveStagingConfigToProductionResponse() = default;
};
class QueryMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};

  QueryMessageAppRequest() {}

  explicit QueryMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
  }


  virtual ~QueryMessageAppRequest() = default;
};
class QueryMessageAppResponseBodyResultAppList : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> appConfig{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<map<string, string>> extension{};
  shared_ptr<long> status{};

  QueryMessageAppResponseBodyResultAppList() {}

  explicit QueryMessageAppResponseBodyResultAppList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["AppConfig"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      appConfig = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~QueryMessageAppResponseBodyResultAppList() = default;
};
class QueryMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMessageAppResponseBodyResultAppList>> appList{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> totalCount{};

  QueryMessageAppResponseBodyResult() {}

  explicit QueryMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appList) {
      vector<boost::any> temp1;
      for(auto item1:*appList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppList"] = boost::any(temp1);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppList") != m.end() && !m["AppList"].empty()) {
      if (typeid(vector<boost::any>) == m["AppList"].type()) {
        vector<QueryMessageAppResponseBodyResultAppList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMessageAppResponseBodyResultAppList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appList = make_shared<vector<QueryMessageAppResponseBodyResultAppList>>(expect1);
      }
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryMessageAppResponseBodyResult() = default;
};
class QueryMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryMessageAppResponseBodyResult>> result{};

  QueryMessageAppResponseBody() {}

  explicit QueryMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryMessageAppResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMessageAppResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMessageAppResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~QueryMessageAppResponseBody() = default;
};
class QueryMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMessageAppResponseBody> body{};

  QueryMessageAppResponse() {}

  explicit QueryMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMessageAppResponse() = default;
};
class QuerySnapshotCallbackAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  QuerySnapshotCallbackAuthRequest() {}

  explicit QuerySnapshotCallbackAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~QuerySnapshotCallbackAuthRequest() = default;
};
class QuerySnapshotCallbackAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> callbackAuthKey{};
  shared_ptr<string> callbackReqAuth{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  QuerySnapshotCallbackAuthResponseBody() {}

  explicit QuerySnapshotCallbackAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackAuthKey) {
      res["CallbackAuthKey"] = boost::any(*callbackAuthKey);
    }
    if (callbackReqAuth) {
      res["CallbackReqAuth"] = boost::any(*callbackReqAuth);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackAuthKey") != m.end() && !m["CallbackAuthKey"].empty()) {
      callbackAuthKey = make_shared<string>(boost::any_cast<string>(m["CallbackAuthKey"]));
    }
    if (m.find("CallbackReqAuth") != m.end() && !m["CallbackReqAuth"].empty()) {
      callbackReqAuth = make_shared<string>(boost::any_cast<string>(m["CallbackReqAuth"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySnapshotCallbackAuthResponseBody() = default;
};
class QuerySnapshotCallbackAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySnapshotCallbackAuthResponseBody> body{};

  QuerySnapshotCallbackAuthResponse() {}

  explicit QuerySnapshotCallbackAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySnapshotCallbackAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySnapshotCallbackAuthResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySnapshotCallbackAuthResponse() = default;
};
class RealTimeRecordCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> command{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  RealTimeRecordCommandRequest() {}

  explicit RealTimeRecordCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~RealTimeRecordCommandRequest() = default;
};
class RealTimeRecordCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RealTimeRecordCommandResponseBody() {}

  explicit RealTimeRecordCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RealTimeRecordCommandResponseBody() = default;
};
class RealTimeRecordCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RealTimeRecordCommandResponseBody> body{};

  RealTimeRecordCommandResponse() {}

  explicit RealTimeRecordCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RealTimeRecordCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RealTimeRecordCommandResponseBody>(model1);
      }
    }
  }


  virtual ~RealTimeRecordCommandResponse() = default;
};
class RealTimeSnapshotCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> command{};
  shared_ptr<string> domainName{};
  shared_ptr<long> interval{};
  shared_ptr<long> mode{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> source{};
  shared_ptr<string> streamName{};

  RealTimeSnapshotCommandRequest() {}

  explicit RealTimeSnapshotCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<long>(boost::any_cast<long>(m["Source"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~RealTimeSnapshotCommandRequest() = default;
};
class RealTimeSnapshotCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RealTimeSnapshotCommandResponseBody() {}

  explicit RealTimeSnapshotCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RealTimeSnapshotCommandResponseBody() = default;
};
class RealTimeSnapshotCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RealTimeSnapshotCommandResponseBody> body{};

  RealTimeSnapshotCommandResponse() {}

  explicit RealTimeSnapshotCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RealTimeSnapshotCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RealTimeSnapshotCommandResponseBody>(model1);
      }
    }
  }


  virtual ~RealTimeSnapshotCommandResponse() = default;
};
class RemoveShowFromShowListRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> showId{};
  shared_ptr<bool> isBatchMode{};
  shared_ptr<vector<string>> showIdList{};

  RemoveShowFromShowListRequest() {}

  explicit RemoveShowFromShowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (isBatchMode) {
      res["isBatchMode"] = boost::any(*isBatchMode);
    }
    if (showIdList) {
      res["showIdList"] = boost::any(*showIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("isBatchMode") != m.end() && !m["isBatchMode"].empty()) {
      isBatchMode = make_shared<bool>(boost::any_cast<bool>(m["isBatchMode"]));
    }
    if (m.find("showIdList") != m.end() && !m["showIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["showIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["showIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      showIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveShowFromShowListRequest() = default;
};
class RemoveShowFromShowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> showId{};
  shared_ptr<string> failedList{};
  shared_ptr<string> successfulShowIds{};

  RemoveShowFromShowListResponseBody() {}

  explicit RemoveShowFromShowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (failedList) {
      res["failedList"] = boost::any(*failedList);
    }
    if (successfulShowIds) {
      res["successfulShowIds"] = boost::any(*successfulShowIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("failedList") != m.end() && !m["failedList"].empty()) {
      failedList = make_shared<string>(boost::any_cast<string>(m["failedList"]));
    }
    if (m.find("successfulShowIds") != m.end() && !m["successfulShowIds"].empty()) {
      successfulShowIds = make_shared<string>(boost::any_cast<string>(m["successfulShowIds"]));
    }
  }


  virtual ~RemoveShowFromShowListResponseBody() = default;
};
class RemoveShowFromShowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveShowFromShowListResponseBody> body{};

  RemoveShowFromShowListResponse() {}

  explicit RemoveShowFromShowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveShowFromShowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveShowFromShowListResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveShowFromShowListResponse() = default;
};
class RestartCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  RestartCasterRequest() {}

  explicit RestartCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~RestartCasterRequest() = default;
};
class RestartCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RestartCasterResponseBody() {}

  explicit RestartCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestartCasterResponseBody() = default;
};
class RestartCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartCasterResponseBody> body{};

  RestartCasterResponse() {}

  explicit RestartCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartCasterResponseBody>(model1);
      }
    }
  }


  virtual ~RestartCasterResponse() = default;
};
class ResumeLiveStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveStreamType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> streamName{};

  ResumeLiveStreamRequest() {}

  explicit ResumeLiveStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveStreamType) {
      res["LiveStreamType"] = boost::any(*liveStreamType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveStreamType") != m.end() && !m["LiveStreamType"].empty()) {
      liveStreamType = make_shared<string>(boost::any_cast<string>(m["LiveStreamType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~ResumeLiveStreamRequest() = default;
};
class ResumeLiveStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResumeLiveStreamResponseBody() {}

  explicit ResumeLiveStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumeLiveStreamResponseBody() = default;
};
class ResumeLiveStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeLiveStreamResponseBody> body{};

  ResumeLiveStreamResponse() {}

  explicit ResumeLiveStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeLiveStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeLiveStreamResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeLiveStreamResponse() = default;
};
class RollbackLiveStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionName{};
  shared_ptr<long> ownerId{};

  RollbackLiveStagingConfigRequest() {}

  explicit RollbackLiveStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~RollbackLiveStagingConfigRequest() = default;
};
class RollbackLiveStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackLiveStagingConfigResponseBody() {}

  explicit RollbackLiveStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackLiveStagingConfigResponseBody() = default;
};
class RollbackLiveStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackLiveStagingConfigResponseBody> body{};

  RollbackLiveStagingConfigResponse() {}

  explicit RollbackLiveStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackLiveStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackLiveStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackLiveStagingConfigResponse() = default;
};
class SendLikeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> broadCastType{};
  shared_ptr<string> count{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};

  SendLikeRequest() {}

  explicit SendLikeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
  }


  virtual ~SendLikeRequest() = default;
};
class SendLikeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> likeCount{};

  SendLikeResponseBodyResult() {}

  explicit SendLikeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (likeCount) {
      res["LikeCount"] = boost::any(*likeCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LikeCount") != m.end() && !m["LikeCount"].empty()) {
      likeCount = make_shared<long>(boost::any_cast<long>(m["LikeCount"]));
    }
  }


  virtual ~SendLikeResponseBodyResult() = default;
};
class SendLikeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SendLikeResponseBodyResult> result{};

  SendLikeResponseBody() {}

  explicit SendLikeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SendLikeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SendLikeResponseBodyResult>(model1);
      }
    }
  }


  virtual ~SendLikeResponseBody() = default;
};
class SendLikeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendLikeResponseBody> body{};

  SendLikeResponse() {}

  explicit SendLikeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendLikeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendLikeResponseBody>(model1);
      }
    }
  }


  virtual ~SendLikeResponse() = default;
};
class SendMessageToGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> data{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};
  shared_ptr<long> type{};

  SendMessageToGroupRequest() {}

  explicit SendMessageToGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SendMessageToGroupRequest() = default;
};
class SendMessageToGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};

  SendMessageToGroupResponseBodyResult() {}

  explicit SendMessageToGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SendMessageToGroupResponseBodyResult() = default;
};
class SendMessageToGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SendMessageToGroupResponseBodyResult> result{};

  SendMessageToGroupResponseBody() {}

  explicit SendMessageToGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SendMessageToGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SendMessageToGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~SendMessageToGroupResponseBody() = default;
};
class SendMessageToGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendMessageToGroupResponseBody> body{};

  SendMessageToGroupResponse() {}

  explicit SendMessageToGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendMessageToGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendMessageToGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SendMessageToGroupResponse() = default;
};
class SendMessageToGroupUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> data{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};
  shared_ptr<vector<string>> receiverIdList{};
  shared_ptr<long> type{};

  SendMessageToGroupUsersRequest() {}

  explicit SendMessageToGroupUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    if (receiverIdList) {
      res["ReceiverIdList"] = boost::any(*receiverIdList);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
    if (m.find("ReceiverIdList") != m.end() && !m["ReceiverIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SendMessageToGroupUsersRequest() = default;
};
class SendMessageToGroupUsersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> data{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};
  shared_ptr<string> receiverIdListShrink{};
  shared_ptr<long> type{};

  SendMessageToGroupUsersShrinkRequest() {}

  explicit SendMessageToGroupUsersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    if (receiverIdListShrink) {
      res["ReceiverIdList"] = boost::any(*receiverIdListShrink);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
    if (m.find("ReceiverIdList") != m.end() && !m["ReceiverIdList"].empty()) {
      receiverIdListShrink = make_shared<string>(boost::any_cast<string>(m["ReceiverIdList"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SendMessageToGroupUsersShrinkRequest() = default;
};
class SendMessageToGroupUsersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};

  SendMessageToGroupUsersResponseBodyResult() {}

  explicit SendMessageToGroupUsersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SendMessageToGroupUsersResponseBodyResult() = default;
};
class SendMessageToGroupUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SendMessageToGroupUsersResponseBodyResult> result{};

  SendMessageToGroupUsersResponseBody() {}

  explicit SendMessageToGroupUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SendMessageToGroupUsersResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SendMessageToGroupUsersResponseBodyResult>(model1);
      }
    }
  }


  virtual ~SendMessageToGroupUsersResponseBody() = default;
};
class SendMessageToGroupUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendMessageToGroupUsersResponseBody> body{};

  SendMessageToGroupUsersResponse() {}

  explicit SendMessageToGroupUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendMessageToGroupUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendMessageToGroupUsersResponseBody>(model1);
      }
    }
  }


  virtual ~SendMessageToGroupUsersResponse() = default;
};
class SendRoomNotificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appUid{};
  shared_ptr<string> data{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> priority{};
  shared_ptr<string> roomId{};

  SendRoomNotificationRequest() {}

  explicit SendRoomNotificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appUid) {
      res["AppUid"] = boost::any(*appUid);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppUid") != m.end() && !m["AppUid"].empty()) {
      appUid = make_shared<string>(boost::any_cast<string>(m["AppUid"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~SendRoomNotificationRequest() = default;
};
class SendRoomNotificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> requestId{};

  SendRoomNotificationResponseBody() {}

  explicit SendRoomNotificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendRoomNotificationResponseBody() = default;
};
class SendRoomNotificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendRoomNotificationResponseBody> body{};

  SendRoomNotificationResponse() {}

  explicit SendRoomNotificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendRoomNotificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendRoomNotificationResponseBody>(model1);
      }
    }
  }


  virtual ~SendRoomNotificationResponse() = default;
};
class SendRoomUserNotificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appUid{};
  shared_ptr<string> data{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> priority{};
  shared_ptr<string> roomId{};
  shared_ptr<string> toAppUid{};

  SendRoomUserNotificationRequest() {}

  explicit SendRoomUserNotificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appUid) {
      res["AppUid"] = boost::any(*appUid);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (toAppUid) {
      res["ToAppUid"] = boost::any(*toAppUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppUid") != m.end() && !m["AppUid"].empty()) {
      appUid = make_shared<string>(boost::any_cast<string>(m["AppUid"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("ToAppUid") != m.end() && !m["ToAppUid"].empty()) {
      toAppUid = make_shared<string>(boost::any_cast<string>(m["ToAppUid"]));
    }
  }


  virtual ~SendRoomUserNotificationRequest() = default;
};
class SendRoomUserNotificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};
  shared_ptr<string> requestId{};

  SendRoomUserNotificationResponseBody() {}

  explicit SendRoomUserNotificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendRoomUserNotificationResponseBody() = default;
};
class SendRoomUserNotificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendRoomUserNotificationResponseBody> body{};

  SendRoomUserNotificationResponse() {}

  explicit SendRoomUserNotificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendRoomUserNotificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendRoomUserNotificationResponseBody>(model1);
      }
    }
  }


  virtual ~SendRoomUserNotificationResponse() = default;
};
class SetCasterChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> faceBeauty{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> playStatus{};
  shared_ptr<string> resourceId{};
  shared_ptr<long> seekOffset{};

  SetCasterChannelRequest() {}

  explicit SetCasterChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (faceBeauty) {
      res["FaceBeauty"] = boost::any(*faceBeauty);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (playStatus) {
      res["PlayStatus"] = boost::any(*playStatus);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (seekOffset) {
      res["SeekOffset"] = boost::any(*seekOffset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("FaceBeauty") != m.end() && !m["FaceBeauty"].empty()) {
      faceBeauty = make_shared<string>(boost::any_cast<string>(m["FaceBeauty"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PlayStatus") != m.end() && !m["PlayStatus"].empty()) {
      playStatus = make_shared<long>(boost::any_cast<long>(m["PlayStatus"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("SeekOffset") != m.end() && !m["SeekOffset"].empty()) {
      seekOffset = make_shared<long>(boost::any_cast<long>(m["SeekOffset"]));
    }
  }


  virtual ~SetCasterChannelRequest() = default;
};
class SetCasterChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetCasterChannelResponseBody() {}

  explicit SetCasterChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCasterChannelResponseBody() = default;
};
class SetCasterChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCasterChannelResponseBody> body{};

  SetCasterChannelResponse() {}

  explicit SetCasterChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCasterChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCasterChannelResponseBody>(model1);
      }
    }
  }


  virtual ~SetCasterChannelResponse() = default;
};
class SetCasterConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> casterId{};
  shared_ptr<string> casterName{};
  shared_ptr<long> channelEnable{};
  shared_ptr<double> delay{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> programEffect{};
  shared_ptr<string> programName{};
  shared_ptr<string> recordConfig{};
  shared_ptr<string> sideOutputUrl{};
  shared_ptr<string> sideOutputUrlList{};
  shared_ptr<string> syncGroupsConfig{};
  shared_ptr<string> transcodeConfig{};
  shared_ptr<string> urgentLiveStreamUrl{};
  shared_ptr<string> urgentMaterialId{};

  SetCasterConfigRequest() {}

  explicit SetCasterConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (channelEnable) {
      res["ChannelEnable"] = boost::any(*channelEnable);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programEffect) {
      res["ProgramEffect"] = boost::any(*programEffect);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (recordConfig) {
      res["RecordConfig"] = boost::any(*recordConfig);
    }
    if (sideOutputUrl) {
      res["SideOutputUrl"] = boost::any(*sideOutputUrl);
    }
    if (sideOutputUrlList) {
      res["SideOutputUrlList"] = boost::any(*sideOutputUrlList);
    }
    if (syncGroupsConfig) {
      res["SyncGroupsConfig"] = boost::any(*syncGroupsConfig);
    }
    if (transcodeConfig) {
      res["TranscodeConfig"] = boost::any(*transcodeConfig);
    }
    if (urgentLiveStreamUrl) {
      res["UrgentLiveStreamUrl"] = boost::any(*urgentLiveStreamUrl);
    }
    if (urgentMaterialId) {
      res["UrgentMaterialId"] = boost::any(*urgentMaterialId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("ChannelEnable") != m.end() && !m["ChannelEnable"].empty()) {
      channelEnable = make_shared<long>(boost::any_cast<long>(m["ChannelEnable"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<double>(boost::any_cast<double>(m["Delay"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramEffect") != m.end() && !m["ProgramEffect"].empty()) {
      programEffect = make_shared<long>(boost::any_cast<long>(m["ProgramEffect"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("RecordConfig") != m.end() && !m["RecordConfig"].empty()) {
      recordConfig = make_shared<string>(boost::any_cast<string>(m["RecordConfig"]));
    }
    if (m.find("SideOutputUrl") != m.end() && !m["SideOutputUrl"].empty()) {
      sideOutputUrl = make_shared<string>(boost::any_cast<string>(m["SideOutputUrl"]));
    }
    if (m.find("SideOutputUrlList") != m.end() && !m["SideOutputUrlList"].empty()) {
      sideOutputUrlList = make_shared<string>(boost::any_cast<string>(m["SideOutputUrlList"]));
    }
    if (m.find("SyncGroupsConfig") != m.end() && !m["SyncGroupsConfig"].empty()) {
      syncGroupsConfig = make_shared<string>(boost::any_cast<string>(m["SyncGroupsConfig"]));
    }
    if (m.find("TranscodeConfig") != m.end() && !m["TranscodeConfig"].empty()) {
      transcodeConfig = make_shared<string>(boost::any_cast<string>(m["TranscodeConfig"]));
    }
    if (m.find("UrgentLiveStreamUrl") != m.end() && !m["UrgentLiveStreamUrl"].empty()) {
      urgentLiveStreamUrl = make_shared<string>(boost::any_cast<string>(m["UrgentLiveStreamUrl"]));
    }
    if (m.find("UrgentMaterialId") != m.end() && !m["UrgentMaterialId"].empty()) {
      urgentMaterialId = make_shared<string>(boost::any_cast<string>(m["UrgentMaterialId"]));
    }
  }


  virtual ~SetCasterConfigRequest() = default;
};
class SetCasterConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  SetCasterConfigResponseBody() {}

  explicit SetCasterConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCasterConfigResponseBody() = default;
};
class SetCasterConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCasterConfigResponseBody> body{};

  SetCasterConfigResponse() {}

  explicit SetCasterConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCasterConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCasterConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetCasterConfigResponse() = default;
};
class SetCasterSceneConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sceneId{};

  SetCasterSceneConfigRequest() {}

  explicit SetCasterSceneConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~SetCasterSceneConfigRequest() = default;
};
class SetCasterSceneConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetCasterSceneConfigResponseBody() {}

  explicit SetCasterSceneConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCasterSceneConfigResponseBody() = default;
};
class SetCasterSceneConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCasterSceneConfigResponseBody> body{};

  SetCasterSceneConfigResponse() {}

  explicit SetCasterSceneConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCasterSceneConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCasterSceneConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetCasterSceneConfigResponse() = default;
};
class SetCasterSyncGroupRequestSyncGroup : public Darabonba::Model {
public:
  shared_ptr<string> hostResourceId{};
  shared_ptr<long> mode{};
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<long> syncDelayThreshold{};
  shared_ptr<vector<long>> syncOffsets{};

  SetCasterSyncGroupRequestSyncGroup() {}

  explicit SetCasterSyncGroupRequestSyncGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostResourceId) {
      res["HostResourceId"] = boost::any(*hostResourceId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (syncDelayThreshold) {
      res["SyncDelayThreshold"] = boost::any(*syncDelayThreshold);
    }
    if (syncOffsets) {
      res["SyncOffsets"] = boost::any(*syncOffsets);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostResourceId") != m.end() && !m["HostResourceId"].empty()) {
      hostResourceId = make_shared<string>(boost::any_cast<string>(m["HostResourceId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SyncDelayThreshold") != m.end() && !m["SyncDelayThreshold"].empty()) {
      syncDelayThreshold = make_shared<long>(boost::any_cast<long>(m["SyncDelayThreshold"]));
    }
    if (m.find("SyncOffsets") != m.end() && !m["SyncOffsets"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SyncOffsets"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SyncOffsets"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      syncOffsets = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~SetCasterSyncGroupRequestSyncGroup() = default;
};
class SetCasterSyncGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<SetCasterSyncGroupRequestSyncGroup>> syncGroup{};

  SetCasterSyncGroupRequest() {}

  explicit SetCasterSyncGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (syncGroup) {
      vector<boost::any> temp1;
      for(auto item1:*syncGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SyncGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SyncGroup") != m.end() && !m["SyncGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SyncGroup"].type()) {
        vector<SetCasterSyncGroupRequestSyncGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SyncGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetCasterSyncGroupRequestSyncGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        syncGroup = make_shared<vector<SetCasterSyncGroupRequestSyncGroup>>(expect1);
      }
    }
  }


  virtual ~SetCasterSyncGroupRequest() = default;
};
class SetCasterSyncGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetCasterSyncGroupResponseBody() {}

  explicit SetCasterSyncGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCasterSyncGroupResponseBody() = default;
};
class SetCasterSyncGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCasterSyncGroupResponseBody> body{};

  SetCasterSyncGroupResponse() {}

  explicit SetCasterSyncGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCasterSyncGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCasterSyncGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SetCasterSyncGroupResponse() = default;
};
class SetCasterTimedEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> eventName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTimeUTC{};

  SetCasterTimedEventRequest() {}

  explicit SetCasterTimedEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTimeUTC) {
      res["StartTimeUTC"] = boost::any(*startTimeUTC);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTimeUTC") != m.end() && !m["StartTimeUTC"].empty()) {
      startTimeUTC = make_shared<string>(boost::any_cast<string>(m["StartTimeUTC"]));
    }
  }


  virtual ~SetCasterTimedEventRequest() = default;
};
class SetCasterTimedEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetCasterTimedEventResponseBody() {}

  explicit SetCasterTimedEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCasterTimedEventResponseBody() = default;
};
class SetCasterTimedEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCasterTimedEventResponseBody> body{};

  SetCasterTimedEventResponse() {}

  explicit SetCasterTimedEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCasterTimedEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCasterTimedEventResponseBody>(model1);
      }
    }
  }


  virtual ~SetCasterTimedEventResponse() = default;
};
class SetLiveDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> forceSet{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> SSLPri{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> securityToken{};

  SetLiveDomainCertificateRequest() {}

  explicit SetLiveDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (forceSet) {
      res["ForceSet"] = boost::any(*forceSet);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (SSLPri) {
      res["SSLPri"] = boost::any(*SSLPri);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ForceSet") != m.end() && !m["ForceSet"].empty()) {
      forceSet = make_shared<string>(boost::any_cast<string>(m["ForceSet"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SSLPri") != m.end() && !m["SSLPri"].empty()) {
      SSLPri = make_shared<string>(boost::any_cast<string>(m["SSLPri"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetLiveDomainCertificateRequest() = default;
};
class SetLiveDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveDomainCertificateResponseBody() {}

  explicit SetLiveDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveDomainCertificateResponseBody() = default;
};
class SetLiveDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveDomainCertificateResponseBody> body{};

  SetLiveDomainCertificateResponse() {}

  explicit SetLiveDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveDomainCertificateResponse() = default;
};
class SetLiveDomainStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functions{};
  shared_ptr<long> ownerId{};

  SetLiveDomainStagingConfigRequest() {}

  explicit SetLiveDomainStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~SetLiveDomainStagingConfigRequest() = default;
};
class SetLiveDomainStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveDomainStagingConfigResponseBody() {}

  explicit SetLiveDomainStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveDomainStagingConfigResponseBody() = default;
};
class SetLiveDomainStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveDomainStagingConfigResponseBody> body{};

  SetLiveDomainStagingConfigResponse() {}

  explicit SetLiveDomainStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveDomainStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveDomainStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveDomainStagingConfigResponse() = default;
};
class SetLiveEdgeTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> httpDns{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};
  shared_ptr<string> targetDomainList{};
  shared_ptr<string> transferArgs{};

  SetLiveEdgeTransferRequest() {}

  explicit SetLiveEdgeTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (httpDns) {
      res["HttpDns"] = boost::any(*httpDns);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (targetDomainList) {
      res["TargetDomainList"] = boost::any(*targetDomainList);
    }
    if (transferArgs) {
      res["TransferArgs"] = boost::any(*transferArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("HttpDns") != m.end() && !m["HttpDns"].empty()) {
      httpDns = make_shared<string>(boost::any_cast<string>(m["HttpDns"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TargetDomainList") != m.end() && !m["TargetDomainList"].empty()) {
      targetDomainList = make_shared<string>(boost::any_cast<string>(m["TargetDomainList"]));
    }
    if (m.find("TransferArgs") != m.end() && !m["TransferArgs"].empty()) {
      transferArgs = make_shared<string>(boost::any_cast<string>(m["TransferArgs"]));
    }
  }


  virtual ~SetLiveEdgeTransferRequest() = default;
};
class SetLiveEdgeTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveEdgeTransferResponseBody() {}

  explicit SetLiveEdgeTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveEdgeTransferResponseBody() = default;
};
class SetLiveEdgeTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveEdgeTransferResponseBody> body{};

  SetLiveEdgeTransferResponse() {}

  explicit SetLiveEdgeTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveEdgeTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveEdgeTransferResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveEdgeTransferResponse() = default;
};
class SetLiveLazyPullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pullAppName{};
  shared_ptr<string> pullDomainName{};
  shared_ptr<string> pullProtocol{};

  SetLiveLazyPullStreamInfoConfigRequest() {}

  explicit SetLiveLazyPullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pullAppName) {
      res["PullAppName"] = boost::any(*pullAppName);
    }
    if (pullDomainName) {
      res["PullDomainName"] = boost::any(*pullDomainName);
    }
    if (pullProtocol) {
      res["PullProtocol"] = boost::any(*pullProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PullAppName") != m.end() && !m["PullAppName"].empty()) {
      pullAppName = make_shared<string>(boost::any_cast<string>(m["PullAppName"]));
    }
    if (m.find("PullDomainName") != m.end() && !m["PullDomainName"].empty()) {
      pullDomainName = make_shared<string>(boost::any_cast<string>(m["PullDomainName"]));
    }
    if (m.find("PullProtocol") != m.end() && !m["PullProtocol"].empty()) {
      pullProtocol = make_shared<string>(boost::any_cast<string>(m["PullProtocol"]));
    }
  }


  virtual ~SetLiveLazyPullStreamInfoConfigRequest() = default;
};
class SetLiveLazyPullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveLazyPullStreamInfoConfigResponseBody() {}

  explicit SetLiveLazyPullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveLazyPullStreamInfoConfigResponseBody() = default;
};
class SetLiveLazyPullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveLazyPullStreamInfoConfigResponseBody> body{};

  SetLiveLazyPullStreamInfoConfigResponse() {}

  explicit SetLiveLazyPullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveLazyPullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveLazyPullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveLazyPullStreamInfoConfigResponse() = default;
};
class SetLiveStreamDelayConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> flvDelay{};
  shared_ptr<string> flvLevel{};
  shared_ptr<long> hlsDelay{};
  shared_ptr<string> hlsLevel{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> rtmpDelay{};
  shared_ptr<string> rtmpLevel{};

  SetLiveStreamDelayConfigRequest() {}

  explicit SetLiveStreamDelayConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (flvDelay) {
      res["FlvDelay"] = boost::any(*flvDelay);
    }
    if (flvLevel) {
      res["FlvLevel"] = boost::any(*flvLevel);
    }
    if (hlsDelay) {
      res["HlsDelay"] = boost::any(*hlsDelay);
    }
    if (hlsLevel) {
      res["HlsLevel"] = boost::any(*hlsLevel);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (rtmpDelay) {
      res["RtmpDelay"] = boost::any(*rtmpDelay);
    }
    if (rtmpLevel) {
      res["RtmpLevel"] = boost::any(*rtmpLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FlvDelay") != m.end() && !m["FlvDelay"].empty()) {
      flvDelay = make_shared<long>(boost::any_cast<long>(m["FlvDelay"]));
    }
    if (m.find("FlvLevel") != m.end() && !m["FlvLevel"].empty()) {
      flvLevel = make_shared<string>(boost::any_cast<string>(m["FlvLevel"]));
    }
    if (m.find("HlsDelay") != m.end() && !m["HlsDelay"].empty()) {
      hlsDelay = make_shared<long>(boost::any_cast<long>(m["HlsDelay"]));
    }
    if (m.find("HlsLevel") != m.end() && !m["HlsLevel"].empty()) {
      hlsLevel = make_shared<string>(boost::any_cast<string>(m["HlsLevel"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RtmpDelay") != m.end() && !m["RtmpDelay"].empty()) {
      rtmpDelay = make_shared<long>(boost::any_cast<long>(m["RtmpDelay"]));
    }
    if (m.find("RtmpLevel") != m.end() && !m["RtmpLevel"].empty()) {
      rtmpLevel = make_shared<string>(boost::any_cast<string>(m["RtmpLevel"]));
    }
  }


  virtual ~SetLiveStreamDelayConfigRequest() = default;
};
class SetLiveStreamDelayConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveStreamDelayConfigResponseBody() {}

  explicit SetLiveStreamDelayConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveStreamDelayConfigResponseBody() = default;
};
class SetLiveStreamDelayConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveStreamDelayConfigResponseBody> body{};

  SetLiveStreamDelayConfigResponse() {}

  explicit SetLiveStreamDelayConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveStreamDelayConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveStreamDelayConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveStreamDelayConfigResponse() = default;
};
class SetLiveStreamOptimizedFeatureConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configName{};
  shared_ptr<string> configStatus{};
  shared_ptr<string> configValue{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  SetLiveStreamOptimizedFeatureConfigRequest() {}

  explicit SetLiveStreamOptimizedFeatureConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configName) {
      res["ConfigName"] = boost::any(*configName);
    }
    if (configStatus) {
      res["ConfigStatus"] = boost::any(*configStatus);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigName") != m.end() && !m["ConfigName"].empty()) {
      configName = make_shared<string>(boost::any_cast<string>(m["ConfigName"]));
    }
    if (m.find("ConfigStatus") != m.end() && !m["ConfigStatus"].empty()) {
      configStatus = make_shared<string>(boost::any_cast<string>(m["ConfigStatus"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~SetLiveStreamOptimizedFeatureConfigRequest() = default;
};
class SetLiveStreamOptimizedFeatureConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveStreamOptimizedFeatureConfigResponseBody() {}

  explicit SetLiveStreamOptimizedFeatureConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveStreamOptimizedFeatureConfigResponseBody() = default;
};
class SetLiveStreamOptimizedFeatureConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveStreamOptimizedFeatureConfigResponseBody> body{};

  SetLiveStreamOptimizedFeatureConfigResponse() {}

  explicit SetLiveStreamOptimizedFeatureConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveStreamOptimizedFeatureConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveStreamOptimizedFeatureConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveStreamOptimizedFeatureConfigResponse() = default;
};
class SetLiveStreamsNotifyUrlConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyAuthKey{};
  shared_ptr<string> notifyReqAuth{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<long> ownerId{};

  SetLiveStreamsNotifyUrlConfigRequest() {}

  explicit SetLiveStreamsNotifyUrlConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyAuthKey) {
      res["NotifyAuthKey"] = boost::any(*notifyAuthKey);
    }
    if (notifyReqAuth) {
      res["NotifyReqAuth"] = boost::any(*notifyReqAuth);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyAuthKey") != m.end() && !m["NotifyAuthKey"].empty()) {
      notifyAuthKey = make_shared<string>(boost::any_cast<string>(m["NotifyAuthKey"]));
    }
    if (m.find("NotifyReqAuth") != m.end() && !m["NotifyReqAuth"].empty()) {
      notifyReqAuth = make_shared<string>(boost::any_cast<string>(m["NotifyReqAuth"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~SetLiveStreamsNotifyUrlConfigRequest() = default;
};
class SetLiveStreamsNotifyUrlConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveStreamsNotifyUrlConfigResponseBody() {}

  explicit SetLiveStreamsNotifyUrlConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveStreamsNotifyUrlConfigResponseBody() = default;
};
class SetLiveStreamsNotifyUrlConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveStreamsNotifyUrlConfigResponseBody> body{};

  SetLiveStreamsNotifyUrlConfigResponse() {}

  explicit SetLiveStreamsNotifyUrlConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveStreamsNotifyUrlConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveStreamsNotifyUrlConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveStreamsNotifyUrlConfigResponse() = default;
};
class SetSnapshotCallbackAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackAuthKey{};
  shared_ptr<string> callbackReqAuth{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  SetSnapshotCallbackAuthRequest() {}

  explicit SetSnapshotCallbackAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackAuthKey) {
      res["CallbackAuthKey"] = boost::any(*callbackAuthKey);
    }
    if (callbackReqAuth) {
      res["CallbackReqAuth"] = boost::any(*callbackReqAuth);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackAuthKey") != m.end() && !m["CallbackAuthKey"].empty()) {
      callbackAuthKey = make_shared<string>(boost::any_cast<string>(m["CallbackAuthKey"]));
    }
    if (m.find("CallbackReqAuth") != m.end() && !m["CallbackReqAuth"].empty()) {
      callbackReqAuth = make_shared<string>(boost::any_cast<string>(m["CallbackReqAuth"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~SetSnapshotCallbackAuthRequest() = default;
};
class SetSnapshotCallbackAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetSnapshotCallbackAuthResponseBody() {}

  explicit SetSnapshotCallbackAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetSnapshotCallbackAuthResponseBody() = default;
};
class SetSnapshotCallbackAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetSnapshotCallbackAuthResponseBody> body{};

  SetSnapshotCallbackAuthResponse() {}

  explicit SetSnapshotCallbackAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetSnapshotCallbackAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetSnapshotCallbackAuthResponseBody>(model1);
      }
    }
  }


  virtual ~SetSnapshotCallbackAuthResponse() = default;
};
class StartCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  StartCasterRequest() {}

  explicit StartCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~StartCasterRequest() = default;
};
class StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo : public Darabonba::Model {
public:
  shared_ptr<string> outputStreamUrl{};
  shared_ptr<string> transcodeConfig{};
  shared_ptr<string> videoFormat{};

  StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo() {}

  explicit StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputStreamUrl) {
      res["OutputStreamUrl"] = boost::any(*outputStreamUrl);
    }
    if (transcodeConfig) {
      res["TranscodeConfig"] = boost::any(*transcodeConfig);
    }
    if (videoFormat) {
      res["VideoFormat"] = boost::any(*videoFormat);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputStreamUrl") != m.end() && !m["OutputStreamUrl"].empty()) {
      outputStreamUrl = make_shared<string>(boost::any_cast<string>(m["OutputStreamUrl"]));
    }
    if (m.find("TranscodeConfig") != m.end() && !m["TranscodeConfig"].empty()) {
      transcodeConfig = make_shared<string>(boost::any_cast<string>(m["TranscodeConfig"]));
    }
    if (m.find("VideoFormat") != m.end() && !m["VideoFormat"].empty()) {
      videoFormat = make_shared<string>(boost::any_cast<string>(m["VideoFormat"]));
    }
  }


  virtual ~StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo() = default;
};
class StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos : public Darabonba::Model {
public:
  shared_ptr<vector<StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo>> streamInfo{};

  StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos() {}

  explicit StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamInfo) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamInfo") != m.end() && !m["StreamInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfo"].type()) {
        vector<StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfo = make_shared<vector<StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo>>(expect1);
      }
    }
  }


  virtual ~StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos() = default;
};
class StartCasterResponseBodyPgmSceneInfosSceneInfo : public Darabonba::Model {
public:
  shared_ptr<string> sceneId{};
  shared_ptr<StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos> streamInfos{};
  shared_ptr<string> streamUrl{};

  StartCasterResponseBodyPgmSceneInfosSceneInfo() {}

  explicit StartCasterResponseBodyPgmSceneInfosSceneInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    if (streamInfos) {
      res["StreamInfos"] = streamInfos ? boost::any(streamInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInfos"].type()) {
        StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInfos"]));
        streamInfos = make_shared<StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos>(model1);
      }
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~StartCasterResponseBodyPgmSceneInfosSceneInfo() = default;
};
class StartCasterResponseBodyPgmSceneInfos : public Darabonba::Model {
public:
  shared_ptr<vector<StartCasterResponseBodyPgmSceneInfosSceneInfo>> sceneInfo{};

  StartCasterResponseBodyPgmSceneInfos() {}

  explicit StartCasterResponseBodyPgmSceneInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sceneInfo) {
      vector<boost::any> temp1;
      for(auto item1:*sceneInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SceneInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SceneInfo") != m.end() && !m["SceneInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SceneInfo"].type()) {
        vector<StartCasterResponseBodyPgmSceneInfosSceneInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SceneInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartCasterResponseBodyPgmSceneInfosSceneInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sceneInfo = make_shared<vector<StartCasterResponseBodyPgmSceneInfosSceneInfo>>(expect1);
      }
    }
  }


  virtual ~StartCasterResponseBodyPgmSceneInfos() = default;
};
class StartCasterResponseBodyPvwSceneInfosSceneInfo : public Darabonba::Model {
public:
  shared_ptr<string> sceneId{};
  shared_ptr<string> streamUrl{};

  StartCasterResponseBodyPvwSceneInfosSceneInfo() {}

  explicit StartCasterResponseBodyPvwSceneInfosSceneInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~StartCasterResponseBodyPvwSceneInfosSceneInfo() = default;
};
class StartCasterResponseBodyPvwSceneInfos : public Darabonba::Model {
public:
  shared_ptr<vector<StartCasterResponseBodyPvwSceneInfosSceneInfo>> sceneInfo{};

  StartCasterResponseBodyPvwSceneInfos() {}

  explicit StartCasterResponseBodyPvwSceneInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sceneInfo) {
      vector<boost::any> temp1;
      for(auto item1:*sceneInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SceneInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SceneInfo") != m.end() && !m["SceneInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SceneInfo"].type()) {
        vector<StartCasterResponseBodyPvwSceneInfosSceneInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SceneInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartCasterResponseBodyPvwSceneInfosSceneInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sceneInfo = make_shared<vector<StartCasterResponseBodyPvwSceneInfosSceneInfo>>(expect1);
      }
    }
  }


  virtual ~StartCasterResponseBodyPvwSceneInfos() = default;
};
class StartCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<StartCasterResponseBodyPgmSceneInfos> pgmSceneInfos{};
  shared_ptr<StartCasterResponseBodyPvwSceneInfos> pvwSceneInfos{};
  shared_ptr<string> requestId{};

  StartCasterResponseBody() {}

  explicit StartCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pgmSceneInfos) {
      res["PgmSceneInfos"] = pgmSceneInfos ? boost::any(pgmSceneInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pvwSceneInfos) {
      res["PvwSceneInfos"] = pvwSceneInfos ? boost::any(pvwSceneInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PgmSceneInfos") != m.end() && !m["PgmSceneInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PgmSceneInfos"].type()) {
        StartCasterResponseBodyPgmSceneInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PgmSceneInfos"]));
        pgmSceneInfos = make_shared<StartCasterResponseBodyPgmSceneInfos>(model1);
      }
    }
    if (m.find("PvwSceneInfos") != m.end() && !m["PvwSceneInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PvwSceneInfos"].type()) {
        StartCasterResponseBodyPvwSceneInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PvwSceneInfos"]));
        pvwSceneInfos = make_shared<StartCasterResponseBodyPvwSceneInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartCasterResponseBody() = default;
};
class StartCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartCasterResponseBody> body{};

  StartCasterResponse() {}

  explicit StartCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartCasterResponseBody>(model1);
      }
    }
  }


  virtual ~StartCasterResponse() = default;
};
class StartCasterSceneRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sceneId{};

  StartCasterSceneRequest() {}

  explicit StartCasterSceneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~StartCasterSceneRequest() = default;
};
class StartCasterSceneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> streamUrl{};

  StartCasterSceneResponseBody() {}

  explicit StartCasterSceneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~StartCasterSceneResponseBody() = default;
};
class StartCasterSceneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartCasterSceneResponseBody> body{};

  StartCasterSceneResponse() {}

  explicit StartCasterSceneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartCasterSceneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartCasterSceneResponseBody>(model1);
      }
    }
  }


  virtual ~StartCasterSceneResponse() = default;
};
class StartLiveDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  StartLiveDomainRequest() {}

  explicit StartLiveDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~StartLiveDomainRequest() = default;
};
class StartLiveDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartLiveDomainResponseBody() {}

  explicit StartLiveDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartLiveDomainResponseBody() = default;
};
class StartLiveDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartLiveDomainResponseBody> body{};

  StartLiveDomainResponse() {}

  explicit StartLiveDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartLiveDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartLiveDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StartLiveDomainResponse() = default;
};
class StartLiveStreamMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> monitorId{};
  shared_ptr<long> ownerId{};

  StartLiveStreamMonitorRequest() {}

  explicit StartLiveStreamMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~StartLiveStreamMonitorRequest() = default;
};
class StartLiveStreamMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartLiveStreamMonitorResponseBody() {}

  explicit StartLiveStreamMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartLiveStreamMonitorResponseBody() = default;
};
class StartLiveStreamMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartLiveStreamMonitorResponseBody> body{};

  StartLiveStreamMonitorResponse() {}

  explicit StartLiveStreamMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartLiveStreamMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartLiveStreamMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~StartLiveStreamMonitorResponse() = default;
};
class StartPlaylistRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};
  shared_ptr<string> resumeMode{};
  shared_ptr<string> startItemId{};

  StartPlaylistRequest() {}

  explicit StartPlaylistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (resumeMode) {
      res["ResumeMode"] = boost::any(*resumeMode);
    }
    if (startItemId) {
      res["StartItemId"] = boost::any(*startItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ResumeMode") != m.end() && !m["ResumeMode"].empty()) {
      resumeMode = make_shared<string>(boost::any_cast<string>(m["ResumeMode"]));
    }
    if (m.find("StartItemId") != m.end() && !m["StartItemId"].empty()) {
      startItemId = make_shared<string>(boost::any_cast<string>(m["StartItemId"]));
    }
  }


  virtual ~StartPlaylistRequest() = default;
};
class StartPlaylistResponseBodyStreamInfoStreamsStream : public Darabonba::Model {
public:
  shared_ptr<string> pullFlvUrl{};
  shared_ptr<string> pullM3U8Url{};
  shared_ptr<string> pullRtmpUrl{};
  shared_ptr<string> quality{};

  StartPlaylistResponseBodyStreamInfoStreamsStream() {}

  explicit StartPlaylistResponseBodyStreamInfoStreamsStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pullFlvUrl) {
      res["PullFlvUrl"] = boost::any(*pullFlvUrl);
    }
    if (pullM3U8Url) {
      res["PullM3U8Url"] = boost::any(*pullM3U8Url);
    }
    if (pullRtmpUrl) {
      res["PullRtmpUrl"] = boost::any(*pullRtmpUrl);
    }
    if (quality) {
      res["Quality"] = boost::any(*quality);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PullFlvUrl") != m.end() && !m["PullFlvUrl"].empty()) {
      pullFlvUrl = make_shared<string>(boost::any_cast<string>(m["PullFlvUrl"]));
    }
    if (m.find("PullM3U8Url") != m.end() && !m["PullM3U8Url"].empty()) {
      pullM3U8Url = make_shared<string>(boost::any_cast<string>(m["PullM3U8Url"]));
    }
    if (m.find("PullRtmpUrl") != m.end() && !m["PullRtmpUrl"].empty()) {
      pullRtmpUrl = make_shared<string>(boost::any_cast<string>(m["PullRtmpUrl"]));
    }
    if (m.find("Quality") != m.end() && !m["Quality"].empty()) {
      quality = make_shared<string>(boost::any_cast<string>(m["Quality"]));
    }
  }


  virtual ~StartPlaylistResponseBodyStreamInfoStreamsStream() = default;
};
class StartPlaylistResponseBodyStreamInfoStreams : public Darabonba::Model {
public:
  shared_ptr<vector<StartPlaylistResponseBodyStreamInfoStreamsStream>> stream{};

  StartPlaylistResponseBodyStreamInfoStreams() {}

  explicit StartPlaylistResponseBodyStreamInfoStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stream) {
      vector<boost::any> temp1;
      for(auto item1:*stream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Stream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      if (typeid(vector<boost::any>) == m["Stream"].type()) {
        vector<StartPlaylistResponseBodyStreamInfoStreamsStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Stream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartPlaylistResponseBodyStreamInfoStreamsStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stream = make_shared<vector<StartPlaylistResponseBodyStreamInfoStreamsStream>>(expect1);
      }
    }
  }


  virtual ~StartPlaylistResponseBodyStreamInfoStreams() = default;
};
class StartPlaylistResponseBodyStreamInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> streamName{};
  shared_ptr<StartPlaylistResponseBodyStreamInfoStreams> streams{};

  StartPlaylistResponseBodyStreamInfo() {}

  explicit StartPlaylistResponseBodyStreamInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        StartPlaylistResponseBodyStreamInfoStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<StartPlaylistResponseBodyStreamInfoStreams>(model1);
      }
    }
  }


  virtual ~StartPlaylistResponseBodyStreamInfo() = default;
};
class StartPlaylistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};
  shared_ptr<StartPlaylistResponseBodyStreamInfo> streamInfo{};

  StartPlaylistResponseBody() {}

  explicit StartPlaylistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamInfo) {
      res["StreamInfo"] = streamInfo ? boost::any(streamInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamInfo") != m.end() && !m["StreamInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInfo"].type()) {
        StartPlaylistResponseBodyStreamInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInfo"]));
        streamInfo = make_shared<StartPlaylistResponseBodyStreamInfo>(model1);
      }
    }
  }


  virtual ~StartPlaylistResponseBody() = default;
};
class StartPlaylistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartPlaylistResponseBody> body{};

  StartPlaylistResponse() {}

  explicit StartPlaylistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartPlaylistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartPlaylistResponseBody>(model1);
      }
    }
  }


  virtual ~StartPlaylistResponse() = default;
};
class StopCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};

  StopCasterRequest() {}

  explicit StopCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~StopCasterRequest() = default;
};
class StopCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopCasterResponseBody() {}

  explicit StopCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopCasterResponseBody() = default;
};
class StopCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopCasterResponseBody> body{};

  StopCasterResponse() {}

  explicit StopCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopCasterResponseBody>(model1);
      }
    }
  }


  virtual ~StopCasterResponse() = default;
};
class StopCasterSceneRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sceneId{};

  StopCasterSceneRequest() {}

  explicit StopCasterSceneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~StopCasterSceneRequest() = default;
};
class StopCasterSceneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopCasterSceneResponseBody() {}

  explicit StopCasterSceneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopCasterSceneResponseBody() = default;
};
class StopCasterSceneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopCasterSceneResponseBody> body{};

  StopCasterSceneResponse() {}

  explicit StopCasterSceneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopCasterSceneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopCasterSceneResponseBody>(model1);
      }
    }
  }


  virtual ~StopCasterSceneResponse() = default;
};
class StopLiveDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  StopLiveDomainRequest() {}

  explicit StopLiveDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~StopLiveDomainRequest() = default;
};
class StopLiveDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopLiveDomainResponseBody() {}

  explicit StopLiveDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopLiveDomainResponseBody() = default;
};
class StopLiveDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopLiveDomainResponseBody> body{};

  StopLiveDomainResponse() {}

  explicit StopLiveDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopLiveDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopLiveDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StopLiveDomainResponse() = default;
};
class StopLiveStreamMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> monitorId{};
  shared_ptr<long> ownerId{};

  StopLiveStreamMonitorRequest() {}

  explicit StopLiveStreamMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~StopLiveStreamMonitorRequest() = default;
};
class StopLiveStreamMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopLiveStreamMonitorResponseBody() {}

  explicit StopLiveStreamMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopLiveStreamMonitorResponseBody() = default;
};
class StopLiveStreamMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopLiveStreamMonitorResponseBody> body{};

  StopLiveStreamMonitorResponse() {}

  explicit StopLiveStreamMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopLiveStreamMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopLiveStreamMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~StopLiveStreamMonitorResponse() = default;
};
class StopPlaylistRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};

  StopPlaylistRequest() {}

  explicit StopPlaylistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
  }


  virtual ~StopPlaylistRequest() = default;
};
class StopPlaylistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  StopPlaylistResponseBody() {}

  explicit StopPlaylistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopPlaylistResponseBody() = default;
};
class StopPlaylistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopPlaylistResponseBody> body{};

  StopPlaylistResponse() {}

  explicit StopPlaylistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopPlaylistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopPlaylistResponseBody>(model1);
      }
    }
  }


  virtual ~StopPlaylistResponse() = default;
};
class TagLiveResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagLiveResourcesRequestTag() {}

  explicit TagLiveResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagLiveResourcesRequestTag() = default;
};
class TagLiveResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagLiveResourcesRequestTag>> tag{};

  TagLiveResourcesRequest() {}

  explicit TagLiveResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagLiveResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagLiveResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagLiveResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagLiveResourcesRequest() = default;
};
class TagLiveResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagLiveResourcesResponseBody() {}

  explicit TagLiveResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagLiveResourcesResponseBody() = default;
};
class TagLiveResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagLiveResourcesResponseBody> body{};

  TagLiveResourcesResponse() {}

  explicit TagLiveResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagLiveResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagLiveResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagLiveResourcesResponse() = default;
};
class UnTagLiveResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UnTagLiveResourcesRequest() {}

  explicit UnTagLiveResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UnTagLiveResourcesRequest() = default;
};
class UnTagLiveResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnTagLiveResourcesResponseBody() {}

  explicit UnTagLiveResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnTagLiveResourcesResponseBody() = default;
};
class UnTagLiveResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnTagLiveResourcesResponseBody> body{};

  UnTagLiveResourcesResponse() {}

  explicit UnTagLiveResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnTagLiveResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnTagLiveResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UnTagLiveResourcesResponse() = default;
};
class UpdateCasterSceneAudioRequestAudioLayer : public Darabonba::Model {
public:
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  UpdateCasterSceneAudioRequestAudioLayer() {}

  explicit UpdateCasterSceneAudioRequestAudioLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~UpdateCasterSceneAudioRequestAudioLayer() = default;
};
class UpdateCasterSceneAudioRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateCasterSceneAudioRequestAudioLayer>> audioLayer{};
  shared_ptr<string> casterId{};
  shared_ptr<long> followEnable{};
  shared_ptr<vector<string>> mixList{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sceneId{};

  UpdateCasterSceneAudioRequest() {}

  explicit UpdateCasterSceneAudioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayer) {
      vector<boost::any> temp1;
      for(auto item1:*audioLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioLayer"] = boost::any(temp1);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (followEnable) {
      res["FollowEnable"] = boost::any(*followEnable);
    }
    if (mixList) {
      res["MixList"] = boost::any(*mixList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayer") != m.end() && !m["AudioLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioLayer"].type()) {
        vector<UpdateCasterSceneAudioRequestAudioLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCasterSceneAudioRequestAudioLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioLayer = make_shared<vector<UpdateCasterSceneAudioRequestAudioLayer>>(expect1);
      }
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("FollowEnable") != m.end() && !m["FollowEnable"].empty()) {
      followEnable = make_shared<long>(boost::any_cast<long>(m["FollowEnable"]));
    }
    if (m.find("MixList") != m.end() && !m["MixList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MixList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MixList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mixList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~UpdateCasterSceneAudioRequest() = default;
};
class UpdateCasterSceneAudioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCasterSceneAudioResponseBody() {}

  explicit UpdateCasterSceneAudioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCasterSceneAudioResponseBody() = default;
};
class UpdateCasterSceneAudioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCasterSceneAudioResponseBody> body{};

  UpdateCasterSceneAudioResponse() {}

  explicit UpdateCasterSceneAudioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCasterSceneAudioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCasterSceneAudioResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCasterSceneAudioResponse() = default;
};
class UpdateCasterSceneConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sceneId{};

  UpdateCasterSceneConfigRequest() {}

  explicit UpdateCasterSceneConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~UpdateCasterSceneConfigRequest() = default;
};
class UpdateCasterSceneConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCasterSceneConfigResponseBody() {}

  explicit UpdateCasterSceneConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCasterSceneConfigResponseBody() = default;
};
class UpdateCasterSceneConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCasterSceneConfigResponseBody> body{};

  UpdateCasterSceneConfigResponse() {}

  explicit UpdateCasterSceneConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCasterSceneConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCasterSceneConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCasterSceneConfigResponse() = default;
};
class UpdateLiveAppSnapshotConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> callback{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> overwriteOssObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sequenceOssObject{};
  shared_ptr<long> timeInterval{};

  UpdateLiveAppSnapshotConfigRequest() {}

  explicit UpdateLiveAppSnapshotConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (overwriteOssObject) {
      res["OverwriteOssObject"] = boost::any(*overwriteOssObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sequenceOssObject) {
      res["SequenceOssObject"] = boost::any(*sequenceOssObject);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OverwriteOssObject") != m.end() && !m["OverwriteOssObject"].empty()) {
      overwriteOssObject = make_shared<string>(boost::any_cast<string>(m["OverwriteOssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SequenceOssObject") != m.end() && !m["SequenceOssObject"].empty()) {
      sequenceOssObject = make_shared<string>(boost::any_cast<string>(m["SequenceOssObject"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~UpdateLiveAppSnapshotConfigRequest() = default;
};
class UpdateLiveAppSnapshotConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveAppSnapshotConfigResponseBody() {}

  explicit UpdateLiveAppSnapshotConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveAppSnapshotConfigResponseBody() = default;
};
class UpdateLiveAppSnapshotConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveAppSnapshotConfigResponseBody> body{};

  UpdateLiveAppSnapshotConfigResponse() {}

  explicit UpdateLiveAppSnapshotConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveAppSnapshotConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveAppSnapshotConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveAppSnapshotConfigResponse() = default;
};
class UpdateLiveAudioAuditConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> bizType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  UpdateLiveAudioAuditConfigRequest() {}

  explicit UpdateLiveAudioAuditConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~UpdateLiveAudioAuditConfigRequest() = default;
};
class UpdateLiveAudioAuditConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveAudioAuditConfigResponseBody() {}

  explicit UpdateLiveAudioAuditConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveAudioAuditConfigResponseBody() = default;
};
class UpdateLiveAudioAuditConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveAudioAuditConfigResponseBody> body{};

  UpdateLiveAudioAuditConfigResponse() {}

  explicit UpdateLiveAudioAuditConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveAudioAuditConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveAudioAuditConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveAudioAuditConfigResponse() = default;
};
class UpdateLiveAudioAuditNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> callback{};
  shared_ptr<string> callbackTemplate{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  UpdateLiveAudioAuditNotifyConfigRequest() {}

  explicit UpdateLiveAudioAuditNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (callbackTemplate) {
      res["CallbackTemplate"] = boost::any(*callbackTemplate);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CallbackTemplate") != m.end() && !m["CallbackTemplate"].empty()) {
      callbackTemplate = make_shared<string>(boost::any_cast<string>(m["CallbackTemplate"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~UpdateLiveAudioAuditNotifyConfigRequest() = default;
};
class UpdateLiveAudioAuditNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveAudioAuditNotifyConfigResponseBody() {}

  explicit UpdateLiveAudioAuditNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveAudioAuditNotifyConfigResponseBody() = default;
};
class UpdateLiveAudioAuditNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveAudioAuditNotifyConfigResponseBody> body{};

  UpdateLiveAudioAuditNotifyConfigResponse() {}

  explicit UpdateLiveAudioAuditNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveAudioAuditNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveAudioAuditNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveAudioAuditNotifyConfigResponse() = default;
};
class UpdateLiveDetectNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  UpdateLiveDetectNotifyConfigRequest() {}

  explicit UpdateLiveDetectNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~UpdateLiveDetectNotifyConfigRequest() = default;
};
class UpdateLiveDetectNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveDetectNotifyConfigResponseBody() {}

  explicit UpdateLiveDetectNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveDetectNotifyConfigResponseBody() = default;
};
class UpdateLiveDetectNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveDetectNotifyConfigResponseBody> body{};

  UpdateLiveDetectNotifyConfigResponse() {}

  explicit UpdateLiveDetectNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveDetectNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveDetectNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveDetectNotifyConfigResponse() = default;
};
class UpdateLivePullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  UpdateLivePullStreamInfoConfigRequest() {}

  explicit UpdateLivePullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~UpdateLivePullStreamInfoConfigRequest() = default;
};
class UpdateLivePullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLivePullStreamInfoConfigResponseBody() {}

  explicit UpdateLivePullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLivePullStreamInfoConfigResponseBody() = default;
};
class UpdateLivePullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLivePullStreamInfoConfigResponseBody> body{};

  UpdateLivePullStreamInfoConfigResponse() {}

  explicit UpdateLivePullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLivePullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLivePullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLivePullStreamInfoConfigResponse() = default;
};
class UpdateLiveRecordNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<bool> needStatusNotify{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> onDemandUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  UpdateLiveRecordNotifyConfigRequest() {}

  explicit UpdateLiveRecordNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (needStatusNotify) {
      res["NeedStatusNotify"] = boost::any(*needStatusNotify);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (onDemandUrl) {
      res["OnDemandUrl"] = boost::any(*onDemandUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NeedStatusNotify") != m.end() && !m["NeedStatusNotify"].empty()) {
      needStatusNotify = make_shared<bool>(boost::any_cast<bool>(m["NeedStatusNotify"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OnDemandUrl") != m.end() && !m["OnDemandUrl"].empty()) {
      onDemandUrl = make_shared<string>(boost::any_cast<string>(m["OnDemandUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~UpdateLiveRecordNotifyConfigRequest() = default;
};
class UpdateLiveRecordNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveRecordNotifyConfigResponseBody() {}

  explicit UpdateLiveRecordNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveRecordNotifyConfigResponseBody() = default;
};
class UpdateLiveRecordNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveRecordNotifyConfigResponseBody> body{};

  UpdateLiveRecordNotifyConfigResponse() {}

  explicit UpdateLiveRecordNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveRecordNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveRecordNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveRecordNotifyConfigResponse() = default;
};
class UpdateLiveSnapshotDetectPornConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> interval{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> scene{};
  shared_ptr<string> securityToken{};

  UpdateLiveSnapshotDetectPornConfigRequest() {}

  explicit UpdateLiveSnapshotDetectPornConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Scene"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Scene"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scene = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~UpdateLiveSnapshotDetectPornConfigRequest() = default;
};
class UpdateLiveSnapshotDetectPornConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveSnapshotDetectPornConfigResponseBody() {}

  explicit UpdateLiveSnapshotDetectPornConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveSnapshotDetectPornConfigResponseBody() = default;
};
class UpdateLiveSnapshotDetectPornConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveSnapshotDetectPornConfigResponseBody> body{};

  UpdateLiveSnapshotDetectPornConfigResponse() {}

  explicit UpdateLiveSnapshotDetectPornConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveSnapshotDetectPornConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveSnapshotDetectPornConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveSnapshotDetectPornConfigResponse() = default;
};
class UpdateLiveSnapshotNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyAuthKey{};
  shared_ptr<string> notifyReqAuth{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<long> ownerId{};

  UpdateLiveSnapshotNotifyConfigRequest() {}

  explicit UpdateLiveSnapshotNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyAuthKey) {
      res["NotifyAuthKey"] = boost::any(*notifyAuthKey);
    }
    if (notifyReqAuth) {
      res["NotifyReqAuth"] = boost::any(*notifyReqAuth);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyAuthKey") != m.end() && !m["NotifyAuthKey"].empty()) {
      notifyAuthKey = make_shared<string>(boost::any_cast<string>(m["NotifyAuthKey"]));
    }
    if (m.find("NotifyReqAuth") != m.end() && !m["NotifyReqAuth"].empty()) {
      notifyReqAuth = make_shared<string>(boost::any_cast<string>(m["NotifyReqAuth"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~UpdateLiveSnapshotNotifyConfigRequest() = default;
};
class UpdateLiveSnapshotNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveSnapshotNotifyConfigResponseBody() {}

  explicit UpdateLiveSnapshotNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveSnapshotNotifyConfigResponseBody() = default;
};
class UpdateLiveSnapshotNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveSnapshotNotifyConfigResponseBody> body{};

  UpdateLiveSnapshotNotifyConfigResponse() {}

  explicit UpdateLiveSnapshotNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveSnapshotNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveSnapshotNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveSnapshotNotifyConfigResponse() = default;
};
class UpdateLiveStreamMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<string> inputList{};
  shared_ptr<string> monitorId{};
  shared_ptr<string> monitorName{};
  shared_ptr<string> outputTemplate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> stream{};

  UpdateLiveStreamMonitorRequest() {}

  explicit UpdateLiveStreamMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (inputList) {
      res["InputList"] = boost::any(*inputList);
    }
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (monitorName) {
      res["MonitorName"] = boost::any(*monitorName);
    }
    if (outputTemplate) {
      res["OutputTemplate"] = boost::any(*outputTemplate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      inputList = make_shared<string>(boost::any_cast<string>(m["InputList"]));
    }
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("MonitorName") != m.end() && !m["MonitorName"].empty()) {
      monitorName = make_shared<string>(boost::any_cast<string>(m["MonitorName"]));
    }
    if (m.find("OutputTemplate") != m.end() && !m["OutputTemplate"].empty()) {
      outputTemplate = make_shared<string>(boost::any_cast<string>(m["OutputTemplate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~UpdateLiveStreamMonitorRequest() = default;
};
class UpdateLiveStreamMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveStreamMonitorResponseBody() {}

  explicit UpdateLiveStreamMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveStreamMonitorResponseBody() = default;
};
class UpdateLiveStreamMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveStreamMonitorResponseBody> body{};

  UpdateLiveStreamMonitorResponse() {}

  explicit UpdateLiveStreamMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveStreamMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveStreamMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveStreamMonitorResponse() = default;
};
class UpdateLiveStreamWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> height{};
  shared_ptr<string> name{};
  shared_ptr<string> offsetCorner{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pictureUrl{};
  shared_ptr<long> refHeight{};
  shared_ptr<long> refWidth{};
  shared_ptr<string> templateId{};
  shared_ptr<long> transparency{};
  shared_ptr<double> XOffset{};
  shared_ptr<double> YOffset{};

  UpdateLiveStreamWatermarkRequest() {}

  explicit UpdateLiveStreamWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (offsetCorner) {
      res["OffsetCorner"] = boost::any(*offsetCorner);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pictureUrl) {
      res["PictureUrl"] = boost::any(*pictureUrl);
    }
    if (refHeight) {
      res["RefHeight"] = boost::any(*refHeight);
    }
    if (refWidth) {
      res["RefWidth"] = boost::any(*refWidth);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transparency) {
      res["Transparency"] = boost::any(*transparency);
    }
    if (XOffset) {
      res["XOffset"] = boost::any(*XOffset);
    }
    if (YOffset) {
      res["YOffset"] = boost::any(*YOffset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OffsetCorner") != m.end() && !m["OffsetCorner"].empty()) {
      offsetCorner = make_shared<string>(boost::any_cast<string>(m["OffsetCorner"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PictureUrl") != m.end() && !m["PictureUrl"].empty()) {
      pictureUrl = make_shared<string>(boost::any_cast<string>(m["PictureUrl"]));
    }
    if (m.find("RefHeight") != m.end() && !m["RefHeight"].empty()) {
      refHeight = make_shared<long>(boost::any_cast<long>(m["RefHeight"]));
    }
    if (m.find("RefWidth") != m.end() && !m["RefWidth"].empty()) {
      refWidth = make_shared<long>(boost::any_cast<long>(m["RefWidth"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Transparency") != m.end() && !m["Transparency"].empty()) {
      transparency = make_shared<long>(boost::any_cast<long>(m["Transparency"]));
    }
    if (m.find("XOffset") != m.end() && !m["XOffset"].empty()) {
      XOffset = make_shared<double>(boost::any_cast<double>(m["XOffset"]));
    }
    if (m.find("YOffset") != m.end() && !m["YOffset"].empty()) {
      YOffset = make_shared<double>(boost::any_cast<double>(m["YOffset"]));
    }
  }


  virtual ~UpdateLiveStreamWatermarkRequest() = default;
};
class UpdateLiveStreamWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveStreamWatermarkResponseBody() {}

  explicit UpdateLiveStreamWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveStreamWatermarkResponseBody() = default;
};
class UpdateLiveStreamWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveStreamWatermarkResponseBody> body{};

  UpdateLiveStreamWatermarkResponse() {}

  explicit UpdateLiveStreamWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveStreamWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveStreamWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveStreamWatermarkResponse() = default;
};
class UpdateLiveStreamWatermarkRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> templateId{};

  UpdateLiveStreamWatermarkRuleRequest() {}

  explicit UpdateLiveStreamWatermarkRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateLiveStreamWatermarkRuleRequest() = default;
};
class UpdateLiveStreamWatermarkRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveStreamWatermarkRuleResponseBody() {}

  explicit UpdateLiveStreamWatermarkRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveStreamWatermarkRuleResponseBody() = default;
};
class UpdateLiveStreamWatermarkRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveStreamWatermarkRuleResponseBody> body{};

  UpdateLiveStreamWatermarkRuleResponse() {}

  explicit UpdateLiveStreamWatermarkRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveStreamWatermarkRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveStreamWatermarkRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveStreamWatermarkRuleResponse() = default;
};
class UpdateLiveTopLevelDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> topLevelDomain{};

  UpdateLiveTopLevelDomainRequest() {}

  explicit UpdateLiveTopLevelDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~UpdateLiveTopLevelDomainRequest() = default;
};
class UpdateLiveTopLevelDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveTopLevelDomainResponseBody() {}

  explicit UpdateLiveTopLevelDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveTopLevelDomainResponseBody() = default;
};
class UpdateLiveTopLevelDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveTopLevelDomainResponseBody> body{};

  UpdateLiveTopLevelDomainResponse() {}

  explicit UpdateLiveTopLevelDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveTopLevelDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveTopLevelDomainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveTopLevelDomainResponse() = default;
};
class UpdateMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> appConfig{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<map<string, string>> extension{};

  UpdateMessageAppRequest() {}

  explicit UpdateMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["AppConfig"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      appConfig = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~UpdateMessageAppRequest() = default;
};
class UpdateMessageAppShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appConfigShrink{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> extensionShrink{};

  UpdateMessageAppShrinkRequest() {}

  explicit UpdateMessageAppShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfigShrink) {
      res["AppConfig"] = boost::any(*appConfigShrink);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (extensionShrink) {
      res["Extension"] = boost::any(*extensionShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      appConfigShrink = make_shared<string>(boost::any_cast<string>(m["AppConfig"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extensionShrink = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
  }


  virtual ~UpdateMessageAppShrinkRequest() = default;
};
class UpdateMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  UpdateMessageAppResponseBodyResult() {}

  explicit UpdateMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMessageAppResponseBodyResult() = default;
};
class UpdateMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateMessageAppResponseBodyResult> result{};

  UpdateMessageAppResponseBody() {}

  explicit UpdateMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateMessageAppResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateMessageAppResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateMessageAppResponseBody() = default;
};
class UpdateMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMessageAppResponseBody> body{};

  UpdateMessageAppResponse() {}

  explicit UpdateMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMessageAppResponse() = default;
};
class UpdateMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<map<string, string>> extension{};
  shared_ptr<string> groupId{};

  UpdateMessageGroupRequest() {}

  explicit UpdateMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~UpdateMessageGroupRequest() = default;
};
class UpdateMessageGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> extensionShrink{};
  shared_ptr<string> groupId{};

  UpdateMessageGroupShrinkRequest() {}

  explicit UpdateMessageGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (extensionShrink) {
      res["Extension"] = boost::any(*extensionShrink);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extensionShrink = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~UpdateMessageGroupShrinkRequest() = default;
};
class UpdateMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  UpdateMessageGroupResponseBodyResult() {}

  explicit UpdateMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMessageGroupResponseBodyResult() = default;
};
class UpdateMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateMessageGroupResponseBodyResult> result{};

  UpdateMessageGroupResponseBody() {}

  explicit UpdateMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateMessageGroupResponseBody() = default;
};
class UpdateMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMessageGroupResponseBody> body{};

  UpdateMessageGroupResponse() {}

  explicit UpdateMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMessageGroupResponse() = default;
};
class UpdateMixStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> inputStreamList{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> mixStreamId{};
  shared_ptr<long> ownerId{};

  UpdateMixStreamRequest() {}

  explicit UpdateMixStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (inputStreamList) {
      res["InputStreamList"] = boost::any(*inputStreamList);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InputStreamList") != m.end() && !m["InputStreamList"].empty()) {
      inputStreamList = make_shared<string>(boost::any_cast<string>(m["InputStreamList"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~UpdateMixStreamRequest() = default;
};
class UpdateMixStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mixStreamId{};
  shared_ptr<string> requestId{};

  UpdateMixStreamResponseBody() {}

  explicit UpdateMixStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMixStreamResponseBody() = default;
};
class UpdateMixStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMixStreamResponseBody> body{};

  UpdateMixStreamResponse() {}

  explicit UpdateMixStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMixStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMixStreamResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMixStreamResponse() = default;
};
class VerifyLiveDomainOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> verifyType{};

  VerifyLiveDomainOwnerRequest() {}

  explicit VerifyLiveDomainOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (verifyType) {
      res["VerifyType"] = boost::any(*verifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("VerifyType") != m.end() && !m["VerifyType"].empty()) {
      verifyType = make_shared<string>(boost::any_cast<string>(m["VerifyType"]));
    }
  }


  virtual ~VerifyLiveDomainOwnerRequest() = default;
};
class VerifyLiveDomainOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  VerifyLiveDomainOwnerResponseBody() {}

  explicit VerifyLiveDomainOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyLiveDomainOwnerResponseBody() = default;
};
class VerifyLiveDomainOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyLiveDomainOwnerResponseBody> body{};

  VerifyLiveDomainOwnerResponse() {}

  explicit VerifyLiveDomainOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyLiveDomainOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyLiveDomainOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyLiveDomainOwnerResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddCasterComponentResponse addCasterComponentWithOptions(shared_ptr<AddCasterComponentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterComponentResponse addCasterComponent(shared_ptr<AddCasterComponentRequest> request);
  AddCasterEpisodeResponse addCasterEpisodeWithOptions(shared_ptr<AddCasterEpisodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterEpisodeResponse addCasterEpisode(shared_ptr<AddCasterEpisodeRequest> request);
  AddCasterEpisodeGroupResponse addCasterEpisodeGroupWithOptions(shared_ptr<AddCasterEpisodeGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterEpisodeGroupResponse addCasterEpisodeGroup(shared_ptr<AddCasterEpisodeGroupRequest> request);
  AddCasterEpisodeGroupContentResponse addCasterEpisodeGroupContentWithOptions(shared_ptr<AddCasterEpisodeGroupContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterEpisodeGroupContentResponse addCasterEpisodeGroupContent(shared_ptr<AddCasterEpisodeGroupContentRequest> request);
  AddCasterLayoutResponse addCasterLayoutWithOptions(shared_ptr<AddCasterLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterLayoutResponse addCasterLayout(shared_ptr<AddCasterLayoutRequest> request);
  AddCasterProgramResponse addCasterProgramWithOptions(shared_ptr<AddCasterProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterProgramResponse addCasterProgram(shared_ptr<AddCasterProgramRequest> request);
  AddCasterVideoResourceResponse addCasterVideoResourceWithOptions(shared_ptr<AddCasterVideoResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterVideoResourceResponse addCasterVideoResource(shared_ptr<AddCasterVideoResourceRequest> request);
  AddCustomLiveStreamTranscodeResponse addCustomLiveStreamTranscodeWithOptions(shared_ptr<AddCustomLiveStreamTranscodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCustomLiveStreamTranscodeResponse addCustomLiveStreamTranscode(shared_ptr<AddCustomLiveStreamTranscodeRequest> request);
  AddLiveAppRecordConfigResponse addLiveAppRecordConfigWithOptions(shared_ptr<AddLiveAppRecordConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveAppRecordConfigResponse addLiveAppRecordConfig(shared_ptr<AddLiveAppRecordConfigRequest> request);
  AddLiveAppSnapshotConfigResponse addLiveAppSnapshotConfigWithOptions(shared_ptr<AddLiveAppSnapshotConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveAppSnapshotConfigResponse addLiveAppSnapshotConfig(shared_ptr<AddLiveAppSnapshotConfigRequest> request);
  AddLiveAudioAuditConfigResponse addLiveAudioAuditConfigWithOptions(shared_ptr<AddLiveAudioAuditConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveAudioAuditConfigResponse addLiveAudioAuditConfig(shared_ptr<AddLiveAudioAuditConfigRequest> request);
  AddLiveAudioAuditNotifyConfigResponse addLiveAudioAuditNotifyConfigWithOptions(shared_ptr<AddLiveAudioAuditNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveAudioAuditNotifyConfigResponse addLiveAudioAuditNotifyConfig(shared_ptr<AddLiveAudioAuditNotifyConfigRequest> request);
  AddLiveDetectNotifyConfigResponse addLiveDetectNotifyConfigWithOptions(shared_ptr<AddLiveDetectNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveDetectNotifyConfigResponse addLiveDetectNotifyConfig(shared_ptr<AddLiveDetectNotifyConfigRequest> request);
  AddLiveDomainResponse addLiveDomainWithOptions(shared_ptr<AddLiveDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveDomainResponse addLiveDomain(shared_ptr<AddLiveDomainRequest> request);
  AddLiveDomainMappingResponse addLiveDomainMappingWithOptions(shared_ptr<AddLiveDomainMappingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveDomainMappingResponse addLiveDomainMapping(shared_ptr<AddLiveDomainMappingRequest> request);
  AddLiveDomainPlayMappingResponse addLiveDomainPlayMappingWithOptions(shared_ptr<AddLiveDomainPlayMappingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveDomainPlayMappingResponse addLiveDomainPlayMapping(shared_ptr<AddLiveDomainPlayMappingRequest> request);
  AddLivePullStreamInfoConfigResponse addLivePullStreamInfoConfigWithOptions(shared_ptr<AddLivePullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLivePullStreamInfoConfigResponse addLivePullStreamInfoConfig(shared_ptr<AddLivePullStreamInfoConfigRequest> request);
  AddLiveRecordNotifyConfigResponse addLiveRecordNotifyConfigWithOptions(shared_ptr<AddLiveRecordNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveRecordNotifyConfigResponse addLiveRecordNotifyConfig(shared_ptr<AddLiveRecordNotifyConfigRequest> request);
  AddLiveRecordVodConfigResponse addLiveRecordVodConfigWithOptions(shared_ptr<AddLiveRecordVodConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveRecordVodConfigResponse addLiveRecordVodConfig(shared_ptr<AddLiveRecordVodConfigRequest> request);
  AddLiveSnapshotDetectPornConfigResponse addLiveSnapshotDetectPornConfigWithOptions(shared_ptr<AddLiveSnapshotDetectPornConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveSnapshotDetectPornConfigResponse addLiveSnapshotDetectPornConfig(shared_ptr<AddLiveSnapshotDetectPornConfigRequest> request);
  AddLiveSnapshotNotifyConfigResponse addLiveSnapshotNotifyConfigWithOptions(shared_ptr<AddLiveSnapshotNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveSnapshotNotifyConfigResponse addLiveSnapshotNotifyConfig(shared_ptr<AddLiveSnapshotNotifyConfigRequest> request);
  AddLiveStreamTranscodeResponse addLiveStreamTranscodeWithOptions(shared_ptr<AddLiveStreamTranscodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveStreamTranscodeResponse addLiveStreamTranscode(shared_ptr<AddLiveStreamTranscodeRequest> request);
  AddLiveStreamWatermarkResponse addLiveStreamWatermarkWithOptions(shared_ptr<AddLiveStreamWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveStreamWatermarkResponse addLiveStreamWatermark(shared_ptr<AddLiveStreamWatermarkRequest> request);
  AddLiveStreamWatermarkRuleResponse addLiveStreamWatermarkRuleWithOptions(shared_ptr<AddLiveStreamWatermarkRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveStreamWatermarkRuleResponse addLiveStreamWatermarkRule(shared_ptr<AddLiveStreamWatermarkRuleRequest> request);
  AddMultiRateConfigResponse addMultiRateConfigWithOptions(shared_ptr<AddMultiRateConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMultiRateConfigResponse addMultiRateConfig(shared_ptr<AddMultiRateConfigRequest> request);
  AddPlaylistItemsResponse addPlaylistItemsWithOptions(shared_ptr<AddPlaylistItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPlaylistItemsResponse addPlaylistItems(shared_ptr<AddPlaylistItemsRequest> request);
  AddRtsLiveStreamTranscodeResponse addRtsLiveStreamTranscodeWithOptions(shared_ptr<AddRtsLiveStreamTranscodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddRtsLiveStreamTranscodeResponse addRtsLiveStreamTranscode(shared_ptr<AddRtsLiveStreamTranscodeRequest> request);
  AddShowIntoShowListResponse addShowIntoShowListWithOptions(shared_ptr<AddShowIntoShowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddShowIntoShowListResponse addShowIntoShowList(shared_ptr<AddShowIntoShowListRequest> request);
  AddStudioLayoutResponse addStudioLayoutWithOptions(shared_ptr<AddStudioLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddStudioLayoutResponse addStudioLayout(shared_ptr<AddStudioLayoutRequest> request);
  AddTrancodeSEIResponse addTrancodeSEIWithOptions(shared_ptr<AddTrancodeSEIRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTrancodeSEIResponse addTrancodeSEI(shared_ptr<AddTrancodeSEIRequest> request);
  AllowPushStreamResponse allowPushStreamWithOptions(shared_ptr<AllowPushStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllowPushStreamResponse allowPushStream(shared_ptr<AllowPushStreamRequest> request);
  BatchDeleteLiveDomainConfigsResponse batchDeleteLiveDomainConfigsWithOptions(shared_ptr<BatchDeleteLiveDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteLiveDomainConfigsResponse batchDeleteLiveDomainConfigs(shared_ptr<BatchDeleteLiveDomainConfigsRequest> request);
  BatchSetLiveDomainConfigsResponse batchSetLiveDomainConfigsWithOptions(shared_ptr<BatchSetLiveDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetLiveDomainConfigsResponse batchSetLiveDomainConfigs(shared_ptr<BatchSetLiveDomainConfigsRequest> request);
  CancelMuteAllGroupUserResponse cancelMuteAllGroupUserWithOptions(shared_ptr<CancelMuteAllGroupUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelMuteAllGroupUserResponse cancelMuteAllGroupUser(shared_ptr<CancelMuteAllGroupUserRequest> request);
  CloseLiveShiftResponse closeLiveShiftWithOptions(shared_ptr<CloseLiveShiftRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseLiveShiftResponse closeLiveShift(shared_ptr<CloseLiveShiftRequest> request);
  CopyCasterResponse copyCasterWithOptions(shared_ptr<CopyCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyCasterResponse copyCaster(shared_ptr<CopyCasterRequest> request);
  CopyCasterSceneConfigResponse copyCasterSceneConfigWithOptions(shared_ptr<CopyCasterSceneConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyCasterSceneConfigResponse copyCasterSceneConfig(shared_ptr<CopyCasterSceneConfigRequest> request);
  CreateCasterResponse createCasterWithOptions(shared_ptr<CreateCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCasterResponse createCaster(shared_ptr<CreateCasterRequest> request);
  CreateCustomTemplateResponse createCustomTemplateWithOptions(shared_ptr<CreateCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomTemplateResponse createCustomTemplate(shared_ptr<CreateCustomTemplateRequest> request);
  CreateLiveRealTimeLogDeliveryResponse createLiveRealTimeLogDeliveryWithOptions(shared_ptr<CreateLiveRealTimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveRealTimeLogDeliveryResponse createLiveRealTimeLogDelivery(shared_ptr<CreateLiveRealTimeLogDeliveryRequest> request);
  CreateLiveStreamMonitorResponse createLiveStreamMonitorWithOptions(shared_ptr<CreateLiveStreamMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveStreamMonitorResponse createLiveStreamMonitor(shared_ptr<CreateLiveStreamMonitorRequest> request);
  CreateLiveStreamRecordIndexFilesResponse createLiveStreamRecordIndexFilesWithOptions(shared_ptr<CreateLiveStreamRecordIndexFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveStreamRecordIndexFilesResponse createLiveStreamRecordIndexFiles(shared_ptr<CreateLiveStreamRecordIndexFilesRequest> request);
  CreateLiveTranscodeTemplateResponse createLiveTranscodeTemplateWithOptions(shared_ptr<CreateLiveTranscodeTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveTranscodeTemplateResponse createLiveTranscodeTemplate(shared_ptr<CreateLiveTranscodeTemplateRequest> request);
  CreateMessageAppResponse createMessageAppWithOptions(shared_ptr<CreateMessageAppRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMessageAppResponse createMessageApp(shared_ptr<CreateMessageAppRequest> request);
  CreateMessageGroupResponse createMessageGroupWithOptions(shared_ptr<CreateMessageGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMessageGroupResponse createMessageGroup(shared_ptr<CreateMessageGroupRequest> request);
  CreateMixStreamResponse createMixStreamWithOptions(shared_ptr<CreateMixStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMixStreamResponse createMixStream(shared_ptr<CreateMixStreamRequest> request);
  DeleteCasterResponse deleteCasterWithOptions(shared_ptr<DeleteCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterResponse deleteCaster(shared_ptr<DeleteCasterRequest> request);
  DeleteCasterComponentResponse deleteCasterComponentWithOptions(shared_ptr<DeleteCasterComponentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterComponentResponse deleteCasterComponent(shared_ptr<DeleteCasterComponentRequest> request);
  DeleteCasterEpisodeResponse deleteCasterEpisodeWithOptions(shared_ptr<DeleteCasterEpisodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterEpisodeResponse deleteCasterEpisode(shared_ptr<DeleteCasterEpisodeRequest> request);
  DeleteCasterEpisodeGroupResponse deleteCasterEpisodeGroupWithOptions(shared_ptr<DeleteCasterEpisodeGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterEpisodeGroupResponse deleteCasterEpisodeGroup(shared_ptr<DeleteCasterEpisodeGroupRequest> request);
  DeleteCasterLayoutResponse deleteCasterLayoutWithOptions(shared_ptr<DeleteCasterLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterLayoutResponse deleteCasterLayout(shared_ptr<DeleteCasterLayoutRequest> request);
  DeleteCasterProgramResponse deleteCasterProgramWithOptions(shared_ptr<DeleteCasterProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterProgramResponse deleteCasterProgram(shared_ptr<DeleteCasterProgramRequest> request);
  DeleteCasterSceneConfigResponse deleteCasterSceneConfigWithOptions(shared_ptr<DeleteCasterSceneConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterSceneConfigResponse deleteCasterSceneConfig(shared_ptr<DeleteCasterSceneConfigRequest> request);
  DeleteCasterVideoResourceResponse deleteCasterVideoResourceWithOptions(shared_ptr<DeleteCasterVideoResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterVideoResourceResponse deleteCasterVideoResource(shared_ptr<DeleteCasterVideoResourceRequest> request);
  DeleteCustomTemplateResponse deleteCustomTemplateWithOptions(shared_ptr<DeleteCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomTemplateResponse deleteCustomTemplate(shared_ptr<DeleteCustomTemplateRequest> request);
  DeleteLiveAppRecordConfigResponse deleteLiveAppRecordConfigWithOptions(shared_ptr<DeleteLiveAppRecordConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveAppRecordConfigResponse deleteLiveAppRecordConfig(shared_ptr<DeleteLiveAppRecordConfigRequest> request);
  DeleteLiveAppSnapshotConfigResponse deleteLiveAppSnapshotConfigWithOptions(shared_ptr<DeleteLiveAppSnapshotConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveAppSnapshotConfigResponse deleteLiveAppSnapshotConfig(shared_ptr<DeleteLiveAppSnapshotConfigRequest> request);
  DeleteLiveAudioAuditConfigResponse deleteLiveAudioAuditConfigWithOptions(shared_ptr<DeleteLiveAudioAuditConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveAudioAuditConfigResponse deleteLiveAudioAuditConfig(shared_ptr<DeleteLiveAudioAuditConfigRequest> request);
  DeleteLiveAudioAuditNotifyConfigResponse deleteLiveAudioAuditNotifyConfigWithOptions(shared_ptr<DeleteLiveAudioAuditNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveAudioAuditNotifyConfigResponse deleteLiveAudioAuditNotifyConfig(shared_ptr<DeleteLiveAudioAuditNotifyConfigRequest> request);
  DeleteLiveDetectNotifyConfigResponse deleteLiveDetectNotifyConfigWithOptions(shared_ptr<DeleteLiveDetectNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveDetectNotifyConfigResponse deleteLiveDetectNotifyConfig(shared_ptr<DeleteLiveDetectNotifyConfigRequest> request);
  DeleteLiveDomainResponse deleteLiveDomainWithOptions(shared_ptr<DeleteLiveDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveDomainResponse deleteLiveDomain(shared_ptr<DeleteLiveDomainRequest> request);
  DeleteLiveDomainMappingResponse deleteLiveDomainMappingWithOptions(shared_ptr<DeleteLiveDomainMappingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveDomainMappingResponse deleteLiveDomainMapping(shared_ptr<DeleteLiveDomainMappingRequest> request);
  DeleteLiveDomainPlayMappingResponse deleteLiveDomainPlayMappingWithOptions(shared_ptr<DeleteLiveDomainPlayMappingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveDomainPlayMappingResponse deleteLiveDomainPlayMapping(shared_ptr<DeleteLiveDomainPlayMappingRequest> request);
  DeleteLiveEdgeTransferResponse deleteLiveEdgeTransferWithOptions(shared_ptr<DeleteLiveEdgeTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveEdgeTransferResponse deleteLiveEdgeTransfer(shared_ptr<DeleteLiveEdgeTransferRequest> request);
  DeleteLiveLazyPullStreamInfoConfigResponse deleteLiveLazyPullStreamInfoConfigWithOptions(shared_ptr<DeleteLiveLazyPullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveLazyPullStreamInfoConfigResponse deleteLiveLazyPullStreamInfoConfig(shared_ptr<DeleteLiveLazyPullStreamInfoConfigRequest> request);
  DeleteLivePullStreamInfoConfigResponse deleteLivePullStreamInfoConfigWithOptions(shared_ptr<DeleteLivePullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLivePullStreamInfoConfigResponse deleteLivePullStreamInfoConfig(shared_ptr<DeleteLivePullStreamInfoConfigRequest> request);
  DeleteLiveRealTimeLogLogstoreResponse deleteLiveRealTimeLogLogstoreWithOptions(shared_ptr<DeleteLiveRealTimeLogLogstoreRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRealTimeLogLogstoreResponse deleteLiveRealTimeLogLogstore(shared_ptr<DeleteLiveRealTimeLogLogstoreRequest> request);
  DeleteLiveRealtimeLogDeliveryResponse deleteLiveRealtimeLogDeliveryWithOptions(shared_ptr<DeleteLiveRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRealtimeLogDeliveryResponse deleteLiveRealtimeLogDelivery(shared_ptr<DeleteLiveRealtimeLogDeliveryRequest> request);
  DeleteLiveRecordNotifyConfigResponse deleteLiveRecordNotifyConfigWithOptions(shared_ptr<DeleteLiveRecordNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRecordNotifyConfigResponse deleteLiveRecordNotifyConfig(shared_ptr<DeleteLiveRecordNotifyConfigRequest> request);
  DeleteLiveRecordVodConfigResponse deleteLiveRecordVodConfigWithOptions(shared_ptr<DeleteLiveRecordVodConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRecordVodConfigResponse deleteLiveRecordVodConfig(shared_ptr<DeleteLiveRecordVodConfigRequest> request);
  DeleteLiveSnapshotDetectPornConfigResponse deleteLiveSnapshotDetectPornConfigWithOptions(shared_ptr<DeleteLiveSnapshotDetectPornConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveSnapshotDetectPornConfigResponse deleteLiveSnapshotDetectPornConfig(shared_ptr<DeleteLiveSnapshotDetectPornConfigRequest> request);
  DeleteLiveSnapshotNotifyConfigResponse deleteLiveSnapshotNotifyConfigWithOptions(shared_ptr<DeleteLiveSnapshotNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveSnapshotNotifyConfigResponse deleteLiveSnapshotNotifyConfig(shared_ptr<DeleteLiveSnapshotNotifyConfigRequest> request);
  DeleteLiveSpecificStagingConfigResponse deleteLiveSpecificStagingConfigWithOptions(shared_ptr<DeleteLiveSpecificStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveSpecificStagingConfigResponse deleteLiveSpecificStagingConfig(shared_ptr<DeleteLiveSpecificStagingConfigRequest> request);
  DeleteLiveStreamMonitorResponse deleteLiveStreamMonitorWithOptions(shared_ptr<DeleteLiveStreamMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamMonitorResponse deleteLiveStreamMonitor(shared_ptr<DeleteLiveStreamMonitorRequest> request);
  DeleteLiveStreamRecordIndexFilesResponse deleteLiveStreamRecordIndexFilesWithOptions(shared_ptr<DeleteLiveStreamRecordIndexFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamRecordIndexFilesResponse deleteLiveStreamRecordIndexFiles(shared_ptr<DeleteLiveStreamRecordIndexFilesRequest> request);
  DeleteLiveStreamTranscodeResponse deleteLiveStreamTranscodeWithOptions(shared_ptr<DeleteLiveStreamTranscodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamTranscodeResponse deleteLiveStreamTranscode(shared_ptr<DeleteLiveStreamTranscodeRequest> request);
  DeleteLiveStreamWatermarkResponse deleteLiveStreamWatermarkWithOptions(shared_ptr<DeleteLiveStreamWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamWatermarkResponse deleteLiveStreamWatermark(shared_ptr<DeleteLiveStreamWatermarkRequest> request);
  DeleteLiveStreamWatermarkRuleResponse deleteLiveStreamWatermarkRuleWithOptions(shared_ptr<DeleteLiveStreamWatermarkRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamWatermarkRuleResponse deleteLiveStreamWatermarkRule(shared_ptr<DeleteLiveStreamWatermarkRuleRequest> request);
  DeleteLiveStreamsNotifyUrlConfigResponse deleteLiveStreamsNotifyUrlConfigWithOptions(shared_ptr<DeleteLiveStreamsNotifyUrlConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamsNotifyUrlConfigResponse deleteLiveStreamsNotifyUrlConfig(shared_ptr<DeleteLiveStreamsNotifyUrlConfigRequest> request);
  DeleteMessageAppResponse deleteMessageAppWithOptions(shared_ptr<DeleteMessageAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMessageAppResponse deleteMessageApp(shared_ptr<DeleteMessageAppRequest> request);
  DeleteMixStreamResponse deleteMixStreamWithOptions(shared_ptr<DeleteMixStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMixStreamResponse deleteMixStream(shared_ptr<DeleteMixStreamRequest> request);
  DeleteMultiRateConfigResponse deleteMultiRateConfigWithOptions(shared_ptr<DeleteMultiRateConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMultiRateConfigResponse deleteMultiRateConfig(shared_ptr<DeleteMultiRateConfigRequest> request);
  DeletePlaylistResponse deletePlaylistWithOptions(shared_ptr<DeletePlaylistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePlaylistResponse deletePlaylist(shared_ptr<DeletePlaylistRequest> request);
  DeletePlaylistItemsResponse deletePlaylistItemsWithOptions(shared_ptr<DeletePlaylistItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePlaylistItemsResponse deletePlaylistItems(shared_ptr<DeletePlaylistItemsRequest> request);
  DeleteRoomResponse deleteRoomWithOptions(shared_ptr<DeleteRoomRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoomResponse deleteRoom(shared_ptr<DeleteRoomRequest> request);
  DeleteSnapshotCallbackAuthResponse deleteSnapshotCallbackAuthWithOptions(shared_ptr<DeleteSnapshotCallbackAuthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnapshotCallbackAuthResponse deleteSnapshotCallbackAuth(shared_ptr<DeleteSnapshotCallbackAuthRequest> request);
  DeleteSnapshotFilesResponse deleteSnapshotFilesWithOptions(shared_ptr<DeleteSnapshotFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnapshotFilesResponse deleteSnapshotFiles(shared_ptr<DeleteSnapshotFilesRequest> request);
  DeleteStudioLayoutResponse deleteStudioLayoutWithOptions(shared_ptr<DeleteStudioLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStudioLayoutResponse deleteStudioLayout(shared_ptr<DeleteStudioLayoutRequest> request);
  DescribeAutoShowListTasksResponse describeAutoShowListTasksWithOptions(shared_ptr<DescribeAutoShowListTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoShowListTasksResponse describeAutoShowListTasks(shared_ptr<DescribeAutoShowListTasksRequest> request);
  DescribeCasterChannelsResponse describeCasterChannelsWithOptions(shared_ptr<DescribeCasterChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterChannelsResponse describeCasterChannels(shared_ptr<DescribeCasterChannelsRequest> request);
  DescribeCasterComponentsResponse describeCasterComponentsWithOptions(shared_ptr<DescribeCasterComponentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterComponentsResponse describeCasterComponents(shared_ptr<DescribeCasterComponentsRequest> request);
  DescribeCasterConfigResponse describeCasterConfigWithOptions(shared_ptr<DescribeCasterConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterConfigResponse describeCasterConfig(shared_ptr<DescribeCasterConfigRequest> request);
  DescribeCasterLayoutsResponse describeCasterLayoutsWithOptions(shared_ptr<DescribeCasterLayoutsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterLayoutsResponse describeCasterLayouts(shared_ptr<DescribeCasterLayoutsRequest> request);
  DescribeCasterProgramResponse describeCasterProgramWithOptions(shared_ptr<DescribeCasterProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterProgramResponse describeCasterProgram(shared_ptr<DescribeCasterProgramRequest> request);
  DescribeCasterSceneAudioResponse describeCasterSceneAudioWithOptions(shared_ptr<DescribeCasterSceneAudioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterSceneAudioResponse describeCasterSceneAudio(shared_ptr<DescribeCasterSceneAudioRequest> request);
  DescribeCasterScenesResponse describeCasterScenesWithOptions(shared_ptr<DescribeCasterScenesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterScenesResponse describeCasterScenes(shared_ptr<DescribeCasterScenesRequest> request);
  DescribeCasterStreamUrlResponse describeCasterStreamUrlWithOptions(shared_ptr<DescribeCasterStreamUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterStreamUrlResponse describeCasterStreamUrl(shared_ptr<DescribeCasterStreamUrlRequest> request);
  DescribeCasterSyncGroupResponse describeCasterSyncGroupWithOptions(shared_ptr<DescribeCasterSyncGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterSyncGroupResponse describeCasterSyncGroup(shared_ptr<DescribeCasterSyncGroupRequest> request);
  DescribeCasterVideoResourcesResponse describeCasterVideoResourcesWithOptions(shared_ptr<DescribeCasterVideoResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterVideoResourcesResponse describeCasterVideoResources(shared_ptr<DescribeCasterVideoResourcesRequest> request);
  DescribeCastersResponse describeCastersWithOptions(shared_ptr<DescribeCastersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCastersResponse describeCasters(shared_ptr<DescribeCastersRequest> request);
  DescribeDomainUsageDataResponse describeDomainUsageDataWithOptions(shared_ptr<DescribeDomainUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainUsageDataResponse describeDomainUsageData(shared_ptr<DescribeDomainUsageDataRequest> request);
  DescribeDomainWithIntegrityResponse describeDomainWithIntegrityWithOptions(shared_ptr<DescribeDomainWithIntegrityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainWithIntegrityResponse describeDomainWithIntegrity(shared_ptr<DescribeDomainWithIntegrityRequest> request);
  DescribeForbidPushStreamRoomListResponse describeForbidPushStreamRoomListWithOptions(shared_ptr<DescribeForbidPushStreamRoomListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeForbidPushStreamRoomListResponse describeForbidPushStreamRoomList(shared_ptr<DescribeForbidPushStreamRoomListRequest> request);
  DescribeHlsLiveStreamRealTimeBpsDataResponse describeHlsLiveStreamRealTimeBpsDataWithOptions(shared_ptr<DescribeHlsLiveStreamRealTimeBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHlsLiveStreamRealTimeBpsDataResponse describeHlsLiveStreamRealTimeBpsData(shared_ptr<DescribeHlsLiveStreamRealTimeBpsDataRequest> request);
  DescribeLiveAudioAuditConfigResponse describeLiveAudioAuditConfigWithOptions(shared_ptr<DescribeLiveAudioAuditConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveAudioAuditConfigResponse describeLiveAudioAuditConfig(shared_ptr<DescribeLiveAudioAuditConfigRequest> request);
  DescribeLiveAudioAuditNotifyConfigResponse describeLiveAudioAuditNotifyConfigWithOptions(shared_ptr<DescribeLiveAudioAuditNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveAudioAuditNotifyConfigResponse describeLiveAudioAuditNotifyConfig(shared_ptr<DescribeLiveAudioAuditNotifyConfigRequest> request);
  DescribeLiveCertificateDetailResponse describeLiveCertificateDetailWithOptions(shared_ptr<DescribeLiveCertificateDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveCertificateDetailResponse describeLiveCertificateDetail(shared_ptr<DescribeLiveCertificateDetailRequest> request);
  DescribeLiveCertificateListResponse describeLiveCertificateListWithOptions(shared_ptr<DescribeLiveCertificateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveCertificateListResponse describeLiveCertificateList(shared_ptr<DescribeLiveCertificateListRequest> request);
  DescribeLiveDetectNotifyConfigResponse describeLiveDetectNotifyConfigWithOptions(shared_ptr<DescribeLiveDetectNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDetectNotifyConfigResponse describeLiveDetectNotifyConfig(shared_ptr<DescribeLiveDetectNotifyConfigRequest> request);
  DescribeLiveDetectPornDataResponse describeLiveDetectPornDataWithOptions(shared_ptr<DescribeLiveDetectPornDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDetectPornDataResponse describeLiveDetectPornData(shared_ptr<DescribeLiveDetectPornDataRequest> request);
  DescribeLiveDomainBpsDataResponse describeLiveDomainBpsDataWithOptions(shared_ptr<DescribeLiveDomainBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainBpsDataResponse describeLiveDomainBpsData(shared_ptr<DescribeLiveDomainBpsDataRequest> request);
  DescribeLiveDomainBpsDataByLayerResponse describeLiveDomainBpsDataByLayerWithOptions(shared_ptr<DescribeLiveDomainBpsDataByLayerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainBpsDataByLayerResponse describeLiveDomainBpsDataByLayer(shared_ptr<DescribeLiveDomainBpsDataByLayerRequest> request);
  DescribeLiveDomainBpsDataByTimeStampResponse describeLiveDomainBpsDataByTimeStampWithOptions(shared_ptr<DescribeLiveDomainBpsDataByTimeStampRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainBpsDataByTimeStampResponse describeLiveDomainBpsDataByTimeStamp(shared_ptr<DescribeLiveDomainBpsDataByTimeStampRequest> request);
  DescribeLiveDomainCertificateInfoResponse describeLiveDomainCertificateInfoWithOptions(shared_ptr<DescribeLiveDomainCertificateInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainCertificateInfoResponse describeLiveDomainCertificateInfo(shared_ptr<DescribeLiveDomainCertificateInfoRequest> request);
  DescribeLiveDomainConfigsResponse describeLiveDomainConfigsWithOptions(shared_ptr<DescribeLiveDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainConfigsResponse describeLiveDomainConfigs(shared_ptr<DescribeLiveDomainConfigsRequest> request);
  DescribeLiveDomainDetailResponse describeLiveDomainDetailWithOptions(shared_ptr<DescribeLiveDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainDetailResponse describeLiveDomainDetail(shared_ptr<DescribeLiveDomainDetailRequest> request);
  DescribeLiveDomainFrameRateAndBitRateDataResponse describeLiveDomainFrameRateAndBitRateDataWithOptions(shared_ptr<DescribeLiveDomainFrameRateAndBitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainFrameRateAndBitRateDataResponse describeLiveDomainFrameRateAndBitRateData(shared_ptr<DescribeLiveDomainFrameRateAndBitRateDataRequest> request);
  DescribeLiveDomainLimitResponse describeLiveDomainLimitWithOptions(shared_ptr<DescribeLiveDomainLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainLimitResponse describeLiveDomainLimit(shared_ptr<DescribeLiveDomainLimitRequest> request);
  DescribeLiveDomainLogResponse describeLiveDomainLogWithOptions(shared_ptr<DescribeLiveDomainLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainLogResponse describeLiveDomainLog(shared_ptr<DescribeLiveDomainLogRequest> request);
  DescribeLiveDomainMappingResponse describeLiveDomainMappingWithOptions(shared_ptr<DescribeLiveDomainMappingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainMappingResponse describeLiveDomainMapping(shared_ptr<DescribeLiveDomainMappingRequest> request);
  DescribeLiveDomainOnlineUserNumResponse describeLiveDomainOnlineUserNumWithOptions(shared_ptr<DescribeLiveDomainOnlineUserNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainOnlineUserNumResponse describeLiveDomainOnlineUserNum(shared_ptr<DescribeLiveDomainOnlineUserNumRequest> request);
  DescribeLiveDomainPushBpsDataResponse describeLiveDomainPushBpsDataWithOptions(shared_ptr<DescribeLiveDomainPushBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainPushBpsDataResponse describeLiveDomainPushBpsData(shared_ptr<DescribeLiveDomainPushBpsDataRequest> request);
  DescribeLiveDomainPushTrafficDataResponse describeLiveDomainPushTrafficDataWithOptions(shared_ptr<DescribeLiveDomainPushTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainPushTrafficDataResponse describeLiveDomainPushTrafficData(shared_ptr<DescribeLiveDomainPushTrafficDataRequest> request);
  DescribeLiveDomainPvUvDataResponse describeLiveDomainPvUvDataWithOptions(shared_ptr<DescribeLiveDomainPvUvDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainPvUvDataResponse describeLiveDomainPvUvData(shared_ptr<DescribeLiveDomainPvUvDataRequest> request);
  DescribeLiveDomainRealTimeBpsDataResponse describeLiveDomainRealTimeBpsDataWithOptions(shared_ptr<DescribeLiveDomainRealTimeBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainRealTimeBpsDataResponse describeLiveDomainRealTimeBpsData(shared_ptr<DescribeLiveDomainRealTimeBpsDataRequest> request);
  DescribeLiveDomainRealTimeHttpCodeDataResponse describeLiveDomainRealTimeHttpCodeDataWithOptions(shared_ptr<DescribeLiveDomainRealTimeHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainRealTimeHttpCodeDataResponse describeLiveDomainRealTimeHttpCodeData(shared_ptr<DescribeLiveDomainRealTimeHttpCodeDataRequest> request);
  DescribeLiveDomainRealTimeTrafficDataResponse describeLiveDomainRealTimeTrafficDataWithOptions(shared_ptr<DescribeLiveDomainRealTimeTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainRealTimeTrafficDataResponse describeLiveDomainRealTimeTrafficData(shared_ptr<DescribeLiveDomainRealTimeTrafficDataRequest> request);
  DescribeLiveDomainRealtimeLogDeliveryResponse describeLiveDomainRealtimeLogDeliveryWithOptions(shared_ptr<DescribeLiveDomainRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainRealtimeLogDeliveryResponse describeLiveDomainRealtimeLogDelivery(shared_ptr<DescribeLiveDomainRealtimeLogDeliveryRequest> request);
  DescribeLiveDomainRecordDataResponse describeLiveDomainRecordDataWithOptions(shared_ptr<DescribeLiveDomainRecordDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainRecordDataResponse describeLiveDomainRecordData(shared_ptr<DescribeLiveDomainRecordDataRequest> request);
  DescribeLiveDomainRecordUsageDataResponse describeLiveDomainRecordUsageDataWithOptions(shared_ptr<DescribeLiveDomainRecordUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainRecordUsageDataResponse describeLiveDomainRecordUsageData(shared_ptr<DescribeLiveDomainRecordUsageDataRequest> request);
  DescribeLiveDomainSnapshotDataResponse describeLiveDomainSnapshotDataWithOptions(shared_ptr<DescribeLiveDomainSnapshotDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainSnapshotDataResponse describeLiveDomainSnapshotData(shared_ptr<DescribeLiveDomainSnapshotDataRequest> request);
  DescribeLiveDomainStagingConfigResponse describeLiveDomainStagingConfigWithOptions(shared_ptr<DescribeLiveDomainStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainStagingConfigResponse describeLiveDomainStagingConfig(shared_ptr<DescribeLiveDomainStagingConfigRequest> request);
  DescribeLiveDomainStreamTranscodeDataResponse describeLiveDomainStreamTranscodeDataWithOptions(shared_ptr<DescribeLiveDomainStreamTranscodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainStreamTranscodeDataResponse describeLiveDomainStreamTranscodeData(shared_ptr<DescribeLiveDomainStreamTranscodeDataRequest> request);
  DescribeLiveDomainTimeShiftDataResponse describeLiveDomainTimeShiftDataWithOptions(shared_ptr<DescribeLiveDomainTimeShiftDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainTimeShiftDataResponse describeLiveDomainTimeShiftData(shared_ptr<DescribeLiveDomainTimeShiftDataRequest> request);
  DescribeLiveDomainTrafficDataResponse describeLiveDomainTrafficDataWithOptions(shared_ptr<DescribeLiveDomainTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainTrafficDataResponse describeLiveDomainTrafficData(shared_ptr<DescribeLiveDomainTrafficDataRequest> request);
  DescribeLiveDomainTranscodeDataResponse describeLiveDomainTranscodeDataWithOptions(shared_ptr<DescribeLiveDomainTranscodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainTranscodeDataResponse describeLiveDomainTranscodeData(shared_ptr<DescribeLiveDomainTranscodeDataRequest> request);
  DescribeLiveDrmUsageDataResponse describeLiveDrmUsageDataWithOptions(shared_ptr<DescribeLiveDrmUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDrmUsageDataResponse describeLiveDrmUsageData(shared_ptr<DescribeLiveDrmUsageDataRequest> request);
  DescribeLiveEdgeTransferResponse describeLiveEdgeTransferWithOptions(shared_ptr<DescribeLiveEdgeTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveEdgeTransferResponse describeLiveEdgeTransfer(shared_ptr<DescribeLiveEdgeTransferRequest> request);
  DescribeLiveLazyPullStreamConfigResponse describeLiveLazyPullStreamConfigWithOptions(shared_ptr<DescribeLiveLazyPullStreamConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveLazyPullStreamConfigResponse describeLiveLazyPullStreamConfig(shared_ptr<DescribeLiveLazyPullStreamConfigRequest> request);
  DescribeLiveProducerUsageDataResponse describeLiveProducerUsageDataWithOptions(shared_ptr<DescribeLiveProducerUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveProducerUsageDataResponse describeLiveProducerUsageData(shared_ptr<DescribeLiveProducerUsageDataRequest> request);
  DescribeLivePullStreamConfigResponse describeLivePullStreamConfigWithOptions(shared_ptr<DescribeLivePullStreamConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLivePullStreamConfigResponse describeLivePullStreamConfig(shared_ptr<DescribeLivePullStreamConfigRequest> request);
  DescribeLiveRealtimeDeliveryAccResponse describeLiveRealtimeDeliveryAccWithOptions(shared_ptr<DescribeLiveRealtimeDeliveryAccRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveRealtimeDeliveryAccResponse describeLiveRealtimeDeliveryAcc(shared_ptr<DescribeLiveRealtimeDeliveryAccRequest> request);
  DescribeLiveRealtimeLogAuthorizedResponse describeLiveRealtimeLogAuthorizedWithOptions(shared_ptr<DescribeLiveRealtimeLogAuthorizedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveRealtimeLogAuthorizedResponse describeLiveRealtimeLogAuthorized(shared_ptr<DescribeLiveRealtimeLogAuthorizedRequest> request);
  DescribeLiveRecordConfigResponse describeLiveRecordConfigWithOptions(shared_ptr<DescribeLiveRecordConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveRecordConfigResponse describeLiveRecordConfig(shared_ptr<DescribeLiveRecordConfigRequest> request);
  DescribeLiveRecordNotifyConfigResponse describeLiveRecordNotifyConfigWithOptions(shared_ptr<DescribeLiveRecordNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveRecordNotifyConfigResponse describeLiveRecordNotifyConfig(shared_ptr<DescribeLiveRecordNotifyConfigRequest> request);
  DescribeLiveRecordVodConfigsResponse describeLiveRecordVodConfigsWithOptions(shared_ptr<DescribeLiveRecordVodConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveRecordVodConfigsResponse describeLiveRecordVodConfigs(shared_ptr<DescribeLiveRecordVodConfigsRequest> request);
  DescribeLiveShiftConfigsResponse describeLiveShiftConfigsWithOptions(shared_ptr<DescribeLiveShiftConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveShiftConfigsResponse describeLiveShiftConfigs(shared_ptr<DescribeLiveShiftConfigsRequest> request);
  DescribeLiveSnapshotConfigResponse describeLiveSnapshotConfigWithOptions(shared_ptr<DescribeLiveSnapshotConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveSnapshotConfigResponse describeLiveSnapshotConfig(shared_ptr<DescribeLiveSnapshotConfigRequest> request);
  DescribeLiveSnapshotDetectPornConfigResponse describeLiveSnapshotDetectPornConfigWithOptions(shared_ptr<DescribeLiveSnapshotDetectPornConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveSnapshotDetectPornConfigResponse describeLiveSnapshotDetectPornConfig(shared_ptr<DescribeLiveSnapshotDetectPornConfigRequest> request);
  DescribeLiveSnapshotNotifyConfigResponse describeLiveSnapshotNotifyConfigWithOptions(shared_ptr<DescribeLiveSnapshotNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveSnapshotNotifyConfigResponse describeLiveSnapshotNotifyConfig(shared_ptr<DescribeLiveSnapshotNotifyConfigRequest> request);
  DescribeLiveStreamAuthCheckingResponse describeLiveStreamAuthCheckingWithOptions(shared_ptr<DescribeLiveStreamAuthCheckingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamAuthCheckingResponse describeLiveStreamAuthChecking(shared_ptr<DescribeLiveStreamAuthCheckingRequest> request);
  DescribeLiveStreamBitRateDataResponse describeLiveStreamBitRateDataWithOptions(shared_ptr<DescribeLiveStreamBitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamBitRateDataResponse describeLiveStreamBitRateData(shared_ptr<DescribeLiveStreamBitRateDataRequest> request);
  DescribeLiveStreamCountResponse describeLiveStreamCountWithOptions(shared_ptr<DescribeLiveStreamCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamCountResponse describeLiveStreamCount(shared_ptr<DescribeLiveStreamCountRequest> request);
  DescribeLiveStreamDelayConfigResponse describeLiveStreamDelayConfigWithOptions(shared_ptr<DescribeLiveStreamDelayConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamDelayConfigResponse describeLiveStreamDelayConfig(shared_ptr<DescribeLiveStreamDelayConfigRequest> request);
  DescribeLiveStreamHistoryUserNumResponse describeLiveStreamHistoryUserNumWithOptions(shared_ptr<DescribeLiveStreamHistoryUserNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamHistoryUserNumResponse describeLiveStreamHistoryUserNum(shared_ptr<DescribeLiveStreamHistoryUserNumRequest> request);
  DescribeLiveStreamMetricDetailDataResponse describeLiveStreamMetricDetailDataWithOptions(shared_ptr<DescribeLiveStreamMetricDetailDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamMetricDetailDataResponse describeLiveStreamMetricDetailData(shared_ptr<DescribeLiveStreamMetricDetailDataRequest> request);
  DescribeLiveStreamMonitorListResponse describeLiveStreamMonitorListWithOptions(shared_ptr<DescribeLiveStreamMonitorListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamMonitorListResponse describeLiveStreamMonitorList(shared_ptr<DescribeLiveStreamMonitorListRequest> request);
  DescribeLiveStreamOptimizedFeatureConfigResponse describeLiveStreamOptimizedFeatureConfigWithOptions(shared_ptr<DescribeLiveStreamOptimizedFeatureConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamOptimizedFeatureConfigResponse describeLiveStreamOptimizedFeatureConfig(shared_ptr<DescribeLiveStreamOptimizedFeatureConfigRequest> request);
  DescribeLiveStreamRecordContentResponse describeLiveStreamRecordContentWithOptions(shared_ptr<DescribeLiveStreamRecordContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamRecordContentResponse describeLiveStreamRecordContent(shared_ptr<DescribeLiveStreamRecordContentRequest> request);
  DescribeLiveStreamRecordIndexFileResponse describeLiveStreamRecordIndexFileWithOptions(shared_ptr<DescribeLiveStreamRecordIndexFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamRecordIndexFileResponse describeLiveStreamRecordIndexFile(shared_ptr<DescribeLiveStreamRecordIndexFileRequest> request);
  DescribeLiveStreamRecordIndexFilesResponse describeLiveStreamRecordIndexFilesWithOptions(shared_ptr<DescribeLiveStreamRecordIndexFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamRecordIndexFilesResponse describeLiveStreamRecordIndexFiles(shared_ptr<DescribeLiveStreamRecordIndexFilesRequest> request);
  DescribeLiveStreamSnapshotInfoResponse describeLiveStreamSnapshotInfoWithOptions(shared_ptr<DescribeLiveStreamSnapshotInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamSnapshotInfoResponse describeLiveStreamSnapshotInfo(shared_ptr<DescribeLiveStreamSnapshotInfoRequest> request);
  DescribeLiveStreamStateResponse describeLiveStreamStateWithOptions(shared_ptr<DescribeLiveStreamStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamStateResponse describeLiveStreamState(shared_ptr<DescribeLiveStreamStateRequest> request);
  DescribeLiveStreamTranscodeInfoResponse describeLiveStreamTranscodeInfoWithOptions(shared_ptr<DescribeLiveStreamTranscodeInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamTranscodeInfoResponse describeLiveStreamTranscodeInfo(shared_ptr<DescribeLiveStreamTranscodeInfoRequest> request);
  DescribeLiveStreamTranscodeStreamNumResponse describeLiveStreamTranscodeStreamNumWithOptions(shared_ptr<DescribeLiveStreamTranscodeStreamNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamTranscodeStreamNumResponse describeLiveStreamTranscodeStreamNum(shared_ptr<DescribeLiveStreamTranscodeStreamNumRequest> request);
  DescribeLiveStreamWatermarkRulesResponse describeLiveStreamWatermarkRulesWithOptions(shared_ptr<DescribeLiveStreamWatermarkRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamWatermarkRulesResponse describeLiveStreamWatermarkRules(shared_ptr<DescribeLiveStreamWatermarkRulesRequest> request);
  DescribeLiveStreamWatermarksResponse describeLiveStreamWatermarksWithOptions(shared_ptr<DescribeLiveStreamWatermarksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamWatermarksResponse describeLiveStreamWatermarks(shared_ptr<DescribeLiveStreamWatermarksRequest> request);
  DescribeLiveStreamsBlockListResponse describeLiveStreamsBlockListWithOptions(shared_ptr<DescribeLiveStreamsBlockListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsBlockListResponse describeLiveStreamsBlockList(shared_ptr<DescribeLiveStreamsBlockListRequest> request);
  DescribeLiveStreamsControlHistoryResponse describeLiveStreamsControlHistoryWithOptions(shared_ptr<DescribeLiveStreamsControlHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsControlHistoryResponse describeLiveStreamsControlHistory(shared_ptr<DescribeLiveStreamsControlHistoryRequest> request);
  DescribeLiveStreamsNotifyRecordsResponse describeLiveStreamsNotifyRecordsWithOptions(shared_ptr<DescribeLiveStreamsNotifyRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsNotifyRecordsResponse describeLiveStreamsNotifyRecords(shared_ptr<DescribeLiveStreamsNotifyRecordsRequest> request);
  DescribeLiveStreamsNotifyUrlConfigResponse describeLiveStreamsNotifyUrlConfigWithOptions(shared_ptr<DescribeLiveStreamsNotifyUrlConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsNotifyUrlConfigResponse describeLiveStreamsNotifyUrlConfig(shared_ptr<DescribeLiveStreamsNotifyUrlConfigRequest> request);
  DescribeLiveStreamsOnlineListResponse describeLiveStreamsOnlineListWithOptions(shared_ptr<DescribeLiveStreamsOnlineListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsOnlineListResponse describeLiveStreamsOnlineList(shared_ptr<DescribeLiveStreamsOnlineListRequest> request);
  DescribeLiveStreamsPublishListResponse describeLiveStreamsPublishListWithOptions(shared_ptr<DescribeLiveStreamsPublishListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsPublishListResponse describeLiveStreamsPublishList(shared_ptr<DescribeLiveStreamsPublishListRequest> request);
  DescribeLiveTagResourcesResponse describeLiveTagResourcesWithOptions(shared_ptr<DescribeLiveTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveTagResourcesResponse describeLiveTagResources(shared_ptr<DescribeLiveTagResourcesRequest> request);
  DescribeLiveTopDomainsByFlowResponse describeLiveTopDomainsByFlowWithOptions(shared_ptr<DescribeLiveTopDomainsByFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveTopDomainsByFlowResponse describeLiveTopDomainsByFlow(shared_ptr<DescribeLiveTopDomainsByFlowRequest> request);
  DescribeLiveUserBillPredictionResponse describeLiveUserBillPredictionWithOptions(shared_ptr<DescribeLiveUserBillPredictionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveUserBillPredictionResponse describeLiveUserBillPrediction(shared_ptr<DescribeLiveUserBillPredictionRequest> request);
  DescribeLiveUserDomainsResponse describeLiveUserDomainsWithOptions(shared_ptr<DescribeLiveUserDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveUserDomainsResponse describeLiveUserDomains(shared_ptr<DescribeLiveUserDomainsRequest> request);
  DescribeLiveUserTagsResponse describeLiveUserTagsWithOptions(shared_ptr<DescribeLiveUserTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveUserTagsResponse describeLiveUserTags(shared_ptr<DescribeLiveUserTagsRequest> request);
  DescribeMeterLiveRtcDurationResponse describeMeterLiveRtcDurationWithOptions(shared_ptr<DescribeMeterLiveRtcDurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterLiveRtcDurationResponse describeMeterLiveRtcDuration(shared_ptr<DescribeMeterLiveRtcDurationRequest> request);
  DescribeMixStreamListResponse describeMixStreamListWithOptions(shared_ptr<DescribeMixStreamListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMixStreamListResponse describeMixStreamList(shared_ptr<DescribeMixStreamListRequest> request);
  DescribeRTSNativeSDKFirstFrameCostResponse describeRTSNativeSDKFirstFrameCostWithOptions(shared_ptr<DescribeRTSNativeSDKFirstFrameCostRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRTSNativeSDKFirstFrameCostResponse describeRTSNativeSDKFirstFrameCost(shared_ptr<DescribeRTSNativeSDKFirstFrameCostRequest> request);
  DescribeRTSNativeSDKFirstFrameDelayResponse describeRTSNativeSDKFirstFrameDelayWithOptions(shared_ptr<DescribeRTSNativeSDKFirstFrameDelayRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRTSNativeSDKFirstFrameDelayResponse describeRTSNativeSDKFirstFrameDelay(shared_ptr<DescribeRTSNativeSDKFirstFrameDelayRequest> request);
  DescribeRTSNativeSDKPlayFailStatusResponse describeRTSNativeSDKPlayFailStatusWithOptions(shared_ptr<DescribeRTSNativeSDKPlayFailStatusRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRTSNativeSDKPlayFailStatusResponse describeRTSNativeSDKPlayFailStatus(shared_ptr<DescribeRTSNativeSDKPlayFailStatusRequest> request);
  DescribeRTSNativeSDKPlayTimeResponse describeRTSNativeSDKPlayTimeWithOptions(shared_ptr<DescribeRTSNativeSDKPlayTimeRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRTSNativeSDKPlayTimeResponse describeRTSNativeSDKPlayTime(shared_ptr<DescribeRTSNativeSDKPlayTimeRequest> request);
  DescribeRTSNativeSDKVvDataResponse describeRTSNativeSDKVvDataWithOptions(shared_ptr<DescribeRTSNativeSDKVvDataRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRTSNativeSDKVvDataResponse describeRTSNativeSDKVvData(shared_ptr<DescribeRTSNativeSDKVvDataRequest> request);
  DescribeRoomKickoutUserListResponse describeRoomKickoutUserListWithOptions(shared_ptr<DescribeRoomKickoutUserListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoomKickoutUserListResponse describeRoomKickoutUserList(shared_ptr<DescribeRoomKickoutUserListRequest> request);
  DescribeRoomListResponse describeRoomListWithOptions(shared_ptr<DescribeRoomListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoomListResponse describeRoomList(shared_ptr<DescribeRoomListRequest> request);
  DescribeRoomStatusResponse describeRoomStatusWithOptions(shared_ptr<DescribeRoomStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoomStatusResponse describeRoomStatus(shared_ptr<DescribeRoomStatusRequest> request);
  DescribeShowListResponse describeShowListWithOptions(shared_ptr<DescribeShowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeShowListResponse describeShowList(shared_ptr<DescribeShowListRequest> request);
  DescribeStudioLayoutsResponse describeStudioLayoutsWithOptions(shared_ptr<DescribeStudioLayoutsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStudioLayoutsResponse describeStudioLayouts(shared_ptr<DescribeStudioLayoutsRequest> request);
  DescribeToutiaoLivePlayResponse describeToutiaoLivePlayWithOptions(shared_ptr<DescribeToutiaoLivePlayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeToutiaoLivePlayResponse describeToutiaoLivePlay(shared_ptr<DescribeToutiaoLivePlayRequest> request);
  DescribeToutiaoLivePublishResponse describeToutiaoLivePublishWithOptions(shared_ptr<DescribeToutiaoLivePublishRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeToutiaoLivePublishResponse describeToutiaoLivePublish(shared_ptr<DescribeToutiaoLivePublishRequest> request);
  DescribeUpBpsPeakDataResponse describeUpBpsPeakDataWithOptions(shared_ptr<DescribeUpBpsPeakDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUpBpsPeakDataResponse describeUpBpsPeakData(shared_ptr<DescribeUpBpsPeakDataRequest> request);
  DescribeUpBpsPeakOfLineResponse describeUpBpsPeakOfLineWithOptions(shared_ptr<DescribeUpBpsPeakOfLineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUpBpsPeakOfLineResponse describeUpBpsPeakOfLine(shared_ptr<DescribeUpBpsPeakOfLineRequest> request);
  DescribeUpPeakPublishStreamDataResponse describeUpPeakPublishStreamDataWithOptions(shared_ptr<DescribeUpPeakPublishStreamDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUpPeakPublishStreamDataResponse describeUpPeakPublishStreamData(shared_ptr<DescribeUpPeakPublishStreamDataRequest> request);
  DisableLiveRealtimeLogDeliveryResponse disableLiveRealtimeLogDeliveryWithOptions(shared_ptr<DisableLiveRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableLiveRealtimeLogDeliveryResponse disableLiveRealtimeLogDelivery(shared_ptr<DisableLiveRealtimeLogDeliveryRequest> request);
  DynamicUpdateWaterMarkStreamRuleResponse dynamicUpdateWaterMarkStreamRuleWithOptions(shared_ptr<DynamicUpdateWaterMarkStreamRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DynamicUpdateWaterMarkStreamRuleResponse dynamicUpdateWaterMarkStreamRule(shared_ptr<DynamicUpdateWaterMarkStreamRuleRequest> request);
  EditPlaylistResponse editPlaylistWithOptions(shared_ptr<EditPlaylistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EditPlaylistResponse editPlaylist(shared_ptr<EditPlaylistRequest> request);
  EditShowAndReplaceResponse editShowAndReplaceWithOptions(shared_ptr<EditShowAndReplaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EditShowAndReplaceResponse editShowAndReplace(shared_ptr<EditShowAndReplaceRequest> request);
  EffectCasterUrgentResponse effectCasterUrgentWithOptions(shared_ptr<EffectCasterUrgentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EffectCasterUrgentResponse effectCasterUrgent(shared_ptr<EffectCasterUrgentRequest> request);
  EffectCasterVideoResourceResponse effectCasterVideoResourceWithOptions(shared_ptr<EffectCasterVideoResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EffectCasterVideoResourceResponse effectCasterVideoResource(shared_ptr<EffectCasterVideoResourceRequest> request);
  EnableLiveRealtimeLogDeliveryResponse enableLiveRealtimeLogDeliveryWithOptions(shared_ptr<EnableLiveRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableLiveRealtimeLogDeliveryResponse enableLiveRealtimeLogDelivery(shared_ptr<EnableLiveRealtimeLogDeliveryRequest> request);
  ForbidLiveStreamResponse forbidLiveStreamWithOptions(shared_ptr<ForbidLiveStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ForbidLiveStreamResponse forbidLiveStream(shared_ptr<ForbidLiveStreamRequest> request);
  ForbidPushStreamResponse forbidPushStreamWithOptions(shared_ptr<ForbidPushStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ForbidPushStreamResponse forbidPushStream(shared_ptr<ForbidPushStreamRequest> request);
  GetAllCustomTemplatesResponse getAllCustomTemplatesWithOptions(shared_ptr<GetAllCustomTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAllCustomTemplatesResponse getAllCustomTemplates(shared_ptr<GetAllCustomTemplatesRequest> request);
  GetCustomTemplateResponse getCustomTemplateWithOptions(shared_ptr<GetCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomTemplateResponse getCustomTemplate(shared_ptr<GetCustomTemplateRequest> request);
  GetEditingJobInfoResponse getEditingJobInfoWithOptions(shared_ptr<GetEditingJobInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEditingJobInfoResponse getEditingJobInfo(shared_ptr<GetEditingJobInfoRequest> request);
  GetMessageAppResponse getMessageAppWithOptions(shared_ptr<GetMessageAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMessageAppResponse getMessageApp(shared_ptr<GetMessageAppRequest> request);
  GetMessageGroupResponse getMessageGroupWithOptions(shared_ptr<GetMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMessageGroupResponse getMessageGroup(shared_ptr<GetMessageGroupRequest> request);
  GetMessageTokenResponse getMessageTokenWithOptions(shared_ptr<GetMessageTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMessageTokenResponse getMessageToken(shared_ptr<GetMessageTokenRequest> request);
  GetMultiRateConfigResponse getMultiRateConfigWithOptions(shared_ptr<GetMultiRateConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMultiRateConfigResponse getMultiRateConfig(shared_ptr<GetMultiRateConfigRequest> request);
  GetMultiRateConfigListResponse getMultiRateConfigListWithOptions(shared_ptr<GetMultiRateConfigListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMultiRateConfigListResponse getMultiRateConfigList(shared_ptr<GetMultiRateConfigListRequest> request);
  HotLiveRtcStreamResponse hotLiveRtcStreamWithOptions(shared_ptr<HotLiveRtcStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotLiveRtcStreamResponse hotLiveRtcStream(shared_ptr<HotLiveRtcStreamRequest> request);
  InitializeAutoShowListTaskResponse initializeAutoShowListTaskWithOptions(shared_ptr<InitializeAutoShowListTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitializeAutoShowListTaskResponse initializeAutoShowListTask(shared_ptr<InitializeAutoShowListTaskRequest> request);
  JoinMessageGroupResponse joinMessageGroupWithOptions(shared_ptr<JoinMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinMessageGroupResponse joinMessageGroup(shared_ptr<JoinMessageGroupRequest> request);
  LeaveMessageGroupResponse leaveMessageGroupWithOptions(shared_ptr<LeaveMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LeaveMessageGroupResponse leaveMessageGroup(shared_ptr<LeaveMessageGroupRequest> request);
  ListLiveRealtimeLogDeliveryResponse listLiveRealtimeLogDeliveryWithOptions(shared_ptr<ListLiveRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRealtimeLogDeliveryResponse listLiveRealtimeLogDelivery(shared_ptr<ListLiveRealtimeLogDeliveryRequest> request);
  ListLiveRealtimeLogDeliveryDomainsResponse listLiveRealtimeLogDeliveryDomainsWithOptions(shared_ptr<ListLiveRealtimeLogDeliveryDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRealtimeLogDeliveryDomainsResponse listLiveRealtimeLogDeliveryDomains(shared_ptr<ListLiveRealtimeLogDeliveryDomainsRequest> request);
  ListLiveRealtimeLogDeliveryInfosResponse listLiveRealtimeLogDeliveryInfosWithOptions(shared_ptr<ListLiveRealtimeLogDeliveryInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRealtimeLogDeliveryInfosResponse listLiveRealtimeLogDeliveryInfos(shared_ptr<ListLiveRealtimeLogDeliveryInfosRequest> request);
  ListMessageResponse listMessageWithOptions(shared_ptr<ListMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageResponse listMessage(shared_ptr<ListMessageRequest> request);
  ListMessageAppResponse listMessageAppWithOptions(shared_ptr<ListMessageAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageAppResponse listMessageApp(shared_ptr<ListMessageAppRequest> request);
  ListMessageGroupResponse listMessageGroupWithOptions(shared_ptr<ListMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageGroupResponse listMessageGroup(shared_ptr<ListMessageGroupRequest> request);
  ListMessageGroupUserResponse listMessageGroupUserWithOptions(shared_ptr<ListMessageGroupUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageGroupUserResponse listMessageGroupUser(shared_ptr<ListMessageGroupUserRequest> request);
  ListMessageGroupUserByIdResponse listMessageGroupUserByIdWithOptions(shared_ptr<ListMessageGroupUserByIdRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageGroupUserByIdResponse listMessageGroupUserById(shared_ptr<ListMessageGroupUserByIdRequest> request);
  ListPlaylistResponse listPlaylistWithOptions(shared_ptr<ListPlaylistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPlaylistResponse listPlaylist(shared_ptr<ListPlaylistRequest> request);
  ListPlaylistItemsResponse listPlaylistItemsWithOptions(shared_ptr<ListPlaylistItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPlaylistItemsResponse listPlaylistItems(shared_ptr<ListPlaylistItemsRequest> request);
  ModifyCasterComponentResponse modifyCasterComponentWithOptions(shared_ptr<ModifyCasterComponentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCasterComponentResponse modifyCasterComponent(shared_ptr<ModifyCasterComponentRequest> request);
  ModifyCasterEpisodeResponse modifyCasterEpisodeWithOptions(shared_ptr<ModifyCasterEpisodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCasterEpisodeResponse modifyCasterEpisode(shared_ptr<ModifyCasterEpisodeRequest> request);
  ModifyCasterLayoutResponse modifyCasterLayoutWithOptions(shared_ptr<ModifyCasterLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCasterLayoutResponse modifyCasterLayout(shared_ptr<ModifyCasterLayoutRequest> request);
  ModifyCasterProgramResponse modifyCasterProgramWithOptions(shared_ptr<ModifyCasterProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCasterProgramResponse modifyCasterProgram(shared_ptr<ModifyCasterProgramRequest> request);
  ModifyCasterVideoResourceResponse modifyCasterVideoResourceWithOptions(shared_ptr<ModifyCasterVideoResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCasterVideoResourceResponse modifyCasterVideoResource(shared_ptr<ModifyCasterVideoResourceRequest> request);
  ModifyLiveDomainSchdmByPropertyResponse modifyLiveDomainSchdmByPropertyWithOptions(shared_ptr<ModifyLiveDomainSchdmByPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLiveDomainSchdmByPropertyResponse modifyLiveDomainSchdmByProperty(shared_ptr<ModifyLiveDomainSchdmByPropertyRequest> request);
  ModifyLiveRealtimeLogDeliveryResponse modifyLiveRealtimeLogDeliveryWithOptions(shared_ptr<ModifyLiveRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLiveRealtimeLogDeliveryResponse modifyLiveRealtimeLogDelivery(shared_ptr<ModifyLiveRealtimeLogDeliveryRequest> request);
  ModifyShowListResponse modifyShowListWithOptions(shared_ptr<ModifyShowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyShowListResponse modifyShowList(shared_ptr<ModifyShowListRequest> request);
  ModifyStudioLayoutResponse modifyStudioLayoutWithOptions(shared_ptr<ModifyStudioLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyStudioLayoutResponse modifyStudioLayout(shared_ptr<ModifyStudioLayoutRequest> request);
  OpenLiveShiftResponse openLiveShiftWithOptions(shared_ptr<OpenLiveShiftRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenLiveShiftResponse openLiveShift(shared_ptr<OpenLiveShiftRequest> request);
  PlayChoosenShowResponse playChoosenShowWithOptions(shared_ptr<PlayChoosenShowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PlayChoosenShowResponse playChoosenShow(shared_ptr<PlayChoosenShowRequest> request);
  PublishLiveStagingConfigToProductionResponse publishLiveStagingConfigToProductionWithOptions(shared_ptr<PublishLiveStagingConfigToProductionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishLiveStagingConfigToProductionResponse publishLiveStagingConfigToProduction(shared_ptr<PublishLiveStagingConfigToProductionRequest> request);
  QueryMessageAppResponse queryMessageAppWithOptions(shared_ptr<QueryMessageAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMessageAppResponse queryMessageApp(shared_ptr<QueryMessageAppRequest> request);
  QuerySnapshotCallbackAuthResponse querySnapshotCallbackAuthWithOptions(shared_ptr<QuerySnapshotCallbackAuthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySnapshotCallbackAuthResponse querySnapshotCallbackAuth(shared_ptr<QuerySnapshotCallbackAuthRequest> request);
  RealTimeRecordCommandResponse realTimeRecordCommandWithOptions(shared_ptr<RealTimeRecordCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RealTimeRecordCommandResponse realTimeRecordCommand(shared_ptr<RealTimeRecordCommandRequest> request);
  RealTimeSnapshotCommandResponse realTimeSnapshotCommandWithOptions(shared_ptr<RealTimeSnapshotCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RealTimeSnapshotCommandResponse realTimeSnapshotCommand(shared_ptr<RealTimeSnapshotCommandRequest> request);
  RemoveShowFromShowListResponse removeShowFromShowListWithOptions(shared_ptr<RemoveShowFromShowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveShowFromShowListResponse removeShowFromShowList(shared_ptr<RemoveShowFromShowListRequest> request);
  RestartCasterResponse restartCasterWithOptions(shared_ptr<RestartCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartCasterResponse restartCaster(shared_ptr<RestartCasterRequest> request);
  ResumeLiveStreamResponse resumeLiveStreamWithOptions(shared_ptr<ResumeLiveStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeLiveStreamResponse resumeLiveStream(shared_ptr<ResumeLiveStreamRequest> request);
  RollbackLiveStagingConfigResponse rollbackLiveStagingConfigWithOptions(shared_ptr<RollbackLiveStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackLiveStagingConfigResponse rollbackLiveStagingConfig(shared_ptr<RollbackLiveStagingConfigRequest> request);
  SendLikeResponse sendLikeWithOptions(shared_ptr<SendLikeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendLikeResponse sendLike(shared_ptr<SendLikeRequest> request);
  SendMessageToGroupResponse sendMessageToGroupWithOptions(shared_ptr<SendMessageToGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendMessageToGroupResponse sendMessageToGroup(shared_ptr<SendMessageToGroupRequest> request);
  SendMessageToGroupUsersResponse sendMessageToGroupUsersWithOptions(shared_ptr<SendMessageToGroupUsersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendMessageToGroupUsersResponse sendMessageToGroupUsers(shared_ptr<SendMessageToGroupUsersRequest> request);
  SendRoomNotificationResponse sendRoomNotificationWithOptions(shared_ptr<SendRoomNotificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendRoomNotificationResponse sendRoomNotification(shared_ptr<SendRoomNotificationRequest> request);
  SendRoomUserNotificationResponse sendRoomUserNotificationWithOptions(shared_ptr<SendRoomUserNotificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendRoomUserNotificationResponse sendRoomUserNotification(shared_ptr<SendRoomUserNotificationRequest> request);
  SetCasterChannelResponse setCasterChannelWithOptions(shared_ptr<SetCasterChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCasterChannelResponse setCasterChannel(shared_ptr<SetCasterChannelRequest> request);
  SetCasterConfigResponse setCasterConfigWithOptions(shared_ptr<SetCasterConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCasterConfigResponse setCasterConfig(shared_ptr<SetCasterConfigRequest> request);
  SetCasterSceneConfigResponse setCasterSceneConfigWithOptions(shared_ptr<SetCasterSceneConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCasterSceneConfigResponse setCasterSceneConfig(shared_ptr<SetCasterSceneConfigRequest> request);
  SetCasterSyncGroupResponse setCasterSyncGroupWithOptions(shared_ptr<SetCasterSyncGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCasterSyncGroupResponse setCasterSyncGroup(shared_ptr<SetCasterSyncGroupRequest> request);
  SetCasterTimedEventResponse setCasterTimedEventWithOptions(shared_ptr<SetCasterTimedEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCasterTimedEventResponse setCasterTimedEvent(shared_ptr<SetCasterTimedEventRequest> request);
  SetLiveDomainCertificateResponse setLiveDomainCertificateWithOptions(shared_ptr<SetLiveDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveDomainCertificateResponse setLiveDomainCertificate(shared_ptr<SetLiveDomainCertificateRequest> request);
  SetLiveDomainStagingConfigResponse setLiveDomainStagingConfigWithOptions(shared_ptr<SetLiveDomainStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveDomainStagingConfigResponse setLiveDomainStagingConfig(shared_ptr<SetLiveDomainStagingConfigRequest> request);
  SetLiveEdgeTransferResponse setLiveEdgeTransferWithOptions(shared_ptr<SetLiveEdgeTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveEdgeTransferResponse setLiveEdgeTransfer(shared_ptr<SetLiveEdgeTransferRequest> request);
  SetLiveLazyPullStreamInfoConfigResponse setLiveLazyPullStreamInfoConfigWithOptions(shared_ptr<SetLiveLazyPullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveLazyPullStreamInfoConfigResponse setLiveLazyPullStreamInfoConfig(shared_ptr<SetLiveLazyPullStreamInfoConfigRequest> request);
  SetLiveStreamDelayConfigResponse setLiveStreamDelayConfigWithOptions(shared_ptr<SetLiveStreamDelayConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveStreamDelayConfigResponse setLiveStreamDelayConfig(shared_ptr<SetLiveStreamDelayConfigRequest> request);
  SetLiveStreamOptimizedFeatureConfigResponse setLiveStreamOptimizedFeatureConfigWithOptions(shared_ptr<SetLiveStreamOptimizedFeatureConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveStreamOptimizedFeatureConfigResponse setLiveStreamOptimizedFeatureConfig(shared_ptr<SetLiveStreamOptimizedFeatureConfigRequest> request);
  SetLiveStreamsNotifyUrlConfigResponse setLiveStreamsNotifyUrlConfigWithOptions(shared_ptr<SetLiveStreamsNotifyUrlConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveStreamsNotifyUrlConfigResponse setLiveStreamsNotifyUrlConfig(shared_ptr<SetLiveStreamsNotifyUrlConfigRequest> request);
  SetSnapshotCallbackAuthResponse setSnapshotCallbackAuthWithOptions(shared_ptr<SetSnapshotCallbackAuthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetSnapshotCallbackAuthResponse setSnapshotCallbackAuth(shared_ptr<SetSnapshotCallbackAuthRequest> request);
  StartCasterResponse startCasterWithOptions(shared_ptr<StartCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartCasterResponse startCaster(shared_ptr<StartCasterRequest> request);
  StartCasterSceneResponse startCasterSceneWithOptions(shared_ptr<StartCasterSceneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartCasterSceneResponse startCasterScene(shared_ptr<StartCasterSceneRequest> request);
  StartLiveDomainResponse startLiveDomainWithOptions(shared_ptr<StartLiveDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartLiveDomainResponse startLiveDomain(shared_ptr<StartLiveDomainRequest> request);
  StartLiveStreamMonitorResponse startLiveStreamMonitorWithOptions(shared_ptr<StartLiveStreamMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartLiveStreamMonitorResponse startLiveStreamMonitor(shared_ptr<StartLiveStreamMonitorRequest> request);
  StartPlaylistResponse startPlaylistWithOptions(shared_ptr<StartPlaylistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartPlaylistResponse startPlaylist(shared_ptr<StartPlaylistRequest> request);
  StopCasterResponse stopCasterWithOptions(shared_ptr<StopCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopCasterResponse stopCaster(shared_ptr<StopCasterRequest> request);
  StopCasterSceneResponse stopCasterSceneWithOptions(shared_ptr<StopCasterSceneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopCasterSceneResponse stopCasterScene(shared_ptr<StopCasterSceneRequest> request);
  StopLiveDomainResponse stopLiveDomainWithOptions(shared_ptr<StopLiveDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopLiveDomainResponse stopLiveDomain(shared_ptr<StopLiveDomainRequest> request);
  StopLiveStreamMonitorResponse stopLiveStreamMonitorWithOptions(shared_ptr<StopLiveStreamMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopLiveStreamMonitorResponse stopLiveStreamMonitor(shared_ptr<StopLiveStreamMonitorRequest> request);
  StopPlaylistResponse stopPlaylistWithOptions(shared_ptr<StopPlaylistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopPlaylistResponse stopPlaylist(shared_ptr<StopPlaylistRequest> request);
  TagLiveResourcesResponse tagLiveResourcesWithOptions(shared_ptr<TagLiveResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagLiveResourcesResponse tagLiveResources(shared_ptr<TagLiveResourcesRequest> request);
  UnTagLiveResourcesResponse unTagLiveResourcesWithOptions(shared_ptr<UnTagLiveResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnTagLiveResourcesResponse unTagLiveResources(shared_ptr<UnTagLiveResourcesRequest> request);
  UpdateCasterSceneAudioResponse updateCasterSceneAudioWithOptions(shared_ptr<UpdateCasterSceneAudioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCasterSceneAudioResponse updateCasterSceneAudio(shared_ptr<UpdateCasterSceneAudioRequest> request);
  UpdateCasterSceneConfigResponse updateCasterSceneConfigWithOptions(shared_ptr<UpdateCasterSceneConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCasterSceneConfigResponse updateCasterSceneConfig(shared_ptr<UpdateCasterSceneConfigRequest> request);
  UpdateLiveAppSnapshotConfigResponse updateLiveAppSnapshotConfigWithOptions(shared_ptr<UpdateLiveAppSnapshotConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveAppSnapshotConfigResponse updateLiveAppSnapshotConfig(shared_ptr<UpdateLiveAppSnapshotConfigRequest> request);
  UpdateLiveAudioAuditConfigResponse updateLiveAudioAuditConfigWithOptions(shared_ptr<UpdateLiveAudioAuditConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveAudioAuditConfigResponse updateLiveAudioAuditConfig(shared_ptr<UpdateLiveAudioAuditConfigRequest> request);
  UpdateLiveAudioAuditNotifyConfigResponse updateLiveAudioAuditNotifyConfigWithOptions(shared_ptr<UpdateLiveAudioAuditNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveAudioAuditNotifyConfigResponse updateLiveAudioAuditNotifyConfig(shared_ptr<UpdateLiveAudioAuditNotifyConfigRequest> request);
  UpdateLiveDetectNotifyConfigResponse updateLiveDetectNotifyConfigWithOptions(shared_ptr<UpdateLiveDetectNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveDetectNotifyConfigResponse updateLiveDetectNotifyConfig(shared_ptr<UpdateLiveDetectNotifyConfigRequest> request);
  UpdateLivePullStreamInfoConfigResponse updateLivePullStreamInfoConfigWithOptions(shared_ptr<UpdateLivePullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLivePullStreamInfoConfigResponse updateLivePullStreamInfoConfig(shared_ptr<UpdateLivePullStreamInfoConfigRequest> request);
  UpdateLiveRecordNotifyConfigResponse updateLiveRecordNotifyConfigWithOptions(shared_ptr<UpdateLiveRecordNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveRecordNotifyConfigResponse updateLiveRecordNotifyConfig(shared_ptr<UpdateLiveRecordNotifyConfigRequest> request);
  UpdateLiveSnapshotDetectPornConfigResponse updateLiveSnapshotDetectPornConfigWithOptions(shared_ptr<UpdateLiveSnapshotDetectPornConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveSnapshotDetectPornConfigResponse updateLiveSnapshotDetectPornConfig(shared_ptr<UpdateLiveSnapshotDetectPornConfigRequest> request);
  UpdateLiveSnapshotNotifyConfigResponse updateLiveSnapshotNotifyConfigWithOptions(shared_ptr<UpdateLiveSnapshotNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveSnapshotNotifyConfigResponse updateLiveSnapshotNotifyConfig(shared_ptr<UpdateLiveSnapshotNotifyConfigRequest> request);
  UpdateLiveStreamMonitorResponse updateLiveStreamMonitorWithOptions(shared_ptr<UpdateLiveStreamMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveStreamMonitorResponse updateLiveStreamMonitor(shared_ptr<UpdateLiveStreamMonitorRequest> request);
  UpdateLiveStreamWatermarkResponse updateLiveStreamWatermarkWithOptions(shared_ptr<UpdateLiveStreamWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveStreamWatermarkResponse updateLiveStreamWatermark(shared_ptr<UpdateLiveStreamWatermarkRequest> request);
  UpdateLiveStreamWatermarkRuleResponse updateLiveStreamWatermarkRuleWithOptions(shared_ptr<UpdateLiveStreamWatermarkRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveStreamWatermarkRuleResponse updateLiveStreamWatermarkRule(shared_ptr<UpdateLiveStreamWatermarkRuleRequest> request);
  UpdateLiveTopLevelDomainResponse updateLiveTopLevelDomainWithOptions(shared_ptr<UpdateLiveTopLevelDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveTopLevelDomainResponse updateLiveTopLevelDomain(shared_ptr<UpdateLiveTopLevelDomainRequest> request);
  UpdateMessageAppResponse updateMessageAppWithOptions(shared_ptr<UpdateMessageAppRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMessageAppResponse updateMessageApp(shared_ptr<UpdateMessageAppRequest> request);
  UpdateMessageGroupResponse updateMessageGroupWithOptions(shared_ptr<UpdateMessageGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMessageGroupResponse updateMessageGroup(shared_ptr<UpdateMessageGroupRequest> request);
  UpdateMixStreamResponse updateMixStreamWithOptions(shared_ptr<UpdateMixStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMixStreamResponse updateMixStream(shared_ptr<UpdateMixStreamRequest> request);
  VerifyLiveDomainOwnerResponse verifyLiveDomainOwnerWithOptions(shared_ptr<VerifyLiveDomainOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyLiveDomainOwnerResponse verifyLiveDomainOwner(shared_ptr<VerifyLiveDomainOwnerRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Live20161101

#endif
