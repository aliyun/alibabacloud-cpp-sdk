// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_LIVE20161101_H_
#define ALIBABACLOUD_LIVE20161101_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Live20161101 {
class AppInfoDTOPlatforms : public Darabonba::Model {
public:
  shared_ptr<string> itemId{};
  shared_ptr<vector<string>> licenseItemIds{};
  shared_ptr<string> pkgName{};
  shared_ptr<string> pkgSignature{};
  shared_ptr<long> platformType{};
  shared_ptr<long> type{};

  AppInfoDTOPlatforms() {}

  explicit AppInfoDTOPlatforms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (licenseItemIds) {
      res["LicenseItemIds"] = boost::any(*licenseItemIds);
    }
    if (pkgName) {
      res["PkgName"] = boost::any(*pkgName);
    }
    if (pkgSignature) {
      res["PkgSignature"] = boost::any(*pkgSignature);
    }
    if (platformType) {
      res["PlatformType"] = boost::any(*platformType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("LicenseItemIds") != m.end() && !m["LicenseItemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LicenseItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LicenseItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      licenseItemIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PkgName") != m.end() && !m["PkgName"].empty()) {
      pkgName = make_shared<string>(boost::any_cast<string>(m["PkgName"]));
    }
    if (m.find("PkgSignature") != m.end() && !m["PkgSignature"].empty()) {
      pkgSignature = make_shared<string>(boost::any_cast<string>(m["PkgSignature"]));
    }
    if (m.find("PlatformType") != m.end() && !m["PlatformType"].empty()) {
      platformType = make_shared<long>(boost::any_cast<long>(m["PlatformType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~AppInfoDTOPlatforms() = default;
};
class AppInfoDTO : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> appType{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> itemId{};
  shared_ptr<string> modificationTime{};
  shared_ptr<vector<AppInfoDTOPlatforms>> platforms{};
  shared_ptr<long> userId{};

  AppInfoDTO() {}

  explicit AppInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (platforms) {
      vector<boost::any> temp1;
      for(auto item1:*platforms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Platforms"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<long>(boost::any_cast<long>(m["AppType"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Platforms") != m.end() && !m["Platforms"].empty()) {
      if (typeid(vector<boost::any>) == m["Platforms"].type()) {
        vector<AppInfoDTOPlatforms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Platforms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppInfoDTOPlatforms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        platforms = make_shared<vector<AppInfoDTOPlatforms>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~AppInfoDTO() = default;
};
class LicenseInstanceAppDTOLicenseConfigs : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> featureIds{};
  shared_ptr<bool> isTrial{};
  shared_ptr<long> sdkId{};
  shared_ptr<string> sdkName{};
  shared_ptr<string> subscription{};
  shared_ptr<string> subscriptionImp{};
  shared_ptr<string> subscriptionPkg{};

  LicenseInstanceAppDTOLicenseConfigs() {}

  explicit LicenseInstanceAppDTOLicenseConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (featureIds) {
      res["FeatureIds"] = boost::any(*featureIds);
    }
    if (isTrial) {
      res["IsTrial"] = boost::any(*isTrial);
    }
    if (sdkId) {
      res["SdkId"] = boost::any(*sdkId);
    }
    if (sdkName) {
      res["SdkName"] = boost::any(*sdkName);
    }
    if (subscription) {
      res["Subscription"] = boost::any(*subscription);
    }
    if (subscriptionImp) {
      res["SubscriptionImp"] = boost::any(*subscriptionImp);
    }
    if (subscriptionPkg) {
      res["SubscriptionPkg"] = boost::any(*subscriptionPkg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("FeatureIds") != m.end() && !m["FeatureIds"].empty()) {
      featureIds = make_shared<string>(boost::any_cast<string>(m["FeatureIds"]));
    }
    if (m.find("IsTrial") != m.end() && !m["IsTrial"].empty()) {
      isTrial = make_shared<bool>(boost::any_cast<bool>(m["IsTrial"]));
    }
    if (m.find("SdkId") != m.end() && !m["SdkId"].empty()) {
      sdkId = make_shared<long>(boost::any_cast<long>(m["SdkId"]));
    }
    if (m.find("SdkName") != m.end() && !m["SdkName"].empty()) {
      sdkName = make_shared<string>(boost::any_cast<string>(m["SdkName"]));
    }
    if (m.find("Subscription") != m.end() && !m["Subscription"].empty()) {
      subscription = make_shared<string>(boost::any_cast<string>(m["Subscription"]));
    }
    if (m.find("SubscriptionImp") != m.end() && !m["SubscriptionImp"].empty()) {
      subscriptionImp = make_shared<string>(boost::any_cast<string>(m["SubscriptionImp"]));
    }
    if (m.find("SubscriptionPkg") != m.end() && !m["SubscriptionPkg"].empty()) {
      subscriptionPkg = make_shared<string>(boost::any_cast<string>(m["SubscriptionPkg"]));
    }
  }


  virtual ~LicenseInstanceAppDTOLicenseConfigs() = default;
};
class LicenseInstanceAppDTO : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> beginOn{};
  shared_ptr<string> contractNo{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> expiredOn{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> itemId{};
  shared_ptr<vector<LicenseInstanceAppDTOLicenseConfigs>> licenseConfigs{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> status{};
  shared_ptr<long> userId{};

  LicenseInstanceAppDTO() {}

  explicit LicenseInstanceAppDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (beginOn) {
      res["BeginOn"] = boost::any(*beginOn);
    }
    if (contractNo) {
      res["ContractNo"] = boost::any(*contractNo);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (expiredOn) {
      res["ExpiredOn"] = boost::any(*expiredOn);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (licenseConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*licenseConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LicenseConfigs"] = boost::any(temp1);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BeginOn") != m.end() && !m["BeginOn"].empty()) {
      beginOn = make_shared<string>(boost::any_cast<string>(m["BeginOn"]));
    }
    if (m.find("ContractNo") != m.end() && !m["ContractNo"].empty()) {
      contractNo = make_shared<string>(boost::any_cast<string>(m["ContractNo"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ExpiredOn") != m.end() && !m["ExpiredOn"].empty()) {
      expiredOn = make_shared<string>(boost::any_cast<string>(m["ExpiredOn"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("LicenseConfigs") != m.end() && !m["LicenseConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["LicenseConfigs"].type()) {
        vector<LicenseInstanceAppDTOLicenseConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LicenseConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LicenseInstanceAppDTOLicenseConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        licenseConfigs = make_shared<vector<LicenseInstanceAppDTOLicenseConfigs>>(expect1);
      }
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~LicenseInstanceAppDTO() = default;
};
class AddCasterComponentRequest : public Darabonba::Model {
public:
  shared_ptr<string> captionLayerContent{};
  shared_ptr<string> casterId{};
  shared_ptr<string> componentLayer{};
  shared_ptr<string> componentName{};
  shared_ptr<string> componentType{};
  shared_ptr<string> effect{};
  shared_ptr<string> htmlLayerContent{};
  shared_ptr<string> imageLayerContent{};
  shared_ptr<string> layerOrder{};
  shared_ptr<string> locationId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> textLayerContent{};

  AddCasterComponentRequest() {}

  explicit AddCasterComponentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (captionLayerContent) {
      res["CaptionLayerContent"] = boost::any(*captionLayerContent);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentLayer) {
      res["ComponentLayer"] = boost::any(*componentLayer);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (componentType) {
      res["ComponentType"] = boost::any(*componentType);
    }
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (htmlLayerContent) {
      res["HtmlLayerContent"] = boost::any(*htmlLayerContent);
    }
    if (imageLayerContent) {
      res["ImageLayerContent"] = boost::any(*imageLayerContent);
    }
    if (layerOrder) {
      res["LayerOrder"] = boost::any(*layerOrder);
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (textLayerContent) {
      res["TextLayerContent"] = boost::any(*textLayerContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaptionLayerContent") != m.end() && !m["CaptionLayerContent"].empty()) {
      captionLayerContent = make_shared<string>(boost::any_cast<string>(m["CaptionLayerContent"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentLayer") != m.end() && !m["ComponentLayer"].empty()) {
      componentLayer = make_shared<string>(boost::any_cast<string>(m["ComponentLayer"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("ComponentType") != m.end() && !m["ComponentType"].empty()) {
      componentType = make_shared<string>(boost::any_cast<string>(m["ComponentType"]));
    }
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("HtmlLayerContent") != m.end() && !m["HtmlLayerContent"].empty()) {
      htmlLayerContent = make_shared<string>(boost::any_cast<string>(m["HtmlLayerContent"]));
    }
    if (m.find("ImageLayerContent") != m.end() && !m["ImageLayerContent"].empty()) {
      imageLayerContent = make_shared<string>(boost::any_cast<string>(m["ImageLayerContent"]));
    }
    if (m.find("LayerOrder") != m.end() && !m["LayerOrder"].empty()) {
      layerOrder = make_shared<string>(boost::any_cast<string>(m["LayerOrder"]));
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TextLayerContent") != m.end() && !m["TextLayerContent"].empty()) {
      textLayerContent = make_shared<string>(boost::any_cast<string>(m["TextLayerContent"]));
    }
  }


  virtual ~AddCasterComponentRequest() = default;
};
class AddCasterComponentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> componentId{};
  shared_ptr<string> requestId{};

  AddCasterComponentResponseBody() {}

  explicit AddCasterComponentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterComponentResponseBody() = default;
};
class AddCasterComponentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterComponentResponseBody> body{};

  AddCasterComponentResponse() {}

  explicit AddCasterComponentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterComponentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterComponentResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterComponentResponse() = default;
};
class AddCasterEpisodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeName{};
  shared_ptr<string> episodeType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> switchType{};

  AddCasterEpisodeRequest() {}

  explicit AddCasterEpisodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeName) {
      res["EpisodeName"] = boost::any(*episodeName);
    }
    if (episodeType) {
      res["EpisodeType"] = boost::any(*episodeType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (switchType) {
      res["SwitchType"] = boost::any(*switchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeName") != m.end() && !m["EpisodeName"].empty()) {
      episodeName = make_shared<string>(boost::any_cast<string>(m["EpisodeName"]));
    }
    if (m.find("EpisodeType") != m.end() && !m["EpisodeType"].empty()) {
      episodeType = make_shared<string>(boost::any_cast<string>(m["EpisodeType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SwitchType") != m.end() && !m["SwitchType"].empty()) {
      switchType = make_shared<string>(boost::any_cast<string>(m["SwitchType"]));
    }
  }


  virtual ~AddCasterEpisodeRequest() = default;
};
class AddCasterEpisodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> episodeId{};
  shared_ptr<string> requestId{};

  AddCasterEpisodeResponseBody() {}

  explicit AddCasterEpisodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterEpisodeResponseBody() = default;
};
class AddCasterEpisodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterEpisodeResponseBody> body{};

  AddCasterEpisodeResponse() {}

  explicit AddCasterEpisodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterEpisodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterEpisodeResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterEpisodeResponse() = default;
};
class AddCasterEpisodeGroupRequestItem : public Darabonba::Model {
public:
  shared_ptr<string> itemName{};
  shared_ptr<string> vodUrl{};

  AddCasterEpisodeGroupRequestItem() {}

  explicit AddCasterEpisodeGroupRequestItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (vodUrl) {
      res["VodUrl"] = boost::any(*vodUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("VodUrl") != m.end() && !m["VodUrl"].empty()) {
      vodUrl = make_shared<string>(boost::any_cast<string>(m["VodUrl"]));
    }
  }


  virtual ~AddCasterEpisodeGroupRequestItem() = default;
};
class AddCasterEpisodeGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> domainName{};
  shared_ptr<vector<AddCasterEpisodeGroupRequestItem>> item{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> repeatNum{};
  shared_ptr<string> sideOutputUrl{};
  shared_ptr<string> startTime{};

  AddCasterEpisodeGroupRequest() {}

  explicit AddCasterEpisodeGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeatNum) {
      res["RepeatNum"] = boost::any(*repeatNum);
    }
    if (sideOutputUrl) {
      res["SideOutputUrl"] = boost::any(*sideOutputUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<AddCasterEpisodeGroupRequestItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasterEpisodeGroupRequestItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<AddCasterEpisodeGroupRequestItem>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepeatNum") != m.end() && !m["RepeatNum"].empty()) {
      repeatNum = make_shared<long>(boost::any_cast<long>(m["RepeatNum"]));
    }
    if (m.find("SideOutputUrl") != m.end() && !m["SideOutputUrl"].empty()) {
      sideOutputUrl = make_shared<string>(boost::any_cast<string>(m["SideOutputUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~AddCasterEpisodeGroupRequest() = default;
};
class AddCasterEpisodeGroupResponseBodyItemIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> itemId{};

  AddCasterEpisodeGroupResponseBodyItemIds() {}

  explicit AddCasterEpisodeGroupResponseBodyItemIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ItemId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      itemId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddCasterEpisodeGroupResponseBodyItemIds() = default;
};
class AddCasterEpisodeGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddCasterEpisodeGroupResponseBodyItemIds> itemIds{};
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  AddCasterEpisodeGroupResponseBody() {}

  explicit AddCasterEpisodeGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemIds) {
      res["ItemIds"] = itemIds ? boost::any(itemIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemIds"].type()) {
        AddCasterEpisodeGroupResponseBodyItemIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemIds"]));
        itemIds = make_shared<AddCasterEpisodeGroupResponseBodyItemIds>(model1);
      }
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterEpisodeGroupResponseBody() = default;
};
class AddCasterEpisodeGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterEpisodeGroupResponseBody> body{};

  AddCasterEpisodeGroupResponse() {}

  explicit AddCasterEpisodeGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterEpisodeGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterEpisodeGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterEpisodeGroupResponse() = default;
};
class AddCasterEpisodeGroupContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> content{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  AddCasterEpisodeGroupContentRequest() {}

  explicit AddCasterEpisodeGroupContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddCasterEpisodeGroupContentRequest() = default;
};
class AddCasterEpisodeGroupContentResponseBodyItemIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> itemId{};

  AddCasterEpisodeGroupContentResponseBodyItemIds() {}

  explicit AddCasterEpisodeGroupContentResponseBodyItemIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ItemId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      itemId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddCasterEpisodeGroupContentResponseBodyItemIds() = default;
};
class AddCasterEpisodeGroupContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddCasterEpisodeGroupContentResponseBodyItemIds> itemIds{};
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  AddCasterEpisodeGroupContentResponseBody() {}

  explicit AddCasterEpisodeGroupContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemIds) {
      res["ItemIds"] = itemIds ? boost::any(itemIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemIds"].type()) {
        AddCasterEpisodeGroupContentResponseBodyItemIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemIds"]));
        itemIds = make_shared<AddCasterEpisodeGroupContentResponseBodyItemIds>(model1);
      }
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterEpisodeGroupContentResponseBody() = default;
};
class AddCasterEpisodeGroupContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterEpisodeGroupContentResponseBody> body{};

  AddCasterEpisodeGroupContentResponse() {}

  explicit AddCasterEpisodeGroupContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterEpisodeGroupContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterEpisodeGroupContentResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterEpisodeGroupContentResponse() = default;
};
class AddCasterLayoutRequestAudioLayer : public Darabonba::Model {
public:
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  AddCasterLayoutRequestAudioLayer() {}

  explicit AddCasterLayoutRequestAudioLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~AddCasterLayoutRequestAudioLayer() = default;
};
class AddCasterLayoutRequestVideoLayer : public Darabonba::Model {
public:
  shared_ptr<string> fillMode{};
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<double> heightNormalized{};
  shared_ptr<vector<double>> positionNormalized{};
  shared_ptr<string> positionRefer{};
  shared_ptr<double> widthNormalized{};

  AddCasterLayoutRequestVideoLayer() {}

  explicit AddCasterLayoutRequestVideoLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fillMode) {
      res["FillMode"] = boost::any(*fillMode);
    }
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionNormalized) {
      res["PositionNormalized"] = boost::any(*positionNormalized);
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (widthNormalized) {
      res["WidthNormalized"] = boost::any(*widthNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FillMode") != m.end() && !m["FillMode"].empty()) {
      fillMode = make_shared<string>(boost::any_cast<string>(m["FillMode"]));
    }
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["PositionNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PositionNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      positionNormalized = make_shared<vector<double>>(toVec1);
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("WidthNormalized") != m.end() && !m["WidthNormalized"].empty()) {
      widthNormalized = make_shared<double>(boost::any_cast<double>(m["WidthNormalized"]));
    }
  }


  virtual ~AddCasterLayoutRequestVideoLayer() = default;
};
class AddCasterLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddCasterLayoutRequestAudioLayer>> audioLayer{};
  shared_ptr<vector<string>> blendList{};
  shared_ptr<string> casterId{};
  shared_ptr<vector<string>> mixList{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<AddCasterLayoutRequestVideoLayer>> videoLayer{};

  AddCasterLayoutRequest() {}

  explicit AddCasterLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayer) {
      vector<boost::any> temp1;
      for(auto item1:*audioLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioLayer"] = boost::any(temp1);
    }
    if (blendList) {
      res["BlendList"] = boost::any(*blendList);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (mixList) {
      res["MixList"] = boost::any(*mixList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (videoLayer) {
      vector<boost::any> temp1;
      for(auto item1:*videoLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayer") != m.end() && !m["AudioLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioLayer"].type()) {
        vector<AddCasterLayoutRequestAudioLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasterLayoutRequestAudioLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioLayer = make_shared<vector<AddCasterLayoutRequestAudioLayer>>(expect1);
      }
    }
    if (m.find("BlendList") != m.end() && !m["BlendList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BlendList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BlendList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      blendList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("MixList") != m.end() && !m["MixList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MixList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MixList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mixList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VideoLayer") != m.end() && !m["VideoLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoLayer"].type()) {
        vector<AddCasterLayoutRequestVideoLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasterLayoutRequestVideoLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoLayer = make_shared<vector<AddCasterLayoutRequestVideoLayer>>(expect1);
      }
    }
  }


  virtual ~AddCasterLayoutRequest() = default;
};
class AddCasterLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> layoutId{};
  shared_ptr<string> requestId{};

  AddCasterLayoutResponseBody() {}

  explicit AddCasterLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterLayoutResponseBody() = default;
};
class AddCasterLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterLayoutResponseBody> body{};

  AddCasterLayoutResponse() {}

  explicit AddCasterLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterLayoutResponse() = default;
};
class AddCasterProgramRequestEpisode : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeName{};
  shared_ptr<string> episodeType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> switchType{};

  AddCasterProgramRequestEpisode() {}

  explicit AddCasterProgramRequestEpisode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeName) {
      res["EpisodeName"] = boost::any(*episodeName);
    }
    if (episodeType) {
      res["EpisodeType"] = boost::any(*episodeType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (switchType) {
      res["SwitchType"] = boost::any(*switchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeName") != m.end() && !m["EpisodeName"].empty()) {
      episodeName = make_shared<string>(boost::any_cast<string>(m["EpisodeName"]));
    }
    if (m.find("EpisodeType") != m.end() && !m["EpisodeType"].empty()) {
      episodeType = make_shared<string>(boost::any_cast<string>(m["EpisodeType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SwitchType") != m.end() && !m["SwitchType"].empty()) {
      switchType = make_shared<string>(boost::any_cast<string>(m["SwitchType"]));
    }
  }


  virtual ~AddCasterProgramRequestEpisode() = default;
};
class AddCasterProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<AddCasterProgramRequestEpisode>> episode{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  AddCasterProgramRequest() {}

  explicit AddCasterProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episode) {
      vector<boost::any> temp1;
      for(auto item1:*episode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Episode"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("Episode") != m.end() && !m["Episode"].empty()) {
      if (typeid(vector<boost::any>) == m["Episode"].type()) {
        vector<AddCasterProgramRequestEpisode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Episode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasterProgramRequestEpisode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        episode = make_shared<vector<AddCasterProgramRequestEpisode>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddCasterProgramRequest() = default;
};
class AddCasterProgramResponseBodyEpisodeIdsEpisodeId : public Darabonba::Model {
public:
  shared_ptr<string> episodeId{};

  AddCasterProgramResponseBodyEpisodeIdsEpisodeId() {}

  explicit AddCasterProgramResponseBodyEpisodeIdsEpisodeId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
  }


  virtual ~AddCasterProgramResponseBodyEpisodeIdsEpisodeId() = default;
};
class AddCasterProgramResponseBodyEpisodeIds : public Darabonba::Model {
public:
  shared_ptr<vector<AddCasterProgramResponseBodyEpisodeIdsEpisodeId>> episodeId{};

  AddCasterProgramResponseBodyEpisodeIds() {}

  explicit AddCasterProgramResponseBodyEpisodeIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (episodeId) {
      vector<boost::any> temp1;
      for(auto item1:*episodeId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EpisodeId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      if (typeid(vector<boost::any>) == m["EpisodeId"].type()) {
        vector<AddCasterProgramResponseBodyEpisodeIdsEpisodeId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EpisodeId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasterProgramResponseBodyEpisodeIdsEpisodeId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        episodeId = make_shared<vector<AddCasterProgramResponseBodyEpisodeIdsEpisodeId>>(expect1);
      }
    }
  }


  virtual ~AddCasterProgramResponseBodyEpisodeIds() = default;
};
class AddCasterProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddCasterProgramResponseBodyEpisodeIds> episodeIds{};
  shared_ptr<string> requestId{};

  AddCasterProgramResponseBody() {}

  explicit AddCasterProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (episodeIds) {
      res["EpisodeIds"] = episodeIds ? boost::any(episodeIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EpisodeIds") != m.end() && !m["EpisodeIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["EpisodeIds"].type()) {
        AddCasterProgramResponseBodyEpisodeIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EpisodeIds"]));
        episodeIds = make_shared<AddCasterProgramResponseBodyEpisodeIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasterProgramResponseBody() = default;
};
class AddCasterProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterProgramResponseBody> body{};

  AddCasterProgramResponse() {}

  explicit AddCasterProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterProgramResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterProgramResponse() = default;
};
class AddCasterVideoResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginOffset{};
  shared_ptr<string> casterId{};
  shared_ptr<long> endOffset{};
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> liveStreamUrl{};
  shared_ptr<string> locationId{};
  shared_ptr<string> materialId{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> ptsCallbackInterval{};
  shared_ptr<string> regionId{};
  shared_ptr<long> repeatNum{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> vodUrl{};

  AddCasterVideoResourceRequest() {}

  explicit AddCasterVideoResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginOffset) {
      res["BeginOffset"] = boost::any(*beginOffset);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (endOffset) {
      res["EndOffset"] = boost::any(*endOffset);
    }
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (liveStreamUrl) {
      res["LiveStreamUrl"] = boost::any(*liveStreamUrl);
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ptsCallbackInterval) {
      res["PtsCallbackInterval"] = boost::any(*ptsCallbackInterval);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeatNum) {
      res["RepeatNum"] = boost::any(*repeatNum);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (vodUrl) {
      res["VodUrl"] = boost::any(*vodUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginOffset") != m.end() && !m["BeginOffset"].empty()) {
      beginOffset = make_shared<long>(boost::any_cast<long>(m["BeginOffset"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EndOffset") != m.end() && !m["EndOffset"].empty()) {
      endOffset = make_shared<long>(boost::any_cast<long>(m["EndOffset"]));
    }
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("LiveStreamUrl") != m.end() && !m["LiveStreamUrl"].empty()) {
      liveStreamUrl = make_shared<string>(boost::any_cast<string>(m["LiveStreamUrl"]));
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PtsCallbackInterval") != m.end() && !m["PtsCallbackInterval"].empty()) {
      ptsCallbackInterval = make_shared<long>(boost::any_cast<long>(m["PtsCallbackInterval"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepeatNum") != m.end() && !m["RepeatNum"].empty()) {
      repeatNum = make_shared<long>(boost::any_cast<long>(m["RepeatNum"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("VodUrl") != m.end() && !m["VodUrl"].empty()) {
      vodUrl = make_shared<string>(boost::any_cast<string>(m["VodUrl"]));
    }
  }


  virtual ~AddCasterVideoResourceRequest() = default;
};
class AddCasterVideoResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceId{};

  AddCasterVideoResourceResponseBody() {}

  explicit AddCasterVideoResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~AddCasterVideoResourceResponseBody() = default;
};
class AddCasterVideoResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasterVideoResourceResponseBody> body{};

  AddCasterVideoResourceResponse() {}

  explicit AddCasterVideoResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasterVideoResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasterVideoResourceResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasterVideoResourceResponse() = default;
};
class AddCustomLiveStreamTranscodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<long> audioBitrate{};
  shared_ptr<long> audioChannelNum{};
  shared_ptr<string> audioCodec{};
  shared_ptr<string> audioProfile{};
  shared_ptr<long> audioRate{};
  shared_ptr<string> bitrateWithSource{};
  shared_ptr<string> domain{};
  shared_ptr<string> encryptParameters{};
  shared_ptr<string> extWithSource{};
  shared_ptr<long> FPS{};
  shared_ptr<string> fpsWithSource{};
  shared_ptr<string> gop{};
  shared_ptr<long> height{};
  shared_ptr<string> kmsKeyExpireInterval{};
  shared_ptr<string> kmsKeyID{};
  shared_ptr<string> kmsUID{};
  shared_ptr<string> lazy{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> profile{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resWithSource{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<long> width{};

  AddCustomLiveStreamTranscodeRequest() {}

  explicit AddCustomLiveStreamTranscodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannelNum) {
      res["AudioChannelNum"] = boost::any(*audioChannelNum);
    }
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioProfile) {
      res["AudioProfile"] = boost::any(*audioProfile);
    }
    if (audioRate) {
      res["AudioRate"] = boost::any(*audioRate);
    }
    if (bitrateWithSource) {
      res["BitrateWithSource"] = boost::any(*bitrateWithSource);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (encryptParameters) {
      res["EncryptParameters"] = boost::any(*encryptParameters);
    }
    if (extWithSource) {
      res["ExtWithSource"] = boost::any(*extWithSource);
    }
    if (FPS) {
      res["FPS"] = boost::any(*FPS);
    }
    if (fpsWithSource) {
      res["FpsWithSource"] = boost::any(*fpsWithSource);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (kmsKeyExpireInterval) {
      res["KmsKeyExpireInterval"] = boost::any(*kmsKeyExpireInterval);
    }
    if (kmsKeyID) {
      res["KmsKeyID"] = boost::any(*kmsKeyID);
    }
    if (kmsUID) {
      res["KmsUID"] = boost::any(*kmsUID);
    }
    if (lazy) {
      res["Lazy"] = boost::any(*lazy);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resWithSource) {
      res["ResWithSource"] = boost::any(*resWithSource);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<long>(boost::any_cast<long>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannelNum") != m.end() && !m["AudioChannelNum"].empty()) {
      audioChannelNum = make_shared<long>(boost::any_cast<long>(m["AudioChannelNum"]));
    }
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioProfile") != m.end() && !m["AudioProfile"].empty()) {
      audioProfile = make_shared<string>(boost::any_cast<string>(m["AudioProfile"]));
    }
    if (m.find("AudioRate") != m.end() && !m["AudioRate"].empty()) {
      audioRate = make_shared<long>(boost::any_cast<long>(m["AudioRate"]));
    }
    if (m.find("BitrateWithSource") != m.end() && !m["BitrateWithSource"].empty()) {
      bitrateWithSource = make_shared<string>(boost::any_cast<string>(m["BitrateWithSource"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EncryptParameters") != m.end() && !m["EncryptParameters"].empty()) {
      encryptParameters = make_shared<string>(boost::any_cast<string>(m["EncryptParameters"]));
    }
    if (m.find("ExtWithSource") != m.end() && !m["ExtWithSource"].empty()) {
      extWithSource = make_shared<string>(boost::any_cast<string>(m["ExtWithSource"]));
    }
    if (m.find("FPS") != m.end() && !m["FPS"].empty()) {
      FPS = make_shared<long>(boost::any_cast<long>(m["FPS"]));
    }
    if (m.find("FpsWithSource") != m.end() && !m["FpsWithSource"].empty()) {
      fpsWithSource = make_shared<string>(boost::any_cast<string>(m["FpsWithSource"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("KmsKeyExpireInterval") != m.end() && !m["KmsKeyExpireInterval"].empty()) {
      kmsKeyExpireInterval = make_shared<string>(boost::any_cast<string>(m["KmsKeyExpireInterval"]));
    }
    if (m.find("KmsKeyID") != m.end() && !m["KmsKeyID"].empty()) {
      kmsKeyID = make_shared<string>(boost::any_cast<string>(m["KmsKeyID"]));
    }
    if (m.find("KmsUID") != m.end() && !m["KmsUID"].empty()) {
      kmsUID = make_shared<string>(boost::any_cast<string>(m["KmsUID"]));
    }
    if (m.find("Lazy") != m.end() && !m["Lazy"].empty()) {
      lazy = make_shared<string>(boost::any_cast<string>(m["Lazy"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<long>(boost::any_cast<long>(m["Profile"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResWithSource") != m.end() && !m["ResWithSource"].empty()) {
      resWithSource = make_shared<string>(boost::any_cast<string>(m["ResWithSource"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~AddCustomLiveStreamTranscodeRequest() = default;
};
class AddCustomLiveStreamTranscodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddCustomLiveStreamTranscodeResponseBody() {}

  explicit AddCustomLiveStreamTranscodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCustomLiveStreamTranscodeResponseBody() = default;
};
class AddCustomLiveStreamTranscodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCustomLiveStreamTranscodeResponseBody> body{};

  AddCustomLiveStreamTranscodeResponse() {}

  explicit AddCustomLiveStreamTranscodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCustomLiveStreamTranscodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCustomLiveStreamTranscodeResponseBody>(model1);
      }
    }
  }


  virtual ~AddCustomLiveStreamTranscodeResponse() = default;
};
class AddLiveAIProduceRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<bool> isLazy{};
  shared_ptr<string> liveTemplate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> studioName{};
  shared_ptr<string> subtitleName{};
  shared_ptr<string> suffix{};

  AddLiveAIProduceRulesRequest() {}

  explicit AddLiveAIProduceRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (isLazy) {
      res["IsLazy"] = boost::any(*isLazy);
    }
    if (liveTemplate) {
      res["LiveTemplate"] = boost::any(*liveTemplate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (studioName) {
      res["StudioName"] = boost::any(*studioName);
    }
    if (subtitleName) {
      res["SubtitleName"] = boost::any(*subtitleName);
    }
    if (suffix) {
      res["Suffix"] = boost::any(*suffix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("IsLazy") != m.end() && !m["IsLazy"].empty()) {
      isLazy = make_shared<bool>(boost::any_cast<bool>(m["IsLazy"]));
    }
    if (m.find("LiveTemplate") != m.end() && !m["LiveTemplate"].empty()) {
      liveTemplate = make_shared<string>(boost::any_cast<string>(m["LiveTemplate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StudioName") != m.end() && !m["StudioName"].empty()) {
      studioName = make_shared<string>(boost::any_cast<string>(m["StudioName"]));
    }
    if (m.find("SubtitleName") != m.end() && !m["SubtitleName"].empty()) {
      subtitleName = make_shared<string>(boost::any_cast<string>(m["SubtitleName"]));
    }
    if (m.find("Suffix") != m.end() && !m["Suffix"].empty()) {
      suffix = make_shared<string>(boost::any_cast<string>(m["Suffix"]));
    }
  }


  virtual ~AddLiveAIProduceRulesRequest() = default;
};
class AddLiveAIProduceRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> rulesId{};

  AddLiveAIProduceRulesResponseBody() {}

  explicit AddLiveAIProduceRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rulesId) {
      res["RulesId"] = boost::any(*rulesId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RulesId") != m.end() && !m["RulesId"].empty()) {
      rulesId = make_shared<string>(boost::any_cast<string>(m["RulesId"]));
    }
  }


  virtual ~AddLiveAIProduceRulesResponseBody() = default;
};
class AddLiveAIProduceRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveAIProduceRulesResponseBody> body{};

  AddLiveAIProduceRulesResponse() {}

  explicit AddLiveAIProduceRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveAIProduceRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveAIProduceRulesResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveAIProduceRulesResponse() = default;
};
class AddLiveAISubtitleRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<double> bgWidthNormalized{};
  shared_ptr<double> borderWidthNormalized{};
  shared_ptr<string> copyFrom{};
  shared_ptr<string> description{};
  shared_ptr<string> dstLanguage{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<double> fontSizeNormalized{};
  shared_ptr<string> height{};
  shared_ptr<long> maxLines{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<double>> positionNormalized{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> showSourceLan{};
  shared_ptr<string> srcLanguage{};
  shared_ptr<string> subtitleName{};
  shared_ptr<string> width{};
  shared_ptr<long> wordPerLine{};

  AddLiveAISubtitleRequest() {}

  explicit AddLiveAISubtitleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (bgWidthNormalized) {
      res["BgWidthNormalized"] = boost::any(*bgWidthNormalized);
    }
    if (borderWidthNormalized) {
      res["BorderWidthNormalized"] = boost::any(*borderWidthNormalized);
    }
    if (copyFrom) {
      res["CopyFrom"] = boost::any(*copyFrom);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dstLanguage) {
      res["DstLanguage"] = boost::any(*dstLanguage);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSizeNormalized) {
      res["FontSizeNormalized"] = boost::any(*fontSizeNormalized);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxLines) {
      res["MaxLines"] = boost::any(*maxLines);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (positionNormalized) {
      res["PositionNormalized"] = boost::any(*positionNormalized);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showSourceLan) {
      res["ShowSourceLan"] = boost::any(*showSourceLan);
    }
    if (srcLanguage) {
      res["SrcLanguage"] = boost::any(*srcLanguage);
    }
    if (subtitleName) {
      res["SubtitleName"] = boost::any(*subtitleName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (wordPerLine) {
      res["WordPerLine"] = boost::any(*wordPerLine);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("BgWidthNormalized") != m.end() && !m["BgWidthNormalized"].empty()) {
      bgWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BgWidthNormalized"]));
    }
    if (m.find("BorderWidthNormalized") != m.end() && !m["BorderWidthNormalized"].empty()) {
      borderWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BorderWidthNormalized"]));
    }
    if (m.find("CopyFrom") != m.end() && !m["CopyFrom"].empty()) {
      copyFrom = make_shared<string>(boost::any_cast<string>(m["CopyFrom"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DstLanguage") != m.end() && !m["DstLanguage"].empty()) {
      dstLanguage = make_shared<string>(boost::any_cast<string>(m["DstLanguage"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSizeNormalized") != m.end() && !m["FontSizeNormalized"].empty()) {
      fontSizeNormalized = make_shared<double>(boost::any_cast<double>(m["FontSizeNormalized"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxLines") != m.end() && !m["MaxLines"].empty()) {
      maxLines = make_shared<long>(boost::any_cast<long>(m["MaxLines"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["PositionNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PositionNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      positionNormalized = make_shared<vector<double>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowSourceLan") != m.end() && !m["ShowSourceLan"].empty()) {
      showSourceLan = make_shared<bool>(boost::any_cast<bool>(m["ShowSourceLan"]));
    }
    if (m.find("SrcLanguage") != m.end() && !m["SrcLanguage"].empty()) {
      srcLanguage = make_shared<string>(boost::any_cast<string>(m["SrcLanguage"]));
    }
    if (m.find("SubtitleName") != m.end() && !m["SubtitleName"].empty()) {
      subtitleName = make_shared<string>(boost::any_cast<string>(m["SubtitleName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("WordPerLine") != m.end() && !m["WordPerLine"].empty()) {
      wordPerLine = make_shared<long>(boost::any_cast<long>(m["WordPerLine"]));
    }
  }


  virtual ~AddLiveAISubtitleRequest() = default;
};
class AddLiveAISubtitleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<double> bgWidthNormalized{};
  shared_ptr<double> borderWidthNormalized{};
  shared_ptr<string> copyFrom{};
  shared_ptr<string> description{};
  shared_ptr<string> dstLanguage{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<double> fontSizeNormalized{};
  shared_ptr<string> height{};
  shared_ptr<long> maxLines{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> positionNormalizedShrink{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> showSourceLan{};
  shared_ptr<string> srcLanguage{};
  shared_ptr<string> subtitleName{};
  shared_ptr<string> width{};
  shared_ptr<long> wordPerLine{};

  AddLiveAISubtitleShrinkRequest() {}

  explicit AddLiveAISubtitleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (bgWidthNormalized) {
      res["BgWidthNormalized"] = boost::any(*bgWidthNormalized);
    }
    if (borderWidthNormalized) {
      res["BorderWidthNormalized"] = boost::any(*borderWidthNormalized);
    }
    if (copyFrom) {
      res["CopyFrom"] = boost::any(*copyFrom);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dstLanguage) {
      res["DstLanguage"] = boost::any(*dstLanguage);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSizeNormalized) {
      res["FontSizeNormalized"] = boost::any(*fontSizeNormalized);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxLines) {
      res["MaxLines"] = boost::any(*maxLines);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (positionNormalizedShrink) {
      res["PositionNormalized"] = boost::any(*positionNormalizedShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showSourceLan) {
      res["ShowSourceLan"] = boost::any(*showSourceLan);
    }
    if (srcLanguage) {
      res["SrcLanguage"] = boost::any(*srcLanguage);
    }
    if (subtitleName) {
      res["SubtitleName"] = boost::any(*subtitleName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (wordPerLine) {
      res["WordPerLine"] = boost::any(*wordPerLine);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("BgWidthNormalized") != m.end() && !m["BgWidthNormalized"].empty()) {
      bgWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BgWidthNormalized"]));
    }
    if (m.find("BorderWidthNormalized") != m.end() && !m["BorderWidthNormalized"].empty()) {
      borderWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BorderWidthNormalized"]));
    }
    if (m.find("CopyFrom") != m.end() && !m["CopyFrom"].empty()) {
      copyFrom = make_shared<string>(boost::any_cast<string>(m["CopyFrom"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DstLanguage") != m.end() && !m["DstLanguage"].empty()) {
      dstLanguage = make_shared<string>(boost::any_cast<string>(m["DstLanguage"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSizeNormalized") != m.end() && !m["FontSizeNormalized"].empty()) {
      fontSizeNormalized = make_shared<double>(boost::any_cast<double>(m["FontSizeNormalized"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxLines") != m.end() && !m["MaxLines"].empty()) {
      maxLines = make_shared<long>(boost::any_cast<long>(m["MaxLines"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      positionNormalizedShrink = make_shared<string>(boost::any_cast<string>(m["PositionNormalized"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowSourceLan") != m.end() && !m["ShowSourceLan"].empty()) {
      showSourceLan = make_shared<bool>(boost::any_cast<bool>(m["ShowSourceLan"]));
    }
    if (m.find("SrcLanguage") != m.end() && !m["SrcLanguage"].empty()) {
      srcLanguage = make_shared<string>(boost::any_cast<string>(m["SrcLanguage"]));
    }
    if (m.find("SubtitleName") != m.end() && !m["SubtitleName"].empty()) {
      subtitleName = make_shared<string>(boost::any_cast<string>(m["SubtitleName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("WordPerLine") != m.end() && !m["WordPerLine"].empty()) {
      wordPerLine = make_shared<long>(boost::any_cast<long>(m["WordPerLine"]));
    }
  }


  virtual ~AddLiveAISubtitleShrinkRequest() = default;
};
class AddLiveAISubtitleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> subtitleId{};

  AddLiveAISubtitleResponseBody() {}

  explicit AddLiveAISubtitleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subtitleId) {
      res["SubtitleId"] = boost::any(*subtitleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubtitleId") != m.end() && !m["SubtitleId"].empty()) {
      subtitleId = make_shared<string>(boost::any_cast<string>(m["SubtitleId"]));
    }
  }


  virtual ~AddLiveAISubtitleResponseBody() = default;
};
class AddLiveAISubtitleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveAISubtitleResponseBody> body{};

  AddLiveAISubtitleResponse() {}

  explicit AddLiveAISubtitleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveAISubtitleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveAISubtitleResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveAISubtitleResponse() = default;
};
class AddLiveAppRecordConfigRequestRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  AddLiveAppRecordConfigRequestRecordFormat() {}

  explicit AddLiveAppRecordConfigRequestRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~AddLiveAppRecordConfigRequestRecordFormat() = default;
};
class AddLiveAppRecordConfigRequestTranscodeRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  AddLiveAppRecordConfigRequestTranscodeRecordFormat() {}

  explicit AddLiveAppRecordConfigRequestTranscodeRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~AddLiveAppRecordConfigRequestTranscodeRecordFormat() = default;
};
class AddLiveAppRecordConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> delayTime{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> onDemand{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<AddLiveAppRecordConfigRequestRecordFormat>> recordFormat{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<vector<AddLiveAppRecordConfigRequestTranscodeRecordFormat>> transcodeRecordFormat{};
  shared_ptr<vector<string>> transcodeTemplates{};

  AddLiveAppRecordConfigRequest() {}

  explicit AddLiveAppRecordConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (delayTime) {
      res["DelayTime"] = boost::any(*delayTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (onDemand) {
      res["OnDemand"] = boost::any(*onDemand);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transcodeRecordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeRecordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeRecordFormat"] = boost::any(temp1);
    }
    if (transcodeTemplates) {
      res["TranscodeTemplates"] = boost::any(*transcodeTemplates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DelayTime") != m.end() && !m["DelayTime"].empty()) {
      delayTime = make_shared<long>(boost::any_cast<long>(m["DelayTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OnDemand") != m.end() && !m["OnDemand"].empty()) {
      onDemand = make_shared<long>(boost::any_cast<long>(m["OnDemand"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<AddLiveAppRecordConfigRequestRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddLiveAppRecordConfigRequestRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<AddLiveAppRecordConfigRequestRecordFormat>>(expect1);
      }
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TranscodeRecordFormat") != m.end() && !m["TranscodeRecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeRecordFormat"].type()) {
        vector<AddLiveAppRecordConfigRequestTranscodeRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeRecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddLiveAppRecordConfigRequestTranscodeRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeRecordFormat = make_shared<vector<AddLiveAppRecordConfigRequestTranscodeRecordFormat>>(expect1);
      }
    }
    if (m.find("TranscodeTemplates") != m.end() && !m["TranscodeTemplates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TranscodeTemplates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TranscodeTemplates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      transcodeTemplates = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddLiveAppRecordConfigRequest() = default;
};
class AddLiveAppRecordConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveAppRecordConfigResponseBody() {}

  explicit AddLiveAppRecordConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveAppRecordConfigResponseBody() = default;
};
class AddLiveAppRecordConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveAppRecordConfigResponseBody> body{};

  AddLiveAppRecordConfigResponse() {}

  explicit AddLiveAppRecordConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveAppRecordConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveAppRecordConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveAppRecordConfigResponse() = default;
};
class AddLiveAppSnapshotConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> callback{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> overwriteOssObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sequenceOssObject{};
  shared_ptr<long> timeInterval{};

  AddLiveAppSnapshotConfigRequest() {}

  explicit AddLiveAppSnapshotConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (overwriteOssObject) {
      res["OverwriteOssObject"] = boost::any(*overwriteOssObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sequenceOssObject) {
      res["SequenceOssObject"] = boost::any(*sequenceOssObject);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OverwriteOssObject") != m.end() && !m["OverwriteOssObject"].empty()) {
      overwriteOssObject = make_shared<string>(boost::any_cast<string>(m["OverwriteOssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SequenceOssObject") != m.end() && !m["SequenceOssObject"].empty()) {
      sequenceOssObject = make_shared<string>(boost::any_cast<string>(m["SequenceOssObject"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~AddLiveAppSnapshotConfigRequest() = default;
};
class AddLiveAppSnapshotConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveAppSnapshotConfigResponseBody() {}

  explicit AddLiveAppSnapshotConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveAppSnapshotConfigResponseBody() = default;
};
class AddLiveAppSnapshotConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveAppSnapshotConfigResponseBody> body{};

  AddLiveAppSnapshotConfigResponse() {}

  explicit AddLiveAppSnapshotConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveAppSnapshotConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveAppSnapshotConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveAppSnapshotConfigResponse() = default;
};
class AddLiveAudioAuditConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> bizType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  AddLiveAudioAuditConfigRequest() {}

  explicit AddLiveAudioAuditConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~AddLiveAudioAuditConfigRequest() = default;
};
class AddLiveAudioAuditConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveAudioAuditConfigResponseBody() {}

  explicit AddLiveAudioAuditConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveAudioAuditConfigResponseBody() = default;
};
class AddLiveAudioAuditConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveAudioAuditConfigResponseBody> body{};

  AddLiveAudioAuditConfigResponse() {}

  explicit AddLiveAudioAuditConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveAudioAuditConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveAudioAuditConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveAudioAuditConfigResponse() = default;
};
class AddLiveAudioAuditNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> callback{};
  shared_ptr<string> callbackTemplate{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  AddLiveAudioAuditNotifyConfigRequest() {}

  explicit AddLiveAudioAuditNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (callbackTemplate) {
      res["CallbackTemplate"] = boost::any(*callbackTemplate);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CallbackTemplate") != m.end() && !m["CallbackTemplate"].empty()) {
      callbackTemplate = make_shared<string>(boost::any_cast<string>(m["CallbackTemplate"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddLiveAudioAuditNotifyConfigRequest() = default;
};
class AddLiveAudioAuditNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveAudioAuditNotifyConfigResponseBody() {}

  explicit AddLiveAudioAuditNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveAudioAuditNotifyConfigResponseBody() = default;
};
class AddLiveAudioAuditNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveAudioAuditNotifyConfigResponseBody> body{};

  AddLiveAudioAuditNotifyConfigResponse() {}

  explicit AddLiveAudioAuditNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveAudioAuditNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveAudioAuditNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveAudioAuditNotifyConfigResponse() = default;
};
class AddLiveCenterTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dstUrl{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> transferArgs{};

  AddLiveCenterTransferRequest() {}

  explicit AddLiveCenterTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dstUrl) {
      res["DstUrl"] = boost::any(*dstUrl);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transferArgs) {
      res["TransferArgs"] = boost::any(*transferArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DstUrl") != m.end() && !m["DstUrl"].empty()) {
      dstUrl = make_shared<string>(boost::any_cast<string>(m["DstUrl"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TransferArgs") != m.end() && !m["TransferArgs"].empty()) {
      transferArgs = make_shared<string>(boost::any_cast<string>(m["TransferArgs"]));
    }
  }


  virtual ~AddLiveCenterTransferRequest() = default;
};
class AddLiveCenterTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveCenterTransferResponseBody() {}

  explicit AddLiveCenterTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveCenterTransferResponseBody() = default;
};
class AddLiveCenterTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveCenterTransferResponseBody> body{};

  AddLiveCenterTransferResponse() {}

  explicit AddLiveCenterTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveCenterTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveCenterTransferResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveCenterTransferResponse() = default;
};
class AddLiveDetectNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  AddLiveDetectNotifyConfigRequest() {}

  explicit AddLiveDetectNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddLiveDetectNotifyConfigRequest() = default;
};
class AddLiveDetectNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveDetectNotifyConfigResponseBody() {}

  explicit AddLiveDetectNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveDetectNotifyConfigResponseBody() = default;
};
class AddLiveDetectNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveDetectNotifyConfigResponseBody> body{};

  AddLiveDetectNotifyConfigResponse() {}

  explicit AddLiveDetectNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveDetectNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveDetectNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveDetectNotifyConfigResponse() = default;
};
class AddLiveDomainRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AddLiveDomainRequestTag() {}

  explicit AddLiveDomainRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddLiveDomainRequestTag() = default;
};
class AddLiveDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkUrl{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveDomainType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scope{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<AddLiveDomainRequestTag>> tag{};
  shared_ptr<string> topLevelDomain{};

  AddLiveDomainRequest() {}

  explicit AddLiveDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkUrl) {
      res["CheckUrl"] = boost::any(*checkUrl);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveDomainType) {
      res["LiveDomainType"] = boost::any(*liveDomainType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckUrl") != m.end() && !m["CheckUrl"].empty()) {
      checkUrl = make_shared<string>(boost::any_cast<string>(m["CheckUrl"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveDomainType") != m.end() && !m["LiveDomainType"].empty()) {
      liveDomainType = make_shared<string>(boost::any_cast<string>(m["LiveDomainType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AddLiveDomainRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddLiveDomainRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AddLiveDomainRequestTag>>(expect1);
      }
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~AddLiveDomainRequest() = default;
};
class AddLiveDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveDomainResponseBody() {}

  explicit AddLiveDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveDomainResponseBody() = default;
};
class AddLiveDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveDomainResponseBody> body{};

  AddLiveDomainResponse() {}

  explicit AddLiveDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveDomainResponse() = default;
};
class AddLiveDomainMappingRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> pullDomain{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> securityToken{};

  AddLiveDomainMappingRequest() {}

  explicit AddLiveDomainMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pullDomain) {
      res["PullDomain"] = boost::any(*pullDomain);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PullDomain") != m.end() && !m["PullDomain"].empty()) {
      pullDomain = make_shared<string>(boost::any_cast<string>(m["PullDomain"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddLiveDomainMappingRequest() = default;
};
class AddLiveDomainMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveDomainMappingResponseBody() {}

  explicit AddLiveDomainMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveDomainMappingResponseBody() = default;
};
class AddLiveDomainMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveDomainMappingResponseBody> body{};

  AddLiveDomainMappingResponse() {}

  explicit AddLiveDomainMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveDomainMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveDomainMappingResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveDomainMappingResponse() = default;
};
class AddLiveDomainPlayMappingRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> playDomain{};
  shared_ptr<string> pullDomain{};
  shared_ptr<string> regionId{};

  AddLiveDomainPlayMappingRequest() {}

  explicit AddLiveDomainPlayMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    if (pullDomain) {
      res["PullDomain"] = boost::any(*pullDomain);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
    if (m.find("PullDomain") != m.end() && !m["PullDomain"].empty()) {
      pullDomain = make_shared<string>(boost::any_cast<string>(m["PullDomain"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddLiveDomainPlayMappingRequest() = default;
};
class AddLiveDomainPlayMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveDomainPlayMappingResponseBody() {}

  explicit AddLiveDomainPlayMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveDomainPlayMappingResponseBody() = default;
};
class AddLiveDomainPlayMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveDomainPlayMappingResponseBody> body{};

  AddLiveDomainPlayMappingResponse() {}

  explicit AddLiveDomainPlayMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveDomainPlayMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveDomainPlayMappingResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveDomainPlayMappingResponse() = default;
};
class AddLiveMessageGroupBandRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<vector<string>> bannedUsers{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};

  AddLiveMessageGroupBandRequest() {}

  explicit AddLiveMessageGroupBandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (bannedUsers) {
      res["BannedUsers"] = boost::any(*bannedUsers);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BannedUsers") != m.end() && !m["BannedUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BannedUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BannedUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bannedUsers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~AddLiveMessageGroupBandRequest() = default;
};
class AddLiveMessageGroupBandShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> bannedUsersShrink{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};

  AddLiveMessageGroupBandShrinkRequest() {}

  explicit AddLiveMessageGroupBandShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (bannedUsersShrink) {
      res["BannedUsers"] = boost::any(*bannedUsersShrink);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BannedUsers") != m.end() && !m["BannedUsers"].empty()) {
      bannedUsersShrink = make_shared<string>(boost::any_cast<string>(m["BannedUsers"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~AddLiveMessageGroupBandShrinkRequest() = default;
};
class AddLiveMessageGroupBandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveMessageGroupBandResponseBody() {}

  explicit AddLiveMessageGroupBandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveMessageGroupBandResponseBody() = default;
};
class AddLiveMessageGroupBandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveMessageGroupBandResponseBody> body{};

  AddLiveMessageGroupBandResponse() {}

  explicit AddLiveMessageGroupBandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveMessageGroupBandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveMessageGroupBandResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveMessageGroupBandResponse() = default;
};
class AddLivePackageConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<bool> ignoreTranscode{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> partDuration{};
  shared_ptr<string> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<long> segmentDuration{};
  shared_ptr<long> segmentNum{};
  shared_ptr<string> streamName{};

  AddLivePackageConfigRequest() {}

  explicit AddLivePackageConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ignoreTranscode) {
      res["IgnoreTranscode"] = boost::any(*ignoreTranscode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (partDuration) {
      res["PartDuration"] = boost::any(*partDuration);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    if (segmentNum) {
      res["SegmentNum"] = boost::any(*segmentNum);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IgnoreTranscode") != m.end() && !m["IgnoreTranscode"].empty()) {
      ignoreTranscode = make_shared<bool>(boost::any_cast<bool>(m["IgnoreTranscode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PartDuration") != m.end() && !m["PartDuration"].empty()) {
      partDuration = make_shared<long>(boost::any_cast<long>(m["PartDuration"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
    if (m.find("SegmentNum") != m.end() && !m["SegmentNum"].empty()) {
      segmentNum = make_shared<long>(boost::any_cast<long>(m["SegmentNum"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~AddLivePackageConfigRequest() = default;
};
class AddLivePackageConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLivePackageConfigResponseBody() {}

  explicit AddLivePackageConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLivePackageConfigResponseBody() = default;
};
class AddLivePackageConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLivePackageConfigResponseBody> body{};

  AddLivePackageConfigResponse() {}

  explicit AddLivePackageConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLivePackageConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLivePackageConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLivePackageConfigResponse() = default;
};
class AddLivePullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  AddLivePullStreamInfoConfigRequest() {}

  explicit AddLivePullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~AddLivePullStreamInfoConfigRequest() = default;
};
class AddLivePullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLivePullStreamInfoConfigResponseBody() {}

  explicit AddLivePullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLivePullStreamInfoConfigResponseBody() = default;
};
class AddLivePullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLivePullStreamInfoConfigResponseBody> body{};

  AddLivePullStreamInfoConfigResponse() {}

  explicit AddLivePullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLivePullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLivePullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLivePullStreamInfoConfigResponse() = default;
};
class AddLiveRecordNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<bool> needStatusNotify{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> onDemandUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  AddLiveRecordNotifyConfigRequest() {}

  explicit AddLiveRecordNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (needStatusNotify) {
      res["NeedStatusNotify"] = boost::any(*needStatusNotify);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (onDemandUrl) {
      res["OnDemandUrl"] = boost::any(*onDemandUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NeedStatusNotify") != m.end() && !m["NeedStatusNotify"].empty()) {
      needStatusNotify = make_shared<bool>(boost::any_cast<bool>(m["NeedStatusNotify"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OnDemandUrl") != m.end() && !m["OnDemandUrl"].empty()) {
      onDemandUrl = make_shared<string>(boost::any_cast<string>(m["OnDemandUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddLiveRecordNotifyConfigRequest() = default;
};
class AddLiveRecordNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveRecordNotifyConfigResponseBody() {}

  explicit AddLiveRecordNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveRecordNotifyConfigResponseBody() = default;
};
class AddLiveRecordNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveRecordNotifyConfigResponseBody> body{};

  AddLiveRecordNotifyConfigResponse() {}

  explicit AddLiveRecordNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveRecordNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveRecordNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveRecordNotifyConfigResponse() = default;
};
class AddLiveRecordVodConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> autoCompose{};
  shared_ptr<string> composeVodTranscodeGroupId{};
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> domainName{};
  shared_ptr<long> onDemand{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> streamName{};
  shared_ptr<string> vodTranscodeGroupId{};

  AddLiveRecordVodConfigRequest() {}

  explicit AddLiveRecordVodConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (autoCompose) {
      res["AutoCompose"] = boost::any(*autoCompose);
    }
    if (composeVodTranscodeGroupId) {
      res["ComposeVodTranscodeGroupId"] = boost::any(*composeVodTranscodeGroupId);
    }
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (onDemand) {
      res["OnDemand"] = boost::any(*onDemand);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (vodTranscodeGroupId) {
      res["VodTranscodeGroupId"] = boost::any(*vodTranscodeGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AutoCompose") != m.end() && !m["AutoCompose"].empty()) {
      autoCompose = make_shared<string>(boost::any_cast<string>(m["AutoCompose"]));
    }
    if (m.find("ComposeVodTranscodeGroupId") != m.end() && !m["ComposeVodTranscodeGroupId"].empty()) {
      composeVodTranscodeGroupId = make_shared<string>(boost::any_cast<string>(m["ComposeVodTranscodeGroupId"]));
    }
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OnDemand") != m.end() && !m["OnDemand"].empty()) {
      onDemand = make_shared<long>(boost::any_cast<long>(m["OnDemand"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("VodTranscodeGroupId") != m.end() && !m["VodTranscodeGroupId"].empty()) {
      vodTranscodeGroupId = make_shared<string>(boost::any_cast<string>(m["VodTranscodeGroupId"]));
    }
  }


  virtual ~AddLiveRecordVodConfigRequest() = default;
};
class AddLiveRecordVodConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveRecordVodConfigResponseBody() {}

  explicit AddLiveRecordVodConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveRecordVodConfigResponseBody() = default;
};
class AddLiveRecordVodConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveRecordVodConfigResponseBody> body{};

  AddLiveRecordVodConfigResponse() {}

  explicit AddLiveRecordVodConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveRecordVodConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveRecordVodConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveRecordVodConfigResponse() = default;
};
class AddLiveSnapshotDetectPornConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> interval{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> scene{};
  shared_ptr<string> securityToken{};

  AddLiveSnapshotDetectPornConfigRequest() {}

  explicit AddLiveSnapshotDetectPornConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Scene"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Scene"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scene = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddLiveSnapshotDetectPornConfigRequest() = default;
};
class AddLiveSnapshotDetectPornConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveSnapshotDetectPornConfigResponseBody() {}

  explicit AddLiveSnapshotDetectPornConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveSnapshotDetectPornConfigResponseBody() = default;
};
class AddLiveSnapshotDetectPornConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveSnapshotDetectPornConfigResponseBody> body{};

  AddLiveSnapshotDetectPornConfigResponse() {}

  explicit AddLiveSnapshotDetectPornConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveSnapshotDetectPornConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveSnapshotDetectPornConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveSnapshotDetectPornConfigResponse() = default;
};
class AddLiveSnapshotNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyAuthKey{};
  shared_ptr<string> notifyReqAuth{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  AddLiveSnapshotNotifyConfigRequest() {}

  explicit AddLiveSnapshotNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyAuthKey) {
      res["NotifyAuthKey"] = boost::any(*notifyAuthKey);
    }
    if (notifyReqAuth) {
      res["NotifyReqAuth"] = boost::any(*notifyReqAuth);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyAuthKey") != m.end() && !m["NotifyAuthKey"].empty()) {
      notifyAuthKey = make_shared<string>(boost::any_cast<string>(m["NotifyAuthKey"]));
    }
    if (m.find("NotifyReqAuth") != m.end() && !m["NotifyReqAuth"].empty()) {
      notifyReqAuth = make_shared<string>(boost::any_cast<string>(m["NotifyReqAuth"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddLiveSnapshotNotifyConfigRequest() = default;
};
class AddLiveSnapshotNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveSnapshotNotifyConfigResponseBody() {}

  explicit AddLiveSnapshotNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveSnapshotNotifyConfigResponseBody() = default;
};
class AddLiveSnapshotNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveSnapshotNotifyConfigResponseBody> body{};

  AddLiveSnapshotNotifyConfigResponse() {}

  explicit AddLiveSnapshotNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveSnapshotNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveSnapshotNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveSnapshotNotifyConfigResponse() = default;
};
class AddLiveStreamMergeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> inAppName1{};
  shared_ptr<string> inAppName2{};
  shared_ptr<string> inStreamName1{};
  shared_ptr<string> inStreamName2{};
  shared_ptr<string> liveMerger{};
  shared_ptr<string> mergeParameters{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  AddLiveStreamMergeRequest() {}

  explicit AddLiveStreamMergeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (inAppName1) {
      res["InAppName1"] = boost::any(*inAppName1);
    }
    if (inAppName2) {
      res["InAppName2"] = boost::any(*inAppName2);
    }
    if (inStreamName1) {
      res["InStreamName1"] = boost::any(*inStreamName1);
    }
    if (inStreamName2) {
      res["InStreamName2"] = boost::any(*inStreamName2);
    }
    if (liveMerger) {
      res["LiveMerger"] = boost::any(*liveMerger);
    }
    if (mergeParameters) {
      res["MergeParameters"] = boost::any(*mergeParameters);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InAppName1") != m.end() && !m["InAppName1"].empty()) {
      inAppName1 = make_shared<string>(boost::any_cast<string>(m["InAppName1"]));
    }
    if (m.find("InAppName2") != m.end() && !m["InAppName2"].empty()) {
      inAppName2 = make_shared<string>(boost::any_cast<string>(m["InAppName2"]));
    }
    if (m.find("InStreamName1") != m.end() && !m["InStreamName1"].empty()) {
      inStreamName1 = make_shared<string>(boost::any_cast<string>(m["InStreamName1"]));
    }
    if (m.find("InStreamName2") != m.end() && !m["InStreamName2"].empty()) {
      inStreamName2 = make_shared<string>(boost::any_cast<string>(m["InStreamName2"]));
    }
    if (m.find("LiveMerger") != m.end() && !m["LiveMerger"].empty()) {
      liveMerger = make_shared<string>(boost::any_cast<string>(m["LiveMerger"]));
    }
    if (m.find("MergeParameters") != m.end() && !m["MergeParameters"].empty()) {
      mergeParameters = make_shared<string>(boost::any_cast<string>(m["MergeParameters"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~AddLiveStreamMergeRequest() = default;
};
class AddLiveStreamMergeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddLiveStreamMergeResponseBody() {}

  explicit AddLiveStreamMergeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveStreamMergeResponseBody() = default;
};
class AddLiveStreamMergeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveStreamMergeResponseBody> body{};

  AddLiveStreamMergeResponse() {}

  explicit AddLiveStreamMergeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveStreamMergeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveStreamMergeResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveStreamMergeResponse() = default;
};
class AddLiveStreamTranscodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<string> encryptParameters{};
  shared_ptr<string> lazy{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> template_{};

  AddLiveStreamTranscodeRequest() {}

  explicit AddLiveStreamTranscodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (encryptParameters) {
      res["EncryptParameters"] = boost::any(*encryptParameters);
    }
    if (lazy) {
      res["Lazy"] = boost::any(*lazy);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EncryptParameters") != m.end() && !m["EncryptParameters"].empty()) {
      encryptParameters = make_shared<string>(boost::any_cast<string>(m["EncryptParameters"]));
    }
    if (m.find("Lazy") != m.end() && !m["Lazy"].empty()) {
      lazy = make_shared<string>(boost::any_cast<string>(m["Lazy"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~AddLiveStreamTranscodeRequest() = default;
};
class AddLiveStreamTranscodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddLiveStreamTranscodeResponseBody() {}

  explicit AddLiveStreamTranscodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddLiveStreamTranscodeResponseBody() = default;
};
class AddLiveStreamTranscodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveStreamTranscodeResponseBody> body{};

  AddLiveStreamTranscodeResponse() {}

  explicit AddLiveStreamTranscodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveStreamTranscodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveStreamTranscodeResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveStreamTranscodeResponse() = default;
};
class AddLiveStreamWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<long> height{};
  shared_ptr<string> name{};
  shared_ptr<string> offsetCorner{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pictureUrl{};
  shared_ptr<long> refHeight{};
  shared_ptr<long> refWidth{};
  shared_ptr<string> regionId{};
  shared_ptr<long> transparency{};
  shared_ptr<long> type{};
  shared_ptr<double> XOffset{};
  shared_ptr<double> YOffset{};

  AddLiveStreamWatermarkRequest() {}

  explicit AddLiveStreamWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (offsetCorner) {
      res["OffsetCorner"] = boost::any(*offsetCorner);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pictureUrl) {
      res["PictureUrl"] = boost::any(*pictureUrl);
    }
    if (refHeight) {
      res["RefHeight"] = boost::any(*refHeight);
    }
    if (refWidth) {
      res["RefWidth"] = boost::any(*refWidth);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (transparency) {
      res["Transparency"] = boost::any(*transparency);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (XOffset) {
      res["XOffset"] = boost::any(*XOffset);
    }
    if (YOffset) {
      res["YOffset"] = boost::any(*YOffset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OffsetCorner") != m.end() && !m["OffsetCorner"].empty()) {
      offsetCorner = make_shared<string>(boost::any_cast<string>(m["OffsetCorner"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PictureUrl") != m.end() && !m["PictureUrl"].empty()) {
      pictureUrl = make_shared<string>(boost::any_cast<string>(m["PictureUrl"]));
    }
    if (m.find("RefHeight") != m.end() && !m["RefHeight"].empty()) {
      refHeight = make_shared<long>(boost::any_cast<long>(m["RefHeight"]));
    }
    if (m.find("RefWidth") != m.end() && !m["RefWidth"].empty()) {
      refWidth = make_shared<long>(boost::any_cast<long>(m["RefWidth"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Transparency") != m.end() && !m["Transparency"].empty()) {
      transparency = make_shared<long>(boost::any_cast<long>(m["Transparency"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("XOffset") != m.end() && !m["XOffset"].empty()) {
      XOffset = make_shared<double>(boost::any_cast<double>(m["XOffset"]));
    }
    if (m.find("YOffset") != m.end() && !m["YOffset"].empty()) {
      YOffset = make_shared<double>(boost::any_cast<double>(m["YOffset"]));
    }
  }


  virtual ~AddLiveStreamWatermarkRequest() = default;
};
class AddLiveStreamWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  AddLiveStreamWatermarkResponseBody() {}

  explicit AddLiveStreamWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~AddLiveStreamWatermarkResponseBody() = default;
};
class AddLiveStreamWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveStreamWatermarkResponseBody> body{};

  AddLiveStreamWatermarkResponse() {}

  explicit AddLiveStreamWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveStreamWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveStreamWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveStreamWatermarkResponse() = default;
};
class AddLiveStreamWatermarkRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stream{};
  shared_ptr<string> templateId{};

  AddLiveStreamWatermarkRuleRequest() {}

  explicit AddLiveStreamWatermarkRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~AddLiveStreamWatermarkRuleRequest() = default;
};
class AddLiveStreamWatermarkRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleId{};

  AddLiveStreamWatermarkRuleResponseBody() {}

  explicit AddLiveStreamWatermarkRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~AddLiveStreamWatermarkRuleResponseBody() = default;
};
class AddLiveStreamWatermarkRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLiveStreamWatermarkRuleResponseBody> body{};

  AddLiveStreamWatermarkRuleResponse() {}

  explicit AddLiveStreamWatermarkRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLiveStreamWatermarkRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLiveStreamWatermarkRuleResponseBody>(model1);
      }
    }
  }


  virtual ~AddLiveStreamWatermarkRuleResponse() = default;
};
class AddPlaylistItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> programConfig{};
  shared_ptr<string> programId{};
  shared_ptr<string> programItems{};
  shared_ptr<string> regionId{};

  AddPlaylistItemsRequest() {}

  explicit AddPlaylistItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programConfig) {
      res["ProgramConfig"] = boost::any(*programConfig);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programItems) {
      res["ProgramItems"] = boost::any(*programItems);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramConfig") != m.end() && !m["ProgramConfig"].empty()) {
      programConfig = make_shared<string>(boost::any_cast<string>(m["ProgramConfig"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramItems") != m.end() && !m["ProgramItems"].empty()) {
      programItems = make_shared<string>(boost::any_cast<string>(m["ProgramItems"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddPlaylistItemsRequest() = default;
};
class AddPlaylistItemsResponseBodyItemsFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};

  AddPlaylistItemsResponseBodyItemsFailedItems() {}

  explicit AddPlaylistItemsResponseBodyItemsFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
  }


  virtual ~AddPlaylistItemsResponseBodyItemsFailedItems() = default;
};
class AddPlaylistItemsResponseBodyItemsSuccessItems : public Darabonba::Model {
public:
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};

  AddPlaylistItemsResponseBodyItemsSuccessItems() {}

  explicit AddPlaylistItemsResponseBodyItemsSuccessItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
  }


  virtual ~AddPlaylistItemsResponseBodyItemsSuccessItems() = default;
};
class AddPlaylistItemsResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<AddPlaylistItemsResponseBodyItemsFailedItems>> failedItems{};
  shared_ptr<vector<AddPlaylistItemsResponseBodyItemsSuccessItems>> successItems{};

  AddPlaylistItemsResponseBodyItems() {}

  explicit AddPlaylistItemsResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successItems) {
      vector<boost::any> temp1;
      for(auto item1:*successItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuccessItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<AddPlaylistItemsResponseBodyItemsFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddPlaylistItemsResponseBodyItemsFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<AddPlaylistItemsResponseBodyItemsFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessItems") != m.end() && !m["SuccessItems"].empty()) {
      if (typeid(vector<boost::any>) == m["SuccessItems"].type()) {
        vector<AddPlaylistItemsResponseBodyItemsSuccessItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuccessItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddPlaylistItemsResponseBodyItemsSuccessItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        successItems = make_shared<vector<AddPlaylistItemsResponseBodyItemsSuccessItems>>(expect1);
      }
    }
  }


  virtual ~AddPlaylistItemsResponseBodyItems() = default;
};
class AddPlaylistItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddPlaylistItemsResponseBodyItems> items{};
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  AddPlaylistItemsResponseBody() {}

  explicit AddPlaylistItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        AddPlaylistItemsResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<AddPlaylistItemsResponseBodyItems>(model1);
      }
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPlaylistItemsResponseBody() = default;
};
class AddPlaylistItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPlaylistItemsResponseBody> body{};

  AddPlaylistItemsResponse() {}

  explicit AddPlaylistItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPlaylistItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPlaylistItemsResponseBody>(model1);
      }
    }
  }


  virtual ~AddPlaylistItemsResponse() = default;
};
class AddRtsLiveStreamTranscodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<long> audioBitrate{};
  shared_ptr<long> audioChannelNum{};
  shared_ptr<string> audioCodec{};
  shared_ptr<string> audioProfile{};
  shared_ptr<long> audioRate{};
  shared_ptr<bool> deleteBframes{};
  shared_ptr<string> domain{};
  shared_ptr<long> FPS{};
  shared_ptr<string> gop{};
  shared_ptr<long> height{};
  shared_ptr<string> lazy{};
  shared_ptr<bool> opus{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> profile{};
  shared_ptr<string> regionId{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<long> width{};

  AddRtsLiveStreamTranscodeRequest() {}

  explicit AddRtsLiveStreamTranscodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannelNum) {
      res["AudioChannelNum"] = boost::any(*audioChannelNum);
    }
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioProfile) {
      res["AudioProfile"] = boost::any(*audioProfile);
    }
    if (audioRate) {
      res["AudioRate"] = boost::any(*audioRate);
    }
    if (deleteBframes) {
      res["DeleteBframes"] = boost::any(*deleteBframes);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (FPS) {
      res["FPS"] = boost::any(*FPS);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (lazy) {
      res["Lazy"] = boost::any(*lazy);
    }
    if (opus) {
      res["Opus"] = boost::any(*opus);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<long>(boost::any_cast<long>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannelNum") != m.end() && !m["AudioChannelNum"].empty()) {
      audioChannelNum = make_shared<long>(boost::any_cast<long>(m["AudioChannelNum"]));
    }
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioProfile") != m.end() && !m["AudioProfile"].empty()) {
      audioProfile = make_shared<string>(boost::any_cast<string>(m["AudioProfile"]));
    }
    if (m.find("AudioRate") != m.end() && !m["AudioRate"].empty()) {
      audioRate = make_shared<long>(boost::any_cast<long>(m["AudioRate"]));
    }
    if (m.find("DeleteBframes") != m.end() && !m["DeleteBframes"].empty()) {
      deleteBframes = make_shared<bool>(boost::any_cast<bool>(m["DeleteBframes"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("FPS") != m.end() && !m["FPS"].empty()) {
      FPS = make_shared<long>(boost::any_cast<long>(m["FPS"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Lazy") != m.end() && !m["Lazy"].empty()) {
      lazy = make_shared<string>(boost::any_cast<string>(m["Lazy"]));
    }
    if (m.find("Opus") != m.end() && !m["Opus"].empty()) {
      opus = make_shared<bool>(boost::any_cast<bool>(m["Opus"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<long>(boost::any_cast<long>(m["Profile"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~AddRtsLiveStreamTranscodeRequest() = default;
};
class AddRtsLiveStreamTranscodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddRtsLiveStreamTranscodeResponseBody() {}

  explicit AddRtsLiveStreamTranscodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddRtsLiveStreamTranscodeResponseBody() = default;
};
class AddRtsLiveStreamTranscodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddRtsLiveStreamTranscodeResponseBody> body{};

  AddRtsLiveStreamTranscodeResponse() {}

  explicit AddRtsLiveStreamTranscodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddRtsLiveStreamTranscodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddRtsLiveStreamTranscodeResponseBody>(model1);
      }
    }
  }


  virtual ~AddRtsLiveStreamTranscodeResponse() = default;
};
class AddShowIntoShowListRequestShowList : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> liveInputType{};
  shared_ptr<long> repeatTimes{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceUrl{};
  shared_ptr<string> showName{};

  AddShowIntoShowListRequestShowList() {}

  explicit AddShowIntoShowListRequestShowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (liveInputType) {
      res["liveInputType"] = boost::any(*liveInputType);
    }
    if (repeatTimes) {
      res["repeatTimes"] = boost::any(*repeatTimes);
    }
    if (resourceId) {
      res["resourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    if (resourceUrl) {
      res["resourceUrl"] = boost::any(*resourceUrl);
    }
    if (showName) {
      res["showName"] = boost::any(*showName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("liveInputType") != m.end() && !m["liveInputType"].empty()) {
      liveInputType = make_shared<long>(boost::any_cast<long>(m["liveInputType"]));
    }
    if (m.find("repeatTimes") != m.end() && !m["repeatTimes"].empty()) {
      repeatTimes = make_shared<long>(boost::any_cast<long>(m["repeatTimes"]));
    }
    if (m.find("resourceId") != m.end() && !m["resourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["resourceId"]));
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
    if (m.find("resourceUrl") != m.end() && !m["resourceUrl"].empty()) {
      resourceUrl = make_shared<string>(boost::any_cast<string>(m["resourceUrl"]));
    }
    if (m.find("showName") != m.end() && !m["showName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["showName"]));
    }
  }


  virtual ~AddShowIntoShowListRequestShowList() = default;
};
class AddShowIntoShowListRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> duration{};
  shared_ptr<long> liveInputType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> repeatTimes{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceUrl{};
  shared_ptr<string> showName{};
  shared_ptr<long> spot{};
  shared_ptr<bool> isBatchMode{};
  shared_ptr<vector<AddShowIntoShowListRequestShowList>> showList{};

  AddShowIntoShowListRequest() {}

  explicit AddShowIntoShowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (liveInputType) {
      res["LiveInputType"] = boost::any(*liveInputType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeatTimes) {
      res["RepeatTimes"] = boost::any(*repeatTimes);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceUrl) {
      res["ResourceUrl"] = boost::any(*resourceUrl);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (spot) {
      res["Spot"] = boost::any(*spot);
    }
    if (isBatchMode) {
      res["isBatchMode"] = boost::any(*isBatchMode);
    }
    if (showList) {
      vector<boost::any> temp1;
      for(auto item1:*showList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["showList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("LiveInputType") != m.end() && !m["LiveInputType"].empty()) {
      liveInputType = make_shared<long>(boost::any_cast<long>(m["LiveInputType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepeatTimes") != m.end() && !m["RepeatTimes"].empty()) {
      repeatTimes = make_shared<long>(boost::any_cast<long>(m["RepeatTimes"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceUrl") != m.end() && !m["ResourceUrl"].empty()) {
      resourceUrl = make_shared<string>(boost::any_cast<string>(m["ResourceUrl"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("Spot") != m.end() && !m["Spot"].empty()) {
      spot = make_shared<long>(boost::any_cast<long>(m["Spot"]));
    }
    if (m.find("isBatchMode") != m.end() && !m["isBatchMode"].empty()) {
      isBatchMode = make_shared<bool>(boost::any_cast<bool>(m["isBatchMode"]));
    }
    if (m.find("showList") != m.end() && !m["showList"].empty()) {
      if (typeid(vector<boost::any>) == m["showList"].type()) {
        vector<AddShowIntoShowListRequestShowList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["showList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddShowIntoShowListRequestShowList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        showList = make_shared<vector<AddShowIntoShowListRequestShowList>>(expect1);
      }
    }
  }


  virtual ~AddShowIntoShowListRequest() = default;
};
class AddShowIntoShowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> showId{};
  shared_ptr<string> failedList{};
  shared_ptr<string> successfulShowIds{};

  AddShowIntoShowListResponseBody() {}

  explicit AddShowIntoShowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (failedList) {
      res["failedList"] = boost::any(*failedList);
    }
    if (successfulShowIds) {
      res["successfulShowIds"] = boost::any(*successfulShowIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("failedList") != m.end() && !m["failedList"].empty()) {
      failedList = make_shared<string>(boost::any_cast<string>(m["failedList"]));
    }
    if (m.find("successfulShowIds") != m.end() && !m["successfulShowIds"].empty()) {
      successfulShowIds = make_shared<string>(boost::any_cast<string>(m["successfulShowIds"]));
    }
  }


  virtual ~AddShowIntoShowListResponseBody() = default;
};
class AddShowIntoShowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddShowIntoShowListResponseBody> body{};

  AddShowIntoShowListResponse() {}

  explicit AddShowIntoShowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddShowIntoShowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddShowIntoShowListResponseBody>(model1);
      }
    }
  }


  virtual ~AddShowIntoShowListResponse() = default;
};
class AddStudioLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgImageConfig{};
  shared_ptr<string> casterId{};
  shared_ptr<string> commonConfig{};
  shared_ptr<string> layerOrderConfigList{};
  shared_ptr<string> layoutName{};
  shared_ptr<string> layoutType{};
  shared_ptr<string> mediaInputConfigList{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> screenInputConfigList{};

  AddStudioLayoutRequest() {}

  explicit AddStudioLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgImageConfig) {
      res["BgImageConfig"] = boost::any(*bgImageConfig);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (commonConfig) {
      res["CommonConfig"] = boost::any(*commonConfig);
    }
    if (layerOrderConfigList) {
      res["LayerOrderConfigList"] = boost::any(*layerOrderConfigList);
    }
    if (layoutName) {
      res["LayoutName"] = boost::any(*layoutName);
    }
    if (layoutType) {
      res["LayoutType"] = boost::any(*layoutType);
    }
    if (mediaInputConfigList) {
      res["MediaInputConfigList"] = boost::any(*mediaInputConfigList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (screenInputConfigList) {
      res["ScreenInputConfigList"] = boost::any(*screenInputConfigList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgImageConfig") != m.end() && !m["BgImageConfig"].empty()) {
      bgImageConfig = make_shared<string>(boost::any_cast<string>(m["BgImageConfig"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CommonConfig") != m.end() && !m["CommonConfig"].empty()) {
      commonConfig = make_shared<string>(boost::any_cast<string>(m["CommonConfig"]));
    }
    if (m.find("LayerOrderConfigList") != m.end() && !m["LayerOrderConfigList"].empty()) {
      layerOrderConfigList = make_shared<string>(boost::any_cast<string>(m["LayerOrderConfigList"]));
    }
    if (m.find("LayoutName") != m.end() && !m["LayoutName"].empty()) {
      layoutName = make_shared<string>(boost::any_cast<string>(m["LayoutName"]));
    }
    if (m.find("LayoutType") != m.end() && !m["LayoutType"].empty()) {
      layoutType = make_shared<string>(boost::any_cast<string>(m["LayoutType"]));
    }
    if (m.find("MediaInputConfigList") != m.end() && !m["MediaInputConfigList"].empty()) {
      mediaInputConfigList = make_shared<string>(boost::any_cast<string>(m["MediaInputConfigList"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScreenInputConfigList") != m.end() && !m["ScreenInputConfigList"].empty()) {
      screenInputConfigList = make_shared<string>(boost::any_cast<string>(m["ScreenInputConfigList"]));
    }
  }


  virtual ~AddStudioLayoutRequest() = default;
};
class AddStudioLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> layoutId{};
  shared_ptr<string> requestId{};

  AddStudioLayoutResponseBody() {}

  explicit AddStudioLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddStudioLayoutResponseBody() = default;
};
class AddStudioLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddStudioLayoutResponseBody> body{};

  AddStudioLayoutResponse() {}

  explicit AddStudioLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddStudioLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddStudioLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~AddStudioLayoutResponse() = default;
};
class AddTrancodeSEIRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> delay{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pattern{};
  shared_ptr<string> regionId{};
  shared_ptr<long> repeat{};
  shared_ptr<string> streamName{};
  shared_ptr<string> text{};

  AddTrancodeSEIRequest() {}

  explicit AddTrancodeSEIRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeat) {
      res["Repeat"] = boost::any(*repeat);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Repeat") != m.end() && !m["Repeat"].empty()) {
      repeat = make_shared<long>(boost::any_cast<long>(m["Repeat"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~AddTrancodeSEIRequest() = default;
};
class AddTrancodeSEIResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddTrancodeSEIResponseBody() {}

  explicit AddTrancodeSEIResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddTrancodeSEIResponseBody() = default;
};
class AddTrancodeSEIResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTrancodeSEIResponseBody> body{};

  AddTrancodeSEIResponse() {}

  explicit AddTrancodeSEIResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTrancodeSEIResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTrancodeSEIResponseBody>(model1);
      }
    }
  }


  virtual ~AddTrancodeSEIResponse() = default;
};
class BanLiveMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<vector<string>> exceptUsers{};
  shared_ptr<string> groupId{};

  BanLiveMessageGroupRequest() {}

  explicit BanLiveMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (exceptUsers) {
      res["ExceptUsers"] = boost::any(*exceptUsers);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("ExceptUsers") != m.end() && !m["ExceptUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExceptUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExceptUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      exceptUsers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~BanLiveMessageGroupRequest() = default;
};
class BanLiveMessageGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> exceptUsersShrink{};
  shared_ptr<string> groupId{};

  BanLiveMessageGroupShrinkRequest() {}

  explicit BanLiveMessageGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (exceptUsersShrink) {
      res["ExceptUsers"] = boost::any(*exceptUsersShrink);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("ExceptUsers") != m.end() && !m["ExceptUsers"].empty()) {
      exceptUsersShrink = make_shared<string>(boost::any_cast<string>(m["ExceptUsers"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~BanLiveMessageGroupShrinkRequest() = default;
};
class BanLiveMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BanLiveMessageGroupResponseBody() {}

  explicit BanLiveMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BanLiveMessageGroupResponseBody() = default;
};
class BanLiveMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BanLiveMessageGroupResponseBody> body{};

  BanLiveMessageGroupResponse() {}

  explicit BanLiveMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BanLiveMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BanLiveMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~BanLiveMessageGroupResponse() = default;
};
class BatchDeleteLiveDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functionNames{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchDeleteLiveDomainConfigsRequest() {}

  explicit BatchDeleteLiveDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchDeleteLiveDomainConfigsRequest() = default;
};
class BatchDeleteLiveDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchDeleteLiveDomainConfigsResponseBody() {}

  explicit BatchDeleteLiveDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchDeleteLiveDomainConfigsResponseBody() = default;
};
class BatchDeleteLiveDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteLiveDomainConfigsResponseBody> body{};

  BatchDeleteLiveDomainConfigsResponse() {}

  explicit BatchDeleteLiveDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteLiveDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteLiveDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteLiveDomainConfigsResponse() = default;
};
class BatchGetOnlineUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> userIds{};

  BatchGetOnlineUsersRequest() {}

  explicit BatchGetOnlineUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIds = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~BatchGetOnlineUsersRequest() = default;
};
class BatchGetOnlineUsersResponseBodyResultOnlineUsers : public Darabonba::Model {
public:
  shared_ptr<long> joinTime{};
  shared_ptr<bool> online{};
  shared_ptr<string> userId{};

  BatchGetOnlineUsersResponseBodyResultOnlineUsers() {}

  explicit BatchGetOnlineUsersResponseBodyResultOnlineUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinTime) {
      res["JoinTime"] = boost::any(*joinTime);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinTime") != m.end() && !m["JoinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["JoinTime"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~BatchGetOnlineUsersResponseBodyResultOnlineUsers() = default;
};
class BatchGetOnlineUsersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetOnlineUsersResponseBodyResultOnlineUsers>> onlineUsers{};

  BatchGetOnlineUsersResponseBodyResult() {}

  explicit BatchGetOnlineUsersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onlineUsers) {
      vector<boost::any> temp1;
      for(auto item1:*onlineUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OnlineUsers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnlineUsers") != m.end() && !m["OnlineUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["OnlineUsers"].type()) {
        vector<BatchGetOnlineUsersResponseBodyResultOnlineUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OnlineUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetOnlineUsersResponseBodyResultOnlineUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        onlineUsers = make_shared<vector<BatchGetOnlineUsersResponseBodyResultOnlineUsers>>(expect1);
      }
    }
  }


  virtual ~BatchGetOnlineUsersResponseBodyResult() = default;
};
class BatchGetOnlineUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<BatchGetOnlineUsersResponseBodyResult> result{};

  BatchGetOnlineUsersResponseBody() {}

  explicit BatchGetOnlineUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        BatchGetOnlineUsersResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<BatchGetOnlineUsersResponseBodyResult>(model1);
      }
    }
  }


  virtual ~BatchGetOnlineUsersResponseBody() = default;
};
class BatchGetOnlineUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetOnlineUsersResponseBody> body{};

  BatchGetOnlineUsersResponse() {}

  explicit BatchGetOnlineUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetOnlineUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetOnlineUsersResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetOnlineUsersResponse() = default;
};
class BatchSetLiveDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functions{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchSetLiveDomainConfigsRequest() {}

  explicit BatchSetLiveDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchSetLiveDomainConfigsRequest() = default;
};
class BatchSetLiveDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetLiveDomainConfigsResponseBody() {}

  explicit BatchSetLiveDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetLiveDomainConfigsResponseBody() = default;
};
class BatchSetLiveDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetLiveDomainConfigsResponseBody> body{};

  BatchSetLiveDomainConfigsResponse() {}

  explicit BatchSetLiveDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetLiveDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetLiveDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetLiveDomainConfigsResponse() = default;
};
class CancelMuteAllGroupUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> broadCastType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};

  CancelMuteAllGroupUserRequest() {}

  explicit CancelMuteAllGroupUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
  }


  virtual ~CancelMuteAllGroupUserRequest() = default;
};
class CancelMuteAllGroupUserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  CancelMuteAllGroupUserResponseBodyResult() {}

  explicit CancelMuteAllGroupUserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelMuteAllGroupUserResponseBodyResult() = default;
};
class CancelMuteAllGroupUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CancelMuteAllGroupUserResponseBodyResult> result{};

  CancelMuteAllGroupUserResponseBody() {}

  explicit CancelMuteAllGroupUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CancelMuteAllGroupUserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CancelMuteAllGroupUserResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CancelMuteAllGroupUserResponseBody() = default;
};
class CancelMuteAllGroupUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelMuteAllGroupUserResponseBody> body{};

  CancelMuteAllGroupUserResponse() {}

  explicit CancelMuteAllGroupUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelMuteAllGroupUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelMuteAllGroupUserResponseBody>(model1);
      }
    }
  }


  virtual ~CancelMuteAllGroupUserResponse() = default;
};
class CancelMuteGroupUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> broadCastType{};
  shared_ptr<vector<string>> cancelMuteUserList{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};

  CancelMuteGroupUserRequest() {}

  explicit CancelMuteGroupUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (cancelMuteUserList) {
      res["CancelMuteUserList"] = boost::any(*cancelMuteUserList);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("CancelMuteUserList") != m.end() && !m["CancelMuteUserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CancelMuteUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CancelMuteUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cancelMuteUserList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
  }


  virtual ~CancelMuteGroupUserRequest() = default;
};
class CancelMuteGroupUserShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> broadCastType{};
  shared_ptr<string> cancelMuteUserListShrink{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};

  CancelMuteGroupUserShrinkRequest() {}

  explicit CancelMuteGroupUserShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (cancelMuteUserListShrink) {
      res["CancelMuteUserList"] = boost::any(*cancelMuteUserListShrink);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("CancelMuteUserList") != m.end() && !m["CancelMuteUserList"].empty()) {
      cancelMuteUserListShrink = make_shared<string>(boost::any_cast<string>(m["CancelMuteUserList"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
  }


  virtual ~CancelMuteGroupUserShrinkRequest() = default;
};
class CancelMuteGroupUserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  CancelMuteGroupUserResponseBodyResult() {}

  explicit CancelMuteGroupUserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelMuteGroupUserResponseBodyResult() = default;
};
class CancelMuteGroupUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CancelMuteGroupUserResponseBodyResult> result{};

  CancelMuteGroupUserResponseBody() {}

  explicit CancelMuteGroupUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CancelMuteGroupUserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CancelMuteGroupUserResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CancelMuteGroupUserResponseBody() = default;
};
class CancelMuteGroupUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelMuteGroupUserResponseBody> body{};

  CancelMuteGroupUserResponse() {}

  explicit CancelMuteGroupUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelMuteGroupUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelMuteGroupUserResponseBody>(model1);
      }
    }
  }


  virtual ~CancelMuteGroupUserResponse() = default;
};
class ChangeLiveDomainResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  ChangeLiveDomainResourceGroupRequest() {}

  explicit ChangeLiveDomainResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ChangeLiveDomainResourceGroupRequest() = default;
};
class ChangeLiveDomainResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ChangeLiveDomainResourceGroupResponseBody() {}

  explicit ChangeLiveDomainResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeLiveDomainResourceGroupResponseBody() = default;
};
class ChangeLiveDomainResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeLiveDomainResourceGroupResponseBody> body{};

  ChangeLiveDomainResourceGroupResponse() {}

  explicit ChangeLiveDomainResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeLiveDomainResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeLiveDomainResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeLiveDomainResourceGroupResponse() = default;
};
class CheckLiveMessageUsersInGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<string>> userIds{};

  CheckLiveMessageUsersInGroupRequest() {}

  explicit CheckLiveMessageUsersInGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CheckLiveMessageUsersInGroupRequest() = default;
};
class CheckLiveMessageUsersInGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<string> userIdsShrink{};

  CheckLiveMessageUsersInGroupShrinkRequest() {}

  explicit CheckLiveMessageUsersInGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (userIdsShrink) {
      res["UserIds"] = boost::any(*userIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIdsShrink = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~CheckLiveMessageUsersInGroupShrinkRequest() = default;
};
class CheckLiveMessageUsersInGroupResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<bool> online{};
  shared_ptr<string> userId{};

  CheckLiveMessageUsersInGroupResponseBodyUsers() {}

  explicit CheckLiveMessageUsersInGroupResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CheckLiveMessageUsersInGroupResponseBodyUsers() = default;
};
class CheckLiveMessageUsersInGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<CheckLiveMessageUsersInGroupResponseBodyUsers>> users{};

  CheckLiveMessageUsersInGroupResponseBody() {}

  explicit CheckLiveMessageUsersInGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<CheckLiveMessageUsersInGroupResponseBodyUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CheckLiveMessageUsersInGroupResponseBodyUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<CheckLiveMessageUsersInGroupResponseBodyUsers>>(expect1);
      }
    }
  }


  virtual ~CheckLiveMessageUsersInGroupResponseBody() = default;
};
class CheckLiveMessageUsersInGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckLiveMessageUsersInGroupResponseBody> body{};

  CheckLiveMessageUsersInGroupResponse() {}

  explicit CheckLiveMessageUsersInGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckLiveMessageUsersInGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckLiveMessageUsersInGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CheckLiveMessageUsersInGroupResponse() = default;
};
class CheckLiveMessageUsersOnlineRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<vector<string>> userIds{};

  CheckLiveMessageUsersOnlineRequest() {}

  explicit CheckLiveMessageUsersOnlineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CheckLiveMessageUsersOnlineRequest() = default;
};
class CheckLiveMessageUsersOnlineShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> userIdsShrink{};

  CheckLiveMessageUsersOnlineShrinkRequest() {}

  explicit CheckLiveMessageUsersOnlineShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (userIdsShrink) {
      res["UserIds"] = boost::any(*userIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIdsShrink = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~CheckLiveMessageUsersOnlineShrinkRequest() = default;
};
class CheckLiveMessageUsersOnlineResponseBodyUserList : public Darabonba::Model {
public:
  shared_ptr<bool> online{};
  shared_ptr<string> userId{};

  CheckLiveMessageUsersOnlineResponseBodyUserList() {}

  explicit CheckLiveMessageUsersOnlineResponseBodyUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CheckLiveMessageUsersOnlineResponseBodyUserList() = default;
};
class CheckLiveMessageUsersOnlineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<CheckLiveMessageUsersOnlineResponseBodyUserList>> userList{};

  CheckLiveMessageUsersOnlineResponseBody() {}

  explicit CheckLiveMessageUsersOnlineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<CheckLiveMessageUsersOnlineResponseBodyUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CheckLiveMessageUsersOnlineResponseBodyUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<CheckLiveMessageUsersOnlineResponseBodyUserList>>(expect1);
      }
    }
  }


  virtual ~CheckLiveMessageUsersOnlineResponseBody() = default;
};
class CheckLiveMessageUsersOnlineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckLiveMessageUsersOnlineResponseBody> body{};

  CheckLiveMessageUsersOnlineResponse() {}

  explicit CheckLiveMessageUsersOnlineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckLiveMessageUsersOnlineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckLiveMessageUsersOnlineResponseBody>(model1);
      }
    }
  }


  virtual ~CheckLiveMessageUsersOnlineResponse() = default;
};
class CloseLiveShiftRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  CloseLiveShiftRequest() {}

  explicit CloseLiveShiftRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~CloseLiveShiftRequest() = default;
};
class CloseLiveShiftResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CloseLiveShiftResponseBody() {}

  explicit CloseLiveShiftResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CloseLiveShiftResponseBody() = default;
};
class CloseLiveShiftResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseLiveShiftResponseBody> body{};

  CloseLiveShiftResponse() {}

  explicit CloseLiveShiftResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseLiveShiftResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseLiveShiftResponseBody>(model1);
      }
    }
  }


  virtual ~CloseLiveShiftResponse() = default;
};
class CopyCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterName{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> srcCasterId{};

  CopyCasterRequest() {}

  explicit CopyCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (srcCasterId) {
      res["SrcCasterId"] = boost::any(*srcCasterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SrcCasterId") != m.end() && !m["SrcCasterId"].empty()) {
      srcCasterId = make_shared<string>(boost::any_cast<string>(m["SrcCasterId"]));
    }
  }


  virtual ~CopyCasterRequest() = default;
};
class CopyCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  CopyCasterResponseBody() {}

  explicit CopyCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyCasterResponseBody() = default;
};
class CopyCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyCasterResponseBody> body{};

  CopyCasterResponse() {}

  explicit CopyCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyCasterResponseBody>(model1);
      }
    }
  }


  virtual ~CopyCasterResponse() = default;
};
class CopyCasterSceneConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> fromSceneId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> toSceneId{};

  CopyCasterSceneConfigRequest() {}

  explicit CopyCasterSceneConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (fromSceneId) {
      res["FromSceneId"] = boost::any(*fromSceneId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (toSceneId) {
      res["ToSceneId"] = boost::any(*toSceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("FromSceneId") != m.end() && !m["FromSceneId"].empty()) {
      fromSceneId = make_shared<string>(boost::any_cast<string>(m["FromSceneId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ToSceneId") != m.end() && !m["ToSceneId"].empty()) {
      toSceneId = make_shared<string>(boost::any_cast<string>(m["ToSceneId"]));
    }
  }


  virtual ~CopyCasterSceneConfigRequest() = default;
};
class CopyCasterSceneConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CopyCasterSceneConfigResponseBody() {}

  explicit CopyCasterSceneConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyCasterSceneConfigResponseBody() = default;
};
class CopyCasterSceneConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyCasterSceneConfigResponseBody> body{};

  CopyCasterSceneConfigResponse() {}

  explicit CopyCasterSceneConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyCasterSceneConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyCasterSceneConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CopyCasterSceneConfigResponse() = default;
};
class CreateCasterRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateCasterRequestTag() {}

  explicit CreateCasterRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateCasterRequestTag() = default;
};
class CreateCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterName{};
  shared_ptr<string> casterTemplate{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> normType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> purchaseTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CreateCasterRequestTag>> tag{};

  CreateCasterRequest() {}

  explicit CreateCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (casterTemplate) {
      res["CasterTemplate"] = boost::any(*casterTemplate);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (normType) {
      res["NormType"] = boost::any(*normType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (purchaseTime) {
      res["PurchaseTime"] = boost::any(*purchaseTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("CasterTemplate") != m.end() && !m["CasterTemplate"].empty()) {
      casterTemplate = make_shared<string>(boost::any_cast<string>(m["CasterTemplate"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("NormType") != m.end() && !m["NormType"].empty()) {
      normType = make_shared<long>(boost::any_cast<long>(m["NormType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PurchaseTime") != m.end() && !m["PurchaseTime"].empty()) {
      purchaseTime = make_shared<string>(boost::any_cast<string>(m["PurchaseTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateCasterRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCasterRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateCasterRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateCasterRequest() = default;
};
class CreateCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  CreateCasterResponseBody() {}

  explicit CreateCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCasterResponseBody() = default;
};
class CreateCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCasterResponseBody> body{};

  CreateCasterResponse() {}

  explicit CreateCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCasterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCasterResponse() = default;
};
class CreateCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> customTemplate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> template_{};

  CreateCustomTemplateRequest() {}

  explicit CreateCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplate) {
      res["CustomTemplate"] = boost::any(*customTemplate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplate") != m.end() && !m["CustomTemplate"].empty()) {
      customTemplate = make_shared<string>(boost::any_cast<string>(m["CustomTemplate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~CreateCustomTemplateRequest() = default;
};
class CreateCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateCustomTemplateResponseBody() {}

  explicit CreateCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomTemplateResponseBody() = default;
};
class CreateCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomTemplateResponseBody> body{};

  CreateCustomTemplateResponse() {}

  explicit CreateCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomTemplateResponse() = default;
};
class CreateEdgeTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamInput{};
  shared_ptr<string> streamOutput{};
  shared_ptr<string> templateId{};

  CreateEdgeTranscodeJobRequest() {}

  explicit CreateEdgeTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamInput) {
      res["StreamInput"] = boost::any(*streamInput);
    }
    if (streamOutput) {
      res["StreamOutput"] = boost::any(*streamOutput);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInput = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("StreamOutput") != m.end() && !m["StreamOutput"].empty()) {
      streamOutput = make_shared<string>(boost::any_cast<string>(m["StreamOutput"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateEdgeTranscodeJobRequest() = default;
};
class CreateEdgeTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  CreateEdgeTranscodeJobResponseBody() {}

  explicit CreateEdgeTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEdgeTranscodeJobResponseBody() = default;
};
class CreateEdgeTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEdgeTranscodeJobResponseBody> body{};

  CreateEdgeTranscodeJobResponse() {}

  explicit CreateEdgeTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEdgeTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEdgeTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEdgeTranscodeJobResponse() = default;
};
class CreateEventSubRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> channelId{};
  shared_ptr<vector<string>> events{};
  shared_ptr<vector<string>> users{};

  CreateEventSubRequest() {}

  explicit CreateEventSubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (events) {
      res["Events"] = boost::any(*events);
    }
    if (users) {
      res["Users"] = boost::any(*users);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Events") != m.end() && !m["Events"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Events"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Events"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      events = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Users"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      users = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateEventSubRequest() = default;
};
class CreateEventSubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> subscribeId{};

  CreateEventSubResponseBody() {}

  explicit CreateEventSubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subscribeId) {
      res["SubscribeId"] = boost::any(*subscribeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubscribeId") != m.end() && !m["SubscribeId"].empty()) {
      subscribeId = make_shared<string>(boost::any_cast<string>(m["SubscribeId"]));
    }
  }


  virtual ~CreateEventSubResponseBody() = default;
};
class CreateEventSubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEventSubResponseBody> body{};

  CreateEventSubResponse() {}

  explicit CreateEventSubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEventSubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEventSubResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEventSubResponse() = default;
};
class CreateLiveAIStudioRequestMattingLayout : public Darabonba::Model {
public:
  shared_ptr<double> heightNormalized{};
  shared_ptr<double> positionX{};
  shared_ptr<double> positionY{};

  CreateLiveAIStudioRequestMattingLayout() {}

  explicit CreateLiveAIStudioRequestMattingLayout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionX) {
      res["PositionX"] = boost::any(*positionX);
    }
    if (positionY) {
      res["PositionY"] = boost::any(*positionY);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionX") != m.end() && !m["PositionX"].empty()) {
      positionX = make_shared<double>(boost::any_cast<double>(m["PositionX"]));
    }
    if (m.find("PositionY") != m.end() && !m["PositionY"].empty()) {
      positionY = make_shared<double>(boost::any_cast<double>(m["PositionY"]));
    }
  }


  virtual ~CreateLiveAIStudioRequestMattingLayout() = default;
};
class CreateLiveAIStudioRequestMediaLayout : public Darabonba::Model {
public:
  shared_ptr<double> heightNormalized{};
  shared_ptr<double> positionX{};
  shared_ptr<double> positionY{};

  CreateLiveAIStudioRequestMediaLayout() {}

  explicit CreateLiveAIStudioRequestMediaLayout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionX) {
      res["PositionX"] = boost::any(*positionX);
    }
    if (positionY) {
      res["PositionY"] = boost::any(*positionY);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionX") != m.end() && !m["PositionX"].empty()) {
      positionX = make_shared<double>(boost::any_cast<double>(m["PositionX"]));
    }
    if (m.find("PositionY") != m.end() && !m["PositionY"].empty()) {
      positionY = make_shared<double>(boost::any_cast<double>(m["PositionY"]));
    }
  }


  virtual ~CreateLiveAIStudioRequestMediaLayout() = default;
};
class CreateLiveAIStudioRequest : public Darabonba::Model {
public:
  shared_ptr<string> backgroundResourceId{};
  shared_ptr<string> backgroundResourceUrl{};
  shared_ptr<string> backgroundType{};
  shared_ptr<string> description{};
  shared_ptr<long> height{};
  shared_ptr<CreateLiveAIStudioRequestMattingLayout> mattingLayout{};
  shared_ptr<string> mattingType{};
  shared_ptr<CreateLiveAIStudioRequestMediaLayout> mediaLayout{};
  shared_ptr<string> mediaResourceId{};
  shared_ptr<string> mediaResourceUrl{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> studioName{};
  shared_ptr<long> width{};

  CreateLiveAIStudioRequest() {}

  explicit CreateLiveAIStudioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundResourceId) {
      res["BackgroundResourceId"] = boost::any(*backgroundResourceId);
    }
    if (backgroundResourceUrl) {
      res["BackgroundResourceUrl"] = boost::any(*backgroundResourceUrl);
    }
    if (backgroundType) {
      res["BackgroundType"] = boost::any(*backgroundType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mattingLayout) {
      res["MattingLayout"] = mattingLayout ? boost::any(mattingLayout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mattingType) {
      res["MattingType"] = boost::any(*mattingType);
    }
    if (mediaLayout) {
      res["MediaLayout"] = mediaLayout ? boost::any(mediaLayout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaResourceId) {
      res["MediaResourceId"] = boost::any(*mediaResourceId);
    }
    if (mediaResourceUrl) {
      res["MediaResourceUrl"] = boost::any(*mediaResourceUrl);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (studioName) {
      res["StudioName"] = boost::any(*studioName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundResourceId") != m.end() && !m["BackgroundResourceId"].empty()) {
      backgroundResourceId = make_shared<string>(boost::any_cast<string>(m["BackgroundResourceId"]));
    }
    if (m.find("BackgroundResourceUrl") != m.end() && !m["BackgroundResourceUrl"].empty()) {
      backgroundResourceUrl = make_shared<string>(boost::any_cast<string>(m["BackgroundResourceUrl"]));
    }
    if (m.find("BackgroundType") != m.end() && !m["BackgroundType"].empty()) {
      backgroundType = make_shared<string>(boost::any_cast<string>(m["BackgroundType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("MattingLayout") != m.end() && !m["MattingLayout"].empty()) {
      if (typeid(map<string, boost::any>) == m["MattingLayout"].type()) {
        CreateLiveAIStudioRequestMattingLayout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MattingLayout"]));
        mattingLayout = make_shared<CreateLiveAIStudioRequestMattingLayout>(model1);
      }
    }
    if (m.find("MattingType") != m.end() && !m["MattingType"].empty()) {
      mattingType = make_shared<string>(boost::any_cast<string>(m["MattingType"]));
    }
    if (m.find("MediaLayout") != m.end() && !m["MediaLayout"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaLayout"].type()) {
        CreateLiveAIStudioRequestMediaLayout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaLayout"]));
        mediaLayout = make_shared<CreateLiveAIStudioRequestMediaLayout>(model1);
      }
    }
    if (m.find("MediaResourceId") != m.end() && !m["MediaResourceId"].empty()) {
      mediaResourceId = make_shared<string>(boost::any_cast<string>(m["MediaResourceId"]));
    }
    if (m.find("MediaResourceUrl") != m.end() && !m["MediaResourceUrl"].empty()) {
      mediaResourceUrl = make_shared<string>(boost::any_cast<string>(m["MediaResourceUrl"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StudioName") != m.end() && !m["StudioName"].empty()) {
      studioName = make_shared<string>(boost::any_cast<string>(m["StudioName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~CreateLiveAIStudioRequest() = default;
};
class CreateLiveAIStudioShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> backgroundResourceId{};
  shared_ptr<string> backgroundResourceUrl{};
  shared_ptr<string> backgroundType{};
  shared_ptr<string> description{};
  shared_ptr<long> height{};
  shared_ptr<string> mattingLayoutShrink{};
  shared_ptr<string> mattingType{};
  shared_ptr<string> mediaLayoutShrink{};
  shared_ptr<string> mediaResourceId{};
  shared_ptr<string> mediaResourceUrl{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> studioName{};
  shared_ptr<long> width{};

  CreateLiveAIStudioShrinkRequest() {}

  explicit CreateLiveAIStudioShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundResourceId) {
      res["BackgroundResourceId"] = boost::any(*backgroundResourceId);
    }
    if (backgroundResourceUrl) {
      res["BackgroundResourceUrl"] = boost::any(*backgroundResourceUrl);
    }
    if (backgroundType) {
      res["BackgroundType"] = boost::any(*backgroundType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mattingLayoutShrink) {
      res["MattingLayout"] = boost::any(*mattingLayoutShrink);
    }
    if (mattingType) {
      res["MattingType"] = boost::any(*mattingType);
    }
    if (mediaLayoutShrink) {
      res["MediaLayout"] = boost::any(*mediaLayoutShrink);
    }
    if (mediaResourceId) {
      res["MediaResourceId"] = boost::any(*mediaResourceId);
    }
    if (mediaResourceUrl) {
      res["MediaResourceUrl"] = boost::any(*mediaResourceUrl);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (studioName) {
      res["StudioName"] = boost::any(*studioName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundResourceId") != m.end() && !m["BackgroundResourceId"].empty()) {
      backgroundResourceId = make_shared<string>(boost::any_cast<string>(m["BackgroundResourceId"]));
    }
    if (m.find("BackgroundResourceUrl") != m.end() && !m["BackgroundResourceUrl"].empty()) {
      backgroundResourceUrl = make_shared<string>(boost::any_cast<string>(m["BackgroundResourceUrl"]));
    }
    if (m.find("BackgroundType") != m.end() && !m["BackgroundType"].empty()) {
      backgroundType = make_shared<string>(boost::any_cast<string>(m["BackgroundType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("MattingLayout") != m.end() && !m["MattingLayout"].empty()) {
      mattingLayoutShrink = make_shared<string>(boost::any_cast<string>(m["MattingLayout"]));
    }
    if (m.find("MattingType") != m.end() && !m["MattingType"].empty()) {
      mattingType = make_shared<string>(boost::any_cast<string>(m["MattingType"]));
    }
    if (m.find("MediaLayout") != m.end() && !m["MediaLayout"].empty()) {
      mediaLayoutShrink = make_shared<string>(boost::any_cast<string>(m["MediaLayout"]));
    }
    if (m.find("MediaResourceId") != m.end() && !m["MediaResourceId"].empty()) {
      mediaResourceId = make_shared<string>(boost::any_cast<string>(m["MediaResourceId"]));
    }
    if (m.find("MediaResourceUrl") != m.end() && !m["MediaResourceUrl"].empty()) {
      mediaResourceUrl = make_shared<string>(boost::any_cast<string>(m["MediaResourceUrl"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StudioName") != m.end() && !m["StudioName"].empty()) {
      studioName = make_shared<string>(boost::any_cast<string>(m["StudioName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~CreateLiveAIStudioShrinkRequest() = default;
};
class CreateLiveAIStudioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> studioId{};

  CreateLiveAIStudioResponseBody() {}

  explicit CreateLiveAIStudioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (studioId) {
      res["StudioId"] = boost::any(*studioId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StudioId") != m.end() && !m["StudioId"].empty()) {
      studioId = make_shared<string>(boost::any_cast<string>(m["StudioId"]));
    }
  }


  virtual ~CreateLiveAIStudioResponseBody() = default;
};
class CreateLiveAIStudioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveAIStudioResponseBody> body{};

  CreateLiveAIStudioResponse() {}

  explicit CreateLiveAIStudioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveAIStudioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveAIStudioResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveAIStudioResponse() = default;
};
class CreateLiveDelayConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<long> delayTime{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stream{};
  shared_ptr<string> taskTriggerMode{};

  CreateLiveDelayConfigRequest() {}

  explicit CreateLiveDelayConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (delayTime) {
      res["DelayTime"] = boost::any(*delayTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (taskTriggerMode) {
      res["TaskTriggerMode"] = boost::any(*taskTriggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("DelayTime") != m.end() && !m["DelayTime"].empty()) {
      delayTime = make_shared<long>(boost::any_cast<long>(m["DelayTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TaskTriggerMode") != m.end() && !m["TaskTriggerMode"].empty()) {
      taskTriggerMode = make_shared<string>(boost::any_cast<string>(m["TaskTriggerMode"]));
    }
  }


  virtual ~CreateLiveDelayConfigRequest() = default;
};
class CreateLiveDelayConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLiveDelayConfigResponseBody() {}

  explicit CreateLiveDelayConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLiveDelayConfigResponseBody() = default;
};
class CreateLiveDelayConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveDelayConfigResponseBody> body{};

  CreateLiveDelayConfigResponse() {}

  explicit CreateLiveDelayConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveDelayConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveDelayConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveDelayConfigResponse() = default;
};
class CreateLiveMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> auditType{};
  shared_ptr<string> auditUrl{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> eventCallbackUrl{};
  shared_ptr<long> msgLifeCycle{};

  CreateLiveMessageAppRequest() {}

  explicit CreateLiveMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (auditType) {
      res["AuditType"] = boost::any(*auditType);
    }
    if (auditUrl) {
      res["AuditUrl"] = boost::any(*auditUrl);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (eventCallbackUrl) {
      res["EventCallbackUrl"] = boost::any(*eventCallbackUrl);
    }
    if (msgLifeCycle) {
      res["MsgLifeCycle"] = boost::any(*msgLifeCycle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AuditType") != m.end() && !m["AuditType"].empty()) {
      auditType = make_shared<long>(boost::any_cast<long>(m["AuditType"]));
    }
    if (m.find("AuditUrl") != m.end() && !m["AuditUrl"].empty()) {
      auditUrl = make_shared<string>(boost::any_cast<string>(m["AuditUrl"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("EventCallbackUrl") != m.end() && !m["EventCallbackUrl"].empty()) {
      eventCallbackUrl = make_shared<string>(boost::any_cast<string>(m["EventCallbackUrl"]));
    }
    if (m.find("MsgLifeCycle") != m.end() && !m["MsgLifeCycle"].empty()) {
      msgLifeCycle = make_shared<long>(boost::any_cast<long>(m["MsgLifeCycle"]));
    }
  }


  virtual ~CreateLiveMessageAppRequest() = default;
};
class CreateLiveMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appSign{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> requestId{};

  CreateLiveMessageAppResponseBody() {}

  explicit CreateLiveMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appSign) {
      res["AppSign"] = boost::any(*appSign);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppSign") != m.end() && !m["AppSign"].empty()) {
      appSign = make_shared<string>(boost::any_cast<string>(m["AppSign"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLiveMessageAppResponseBody() = default;
};
class CreateLiveMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveMessageAppResponseBody> body{};

  CreateLiveMessageAppResponse() {}

  explicit CreateLiveMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveMessageAppResponse() = default;
};
class CreateLiveMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> administrators{};
  shared_ptr<string> appId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupInfo{};
  shared_ptr<string> groupName{};

  CreateLiveMessageGroupRequest() {}

  explicit CreateLiveMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (administrators) {
      res["Administrators"] = boost::any(*administrators);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupInfo) {
      res["GroupInfo"] = boost::any(*groupInfo);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Administrators") != m.end() && !m["Administrators"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Administrators"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Administrators"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      administrators = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      groupInfo = make_shared<string>(boost::any_cast<string>(m["GroupInfo"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~CreateLiveMessageGroupRequest() = default;
};
class CreateLiveMessageGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> administratorsShrink{};
  shared_ptr<string> appId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupInfo{};
  shared_ptr<string> groupName{};

  CreateLiveMessageGroupShrinkRequest() {}

  explicit CreateLiveMessageGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (administratorsShrink) {
      res["Administrators"] = boost::any(*administratorsShrink);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupInfo) {
      res["GroupInfo"] = boost::any(*groupInfo);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Administrators") != m.end() && !m["Administrators"].empty()) {
      administratorsShrink = make_shared<string>(boost::any_cast<string>(m["Administrators"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      groupInfo = make_shared<string>(boost::any_cast<string>(m["GroupInfo"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~CreateLiveMessageGroupShrinkRequest() = default;
};
class CreateLiveMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> alreadyDelete{};
  shared_ptr<bool> alreadyExists{};
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};

  CreateLiveMessageGroupResponseBody() {}

  explicit CreateLiveMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alreadyDelete) {
      res["AlreadyDelete"] = boost::any(*alreadyDelete);
    }
    if (alreadyExists) {
      res["AlreadyExists"] = boost::any(*alreadyExists);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlreadyDelete") != m.end() && !m["AlreadyDelete"].empty()) {
      alreadyDelete = make_shared<bool>(boost::any_cast<bool>(m["AlreadyDelete"]));
    }
    if (m.find("AlreadyExists") != m.end() && !m["AlreadyExists"].empty()) {
      alreadyExists = make_shared<bool>(boost::any_cast<bool>(m["AlreadyExists"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLiveMessageGroupResponseBody() = default;
};
class CreateLiveMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveMessageGroupResponseBody> body{};

  CreateLiveMessageGroupResponse() {}

  explicit CreateLiveMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveMessageGroupResponse() = default;
};
class CreateLivePrivateLineRequest : public Darabonba::Model {
public:
  shared_ptr<string> accelerationArea{};
  shared_ptr<string> accelerationType{};
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> maxBandwidth{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reuse{};
  shared_ptr<string> streamName{};
  shared_ptr<string> videoCenter{};

  CreateLivePrivateLineRequest() {}

  explicit CreateLivePrivateLineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerationArea) {
      res["AccelerationArea"] = boost::any(*accelerationArea);
    }
    if (accelerationType) {
      res["AccelerationType"] = boost::any(*accelerationType);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxBandwidth) {
      res["MaxBandwidth"] = boost::any(*maxBandwidth);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reuse) {
      res["Reuse"] = boost::any(*reuse);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (videoCenter) {
      res["VideoCenter"] = boost::any(*videoCenter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerationArea") != m.end() && !m["AccelerationArea"].empty()) {
      accelerationArea = make_shared<string>(boost::any_cast<string>(m["AccelerationArea"]));
    }
    if (m.find("AccelerationType") != m.end() && !m["AccelerationType"].empty()) {
      accelerationType = make_shared<string>(boost::any_cast<string>(m["AccelerationType"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxBandwidth") != m.end() && !m["MaxBandwidth"].empty()) {
      maxBandwidth = make_shared<string>(boost::any_cast<string>(m["MaxBandwidth"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reuse") != m.end() && !m["Reuse"].empty()) {
      reuse = make_shared<string>(boost::any_cast<string>(m["Reuse"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("VideoCenter") != m.end() && !m["VideoCenter"].empty()) {
      videoCenter = make_shared<string>(boost::any_cast<string>(m["VideoCenter"]));
    }
  }


  virtual ~CreateLivePrivateLineRequest() = default;
};
class CreateLivePrivateLineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLivePrivateLineResponseBody() {}

  explicit CreateLivePrivateLineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLivePrivateLineResponseBody() = default;
};
class CreateLivePrivateLineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLivePrivateLineResponseBody> body{};

  CreateLivePrivateLineResponse() {}

  explicit CreateLivePrivateLineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLivePrivateLineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLivePrivateLineResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLivePrivateLineResponse() = default;
};
class CreateLivePullToPushRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> dstUrl{};
  shared_ptr<string> endTime{};
  shared_ptr<long> fileIndex{};
  shared_ptr<long> offset{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<long> repeatNumber{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> sourceProtocol{};
  shared_ptr<string> sourceType{};
  shared_ptr<vector<string>> sourceUrls{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskName{};

  CreateLivePullToPushRequest() {}

  explicit CreateLivePullToPushRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (dstUrl) {
      res["DstUrl"] = boost::any(*dstUrl);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileIndex) {
      res["FileIndex"] = boost::any(*fileIndex);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeatNumber) {
      res["RepeatNumber"] = boost::any(*repeatNumber);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (sourceProtocol) {
      res["SourceProtocol"] = boost::any(*sourceProtocol);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceUrls) {
      res["SourceUrls"] = boost::any(*sourceUrls);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("DstUrl") != m.end() && !m["DstUrl"].empty()) {
      dstUrl = make_shared<string>(boost::any_cast<string>(m["DstUrl"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FileIndex") != m.end() && !m["FileIndex"].empty()) {
      fileIndex = make_shared<long>(boost::any_cast<long>(m["FileIndex"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepeatNumber") != m.end() && !m["RepeatNumber"].empty()) {
      repeatNumber = make_shared<long>(boost::any_cast<long>(m["RepeatNumber"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("SourceProtocol") != m.end() && !m["SourceProtocol"].empty()) {
      sourceProtocol = make_shared<string>(boost::any_cast<string>(m["SourceProtocol"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceUrls") != m.end() && !m["SourceUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateLivePullToPushRequest() = default;
};
class CreateLivePullToPushShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> dstUrl{};
  shared_ptr<string> endTime{};
  shared_ptr<long> fileIndex{};
  shared_ptr<long> offset{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<long> repeatNumber{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> sourceProtocol{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceUrlsShrink{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskName{};

  CreateLivePullToPushShrinkRequest() {}

  explicit CreateLivePullToPushShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (dstUrl) {
      res["DstUrl"] = boost::any(*dstUrl);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileIndex) {
      res["FileIndex"] = boost::any(*fileIndex);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeatNumber) {
      res["RepeatNumber"] = boost::any(*repeatNumber);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (sourceProtocol) {
      res["SourceProtocol"] = boost::any(*sourceProtocol);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceUrlsShrink) {
      res["SourceUrls"] = boost::any(*sourceUrlsShrink);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("DstUrl") != m.end() && !m["DstUrl"].empty()) {
      dstUrl = make_shared<string>(boost::any_cast<string>(m["DstUrl"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FileIndex") != m.end() && !m["FileIndex"].empty()) {
      fileIndex = make_shared<long>(boost::any_cast<long>(m["FileIndex"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepeatNumber") != m.end() && !m["RepeatNumber"].empty()) {
      repeatNumber = make_shared<long>(boost::any_cast<long>(m["RepeatNumber"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("SourceProtocol") != m.end() && !m["SourceProtocol"].empty()) {
      sourceProtocol = make_shared<string>(boost::any_cast<string>(m["SourceProtocol"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceUrls") != m.end() && !m["SourceUrls"].empty()) {
      sourceUrlsShrink = make_shared<string>(boost::any_cast<string>(m["SourceUrls"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateLivePullToPushShrinkRequest() = default;
};
class CreateLivePullToPushResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};
  shared_ptr<string> taskId{};

  CreateLivePullToPushResponseBody() {}

  explicit CreateLivePullToPushResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateLivePullToPushResponseBody() = default;
};
class CreateLivePullToPushResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLivePullToPushResponseBody> body{};

  CreateLivePullToPushResponse() {}

  explicit CreateLivePullToPushResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLivePullToPushResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLivePullToPushResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLivePullToPushResponse() = default;
};
class CreateLiveRealTimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> logstore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};

  CreateLiveRealTimeLogDeliveryRequest() {}

  explicit CreateLiveRealTimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateLiveRealTimeLogDeliveryRequest() = default;
};
class CreateLiveRealTimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLiveRealTimeLogDeliveryResponseBody() {}

  explicit CreateLiveRealTimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLiveRealTimeLogDeliveryResponseBody() = default;
};
class CreateLiveRealTimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveRealTimeLogDeliveryResponseBody> body{};

  CreateLiveRealTimeLogDeliveryResponse() {}

  explicit CreateLiveRealTimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveRealTimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveRealTimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveRealTimeLogDeliveryResponse() = default;
};
class CreateLiveStreamMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> dingTalkWebHookUrl{};
  shared_ptr<string> domain{};
  shared_ptr<string> inputList{};
  shared_ptr<string> monitorConfig{};
  shared_ptr<string> monitorName{};
  shared_ptr<string> outputTemplate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stream{};

  CreateLiveStreamMonitorRequest() {}

  explicit CreateLiveStreamMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (dingTalkWebHookUrl) {
      res["DingTalkWebHookUrl"] = boost::any(*dingTalkWebHookUrl);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (inputList) {
      res["InputList"] = boost::any(*inputList);
    }
    if (monitorConfig) {
      res["MonitorConfig"] = boost::any(*monitorConfig);
    }
    if (monitorName) {
      res["MonitorName"] = boost::any(*monitorName);
    }
    if (outputTemplate) {
      res["OutputTemplate"] = boost::any(*outputTemplate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("DingTalkWebHookUrl") != m.end() && !m["DingTalkWebHookUrl"].empty()) {
      dingTalkWebHookUrl = make_shared<string>(boost::any_cast<string>(m["DingTalkWebHookUrl"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      inputList = make_shared<string>(boost::any_cast<string>(m["InputList"]));
    }
    if (m.find("MonitorConfig") != m.end() && !m["MonitorConfig"].empty()) {
      monitorConfig = make_shared<string>(boost::any_cast<string>(m["MonitorConfig"]));
    }
    if (m.find("MonitorName") != m.end() && !m["MonitorName"].empty()) {
      monitorName = make_shared<string>(boost::any_cast<string>(m["MonitorName"]));
    }
    if (m.find("OutputTemplate") != m.end() && !m["OutputTemplate"].empty()) {
      outputTemplate = make_shared<string>(boost::any_cast<string>(m["OutputTemplate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~CreateLiveStreamMonitorRequest() = default;
};
class CreateLiveStreamMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> monitorId{};
  shared_ptr<string> requestId{};

  CreateLiveStreamMonitorResponseBody() {}

  explicit CreateLiveStreamMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLiveStreamMonitorResponseBody() = default;
};
class CreateLiveStreamMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveStreamMonitorResponseBody> body{};

  CreateLiveStreamMonitorResponse() {}

  explicit CreateLiveStreamMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveStreamMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveStreamMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveStreamMonitorResponse() = default;
};
class CreateLiveStreamRecordIndexFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<bool> endTimeIncluded{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  CreateLiveStreamRecordIndexFilesRequest() {}

  explicit CreateLiveStreamRecordIndexFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endTimeIncluded) {
      res["EndTimeIncluded"] = boost::any(*endTimeIncluded);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndTimeIncluded") != m.end() && !m["EndTimeIncluded"].empty()) {
      endTimeIncluded = make_shared<bool>(boost::any_cast<bool>(m["EndTimeIncluded"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~CreateLiveStreamRecordIndexFilesRequest() = default;
};
class CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainName{};
  shared_ptr<double> duration{};
  shared_ptr<string> endTime{};
  shared_ptr<long> height{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<string> recordId{};
  shared_ptr<string> recordUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<long> width{};

  CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo() {}

  explicit CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordUrl) {
      res["RecordUrl"] = boost::any(*recordUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RecordUrl") != m.end() && !m["RecordUrl"].empty()) {
      recordUrl = make_shared<string>(boost::any_cast<string>(m["RecordUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo() = default;
};
class CreateLiveStreamRecordIndexFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo> recordInfo{};
  shared_ptr<string> requestId{};

  CreateLiveStreamRecordIndexFilesResponseBody() {}

  explicit CreateLiveStreamRecordIndexFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordInfo) {
      res["RecordInfo"] = recordInfo ? boost::any(recordInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordInfo") != m.end() && !m["RecordInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordInfo"].type()) {
        CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordInfo"]));
        recordInfo = make_shared<CreateLiveStreamRecordIndexFilesResponseBodyRecordInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLiveStreamRecordIndexFilesResponseBody() = default;
};
class CreateLiveStreamRecordIndexFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveStreamRecordIndexFilesResponseBody> body{};

  CreateLiveStreamRecordIndexFilesResponse() {}

  explicit CreateLiveStreamRecordIndexFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveStreamRecordIndexFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveStreamRecordIndexFilesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveStreamRecordIndexFilesResponse() = default;
};
class CreateMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> appConfig{};
  shared_ptr<string> appName{};
  shared_ptr<map<string, string>> extension{};

  CreateMessageAppRequest() {}

  explicit CreateMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["AppConfig"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      appConfig = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~CreateMessageAppRequest() = default;
};
class CreateMessageAppShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appConfigShrink{};
  shared_ptr<string> appName{};
  shared_ptr<string> extensionShrink{};

  CreateMessageAppShrinkRequest() {}

  explicit CreateMessageAppShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfigShrink) {
      res["AppConfig"] = boost::any(*appConfigShrink);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (extensionShrink) {
      res["Extension"] = boost::any(*extensionShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      appConfigShrink = make_shared<string>(boost::any_cast<string>(m["AppConfig"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extensionShrink = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
  }


  virtual ~CreateMessageAppShrinkRequest() = default;
};
class CreateMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  CreateMessageAppResponseBodyResult() {}

  explicit CreateMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~CreateMessageAppResponseBodyResult() = default;
};
class CreateMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateMessageAppResponseBodyResult> result{};

  CreateMessageAppResponseBody() {}

  explicit CreateMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateMessageAppResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateMessageAppResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateMessageAppResponseBody() = default;
};
class CreateMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMessageAppResponseBody> body{};

  CreateMessageAppResponse() {}

  explicit CreateMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMessageAppResponse() = default;
};
class CreateMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> creatorId{};
  shared_ptr<map<string, string>> extension{};

  CreateMessageGroupRequest() {}

  explicit CreateMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~CreateMessageGroupRequest() = default;
};
class CreateMessageGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extensionShrink{};

  CreateMessageGroupShrinkRequest() {}

  explicit CreateMessageGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extensionShrink) {
      res["Extension"] = boost::any(*extensionShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extensionShrink = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
  }


  virtual ~CreateMessageGroupShrinkRequest() = default;
};
class CreateMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> extension{};
  shared_ptr<string> groupId{};

  CreateMessageGroupResponseBodyResult() {}

  explicit CreateMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Extension"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~CreateMessageGroupResponseBodyResult() = default;
};
class CreateMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateMessageGroupResponseBodyResult> result{};

  CreateMessageGroupResponseBody() {}

  explicit CreateMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateMessageGroupResponseBody() = default;
};
class CreateMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMessageGroupResponseBody> body{};

  CreateMessageGroupResponse() {}

  explicit CreateMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMessageGroupResponse() = default;
};
class CreateMixStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackConfig{};
  shared_ptr<string> domainName{};
  shared_ptr<string> inputStreamList{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> outputConfig{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  CreateMixStreamRequest() {}

  explicit CreateMixStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackConfig) {
      res["CallbackConfig"] = boost::any(*callbackConfig);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (inputStreamList) {
      res["InputStreamList"] = boost::any(*inputStreamList);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackConfig") != m.end() && !m["CallbackConfig"].empty()) {
      callbackConfig = make_shared<string>(boost::any_cast<string>(m["CallbackConfig"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InputStreamList") != m.end() && !m["InputStreamList"].empty()) {
      inputStreamList = make_shared<string>(boost::any_cast<string>(m["InputStreamList"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateMixStreamRequest() = default;
};
class CreateMixStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mixStreamId{};
  shared_ptr<string> requestId{};

  CreateMixStreamResponseBody() {}

  explicit CreateMixStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMixStreamResponseBody() = default;
};
class CreateMixStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMixStreamResponseBody> body{};

  CreateMixStreamResponse() {}

  explicit CreateMixStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMixStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMixStreamResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMixStreamResponse() = default;
};
class CreateRTCWhipStreamAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> displayName{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> userId{};

  CreateRTCWhipStreamAddressRequest() {}

  explicit CreateRTCWhipStreamAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateRTCWhipStreamAddressRequest() = default;
};
class CreateRTCWhipStreamAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> whipAddress{};

  CreateRTCWhipStreamAddressResponseBody() {}

  explicit CreateRTCWhipStreamAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (whipAddress) {
      res["WhipAddress"] = boost::any(*whipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WhipAddress") != m.end() && !m["WhipAddress"].empty()) {
      whipAddress = make_shared<string>(boost::any_cast<string>(m["WhipAddress"]));
    }
  }


  virtual ~CreateRTCWhipStreamAddressResponseBody() = default;
};
class CreateRTCWhipStreamAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRTCWhipStreamAddressResponseBody> body{};

  CreateRTCWhipStreamAddressResponse() {}

  explicit CreateRTCWhipStreamAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRTCWhipStreamAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRTCWhipStreamAddressResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRTCWhipStreamAddressResponse() = default;
};
class CreateRoomRealTimeStreamAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> displayName{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> userId{};

  CreateRoomRealTimeStreamAddressRequest() {}

  explicit CreateRoomRealTimeStreamAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateRoomRealTimeStreamAddressRequest() = default;
};
class CreateRoomRealTimeStreamAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> rtmpAddress{};

  CreateRoomRealTimeStreamAddressResponseBody() {}

  explicit CreateRoomRealTimeStreamAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rtmpAddress) {
      res["RtmpAddress"] = boost::any(*rtmpAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RtmpAddress") != m.end() && !m["RtmpAddress"].empty()) {
      rtmpAddress = make_shared<string>(boost::any_cast<string>(m["RtmpAddress"]));
    }
  }


  virtual ~CreateRoomRealTimeStreamAddressResponseBody() = default;
};
class CreateRoomRealTimeStreamAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRoomRealTimeStreamAddressResponseBody> body{};

  CreateRoomRealTimeStreamAddressResponse() {}

  explicit CreateRoomRealTimeStreamAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRoomRealTimeStreamAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRoomRealTimeStreamAddressResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRoomRealTimeStreamAddressResponse() = default;
};
class CreateRtcAsrTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<long> autoTerminateDelay{};
  shared_ptr<bool> autoTerminateEnabled{};
  shared_ptr<string> callbackURL{};
  shared_ptr<string> channelID{};
  shared_ptr<string> language{};
  shared_ptr<string> mode{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> reportInterval{};
  shared_ptr<string> rtcUserId{};
  shared_ptr<string> SDKAppID{};
  shared_ptr<string> streamURL{};
  shared_ptr<string> targetLanguages{};
  shared_ptr<bool> translateEnabled{};

  CreateRtcAsrTaskRequest() {}

  explicit CreateRtcAsrTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (autoTerminateDelay) {
      res["AutoTerminateDelay"] = boost::any(*autoTerminateDelay);
    }
    if (autoTerminateEnabled) {
      res["AutoTerminateEnabled"] = boost::any(*autoTerminateEnabled);
    }
    if (callbackURL) {
      res["CallbackURL"] = boost::any(*callbackURL);
    }
    if (channelID) {
      res["ChannelID"] = boost::any(*channelID);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reportInterval) {
      res["ReportInterval"] = boost::any(*reportInterval);
    }
    if (rtcUserId) {
      res["RtcUserId"] = boost::any(*rtcUserId);
    }
    if (SDKAppID) {
      res["SDKAppID"] = boost::any(*SDKAppID);
    }
    if (streamURL) {
      res["StreamURL"] = boost::any(*streamURL);
    }
    if (targetLanguages) {
      res["TargetLanguages"] = boost::any(*targetLanguages);
    }
    if (translateEnabled) {
      res["TranslateEnabled"] = boost::any(*translateEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("AutoTerminateDelay") != m.end() && !m["AutoTerminateDelay"].empty()) {
      autoTerminateDelay = make_shared<long>(boost::any_cast<long>(m["AutoTerminateDelay"]));
    }
    if (m.find("AutoTerminateEnabled") != m.end() && !m["AutoTerminateEnabled"].empty()) {
      autoTerminateEnabled = make_shared<bool>(boost::any_cast<bool>(m["AutoTerminateEnabled"]));
    }
    if (m.find("CallbackURL") != m.end() && !m["CallbackURL"].empty()) {
      callbackURL = make_shared<string>(boost::any_cast<string>(m["CallbackURL"]));
    }
    if (m.find("ChannelID") != m.end() && !m["ChannelID"].empty()) {
      channelID = make_shared<string>(boost::any_cast<string>(m["ChannelID"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReportInterval") != m.end() && !m["ReportInterval"].empty()) {
      reportInterval = make_shared<long>(boost::any_cast<long>(m["ReportInterval"]));
    }
    if (m.find("RtcUserId") != m.end() && !m["RtcUserId"].empty()) {
      rtcUserId = make_shared<string>(boost::any_cast<string>(m["RtcUserId"]));
    }
    if (m.find("SDKAppID") != m.end() && !m["SDKAppID"].empty()) {
      SDKAppID = make_shared<string>(boost::any_cast<string>(m["SDKAppID"]));
    }
    if (m.find("StreamURL") != m.end() && !m["StreamURL"].empty()) {
      streamURL = make_shared<string>(boost::any_cast<string>(m["StreamURL"]));
    }
    if (m.find("TargetLanguages") != m.end() && !m["TargetLanguages"].empty()) {
      targetLanguages = make_shared<string>(boost::any_cast<string>(m["TargetLanguages"]));
    }
    if (m.find("TranslateEnabled") != m.end() && !m["TranslateEnabled"].empty()) {
      translateEnabled = make_shared<bool>(boost::any_cast<bool>(m["TranslateEnabled"]));
    }
  }


  virtual ~CreateRtcAsrTaskRequest() = default;
};
class CreateRtcAsrTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};
  shared_ptr<string> taskId{};

  CreateRtcAsrTaskResponseBody() {}

  explicit CreateRtcAsrTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateRtcAsrTaskResponseBody() = default;
};
class CreateRtcAsrTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRtcAsrTaskResponseBody> body{};

  CreateRtcAsrTaskResponse() {}

  explicit CreateRtcAsrTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRtcAsrTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRtcAsrTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRtcAsrTaskResponse() = default;
};
class CreateRtcMPUEventSubRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> channelIds{};

  CreateRtcMPUEventSubRequest() {}

  explicit CreateRtcMPUEventSubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (channelIds) {
      res["ChannelIds"] = boost::any(*channelIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("ChannelIds") != m.end() && !m["ChannelIds"].empty()) {
      channelIds = make_shared<string>(boost::any_cast<string>(m["ChannelIds"]));
    }
  }


  virtual ~CreateRtcMPUEventSubRequest() = default;
};
class CreateRtcMPUEventSubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> subId{};

  CreateRtcMPUEventSubResponseBody() {}

  explicit CreateRtcMPUEventSubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subId) {
      res["SubId"] = boost::any(*subId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubId") != m.end() && !m["SubId"].empty()) {
      subId = make_shared<string>(boost::any_cast<string>(m["SubId"]));
    }
  }


  virtual ~CreateRtcMPUEventSubResponseBody() = default;
};
class CreateRtcMPUEventSubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRtcMPUEventSubResponseBody> body{};

  CreateRtcMPUEventSubResponse() {}

  explicit CreateRtcMPUEventSubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRtcMPUEventSubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRtcMPUEventSubResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRtcMPUEventSubResponse() = default;
};
class DeleteCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteCasterRequest() {}

  explicit DeleteCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCasterRequest() = default;
};
class DeleteCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  DeleteCasterResponseBody() {}

  explicit DeleteCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterResponseBody() = default;
};
class DeleteCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterResponseBody> body{};

  DeleteCasterResponse() {}

  explicit DeleteCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterResponse() = default;
};
class DeleteCasterComponentRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> componentId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteCasterComponentRequest() {}

  explicit DeleteCasterComponentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCasterComponentRequest() = default;
};
class DeleteCasterComponentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> componentId{};
  shared_ptr<string> requestId{};

  DeleteCasterComponentResponseBody() {}

  explicit DeleteCasterComponentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterComponentResponseBody() = default;
};
class DeleteCasterComponentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterComponentResponseBody> body{};

  DeleteCasterComponentResponse() {}

  explicit DeleteCasterComponentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterComponentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterComponentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterComponentResponse() = default;
};
class DeleteCasterEpisodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> episodeId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteCasterEpisodeRequest() {}

  explicit DeleteCasterEpisodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCasterEpisodeRequest() = default;
};
class DeleteCasterEpisodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> requestId{};

  DeleteCasterEpisodeResponseBody() {}

  explicit DeleteCasterEpisodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterEpisodeResponseBody() = default;
};
class DeleteCasterEpisodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterEpisodeResponseBody> body{};

  DeleteCasterEpisodeResponse() {}

  explicit DeleteCasterEpisodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterEpisodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterEpisodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterEpisodeResponse() = default;
};
class DeleteCasterEpisodeGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};
  shared_ptr<string> regionId{};

  DeleteCasterEpisodeGroupRequest() {}

  explicit DeleteCasterEpisodeGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCasterEpisodeGroupRequest() = default;
};
class DeleteCasterEpisodeGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCasterEpisodeGroupResponseBody() {}

  explicit DeleteCasterEpisodeGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterEpisodeGroupResponseBody() = default;
};
class DeleteCasterEpisodeGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterEpisodeGroupResponseBody> body{};

  DeleteCasterEpisodeGroupResponse() {}

  explicit DeleteCasterEpisodeGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterEpisodeGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterEpisodeGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterEpisodeGroupResponse() = default;
};
class DeleteCasterLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteCasterLayoutRequest() {}

  explicit DeleteCasterLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCasterLayoutRequest() = default;
};
class DeleteCasterLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> requestId{};

  DeleteCasterLayoutResponseBody() {}

  explicit DeleteCasterLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterLayoutResponseBody() = default;
};
class DeleteCasterLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterLayoutResponseBody> body{};

  DeleteCasterLayoutResponse() {}

  explicit DeleteCasterLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterLayoutResponse() = default;
};
class DeleteCasterProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteCasterProgramRequest() {}

  explicit DeleteCasterProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCasterProgramRequest() = default;
};
class DeleteCasterProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  DeleteCasterProgramResponseBody() {}

  explicit DeleteCasterProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterProgramResponseBody() = default;
};
class DeleteCasterProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterProgramResponseBody> body{};

  DeleteCasterProgramResponse() {}

  explicit DeleteCasterProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterProgramResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterProgramResponse() = default;
};
class DeleteCasterSceneConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sceneId{};
  shared_ptr<string> type{};

  DeleteCasterSceneConfigRequest() {}

  explicit DeleteCasterSceneConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteCasterSceneConfigRequest() = default;
};
class DeleteCasterSceneConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCasterSceneConfigResponseBody() {}

  explicit DeleteCasterSceneConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterSceneConfigResponseBody() = default;
};
class DeleteCasterSceneConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterSceneConfigResponseBody> body{};

  DeleteCasterSceneConfigResponse() {}

  explicit DeleteCasterSceneConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterSceneConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterSceneConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterSceneConfigResponse() = default;
};
class DeleteCasterVideoResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};

  DeleteCasterVideoResourceRequest() {}

  explicit DeleteCasterVideoResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~DeleteCasterVideoResourceRequest() = default;
};
class DeleteCasterVideoResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCasterVideoResourceResponseBody() {}

  explicit DeleteCasterVideoResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCasterVideoResourceResponseBody() = default;
};
class DeleteCasterVideoResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCasterVideoResourceResponseBody> body{};

  DeleteCasterVideoResourceResponse() {}

  explicit DeleteCasterVideoResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCasterVideoResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCasterVideoResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCasterVideoResourceResponse() = default;
};
class DeleteChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};

  DeleteChannelRequest() {}

  explicit DeleteChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
  }


  virtual ~DeleteChannelRequest() = default;
};
class DeleteChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteChannelResponseBody() {}

  explicit DeleteChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteChannelResponseBody() = default;
};
class DeleteChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteChannelResponseBody> body{};

  DeleteChannelResponse() {}

  explicit DeleteChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteChannelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteChannelResponse() = default;
};
class DeleteCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> template_{};

  DeleteCustomTemplateRequest() {}

  explicit DeleteCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~DeleteCustomTemplateRequest() = default;
};
class DeleteCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomTemplateResponseBody() {}

  explicit DeleteCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomTemplateResponseBody() = default;
};
class DeleteCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomTemplateResponseBody> body{};

  DeleteCustomTemplateResponse() {}

  explicit DeleteCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomTemplateResponse() = default;
};
class DeleteEdgeTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteEdgeTranscodeJobRequest() {}

  explicit DeleteEdgeTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteEdgeTranscodeJobRequest() = default;
};
class DeleteEdgeTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEdgeTranscodeJobResponseBody() {}

  explicit DeleteEdgeTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEdgeTranscodeJobResponseBody() = default;
};
class DeleteEdgeTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEdgeTranscodeJobResponseBody> body{};

  DeleteEdgeTranscodeJobResponse() {}

  explicit DeleteEdgeTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEdgeTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEdgeTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEdgeTranscodeJobResponse() = default;
};
class DeleteEventSubRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> subscribeId{};

  DeleteEventSubRequest() {}

  explicit DeleteEventSubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (subscribeId) {
      res["SubscribeId"] = boost::any(*subscribeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("SubscribeId") != m.end() && !m["SubscribeId"].empty()) {
      subscribeId = make_shared<string>(boost::any_cast<string>(m["SubscribeId"]));
    }
  }


  virtual ~DeleteEventSubRequest() = default;
};
class DeleteEventSubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEventSubResponseBody() {}

  explicit DeleteEventSubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEventSubResponseBody() = default;
};
class DeleteEventSubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEventSubResponseBody> body{};

  DeleteEventSubResponse() {}

  explicit DeleteEventSubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEventSubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEventSubResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEventSubResponse() = default;
};
class DeleteLiveAIProduceRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> rulesId{};
  shared_ptr<string> suffixName{};

  DeleteLiveAIProduceRulesRequest() {}

  explicit DeleteLiveAIProduceRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rulesId) {
      res["RulesId"] = boost::any(*rulesId);
    }
    if (suffixName) {
      res["SuffixName"] = boost::any(*suffixName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RulesId") != m.end() && !m["RulesId"].empty()) {
      rulesId = make_shared<string>(boost::any_cast<string>(m["RulesId"]));
    }
    if (m.find("SuffixName") != m.end() && !m["SuffixName"].empty()) {
      suffixName = make_shared<string>(boost::any_cast<string>(m["SuffixName"]));
    }
  }


  virtual ~DeleteLiveAIProduceRulesRequest() = default;
};
class DeleteLiveAIProduceRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveAIProduceRulesResponseBody() {}

  explicit DeleteLiveAIProduceRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveAIProduceRulesResponseBody() = default;
};
class DeleteLiveAIProduceRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveAIProduceRulesResponseBody> body{};

  DeleteLiveAIProduceRulesResponse() {}

  explicit DeleteLiveAIProduceRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveAIProduceRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveAIProduceRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveAIProduceRulesResponse() = default;
};
class DeleteLiveAIStudioRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> studioId{};

  DeleteLiveAIStudioRequest() {}

  explicit DeleteLiveAIStudioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (studioId) {
      res["StudioId"] = boost::any(*studioId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StudioId") != m.end() && !m["StudioId"].empty()) {
      studioId = make_shared<string>(boost::any_cast<string>(m["StudioId"]));
    }
  }


  virtual ~DeleteLiveAIStudioRequest() = default;
};
class DeleteLiveAIStudioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveAIStudioResponseBody() {}

  explicit DeleteLiveAIStudioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveAIStudioResponseBody() = default;
};
class DeleteLiveAIStudioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveAIStudioResponseBody> body{};

  DeleteLiveAIStudioResponse() {}

  explicit DeleteLiveAIStudioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveAIStudioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveAIStudioResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveAIStudioResponse() = default;
};
class DeleteLiveAISubtitleRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subtitleId{};
  shared_ptr<string> subtitleName{};

  DeleteLiveAISubtitleRequest() {}

  explicit DeleteLiveAISubtitleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subtitleId) {
      res["SubtitleId"] = boost::any(*subtitleId);
    }
    if (subtitleName) {
      res["SubtitleName"] = boost::any(*subtitleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubtitleId") != m.end() && !m["SubtitleId"].empty()) {
      subtitleId = make_shared<string>(boost::any_cast<string>(m["SubtitleId"]));
    }
    if (m.find("SubtitleName") != m.end() && !m["SubtitleName"].empty()) {
      subtitleName = make_shared<string>(boost::any_cast<string>(m["SubtitleName"]));
    }
  }


  virtual ~DeleteLiveAISubtitleRequest() = default;
};
class DeleteLiveAISubtitleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveAISubtitleResponseBody() {}

  explicit DeleteLiveAISubtitleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveAISubtitleResponseBody() = default;
};
class DeleteLiveAISubtitleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveAISubtitleResponseBody> body{};

  DeleteLiveAISubtitleResponse() {}

  explicit DeleteLiveAISubtitleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveAISubtitleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveAISubtitleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveAISubtitleResponse() = default;
};
class DeleteLiveAppRecordConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> streamName{};

  DeleteLiveAppRecordConfigRequest() {}

  explicit DeleteLiveAppRecordConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLiveAppRecordConfigRequest() = default;
};
class DeleteLiveAppRecordConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveAppRecordConfigResponseBody() {}

  explicit DeleteLiveAppRecordConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveAppRecordConfigResponseBody() = default;
};
class DeleteLiveAppRecordConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveAppRecordConfigResponseBody> body{};

  DeleteLiveAppRecordConfigResponse() {}

  explicit DeleteLiveAppRecordConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveAppRecordConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveAppRecordConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveAppRecordConfigResponse() = default;
};
class DeleteLiveAppSnapshotConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveAppSnapshotConfigRequest() {}

  explicit DeleteLiveAppSnapshotConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveAppSnapshotConfigRequest() = default;
};
class DeleteLiveAppSnapshotConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveAppSnapshotConfigResponseBody() {}

  explicit DeleteLiveAppSnapshotConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveAppSnapshotConfigResponseBody() = default;
};
class DeleteLiveAppSnapshotConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveAppSnapshotConfigResponseBody> body{};

  DeleteLiveAppSnapshotConfigResponse() {}

  explicit DeleteLiveAppSnapshotConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveAppSnapshotConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveAppSnapshotConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveAppSnapshotConfigResponse() = default;
};
class DeleteLiveAudioAuditConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DeleteLiveAudioAuditConfigRequest() {}

  explicit DeleteLiveAudioAuditConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLiveAudioAuditConfigRequest() = default;
};
class DeleteLiveAudioAuditConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveAudioAuditConfigResponseBody() {}

  explicit DeleteLiveAudioAuditConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveAudioAuditConfigResponseBody() = default;
};
class DeleteLiveAudioAuditConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveAudioAuditConfigResponseBody> body{};

  DeleteLiveAudioAuditConfigResponse() {}

  explicit DeleteLiveAudioAuditConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveAudioAuditConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveAudioAuditConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveAudioAuditConfigResponse() = default;
};
class DeleteLiveAudioAuditNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteLiveAudioAuditNotifyConfigRequest() {}

  explicit DeleteLiveAudioAuditNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteLiveAudioAuditNotifyConfigRequest() = default;
};
class DeleteLiveAudioAuditNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveAudioAuditNotifyConfigResponseBody() {}

  explicit DeleteLiveAudioAuditNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveAudioAuditNotifyConfigResponseBody() = default;
};
class DeleteLiveAudioAuditNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveAudioAuditNotifyConfigResponseBody> body{};

  DeleteLiveAudioAuditNotifyConfigResponse() {}

  explicit DeleteLiveAudioAuditNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveAudioAuditNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveAudioAuditNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveAudioAuditNotifyConfigResponse() = default;
};
class DeleteLiveCenterTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dstUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DeleteLiveCenterTransferRequest() {}

  explicit DeleteLiveCenterTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dstUrl) {
      res["DstUrl"] = boost::any(*dstUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DstUrl") != m.end() && !m["DstUrl"].empty()) {
      dstUrl = make_shared<string>(boost::any_cast<string>(m["DstUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLiveCenterTransferRequest() = default;
};
class DeleteLiveCenterTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveCenterTransferResponseBody() {}

  explicit DeleteLiveCenterTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveCenterTransferResponseBody() = default;
};
class DeleteLiveCenterTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveCenterTransferResponseBody> body{};

  DeleteLiveCenterTransferResponse() {}

  explicit DeleteLiveCenterTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveCenterTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveCenterTransferResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveCenterTransferResponse() = default;
};
class DeleteLiveDelayConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stream{};

  DeleteLiveDelayConfigRequest() {}

  explicit DeleteLiveDelayConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~DeleteLiveDelayConfigRequest() = default;
};
class DeleteLiveDelayConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveDelayConfigResponseBody() {}

  explicit DeleteLiveDelayConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveDelayConfigResponseBody() = default;
};
class DeleteLiveDelayConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveDelayConfigResponseBody> body{};

  DeleteLiveDelayConfigResponse() {}

  explicit DeleteLiveDelayConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveDelayConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveDelayConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveDelayConfigResponse() = default;
};
class DeleteLiveDetectNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveDetectNotifyConfigRequest() {}

  explicit DeleteLiveDetectNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveDetectNotifyConfigRequest() = default;
};
class DeleteLiveDetectNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveDetectNotifyConfigResponseBody() {}

  explicit DeleteLiveDetectNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveDetectNotifyConfigResponseBody() = default;
};
class DeleteLiveDetectNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveDetectNotifyConfigResponseBody> body{};

  DeleteLiveDetectNotifyConfigResponse() {}

  explicit DeleteLiveDetectNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveDetectNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveDetectNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveDetectNotifyConfigResponse() = default;
};
class DeleteLiveDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveDomainRequest() {}

  explicit DeleteLiveDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveDomainRequest() = default;
};
class DeleteLiveDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveDomainResponseBody() {}

  explicit DeleteLiveDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveDomainResponseBody() = default;
};
class DeleteLiveDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveDomainResponseBody> body{};

  DeleteLiveDomainResponse() {}

  explicit DeleteLiveDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveDomainResponse() = default;
};
class DeleteLiveDomainMappingRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> pullDomain{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> securityToken{};

  DeleteLiveDomainMappingRequest() {}

  explicit DeleteLiveDomainMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pullDomain) {
      res["PullDomain"] = boost::any(*pullDomain);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PullDomain") != m.end() && !m["PullDomain"].empty()) {
      pullDomain = make_shared<string>(boost::any_cast<string>(m["PullDomain"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveDomainMappingRequest() = default;
};
class DeleteLiveDomainMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveDomainMappingResponseBody() {}

  explicit DeleteLiveDomainMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveDomainMappingResponseBody() = default;
};
class DeleteLiveDomainMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveDomainMappingResponseBody> body{};

  DeleteLiveDomainMappingResponse() {}

  explicit DeleteLiveDomainMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveDomainMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveDomainMappingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveDomainMappingResponse() = default;
};
class DeleteLiveDomainPlayMappingRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> playDomain{};
  shared_ptr<string> pullDomain{};
  shared_ptr<string> regionId{};

  DeleteLiveDomainPlayMappingRequest() {}

  explicit DeleteLiveDomainPlayMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    if (pullDomain) {
      res["PullDomain"] = boost::any(*pullDomain);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
    if (m.find("PullDomain") != m.end() && !m["PullDomain"].empty()) {
      pullDomain = make_shared<string>(boost::any_cast<string>(m["PullDomain"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteLiveDomainPlayMappingRequest() = default;
};
class DeleteLiveDomainPlayMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveDomainPlayMappingResponseBody() {}

  explicit DeleteLiveDomainPlayMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveDomainPlayMappingResponseBody() = default;
};
class DeleteLiveDomainPlayMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveDomainPlayMappingResponseBody> body{};

  DeleteLiveDomainPlayMappingResponse() {}

  explicit DeleteLiveDomainPlayMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveDomainPlayMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveDomainPlayMappingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveDomainPlayMappingResponse() = default;
};
class DeleteLiveEdgeTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteLiveEdgeTransferRequest() {}

  explicit DeleteLiveEdgeTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteLiveEdgeTransferRequest() = default;
};
class DeleteLiveEdgeTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveEdgeTransferResponseBody() {}

  explicit DeleteLiveEdgeTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveEdgeTransferResponseBody() = default;
};
class DeleteLiveEdgeTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveEdgeTransferResponseBody> body{};

  DeleteLiveEdgeTransferResponse() {}

  explicit DeleteLiveEdgeTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveEdgeTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveEdgeTransferResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveEdgeTransferResponse() = default;
};
class DeleteLiveLazyPullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteLiveLazyPullStreamInfoConfigRequest() {}

  explicit DeleteLiveLazyPullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteLiveLazyPullStreamInfoConfigRequest() = default;
};
class DeleteLiveLazyPullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveLazyPullStreamInfoConfigResponseBody() {}

  explicit DeleteLiveLazyPullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveLazyPullStreamInfoConfigResponseBody() = default;
};
class DeleteLiveLazyPullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveLazyPullStreamInfoConfigResponseBody> body{};

  DeleteLiveLazyPullStreamInfoConfigResponse() {}

  explicit DeleteLiveLazyPullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveLazyPullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveLazyPullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveLazyPullStreamInfoConfigResponse() = default;
};
class DeleteLiveMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorId{};

  DeleteLiveMessageGroupRequest() {}

  explicit DeleteLiveMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
  }


  virtual ~DeleteLiveMessageGroupRequest() = default;
};
class DeleteLiveMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};

  DeleteLiveMessageGroupResponseBody() {}

  explicit DeleteLiveMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveMessageGroupResponseBody() = default;
};
class DeleteLiveMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveMessageGroupResponseBody> body{};

  DeleteLiveMessageGroupResponse() {}

  explicit DeleteLiveMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveMessageGroupResponse() = default;
};
class DeleteLiveMessageGroupMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> deleterId{};
  shared_ptr<string> deleterInfo{};
  shared_ptr<string> groupId{};
  shared_ptr<string> messageId{};

  DeleteLiveMessageGroupMessageRequest() {}

  explicit DeleteLiveMessageGroupMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (deleterId) {
      res["DeleterId"] = boost::any(*deleterId);
    }
    if (deleterInfo) {
      res["DeleterInfo"] = boost::any(*deleterInfo);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DeleterId") != m.end() && !m["DeleterId"].empty()) {
      deleterId = make_shared<string>(boost::any_cast<string>(m["DeleterId"]));
    }
    if (m.find("DeleterInfo") != m.end() && !m["DeleterInfo"].empty()) {
      deleterInfo = make_shared<string>(boost::any_cast<string>(m["DeleterInfo"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~DeleteLiveMessageGroupMessageRequest() = default;
};
class DeleteLiveMessageGroupMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> messageId{};
  shared_ptr<string> requestId{};

  DeleteLiveMessageGroupMessageResponseBody() {}

  explicit DeleteLiveMessageGroupMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveMessageGroupMessageResponseBody() = default;
};
class DeleteLiveMessageGroupMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveMessageGroupMessageResponseBody> body{};

  DeleteLiveMessageGroupMessageResponse() {}

  explicit DeleteLiveMessageGroupMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveMessageGroupMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveMessageGroupMessageResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveMessageGroupMessageResponse() = default;
};
class DeleteLiveMessageUserMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> deleterId{};
  shared_ptr<string> deleterInfo{};
  shared_ptr<string> messageId{};
  shared_ptr<string> receiverId{};

  DeleteLiveMessageUserMessageRequest() {}

  explicit DeleteLiveMessageUserMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (deleterId) {
      res["DeleterId"] = boost::any(*deleterId);
    }
    if (deleterInfo) {
      res["DeleterInfo"] = boost::any(*deleterInfo);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (receiverId) {
      res["ReceiverId"] = boost::any(*receiverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DeleterId") != m.end() && !m["DeleterId"].empty()) {
      deleterId = make_shared<string>(boost::any_cast<string>(m["DeleterId"]));
    }
    if (m.find("DeleterInfo") != m.end() && !m["DeleterInfo"].empty()) {
      deleterInfo = make_shared<string>(boost::any_cast<string>(m["DeleterInfo"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("ReceiverId") != m.end() && !m["ReceiverId"].empty()) {
      receiverId = make_shared<string>(boost::any_cast<string>(m["ReceiverId"]));
    }
  }


  virtual ~DeleteLiveMessageUserMessageRequest() = default;
};
class DeleteLiveMessageUserMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveMessageUserMessageResponseBody() {}

  explicit DeleteLiveMessageUserMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveMessageUserMessageResponseBody() = default;
};
class DeleteLiveMessageUserMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveMessageUserMessageResponseBody> body{};

  DeleteLiveMessageUserMessageResponse() {}

  explicit DeleteLiveMessageUserMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveMessageUserMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveMessageUserMessageResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveMessageUserMessageResponse() = default;
};
class DeleteLivePackageConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DeleteLivePackageConfigRequest() {}

  explicit DeleteLivePackageConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLivePackageConfigRequest() = default;
};
class DeleteLivePackageConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLivePackageConfigResponseBody() {}

  explicit DeleteLivePackageConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLivePackageConfigResponseBody() = default;
};
class DeleteLivePackageConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLivePackageConfigResponseBody> body{};

  DeleteLivePackageConfigResponse() {}

  explicit DeleteLivePackageConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLivePackageConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLivePackageConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLivePackageConfigResponse() = default;
};
class DeleteLivePrivateLineRequest : public Darabonba::Model {
public:
  shared_ptr<string> accelerationType{};
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DeleteLivePrivateLineRequest() {}

  explicit DeleteLivePrivateLineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerationType) {
      res["AccelerationType"] = boost::any(*accelerationType);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerationType") != m.end() && !m["AccelerationType"].empty()) {
      accelerationType = make_shared<string>(boost::any_cast<string>(m["AccelerationType"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLivePrivateLineRequest() = default;
};
class DeleteLivePrivateLineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLivePrivateLineResponseBody() {}

  explicit DeleteLivePrivateLineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLivePrivateLineResponseBody() = default;
};
class DeleteLivePrivateLineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLivePrivateLineResponseBody> body{};

  DeleteLivePrivateLineResponse() {}

  explicit DeleteLivePrivateLineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLivePrivateLineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLivePrivateLineResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLivePrivateLineResponse() = default;
};
class DeleteLivePullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DeleteLivePullStreamInfoConfigRequest() {}

  explicit DeleteLivePullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLivePullStreamInfoConfigRequest() = default;
};
class DeleteLivePullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLivePullStreamInfoConfigResponseBody() {}

  explicit DeleteLivePullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLivePullStreamInfoConfigResponseBody() = default;
};
class DeleteLivePullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLivePullStreamInfoConfigResponseBody> body{};

  DeleteLivePullStreamInfoConfigResponse() {}

  explicit DeleteLivePullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLivePullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLivePullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLivePullStreamInfoConfigResponse() = default;
};
class DeleteLivePullToPushRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  DeleteLivePullToPushRequest() {}

  explicit DeleteLivePullToPushRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DeleteLivePullToPushRequest() = default;
};
class DeleteLivePullToPushResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  DeleteLivePullToPushResponseBody() {}

  explicit DeleteLivePullToPushResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~DeleteLivePullToPushResponseBody() = default;
};
class DeleteLivePullToPushResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLivePullToPushResponseBody> body{};

  DeleteLivePullToPushResponse() {}

  explicit DeleteLivePullToPushResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLivePullToPushResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLivePullToPushResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLivePullToPushResponse() = default;
};
class DeleteLiveRealTimeLogLogstoreRequest : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};

  DeleteLiveRealTimeLogLogstoreRequest() {}

  explicit DeleteLiveRealTimeLogLogstoreRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteLiveRealTimeLogLogstoreRequest() = default;
};
class DeleteLiveRealTimeLogLogstoreResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveRealTimeLogLogstoreResponseBody() {}

  explicit DeleteLiveRealTimeLogLogstoreResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRealTimeLogLogstoreResponseBody() = default;
};
class DeleteLiveRealTimeLogLogstoreResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRealTimeLogLogstoreResponseBody> body{};

  DeleteLiveRealTimeLogLogstoreResponse() {}

  explicit DeleteLiveRealTimeLogLogstoreResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRealTimeLogLogstoreResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRealTimeLogLogstoreResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRealTimeLogLogstoreResponse() = default;
};
class DeleteLiveRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> logstore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};

  DeleteLiveRealtimeLogDeliveryRequest() {}

  explicit DeleteLiveRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteLiveRealtimeLogDeliveryRequest() = default;
};
class DeleteLiveRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveRealtimeLogDeliveryResponseBody() {}

  explicit DeleteLiveRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRealtimeLogDeliveryResponseBody() = default;
};
class DeleteLiveRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRealtimeLogDeliveryResponseBody> body{};

  DeleteLiveRealtimeLogDeliveryResponse() {}

  explicit DeleteLiveRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRealtimeLogDeliveryResponse() = default;
};
class DeleteLiveRecordNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveRecordNotifyConfigRequest() {}

  explicit DeleteLiveRecordNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveRecordNotifyConfigRequest() = default;
};
class DeleteLiveRecordNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveRecordNotifyConfigResponseBody() {}

  explicit DeleteLiveRecordNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRecordNotifyConfigResponseBody() = default;
};
class DeleteLiveRecordNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRecordNotifyConfigResponseBody> body{};

  DeleteLiveRecordNotifyConfigResponse() {}

  explicit DeleteLiveRecordNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRecordNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRecordNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRecordNotifyConfigResponse() = default;
};
class DeleteLiveRecordVodConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DeleteLiveRecordVodConfigRequest() {}

  explicit DeleteLiveRecordVodConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLiveRecordVodConfigRequest() = default;
};
class DeleteLiveRecordVodConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveRecordVodConfigResponseBody() {}

  explicit DeleteLiveRecordVodConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRecordVodConfigResponseBody() = default;
};
class DeleteLiveRecordVodConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRecordVodConfigResponseBody> body{};

  DeleteLiveRecordVodConfigResponse() {}

  explicit DeleteLiveRecordVodConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRecordVodConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRecordVodConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRecordVodConfigResponse() = default;
};
class DeleteLiveSnapshotDetectPornConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveSnapshotDetectPornConfigRequest() {}

  explicit DeleteLiveSnapshotDetectPornConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveSnapshotDetectPornConfigRequest() = default;
};
class DeleteLiveSnapshotDetectPornConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveSnapshotDetectPornConfigResponseBody() {}

  explicit DeleteLiveSnapshotDetectPornConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveSnapshotDetectPornConfigResponseBody() = default;
};
class DeleteLiveSnapshotDetectPornConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveSnapshotDetectPornConfigResponseBody> body{};

  DeleteLiveSnapshotDetectPornConfigResponse() {}

  explicit DeleteLiveSnapshotDetectPornConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveSnapshotDetectPornConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveSnapshotDetectPornConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveSnapshotDetectPornConfigResponse() = default;
};
class DeleteLiveSnapshotNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteLiveSnapshotNotifyConfigRequest() {}

  explicit DeleteLiveSnapshotNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteLiveSnapshotNotifyConfigRequest() = default;
};
class DeleteLiveSnapshotNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveSnapshotNotifyConfigResponseBody() {}

  explicit DeleteLiveSnapshotNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveSnapshotNotifyConfigResponseBody() = default;
};
class DeleteLiveSnapshotNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveSnapshotNotifyConfigResponseBody> body{};

  DeleteLiveSnapshotNotifyConfigResponse() {}

  explicit DeleteLiveSnapshotNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveSnapshotNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveSnapshotNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveSnapshotNotifyConfigResponse() = default;
};
class DeleteLiveSpecificStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteLiveSpecificStagingConfigRequest() {}

  explicit DeleteLiveSpecificStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLiveSpecificStagingConfigRequest() = default;
};
class DeleteLiveSpecificStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveSpecificStagingConfigResponseBody() {}

  explicit DeleteLiveSpecificStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveSpecificStagingConfigResponseBody() = default;
};
class DeleteLiveSpecificStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveSpecificStagingConfigResponseBody> body{};

  DeleteLiveSpecificStagingConfigResponse() {}

  explicit DeleteLiveSpecificStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveSpecificStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveSpecificStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveSpecificStagingConfigResponse() = default;
};
class DeleteLiveStreamBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DeleteLiveStreamBlockRequest() {}

  explicit DeleteLiveStreamBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLiveStreamBlockRequest() = default;
};
class DeleteLiveStreamBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DeleteLiveStreamBlockResponseBody() {}

  explicit DeleteLiveStreamBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DeleteLiveStreamBlockResponseBody() = default;
};
class DeleteLiveStreamBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamBlockResponseBody> body{};

  DeleteLiveStreamBlockResponse() {}

  explicit DeleteLiveStreamBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamBlockResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamBlockResponse() = default;
};
class DeleteLiveStreamMergeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DeleteLiveStreamMergeRequest() {}

  explicit DeleteLiveStreamMergeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLiveStreamMergeRequest() = default;
};
class DeleteLiveStreamMergeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveStreamMergeResponseBody() {}

  explicit DeleteLiveStreamMergeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamMergeResponseBody() = default;
};
class DeleteLiveStreamMergeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamMergeResponseBody> body{};

  DeleteLiveStreamMergeResponse() {}

  explicit DeleteLiveStreamMergeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamMergeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamMergeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamMergeResponse() = default;
};
class DeleteLiveStreamMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> monitorId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteLiveStreamMonitorRequest() {}

  explicit DeleteLiveStreamMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteLiveStreamMonitorRequest() = default;
};
class DeleteLiveStreamMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveStreamMonitorResponseBody() {}

  explicit DeleteLiveStreamMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamMonitorResponseBody() = default;
};
class DeleteLiveStreamMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamMonitorResponseBody> body{};

  DeleteLiveStreamMonitorResponse() {}

  explicit DeleteLiveStreamMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamMonitorResponse() = default;
};
class DeleteLiveStreamRecordIndexFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> recordId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> removeFile{};
  shared_ptr<string> streamName{};

  DeleteLiveStreamRecordIndexFilesRequest() {}

  explicit DeleteLiveStreamRecordIndexFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (removeFile) {
      res["RemoveFile"] = boost::any(*removeFile);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoveFile") != m.end() && !m["RemoveFile"].empty()) {
      removeFile = make_shared<string>(boost::any_cast<string>(m["RemoveFile"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteLiveStreamRecordIndexFilesRequest() = default;
};
class DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> recordId{};

  DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo() {}

  explicit DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
  }


  virtual ~DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo() = default;
};
class DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo>> recordDeleteInfo{};

  DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList() {}

  explicit DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordDeleteInfo) {
      vector<boost::any> temp1;
      for(auto item1:*recordDeleteInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordDeleteInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordDeleteInfo") != m.end() && !m["RecordDeleteInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordDeleteInfo"].type()) {
        vector<DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordDeleteInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordDeleteInfo = make_shared<vector<DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoListRecordDeleteInfo>>(expect1);
      }
    }
  }


  virtual ~DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList() = default;
};
class DeleteLiveStreamRecordIndexFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList> recordDeleteInfoList{};
  shared_ptr<string> requestId{};

  DeleteLiveStreamRecordIndexFilesResponseBody() {}

  explicit DeleteLiveStreamRecordIndexFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (recordDeleteInfoList) {
      res["RecordDeleteInfoList"] = recordDeleteInfoList ? boost::any(recordDeleteInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RecordDeleteInfoList") != m.end() && !m["RecordDeleteInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordDeleteInfoList"].type()) {
        DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordDeleteInfoList"]));
        recordDeleteInfoList = make_shared<DeleteLiveStreamRecordIndexFilesResponseBodyRecordDeleteInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamRecordIndexFilesResponseBody() = default;
};
class DeleteLiveStreamRecordIndexFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamRecordIndexFilesResponseBody> body{};

  DeleteLiveStreamRecordIndexFilesResponse() {}

  explicit DeleteLiveStreamRecordIndexFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamRecordIndexFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamRecordIndexFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamRecordIndexFilesResponse() = default;
};
class DeleteLiveStreamTranscodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> template_{};

  DeleteLiveStreamTranscodeRequest() {}

  explicit DeleteLiveStreamTranscodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~DeleteLiveStreamTranscodeRequest() = default;
};
class DeleteLiveStreamTranscodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveStreamTranscodeResponseBody() {}

  explicit DeleteLiveStreamTranscodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamTranscodeResponseBody() = default;
};
class DeleteLiveStreamTranscodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamTranscodeResponseBody> body{};

  DeleteLiveStreamTranscodeResponse() {}

  explicit DeleteLiveStreamTranscodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamTranscodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamTranscodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamTranscodeResponse() = default;
};
class DeleteLiveStreamWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> templateId{};

  DeleteLiveStreamWatermarkRequest() {}

  explicit DeleteLiveStreamWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteLiveStreamWatermarkRequest() = default;
};
class DeleteLiveStreamWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveStreamWatermarkResponseBody() {}

  explicit DeleteLiveStreamWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamWatermarkResponseBody() = default;
};
class DeleteLiveStreamWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamWatermarkResponseBody> body{};

  DeleteLiveStreamWatermarkResponse() {}

  explicit DeleteLiveStreamWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamWatermarkResponse() = default;
};
class DeleteLiveStreamWatermarkRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> stream{};

  DeleteLiveStreamWatermarkRuleRequest() {}

  explicit DeleteLiveStreamWatermarkRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~DeleteLiveStreamWatermarkRuleRequest() = default;
};
class DeleteLiveStreamWatermarkRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveStreamWatermarkRuleResponseBody() {}

  explicit DeleteLiveStreamWatermarkRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamWatermarkRuleResponseBody() = default;
};
class DeleteLiveStreamWatermarkRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamWatermarkRuleResponseBody> body{};

  DeleteLiveStreamWatermarkRuleResponse() {}

  explicit DeleteLiveStreamWatermarkRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamWatermarkRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamWatermarkRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamWatermarkRuleResponse() = default;
};
class DeleteLiveStreamsNotifyUrlConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteLiveStreamsNotifyUrlConfigRequest() {}

  explicit DeleteLiveStreamsNotifyUrlConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteLiveStreamsNotifyUrlConfigRequest() = default;
};
class DeleteLiveStreamsNotifyUrlConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveStreamsNotifyUrlConfigResponseBody() {}

  explicit DeleteLiveStreamsNotifyUrlConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveStreamsNotifyUrlConfigResponseBody() = default;
};
class DeleteLiveStreamsNotifyUrlConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveStreamsNotifyUrlConfigResponseBody> body{};

  DeleteLiveStreamsNotifyUrlConfigResponse() {}

  explicit DeleteLiveStreamsNotifyUrlConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveStreamsNotifyUrlConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveStreamsNotifyUrlConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveStreamsNotifyUrlConfigResponse() = default;
};
class DeleteMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DeleteMessageAppRequest() {}

  explicit DeleteMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteMessageAppRequest() = default;
};
class DeleteMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  DeleteMessageAppResponseBodyResult() {}

  explicit DeleteMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMessageAppResponseBodyResult() = default;
};
class DeleteMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteMessageAppResponseBodyResult> result{};

  DeleteMessageAppResponseBody() {}

  explicit DeleteMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DeleteMessageAppResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DeleteMessageAppResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DeleteMessageAppResponseBody() = default;
};
class DeleteMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMessageAppResponseBody> body{};

  DeleteMessageAppResponse() {}

  explicit DeleteMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMessageAppResponse() = default;
};
class DeleteMixStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> mixStreamId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DeleteMixStreamRequest() {}

  explicit DeleteMixStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteMixStreamRequest() = default;
};
class DeleteMixStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mixStreamId{};
  shared_ptr<string> requestId{};

  DeleteMixStreamResponseBody() {}

  explicit DeleteMixStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMixStreamResponseBody() = default;
};
class DeleteMixStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMixStreamResponseBody> body{};

  DeleteMixStreamResponse() {}

  explicit DeleteMixStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMixStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMixStreamResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMixStreamResponse() = default;
};
class DeletePlaylistRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};
  shared_ptr<string> regionId{};

  DeletePlaylistRequest() {}

  explicit DeletePlaylistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeletePlaylistRequest() = default;
};
class DeletePlaylistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  DeletePlaylistResponseBody() {}

  explicit DeletePlaylistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePlaylistResponseBody() = default;
};
class DeletePlaylistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePlaylistResponseBody> body{};

  DeletePlaylistResponse() {}

  explicit DeletePlaylistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePlaylistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePlaylistResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePlaylistResponse() = default;
};
class DeletePlaylistItemsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};
  shared_ptr<string> programItemIds{};
  shared_ptr<string> regionId{};

  DeletePlaylistItemsRequest() {}

  explicit DeletePlaylistItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programItemIds) {
      res["ProgramItemIds"] = boost::any(*programItemIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramItemIds") != m.end() && !m["ProgramItemIds"].empty()) {
      programItemIds = make_shared<string>(boost::any_cast<string>(m["ProgramItemIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeletePlaylistItemsRequest() = default;
};
class DeletePlaylistItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  DeletePlaylistItemsResponseBody() {}

  explicit DeletePlaylistItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePlaylistItemsResponseBody() = default;
};
class DeletePlaylistItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePlaylistItemsResponseBody> body{};

  DeletePlaylistItemsResponse() {}

  explicit DeletePlaylistItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePlaylistItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePlaylistItemsResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePlaylistItemsResponse() = default;
};
class DeleteRtcAsrTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  DeleteRtcAsrTaskRequest() {}

  explicit DeleteRtcAsrTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DeleteRtcAsrTaskRequest() = default;
};
class DeleteRtcAsrTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  DeleteRtcAsrTaskResponseBody() {}

  explicit DeleteRtcAsrTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~DeleteRtcAsrTaskResponseBody() = default;
};
class DeleteRtcAsrTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRtcAsrTaskResponseBody> body{};

  DeleteRtcAsrTaskResponse() {}

  explicit DeleteRtcAsrTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRtcAsrTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRtcAsrTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRtcAsrTaskResponse() = default;
};
class DeleteRtcMPUEventSubRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DeleteRtcMPUEventSubRequest() {}

  explicit DeleteRtcMPUEventSubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteRtcMPUEventSubRequest() = default;
};
class DeleteRtcMPUEventSubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRtcMPUEventSubResponseBody() {}

  explicit DeleteRtcMPUEventSubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRtcMPUEventSubResponseBody() = default;
};
class DeleteRtcMPUEventSubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRtcMPUEventSubResponseBody> body{};

  DeleteRtcMPUEventSubResponse() {}

  explicit DeleteRtcMPUEventSubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRtcMPUEventSubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRtcMPUEventSubResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRtcMPUEventSubResponse() = default;
};
class DeleteSnapshotCallbackAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteSnapshotCallbackAuthRequest() {}

  explicit DeleteSnapshotCallbackAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteSnapshotCallbackAuthRequest() = default;
};
class DeleteSnapshotCallbackAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSnapshotCallbackAuthResponseBody() {}

  explicit DeleteSnapshotCallbackAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSnapshotCallbackAuthResponseBody() = default;
};
class DeleteSnapshotCallbackAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSnapshotCallbackAuthResponseBody> body{};

  DeleteSnapshotCallbackAuthResponse() {}

  explicit DeleteSnapshotCallbackAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnapshotCallbackAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnapshotCallbackAuthResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnapshotCallbackAuthResponse() = default;
};
class DeleteSnapshotFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<vector<long>> createTimestampList{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> removeFile{};
  shared_ptr<string> streamName{};

  DeleteSnapshotFilesRequest() {}

  explicit DeleteSnapshotFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTimestampList) {
      res["CreateTimestampList"] = boost::any(*createTimestampList);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (removeFile) {
      res["RemoveFile"] = boost::any(*removeFile);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTimestampList") != m.end() && !m["CreateTimestampList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateTimestampList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateTimestampList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createTimestampList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RemoveFile") != m.end() && !m["RemoveFile"].empty()) {
      removeFile = make_shared<bool>(boost::any_cast<bool>(m["RemoveFile"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteSnapshotFilesRequest() = default;
};
class DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo : public Darabonba::Model {
public:
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> message{};

  DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo() {}

  explicit DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo() = default;
};
class DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo>> snapshotDeleteInfo{};

  DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList() {}

  explicit DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotDeleteInfo) {
      vector<boost::any> temp1;
      for(auto item1:*snapshotDeleteInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnapshotDeleteInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotDeleteInfo") != m.end() && !m["SnapshotDeleteInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SnapshotDeleteInfo"].type()) {
        vector<DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnapshotDeleteInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshotDeleteInfo = make_shared<vector<DeleteSnapshotFilesResponseBodySnapshotDeleteInfoListSnapshotDeleteInfo>>(expect1);
      }
    }
  }


  virtual ~DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList() = default;
};
class DeleteSnapshotFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> failureCount{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList> snapshotDeleteInfoList{};
  shared_ptr<long> successCount{};

  DeleteSnapshotFilesResponseBody() {}

  explicit DeleteSnapshotFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failureCount) {
      res["FailureCount"] = boost::any(*failureCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotDeleteInfoList) {
      res["SnapshotDeleteInfoList"] = snapshotDeleteInfoList ? boost::any(snapshotDeleteInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailureCount") != m.end() && !m["FailureCount"].empty()) {
      failureCount = make_shared<long>(boost::any_cast<long>(m["FailureCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotDeleteInfoList") != m.end() && !m["SnapshotDeleteInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotDeleteInfoList"].type()) {
        DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotDeleteInfoList"]));
        snapshotDeleteInfoList = make_shared<DeleteSnapshotFilesResponseBodySnapshotDeleteInfoList>(model1);
      }
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~DeleteSnapshotFilesResponseBody() = default;
};
class DeleteSnapshotFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSnapshotFilesResponseBody> body{};

  DeleteSnapshotFilesResponse() {}

  explicit DeleteSnapshotFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnapshotFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnapshotFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnapshotFilesResponse() = default;
};
class DeleteStudioLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DeleteStudioLayoutRequest() {}

  explicit DeleteStudioLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteStudioLayoutRequest() = default;
};
class DeleteStudioLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteStudioLayoutResponseBody() {}

  explicit DeleteStudioLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteStudioLayoutResponseBody() = default;
};
class DeleteStudioLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteStudioLayoutResponseBody> body{};

  DeleteStudioLayoutResponse() {}

  explicit DeleteStudioLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStudioLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStudioLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStudioLayoutResponse() = default;
};
class DescribeAutoShowListTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeAutoShowListTasksRequest() {}

  explicit DescribeAutoShowListTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeAutoShowListTasksRequest() = default;
};
class DescribeAutoShowListTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> autoShowListTasks{};
  shared_ptr<string> requestId{};

  DescribeAutoShowListTasksResponseBody() {}

  explicit DescribeAutoShowListTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoShowListTasks) {
      res["AutoShowListTasks"] = boost::any(*autoShowListTasks);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoShowListTasks") != m.end() && !m["AutoShowListTasks"].empty()) {
      autoShowListTasks = make_shared<string>(boost::any_cast<string>(m["AutoShowListTasks"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAutoShowListTasksResponseBody() = default;
};
class DescribeAutoShowListTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAutoShowListTasksResponseBody> body{};

  DescribeAutoShowListTasksResponse() {}

  explicit DescribeAutoShowListTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoShowListTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoShowListTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoShowListTasksResponse() = default;
};
class DescribeCasterChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeCasterChannelsRequest() {}

  explicit DescribeCasterChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCasterChannelsRequest() = default;
};
class DescribeCasterChannelsResponseBodyChannelsChannel : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> faceBeauty{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> rtmpUrl{};
  shared_ptr<string> streamUrl{};

  DescribeCasterChannelsResponseBodyChannelsChannel() {}

  explicit DescribeCasterChannelsResponseBodyChannelsChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (faceBeauty) {
      res["FaceBeauty"] = boost::any(*faceBeauty);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (rtmpUrl) {
      res["RtmpUrl"] = boost::any(*rtmpUrl);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("FaceBeauty") != m.end() && !m["FaceBeauty"].empty()) {
      faceBeauty = make_shared<string>(boost::any_cast<string>(m["FaceBeauty"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("RtmpUrl") != m.end() && !m["RtmpUrl"].empty()) {
      rtmpUrl = make_shared<string>(boost::any_cast<string>(m["RtmpUrl"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~DescribeCasterChannelsResponseBodyChannelsChannel() = default;
};
class DescribeCasterChannelsResponseBodyChannels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterChannelsResponseBodyChannelsChannel>> channel{};

  DescribeCasterChannelsResponseBodyChannels() {}

  explicit DescribeCasterChannelsResponseBodyChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      vector<boost::any> temp1;
      for(auto item1:*channel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Channel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(vector<boost::any>) == m["Channel"].type()) {
        vector<DescribeCasterChannelsResponseBodyChannelsChannel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Channel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterChannelsResponseBodyChannelsChannel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channel = make_shared<vector<DescribeCasterChannelsResponseBodyChannelsChannel>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterChannelsResponseBodyChannels() = default;
};
class DescribeCasterChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterChannelsResponseBodyChannels> channels{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCasterChannelsResponseBody() {}

  explicit DescribeCasterChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = channels ? boost::any(channels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      if (typeid(map<string, boost::any>) == m["Channels"].type()) {
        DescribeCasterChannelsResponseBodyChannels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Channels"]));
        channels = make_shared<DescribeCasterChannelsResponseBodyChannels>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterChannelsResponseBody() = default;
};
class DescribeCasterChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterChannelsResponseBody> body{};

  DescribeCasterChannelsResponse() {}

  explicit DescribeCasterChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterChannelsResponse() = default;
};
class DescribeCasterComponentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> componentId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeCasterComponentsRequest() {}

  explicit DescribeCasterComponentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCasterComponentsRequest() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent : public Darabonba::Model {
public:
  shared_ptr<string> borderColor{};
  shared_ptr<double> borderWidthNormalized{};
  shared_ptr<string> color{};
  shared_ptr<string> fontName{};
  shared_ptr<double> lineSpaceNormalized{};
  shared_ptr<string> locationId{};
  shared_ptr<long> ptsOffset{};
  shared_ptr<bool> showSourceLan{};
  shared_ptr<double> sizeNormalized{};
  shared_ptr<string> sourceLan{};
  shared_ptr<string> targetLan{};
  shared_ptr<long> wordCountPerLine{};
  shared_ptr<double> wordSpaceNormalized{};
  shared_ptr<long> wordsCount{};

  DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidthNormalized) {
      res["BorderWidthNormalized"] = boost::any(*borderWidthNormalized);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (lineSpaceNormalized) {
      res["LineSpaceNormalized"] = boost::any(*lineSpaceNormalized);
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (ptsOffset) {
      res["PtsOffset"] = boost::any(*ptsOffset);
    }
    if (showSourceLan) {
      res["ShowSourceLan"] = boost::any(*showSourceLan);
    }
    if (sizeNormalized) {
      res["SizeNormalized"] = boost::any(*sizeNormalized);
    }
    if (sourceLan) {
      res["SourceLan"] = boost::any(*sourceLan);
    }
    if (targetLan) {
      res["TargetLan"] = boost::any(*targetLan);
    }
    if (wordCountPerLine) {
      res["WordCountPerLine"] = boost::any(*wordCountPerLine);
    }
    if (wordSpaceNormalized) {
      res["WordSpaceNormalized"] = boost::any(*wordSpaceNormalized);
    }
    if (wordsCount) {
      res["WordsCount"] = boost::any(*wordsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidthNormalized") != m.end() && !m["BorderWidthNormalized"].empty()) {
      borderWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BorderWidthNormalized"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("LineSpaceNormalized") != m.end() && !m["LineSpaceNormalized"].empty()) {
      lineSpaceNormalized = make_shared<double>(boost::any_cast<double>(m["LineSpaceNormalized"]));
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("PtsOffset") != m.end() && !m["PtsOffset"].empty()) {
      ptsOffset = make_shared<long>(boost::any_cast<long>(m["PtsOffset"]));
    }
    if (m.find("ShowSourceLan") != m.end() && !m["ShowSourceLan"].empty()) {
      showSourceLan = make_shared<bool>(boost::any_cast<bool>(m["ShowSourceLan"]));
    }
    if (m.find("SizeNormalized") != m.end() && !m["SizeNormalized"].empty()) {
      sizeNormalized = make_shared<double>(boost::any_cast<double>(m["SizeNormalized"]));
    }
    if (m.find("SourceLan") != m.end() && !m["SourceLan"].empty()) {
      sourceLan = make_shared<string>(boost::any_cast<string>(m["SourceLan"]));
    }
    if (m.find("TargetLan") != m.end() && !m["TargetLan"].empty()) {
      targetLan = make_shared<string>(boost::any_cast<string>(m["TargetLan"]));
    }
    if (m.find("WordCountPerLine") != m.end() && !m["WordCountPerLine"].empty()) {
      wordCountPerLine = make_shared<long>(boost::any_cast<long>(m["WordCountPerLine"]));
    }
    if (m.find("WordSpaceNormalized") != m.end() && !m["WordSpaceNormalized"].empty()) {
      wordSpaceNormalized = make_shared<double>(boost::any_cast<double>(m["WordSpaceNormalized"]));
    }
    if (m.find("WordsCount") != m.end() && !m["WordsCount"].empty()) {
      wordsCount = make_shared<long>(boost::any_cast<long>(m["WordsCount"]));
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds : public Darabonba::Model {
public:
  shared_ptr<vector<double>> position{};

  DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (position) {
      res["Position"] = boost::any(*position);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["Position"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Position"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      position = make_shared<vector<double>>(toVec1);
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer : public Darabonba::Model {
public:
  shared_ptr<double> heightNormalized{};
  shared_ptr<DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds> positionNormalizeds{};
  shared_ptr<string> positionRefer{};
  shared_ptr<long> transparency{};
  shared_ptr<double> widthNormalized{};

  DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionNormalizeds) {
      res["PositionNormalizeds"] = positionNormalizeds ? boost::any(positionNormalizeds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (transparency) {
      res["Transparency"] = boost::any(*transparency);
    }
    if (widthNormalized) {
      res["WidthNormalized"] = boost::any(*widthNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionNormalizeds") != m.end() && !m["PositionNormalizeds"].empty()) {
      if (typeid(map<string, boost::any>) == m["PositionNormalizeds"].type()) {
        DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PositionNormalizeds"]));
        positionNormalizeds = make_shared<DescribeCasterComponentsResponseBodyComponentsComponentComponentLayerPositionNormalizeds>(model1);
      }
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("Transparency") != m.end() && !m["Transparency"].empty()) {
      transparency = make_shared<long>(boost::any_cast<long>(m["Transparency"]));
    }
    if (m.find("WidthNormalized") != m.end() && !m["WidthNormalized"].empty()) {
      widthNormalized = make_shared<double>(boost::any_cast<double>(m["WidthNormalized"]));
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent : public Darabonba::Model {
public:
  shared_ptr<string> materialId{};

  DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent : public Darabonba::Model {
public:
  shared_ptr<string> borderColor{};
  shared_ptr<double> borderWidthNormalized{};
  shared_ptr<string> color{};
  shared_ptr<string> fontName{};
  shared_ptr<double> sizeNormalized{};
  shared_ptr<string> text{};

  DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidthNormalized) {
      res["BorderWidthNormalized"] = boost::any(*borderWidthNormalized);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (sizeNormalized) {
      res["SizeNormalized"] = boost::any(*sizeNormalized);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidthNormalized") != m.end() && !m["BorderWidthNormalized"].empty()) {
      borderWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BorderWidthNormalized"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("SizeNormalized") != m.end() && !m["SizeNormalized"].empty()) {
      sizeNormalized = make_shared<double>(boost::any_cast<double>(m["SizeNormalized"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent() = default;
};
class DescribeCasterComponentsResponseBodyComponentsComponent : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent> captionLayerContent{};
  shared_ptr<string> componentId{};
  shared_ptr<DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer> componentLayer{};
  shared_ptr<string> componentName{};
  shared_ptr<string> componentType{};
  shared_ptr<string> effect{};
  shared_ptr<DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent> imageLayerContent{};
  shared_ptr<string> locationId{};
  shared_ptr<DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent> textLayerContent{};

  DescribeCasterComponentsResponseBodyComponentsComponent() {}

  explicit DescribeCasterComponentsResponseBodyComponentsComponent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (captionLayerContent) {
      res["CaptionLayerContent"] = captionLayerContent ? boost::any(captionLayerContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (componentLayer) {
      res["ComponentLayer"] = componentLayer ? boost::any(componentLayer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (componentType) {
      res["ComponentType"] = boost::any(*componentType);
    }
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (imageLayerContent) {
      res["ImageLayerContent"] = imageLayerContent ? boost::any(imageLayerContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (textLayerContent) {
      res["TextLayerContent"] = textLayerContent ? boost::any(textLayerContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaptionLayerContent") != m.end() && !m["CaptionLayerContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["CaptionLayerContent"].type()) {
        DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CaptionLayerContent"]));
        captionLayerContent = make_shared<DescribeCasterComponentsResponseBodyComponentsComponentCaptionLayerContent>(model1);
      }
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("ComponentLayer") != m.end() && !m["ComponentLayer"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentLayer"].type()) {
        DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentLayer"]));
        componentLayer = make_shared<DescribeCasterComponentsResponseBodyComponentsComponentComponentLayer>(model1);
      }
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("ComponentType") != m.end() && !m["ComponentType"].empty()) {
      componentType = make_shared<string>(boost::any_cast<string>(m["ComponentType"]));
    }
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("ImageLayerContent") != m.end() && !m["ImageLayerContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageLayerContent"].type()) {
        DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageLayerContent"]));
        imageLayerContent = make_shared<DescribeCasterComponentsResponseBodyComponentsComponentImageLayerContent>(model1);
      }
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("TextLayerContent") != m.end() && !m["TextLayerContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["TextLayerContent"].type()) {
        DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TextLayerContent"]));
        textLayerContent = make_shared<DescribeCasterComponentsResponseBodyComponentsComponentTextLayerContent>(model1);
      }
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponentsComponent() = default;
};
class DescribeCasterComponentsResponseBodyComponents : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterComponentsResponseBodyComponentsComponent>> component{};

  DescribeCasterComponentsResponseBodyComponents() {}

  explicit DescribeCasterComponentsResponseBodyComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (component) {
      vector<boost::any> temp1;
      for(auto item1:*component){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Component"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Component") != m.end() && !m["Component"].empty()) {
      if (typeid(vector<boost::any>) == m["Component"].type()) {
        vector<DescribeCasterComponentsResponseBodyComponentsComponent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Component"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterComponentsResponseBodyComponentsComponent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        component = make_shared<vector<DescribeCasterComponentsResponseBodyComponentsComponent>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterComponentsResponseBodyComponents() = default;
};
class DescribeCasterComponentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterComponentsResponseBodyComponents> components{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCasterComponentsResponseBody() {}

  explicit DescribeCasterComponentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (components) {
      res["Components"] = components ? boost::any(components->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Components") != m.end() && !m["Components"].empty()) {
      if (typeid(map<string, boost::any>) == m["Components"].type()) {
        DescribeCasterComponentsResponseBodyComponents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Components"]));
        components = make_shared<DescribeCasterComponentsResponseBodyComponents>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterComponentsResponseBody() = default;
};
class DescribeCasterComponentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterComponentsResponseBody> body{};

  DescribeCasterComponentsResponse() {}

  explicit DescribeCasterComponentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterComponentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterComponentsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterComponentsResponse() = default;
};
class DescribeCasterConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeCasterConfigRequest() {}

  explicit DescribeCasterConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCasterConfigRequest() = default;
};
class DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<string> sliceOssObjectPrefix{};

  DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat() {}

  explicit DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat() = default;
};
class DescribeCasterConfigResponseBodyRecordConfigRecordFormat : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat>> recordFormat{};

  DescribeCasterConfigResponseBodyRecordConfigRecordFormat() {}

  explicit DescribeCasterConfigResponseBodyRecordConfigRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<DescribeCasterConfigResponseBodyRecordConfigRecordFormatRecordFormat>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponseBodyRecordConfigRecordFormat() = default;
};
class DescribeCasterConfigResponseBodyRecordConfig : public Darabonba::Model {
public:
  shared_ptr<long> onDemand{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<DescribeCasterConfigResponseBodyRecordConfigRecordFormat> recordFormat{};

  DescribeCasterConfigResponseBodyRecordConfig() {}

  explicit DescribeCasterConfigResponseBodyRecordConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onDemand) {
      res["OnDemand"] = boost::any(*onDemand);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (recordFormat) {
      res["RecordFormat"] = recordFormat ? boost::any(recordFormat->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnDemand") != m.end() && !m["OnDemand"].empty()) {
      onDemand = make_shared<long>(boost::any_cast<long>(m["OnDemand"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordFormat"].type()) {
        DescribeCasterConfigResponseBodyRecordConfigRecordFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordFormat"]));
        recordFormat = make_shared<DescribeCasterConfigResponseBodyRecordConfigRecordFormat>(model1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponseBodyRecordConfig() = default;
};
class DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};

  DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds() {}

  explicit DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds() = default;
};
class DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup : public Darabonba::Model {
public:
  shared_ptr<string> hostResourceId{};
  shared_ptr<long> mode{};
  shared_ptr<DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds> resourceIds{};

  DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup() {}

  explicit DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostResourceId) {
      res["HostResourceId"] = boost::any(*hostResourceId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (resourceIds) {
      res["ResourceIds"] = resourceIds ? boost::any(resourceIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostResourceId") != m.end() && !m["HostResourceId"].empty()) {
      hostResourceId = make_shared<string>(boost::any_cast<string>(m["HostResourceId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceIds"].type()) {
        DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceIds"]));
        resourceIds = make_shared<DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroupResourceIds>(model1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup() = default;
};
class DescribeCasterConfigResponseBodySyncGroupsConfig : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup>> syncGroup{};

  DescribeCasterConfigResponseBodySyncGroupsConfig() {}

  explicit DescribeCasterConfigResponseBodySyncGroupsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (syncGroup) {
      vector<boost::any> temp1;
      for(auto item1:*syncGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SyncGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SyncGroup") != m.end() && !m["SyncGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SyncGroup"].type()) {
        vector<DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SyncGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        syncGroup = make_shared<vector<DescribeCasterConfigResponseBodySyncGroupsConfigSyncGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponseBodySyncGroupsConfig() = default;
};
class DescribeCasterConfigResponseBodyTranscodeConfigCustomParamsVideo : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<long> fps{};
  shared_ptr<long> height{};
  shared_ptr<long> width{};

  DescribeCasterConfigResponseBodyTranscodeConfigCustomParamsVideo() {}

  explicit DescribeCasterConfigResponseBodyTranscodeConfigCustomParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["bitrate"] = boost::any(*bitrate);
    }
    if (fps) {
      res["fps"] = boost::any(*fps);
    }
    if (height) {
      res["height"] = boost::any(*height);
    }
    if (width) {
      res["width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bitrate") != m.end() && !m["bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["bitrate"]));
    }
    if (m.find("fps") != m.end() && !m["fps"].empty()) {
      fps = make_shared<long>(boost::any_cast<long>(m["fps"]));
    }
    if (m.find("height") != m.end() && !m["height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["height"]));
    }
    if (m.find("width") != m.end() && !m["width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["width"]));
    }
  }


  virtual ~DescribeCasterConfigResponseBodyTranscodeConfigCustomParamsVideo() = default;
};
class DescribeCasterConfigResponseBodyTranscodeConfigCustomParams : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterConfigResponseBodyTranscodeConfigCustomParamsVideo> video{};

  DescribeCasterConfigResponseBodyTranscodeConfigCustomParams() {}

  explicit DescribeCasterConfigResponseBodyTranscodeConfigCustomParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      res["video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("video") != m.end() && !m["video"].empty()) {
      if (typeid(map<string, boost::any>) == m["video"].type()) {
        DescribeCasterConfigResponseBodyTranscodeConfigCustomParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["video"]));
        video = make_shared<DescribeCasterConfigResponseBodyTranscodeConfigCustomParamsVideo>(model1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponseBodyTranscodeConfigCustomParams() = default;
};
class DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> locationId{};

  DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds() {}

  explicit DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LocationId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LocationId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locationId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds() = default;
};
class DescribeCasterConfigResponseBodyTranscodeConfig : public Darabonba::Model {
public:
  shared_ptr<string> casterTemplate{};
  shared_ptr<DescribeCasterConfigResponseBodyTranscodeConfigCustomParams> customParams{};
  shared_ptr<DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds> liveTemplateIds{};

  DescribeCasterConfigResponseBodyTranscodeConfig() {}

  explicit DescribeCasterConfigResponseBodyTranscodeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterTemplate) {
      res["CasterTemplate"] = boost::any(*casterTemplate);
    }
    if (customParams) {
      res["CustomParams"] = customParams ? boost::any(customParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (liveTemplateIds) {
      res["LiveTemplateIds"] = liveTemplateIds ? boost::any(liveTemplateIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterTemplate") != m.end() && !m["CasterTemplate"].empty()) {
      casterTemplate = make_shared<string>(boost::any_cast<string>(m["CasterTemplate"]));
    }
    if (m.find("CustomParams") != m.end() && !m["CustomParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomParams"].type()) {
        DescribeCasterConfigResponseBodyTranscodeConfigCustomParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomParams"]));
        customParams = make_shared<DescribeCasterConfigResponseBodyTranscodeConfigCustomParams>(model1);
      }
    }
    if (m.find("LiveTemplateIds") != m.end() && !m["LiveTemplateIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveTemplateIds"].type()) {
        DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveTemplateIds"]));
        liveTemplateIds = make_shared<DescribeCasterConfigResponseBodyTranscodeConfigLiveTemplateIds>(model1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponseBodyTranscodeConfig() = default;
};
class DescribeCasterConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> autoSwitchUrgentConfig{};
  shared_ptr<string> autoSwitchUrgentOn{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> casterId{};
  shared_ptr<string> casterName{};
  shared_ptr<long> channelEnable{};
  shared_ptr<double> delay{};
  shared_ptr<string> domainName{};
  shared_ptr<long> programEffect{};
  shared_ptr<string> programName{};
  shared_ptr<DescribeCasterConfigResponseBodyRecordConfig> recordConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sideOutputUrl{};
  shared_ptr<string> sideOutputUrlList{};
  shared_ptr<DescribeCasterConfigResponseBodySyncGroupsConfig> syncGroupsConfig{};
  shared_ptr<DescribeCasterConfigResponseBodyTranscodeConfig> transcodeConfig{};
  shared_ptr<string> urgentImageId{};
  shared_ptr<string> urgentImageUrl{};
  shared_ptr<string> urgentLiveStreamUrl{};
  shared_ptr<string> urgentMaterialId{};

  DescribeCasterConfigResponseBody() {}

  explicit DescribeCasterConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSwitchUrgentConfig) {
      res["AutoSwitchUrgentConfig"] = boost::any(*autoSwitchUrgentConfig);
    }
    if (autoSwitchUrgentOn) {
      res["AutoSwitchUrgentOn"] = boost::any(*autoSwitchUrgentOn);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (channelEnable) {
      res["ChannelEnable"] = boost::any(*channelEnable);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (programEffect) {
      res["ProgramEffect"] = boost::any(*programEffect);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (recordConfig) {
      res["RecordConfig"] = recordConfig ? boost::any(recordConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sideOutputUrl) {
      res["SideOutputUrl"] = boost::any(*sideOutputUrl);
    }
    if (sideOutputUrlList) {
      res["SideOutputUrlList"] = boost::any(*sideOutputUrlList);
    }
    if (syncGroupsConfig) {
      res["SyncGroupsConfig"] = syncGroupsConfig ? boost::any(syncGroupsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transcodeConfig) {
      res["TranscodeConfig"] = transcodeConfig ? boost::any(transcodeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (urgentImageId) {
      res["UrgentImageId"] = boost::any(*urgentImageId);
    }
    if (urgentImageUrl) {
      res["UrgentImageUrl"] = boost::any(*urgentImageUrl);
    }
    if (urgentLiveStreamUrl) {
      res["UrgentLiveStreamUrl"] = boost::any(*urgentLiveStreamUrl);
    }
    if (urgentMaterialId) {
      res["UrgentMaterialId"] = boost::any(*urgentMaterialId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSwitchUrgentConfig") != m.end() && !m["AutoSwitchUrgentConfig"].empty()) {
      autoSwitchUrgentConfig = make_shared<string>(boost::any_cast<string>(m["AutoSwitchUrgentConfig"]));
    }
    if (m.find("AutoSwitchUrgentOn") != m.end() && !m["AutoSwitchUrgentOn"].empty()) {
      autoSwitchUrgentOn = make_shared<string>(boost::any_cast<string>(m["AutoSwitchUrgentOn"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("ChannelEnable") != m.end() && !m["ChannelEnable"].empty()) {
      channelEnable = make_shared<long>(boost::any_cast<long>(m["ChannelEnable"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<double>(boost::any_cast<double>(m["Delay"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ProgramEffect") != m.end() && !m["ProgramEffect"].empty()) {
      programEffect = make_shared<long>(boost::any_cast<long>(m["ProgramEffect"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("RecordConfig") != m.end() && !m["RecordConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordConfig"].type()) {
        DescribeCasterConfigResponseBodyRecordConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordConfig"]));
        recordConfig = make_shared<DescribeCasterConfigResponseBodyRecordConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SideOutputUrl") != m.end() && !m["SideOutputUrl"].empty()) {
      sideOutputUrl = make_shared<string>(boost::any_cast<string>(m["SideOutputUrl"]));
    }
    if (m.find("SideOutputUrlList") != m.end() && !m["SideOutputUrlList"].empty()) {
      sideOutputUrlList = make_shared<string>(boost::any_cast<string>(m["SideOutputUrlList"]));
    }
    if (m.find("SyncGroupsConfig") != m.end() && !m["SyncGroupsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SyncGroupsConfig"].type()) {
        DescribeCasterConfigResponseBodySyncGroupsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SyncGroupsConfig"]));
        syncGroupsConfig = make_shared<DescribeCasterConfigResponseBodySyncGroupsConfig>(model1);
      }
    }
    if (m.find("TranscodeConfig") != m.end() && !m["TranscodeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeConfig"].type()) {
        DescribeCasterConfigResponseBodyTranscodeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeConfig"]));
        transcodeConfig = make_shared<DescribeCasterConfigResponseBodyTranscodeConfig>(model1);
      }
    }
    if (m.find("UrgentImageId") != m.end() && !m["UrgentImageId"].empty()) {
      urgentImageId = make_shared<string>(boost::any_cast<string>(m["UrgentImageId"]));
    }
    if (m.find("UrgentImageUrl") != m.end() && !m["UrgentImageUrl"].empty()) {
      urgentImageUrl = make_shared<string>(boost::any_cast<string>(m["UrgentImageUrl"]));
    }
    if (m.find("UrgentLiveStreamUrl") != m.end() && !m["UrgentLiveStreamUrl"].empty()) {
      urgentLiveStreamUrl = make_shared<string>(boost::any_cast<string>(m["UrgentLiveStreamUrl"]));
    }
    if (m.find("UrgentMaterialId") != m.end() && !m["UrgentMaterialId"].empty()) {
      urgentMaterialId = make_shared<string>(boost::any_cast<string>(m["UrgentMaterialId"]));
    }
  }


  virtual ~DescribeCasterConfigResponseBody() = default;
};
class DescribeCasterConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterConfigResponseBody> body{};

  DescribeCasterConfigResponse() {}

  explicit DescribeCasterConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterConfigResponse() = default;
};
class DescribeCasterLayoutsRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeCasterLayoutsRequest() {}

  explicit DescribeCasterLayoutsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCasterLayoutsRequest() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer : public Darabonba::Model {
public:
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer>> audioLayer{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayer) {
      vector<boost::any> temp1;
      for(auto item1:*audioLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayer") != m.end() && !m["AudioLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioLayer"].type()) {
        vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioLayer = make_shared<vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayersAudioLayer>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> locationId{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LocationId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LocationId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locationId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> locationId{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LocationId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LocationId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locationId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds : public Darabonba::Model {
public:
  shared_ptr<vector<double>> position{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (position) {
      res["Position"] = boost::any(*position);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["Position"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Position"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      position = make_shared<vector<double>>(toVec1);
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer : public Darabonba::Model {
public:
  shared_ptr<string> fillMode{};
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<double> heightNormalized{};
  shared_ptr<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds> positionNormalizeds{};
  shared_ptr<string> positionRefer{};
  shared_ptr<double> widthNormalized{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fillMode) {
      res["FillMode"] = boost::any(*fillMode);
    }
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionNormalizeds) {
      res["PositionNormalizeds"] = positionNormalizeds ? boost::any(positionNormalizeds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (widthNormalized) {
      res["WidthNormalized"] = boost::any(*widthNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FillMode") != m.end() && !m["FillMode"].empty()) {
      fillMode = make_shared<string>(boost::any_cast<string>(m["FillMode"]));
    }
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionNormalizeds") != m.end() && !m["PositionNormalizeds"].empty()) {
      if (typeid(map<string, boost::any>) == m["PositionNormalizeds"].type()) {
        DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PositionNormalizeds"]));
        positionNormalizeds = make_shared<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayerPositionNormalizeds>(model1);
      }
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("WidthNormalized") != m.end() && !m["WidthNormalized"].empty()) {
      widthNormalized = make_shared<double>(boost::any_cast<double>(m["WidthNormalized"]));
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer>> videoLayer{};

  DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoLayer) {
      vector<boost::any> temp1;
      for(auto item1:*videoLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoLayer") != m.end() && !m["VideoLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoLayer"].type()) {
        vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoLayer = make_shared<vector<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayersVideoLayer>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers() = default;
};
class DescribeCasterLayoutsResponseBodyLayoutsLayout : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers> audioLayers{};
  shared_ptr<DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList> blendList{};
  shared_ptr<string> layoutId{};
  shared_ptr<DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList> mixList{};
  shared_ptr<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers> videoLayers{};

  DescribeCasterLayoutsResponseBodyLayoutsLayout() {}

  explicit DescribeCasterLayoutsResponseBodyLayoutsLayout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayers) {
      res["AudioLayers"] = audioLayers ? boost::any(audioLayers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (blendList) {
      res["BlendList"] = blendList ? boost::any(blendList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (mixList) {
      res["MixList"] = mixList ? boost::any(mixList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoLayers) {
      res["VideoLayers"] = videoLayers ? boost::any(videoLayers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayers") != m.end() && !m["AudioLayers"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioLayers"].type()) {
        DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioLayers"]));
        audioLayers = make_shared<DescribeCasterLayoutsResponseBodyLayoutsLayoutAudioLayers>(model1);
      }
    }
    if (m.find("BlendList") != m.end() && !m["BlendList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BlendList"].type()) {
        DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BlendList"]));
        blendList = make_shared<DescribeCasterLayoutsResponseBodyLayoutsLayoutBlendList>(model1);
      }
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("MixList") != m.end() && !m["MixList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MixList"].type()) {
        DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MixList"]));
        mixList = make_shared<DescribeCasterLayoutsResponseBodyLayoutsLayoutMixList>(model1);
      }
    }
    if (m.find("VideoLayers") != m.end() && !m["VideoLayers"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoLayers"].type()) {
        DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoLayers"]));
        videoLayers = make_shared<DescribeCasterLayoutsResponseBodyLayoutsLayoutVideoLayers>(model1);
      }
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayoutsLayout() = default;
};
class DescribeCasterLayoutsResponseBodyLayouts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterLayoutsResponseBodyLayoutsLayout>> layout{};

  DescribeCasterLayoutsResponseBodyLayouts() {}

  explicit DescribeCasterLayoutsResponseBodyLayouts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layout) {
      vector<boost::any> temp1;
      for(auto item1:*layout){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Layout"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Layout") != m.end() && !m["Layout"].empty()) {
      if (typeid(vector<boost::any>) == m["Layout"].type()) {
        vector<DescribeCasterLayoutsResponseBodyLayoutsLayout> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Layout"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterLayoutsResponseBodyLayoutsLayout model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        layout = make_shared<vector<DescribeCasterLayoutsResponseBodyLayoutsLayout>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterLayoutsResponseBodyLayouts() = default;
};
class DescribeCasterLayoutsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterLayoutsResponseBodyLayouts> layouts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCasterLayoutsResponseBody() {}

  explicit DescribeCasterLayoutsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layouts) {
      res["Layouts"] = layouts ? boost::any(layouts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Layouts") != m.end() && !m["Layouts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Layouts"].type()) {
        DescribeCasterLayoutsResponseBodyLayouts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Layouts"]));
        layouts = make_shared<DescribeCasterLayoutsResponseBodyLayouts>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterLayoutsResponseBody() = default;
};
class DescribeCasterLayoutsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterLayoutsResponseBody> body{};

  DescribeCasterLayoutsResponse() {}

  explicit DescribeCasterLayoutsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterLayoutsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterLayoutsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterLayoutsResponse() = default;
};
class DescribeCasterProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> episodeType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<long> status{};

  DescribeCasterProgramRequest() {}

  explicit DescribeCasterProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (episodeType) {
      res["EpisodeType"] = boost::any(*episodeType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("EpisodeType") != m.end() && !m["EpisodeType"].empty()) {
      episodeType = make_shared<string>(boost::any_cast<string>(m["EpisodeType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeCasterProgramRequest() = default;
};
class DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentId{};

  DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds() {}

  explicit DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds() = default;
};
class DescribeCasterProgramResponseBodyEpisodesEpisode : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds> componentIds{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> episodeName{};
  shared_ptr<string> episodeType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> startTime{};
  shared_ptr<long> status{};
  shared_ptr<string> switchType{};

  DescribeCasterProgramResponseBodyEpisodesEpisode() {}

  explicit DescribeCasterProgramResponseBodyEpisodesEpisode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentIds) {
      res["ComponentIds"] = componentIds ? boost::any(componentIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (episodeName) {
      res["EpisodeName"] = boost::any(*episodeName);
    }
    if (episodeType) {
      res["EpisodeType"] = boost::any(*episodeType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (switchType) {
      res["SwitchType"] = boost::any(*switchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentIds") != m.end() && !m["ComponentIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentIds"].type()) {
        DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentIds"]));
        componentIds = make_shared<DescribeCasterProgramResponseBodyEpisodesEpisodeComponentIds>(model1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("EpisodeName") != m.end() && !m["EpisodeName"].empty()) {
      episodeName = make_shared<string>(boost::any_cast<string>(m["EpisodeName"]));
    }
    if (m.find("EpisodeType") != m.end() && !m["EpisodeType"].empty()) {
      episodeType = make_shared<string>(boost::any_cast<string>(m["EpisodeType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SwitchType") != m.end() && !m["SwitchType"].empty()) {
      switchType = make_shared<string>(boost::any_cast<string>(m["SwitchType"]));
    }
  }


  virtual ~DescribeCasterProgramResponseBodyEpisodesEpisode() = default;
};
class DescribeCasterProgramResponseBodyEpisodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterProgramResponseBodyEpisodesEpisode>> episode{};

  DescribeCasterProgramResponseBodyEpisodes() {}

  explicit DescribeCasterProgramResponseBodyEpisodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (episode) {
      vector<boost::any> temp1;
      for(auto item1:*episode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Episode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Episode") != m.end() && !m["Episode"].empty()) {
      if (typeid(vector<boost::any>) == m["Episode"].type()) {
        vector<DescribeCasterProgramResponseBodyEpisodesEpisode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Episode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterProgramResponseBodyEpisodesEpisode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        episode = make_shared<vector<DescribeCasterProgramResponseBodyEpisodesEpisode>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterProgramResponseBodyEpisodes() = default;
};
class DescribeCasterProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<DescribeCasterProgramResponseBodyEpisodes> episodes{};
  shared_ptr<long> programEffect{};
  shared_ptr<string> programName{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCasterProgramResponseBody() {}

  explicit DescribeCasterProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episodes) {
      res["Episodes"] = episodes ? boost::any(episodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programEffect) {
      res["ProgramEffect"] = boost::any(*programEffect);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("Episodes") != m.end() && !m["Episodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Episodes"].type()) {
        DescribeCasterProgramResponseBodyEpisodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Episodes"]));
        episodes = make_shared<DescribeCasterProgramResponseBodyEpisodes>(model1);
      }
    }
    if (m.find("ProgramEffect") != m.end() && !m["ProgramEffect"].empty()) {
      programEffect = make_shared<long>(boost::any_cast<long>(m["ProgramEffect"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterProgramResponseBody() = default;
};
class DescribeCasterProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterProgramResponseBody> body{};

  DescribeCasterProgramResponse() {}

  explicit DescribeCasterProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterProgramResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterProgramResponse() = default;
};
class DescribeCasterSceneAudioRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sceneId{};

  DescribeCasterSceneAudioRequest() {}

  explicit DescribeCasterSceneAudioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~DescribeCasterSceneAudioRequest() = default;
};
class DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer : public Darabonba::Model {
public:
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer() {}

  explicit DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer() = default;
};
class DescribeCasterSceneAudioResponseBodyAudioLayers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer>> audioLayer{};

  DescribeCasterSceneAudioResponseBodyAudioLayers() {}

  explicit DescribeCasterSceneAudioResponseBodyAudioLayers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayer) {
      vector<boost::any> temp1;
      for(auto item1:*audioLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayer") != m.end() && !m["AudioLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioLayer"].type()) {
        vector<DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioLayer = make_shared<vector<DescribeCasterSceneAudioResponseBodyAudioLayersAudioLayer>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterSceneAudioResponseBodyAudioLayers() = default;
};
class DescribeCasterSceneAudioResponseBodyMixList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> locationId{};

  DescribeCasterSceneAudioResponseBodyMixList() {}

  explicit DescribeCasterSceneAudioResponseBodyMixList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LocationId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LocationId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locationId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterSceneAudioResponseBodyMixList() = default;
};
class DescribeCasterSceneAudioResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterSceneAudioResponseBodyAudioLayers> audioLayers{};
  shared_ptr<string> casterId{};
  shared_ptr<long> followEnable{};
  shared_ptr<DescribeCasterSceneAudioResponseBodyMixList> mixList{};
  shared_ptr<string> requestId{};

  DescribeCasterSceneAudioResponseBody() {}

  explicit DescribeCasterSceneAudioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayers) {
      res["AudioLayers"] = audioLayers ? boost::any(audioLayers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (followEnable) {
      res["FollowEnable"] = boost::any(*followEnable);
    }
    if (mixList) {
      res["MixList"] = mixList ? boost::any(mixList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayers") != m.end() && !m["AudioLayers"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioLayers"].type()) {
        DescribeCasterSceneAudioResponseBodyAudioLayers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioLayers"]));
        audioLayers = make_shared<DescribeCasterSceneAudioResponseBodyAudioLayers>(model1);
      }
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("FollowEnable") != m.end() && !m["FollowEnable"].empty()) {
      followEnable = make_shared<long>(boost::any_cast<long>(m["FollowEnable"]));
    }
    if (m.find("MixList") != m.end() && !m["MixList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MixList"].type()) {
        DescribeCasterSceneAudioResponseBodyMixList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MixList"]));
        mixList = make_shared<DescribeCasterSceneAudioResponseBodyMixList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCasterSceneAudioResponseBody() = default;
};
class DescribeCasterSceneAudioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterSceneAudioResponseBody> body{};

  DescribeCasterSceneAudioResponse() {}

  explicit DescribeCasterSceneAudioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterSceneAudioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterSceneAudioResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterSceneAudioResponse() = default;
};
class DescribeCasterScenesRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sceneId{};

  DescribeCasterScenesRequest() {}

  explicit DescribeCasterScenesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~DescribeCasterScenesRequest() = default;
};
class DescribeCasterScenesResponseBodySceneListSceneComponentIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentId{};

  DescribeCasterScenesResponseBodySceneListSceneComponentIds() {}

  explicit DescribeCasterScenesResponseBodySceneListSceneComponentIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["componentId"] = boost::any(*componentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("componentId") != m.end() && !m["componentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["componentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["componentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCasterScenesResponseBodySceneListSceneComponentIds() = default;
};
class DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo : public Darabonba::Model {
public:
  shared_ptr<string> outputStreamUrl{};
  shared_ptr<string> transcodeConfig{};
  shared_ptr<string> videoFormat{};

  DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo() {}

  explicit DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputStreamUrl) {
      res["OutputStreamUrl"] = boost::any(*outputStreamUrl);
    }
    if (transcodeConfig) {
      res["TranscodeConfig"] = boost::any(*transcodeConfig);
    }
    if (videoFormat) {
      res["VideoFormat"] = boost::any(*videoFormat);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputStreamUrl") != m.end() && !m["OutputStreamUrl"].empty()) {
      outputStreamUrl = make_shared<string>(boost::any_cast<string>(m["OutputStreamUrl"]));
    }
    if (m.find("TranscodeConfig") != m.end() && !m["TranscodeConfig"].empty()) {
      transcodeConfig = make_shared<string>(boost::any_cast<string>(m["TranscodeConfig"]));
    }
    if (m.find("VideoFormat") != m.end() && !m["VideoFormat"].empty()) {
      videoFormat = make_shared<string>(boost::any_cast<string>(m["VideoFormat"]));
    }
  }


  virtual ~DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo() = default;
};
class DescribeCasterScenesResponseBodySceneListSceneStreamInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo>> streamInfo{};

  DescribeCasterScenesResponseBodySceneListSceneStreamInfos() {}

  explicit DescribeCasterScenesResponseBodySceneListSceneStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamInfo) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamInfo") != m.end() && !m["StreamInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfo"].type()) {
        vector<DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfo = make_shared<vector<DescribeCasterScenesResponseBodySceneListSceneStreamInfosStreamInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterScenesResponseBodySceneListSceneStreamInfos() = default;
};
class DescribeCasterScenesResponseBodySceneListScene : public Darabonba::Model {
public:
  shared_ptr<DescribeCasterScenesResponseBodySceneListSceneComponentIds> componentIds{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> outputType{};
  shared_ptr<string> sceneId{};
  shared_ptr<string> sceneName{};
  shared_ptr<long> status{};
  shared_ptr<DescribeCasterScenesResponseBodySceneListSceneStreamInfos> streamInfos{};
  shared_ptr<string> streamUrl{};

  DescribeCasterScenesResponseBodySceneListScene() {}

  explicit DescribeCasterScenesResponseBodySceneListScene(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentIds) {
      res["ComponentIds"] = componentIds ? boost::any(componentIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    if (sceneName) {
      res["SceneName"] = boost::any(*sceneName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInfos) {
      res["StreamInfos"] = streamInfos ? boost::any(streamInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentIds") != m.end() && !m["ComponentIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentIds"].type()) {
        DescribeCasterScenesResponseBodySceneListSceneComponentIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentIds"]));
        componentIds = make_shared<DescribeCasterScenesResponseBodySceneListSceneComponentIds>(model1);
      }
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
    if (m.find("SceneName") != m.end() && !m["SceneName"].empty()) {
      sceneName = make_shared<string>(boost::any_cast<string>(m["SceneName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInfos"].type()) {
        DescribeCasterScenesResponseBodySceneListSceneStreamInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInfos"]));
        streamInfos = make_shared<DescribeCasterScenesResponseBodySceneListSceneStreamInfos>(model1);
      }
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~DescribeCasterScenesResponseBodySceneListScene() = default;
};
class DescribeCasterScenesResponseBodySceneList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterScenesResponseBodySceneListScene>> scene{};

  DescribeCasterScenesResponseBodySceneList() {}

  explicit DescribeCasterScenesResponseBodySceneList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scene) {
      vector<boost::any> temp1;
      for(auto item1:*scene){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Scene"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      if (typeid(vector<boost::any>) == m["Scene"].type()) {
        vector<DescribeCasterScenesResponseBodySceneListScene> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Scene"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterScenesResponseBodySceneListScene model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scene = make_shared<vector<DescribeCasterScenesResponseBodySceneListScene>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterScenesResponseBodySceneList() = default;
};
class DescribeCasterScenesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCasterScenesResponseBodySceneList> sceneList{};
  shared_ptr<long> total{};

  DescribeCasterScenesResponseBody() {}

  explicit DescribeCasterScenesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sceneList) {
      res["SceneList"] = sceneList ? boost::any(sceneList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SceneList") != m.end() && !m["SceneList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SceneList"].type()) {
        DescribeCasterScenesResponseBodySceneList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SceneList"]));
        sceneList = make_shared<DescribeCasterScenesResponseBodySceneList>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterScenesResponseBody() = default;
};
class DescribeCasterScenesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterScenesResponseBody> body{};

  DescribeCasterScenesResponse() {}

  explicit DescribeCasterScenesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterScenesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterScenesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterScenesResponse() = default;
};
class DescribeCasterStreamUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeCasterStreamUrlRequest() {}

  explicit DescribeCasterStreamUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCasterStreamUrlRequest() = default;
};
class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo : public Darabonba::Model {
public:
  shared_ptr<string> outputStreamUrl{};
  shared_ptr<string> transcodeConfig{};
  shared_ptr<string> videoFormat{};

  DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo() {}

  explicit DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputStreamUrl) {
      res["OutputStreamUrl"] = boost::any(*outputStreamUrl);
    }
    if (transcodeConfig) {
      res["TranscodeConfig"] = boost::any(*transcodeConfig);
    }
    if (videoFormat) {
      res["VideoFormat"] = boost::any(*videoFormat);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputStreamUrl") != m.end() && !m["OutputStreamUrl"].empty()) {
      outputStreamUrl = make_shared<string>(boost::any_cast<string>(m["OutputStreamUrl"]));
    }
    if (m.find("TranscodeConfig") != m.end() && !m["TranscodeConfig"].empty()) {
      transcodeConfig = make_shared<string>(boost::any_cast<string>(m["TranscodeConfig"]));
    }
    if (m.find("VideoFormat") != m.end() && !m["VideoFormat"].empty()) {
      videoFormat = make_shared<string>(boost::any_cast<string>(m["VideoFormat"]));
    }
  }


  virtual ~DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo() = default;
};
class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo>> streamInfo{};

  DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos() {}

  explicit DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamInfo) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamInfo") != m.end() && !m["StreamInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfo"].type()) {
        vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfo = make_shared<vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfosStreamInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos() = default;
};
class DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream : public Darabonba::Model {
public:
  shared_ptr<long> outputType{};
  shared_ptr<string> rtmpUrl{};
  shared_ptr<string> sceneId{};
  shared_ptr<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos> streamInfos{};
  shared_ptr<string> streamUrl{};

  DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream() {}

  explicit DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (rtmpUrl) {
      res["RtmpUrl"] = boost::any(*rtmpUrl);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    if (streamInfos) {
      res["StreamInfos"] = streamInfos ? boost::any(streamInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<long>(boost::any_cast<long>(m["OutputType"]));
    }
    if (m.find("RtmpUrl") != m.end() && !m["RtmpUrl"].empty()) {
      rtmpUrl = make_shared<string>(boost::any_cast<string>(m["RtmpUrl"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInfos"].type()) {
        DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInfos"]));
        streamInfos = make_shared<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStreamStreamInfos>(model1);
      }
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream() = default;
};
class DescribeCasterStreamUrlResponseBodyCasterStreams : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream>> casterStream{};

  DescribeCasterStreamUrlResponseBodyCasterStreams() {}

  explicit DescribeCasterStreamUrlResponseBodyCasterStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterStream) {
      vector<boost::any> temp1;
      for(auto item1:*casterStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CasterStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterStream") != m.end() && !m["CasterStream"].empty()) {
      if (typeid(vector<boost::any>) == m["CasterStream"].type()) {
        vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CasterStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        casterStream = make_shared<vector<DescribeCasterStreamUrlResponseBodyCasterStreamsCasterStream>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterStreamUrlResponseBodyCasterStreams() = default;
};
class DescribeCasterStreamUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<DescribeCasterStreamUrlResponseBodyCasterStreams> casterStreams{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCasterStreamUrlResponseBody() {}

  explicit DescribeCasterStreamUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (casterStreams) {
      res["CasterStreams"] = casterStreams ? boost::any(casterStreams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CasterStreams") != m.end() && !m["CasterStreams"].empty()) {
      if (typeid(map<string, boost::any>) == m["CasterStreams"].type()) {
        DescribeCasterStreamUrlResponseBodyCasterStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CasterStreams"]));
        casterStreams = make_shared<DescribeCasterStreamUrlResponseBodyCasterStreams>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCasterStreamUrlResponseBody() = default;
};
class DescribeCasterStreamUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterStreamUrlResponseBody> body{};

  DescribeCasterStreamUrlResponse() {}

  explicit DescribeCasterStreamUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterStreamUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterStreamUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterStreamUrlResponse() = default;
};
class DescribeCasterVideoResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeCasterVideoResourcesRequest() {}

  explicit DescribeCasterVideoResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCasterVideoResourcesRequest() = default;
};
class DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource : public Darabonba::Model {
public:
  shared_ptr<long> beginOffset{};
  shared_ptr<long> endOffset{};
  shared_ptr<string> flvUrl{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> liveStreamUrl{};
  shared_ptr<string> locationId{};
  shared_ptr<string> materialId{};
  shared_ptr<long> ptsCallbackInterval{};
  shared_ptr<long> repeatNum{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> vodUrl{};

  DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource() {}

  explicit DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginOffset) {
      res["BeginOffset"] = boost::any(*beginOffset);
    }
    if (endOffset) {
      res["EndOffset"] = boost::any(*endOffset);
    }
    if (flvUrl) {
      res["FlvUrl"] = boost::any(*flvUrl);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (liveStreamUrl) {
      res["LiveStreamUrl"] = boost::any(*liveStreamUrl);
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (ptsCallbackInterval) {
      res["PtsCallbackInterval"] = boost::any(*ptsCallbackInterval);
    }
    if (repeatNum) {
      res["RepeatNum"] = boost::any(*repeatNum);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (vodUrl) {
      res["VodUrl"] = boost::any(*vodUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginOffset") != m.end() && !m["BeginOffset"].empty()) {
      beginOffset = make_shared<long>(boost::any_cast<long>(m["BeginOffset"]));
    }
    if (m.find("EndOffset") != m.end() && !m["EndOffset"].empty()) {
      endOffset = make_shared<long>(boost::any_cast<long>(m["EndOffset"]));
    }
    if (m.find("FlvUrl") != m.end() && !m["FlvUrl"].empty()) {
      flvUrl = make_shared<string>(boost::any_cast<string>(m["FlvUrl"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("LiveStreamUrl") != m.end() && !m["LiveStreamUrl"].empty()) {
      liveStreamUrl = make_shared<string>(boost::any_cast<string>(m["LiveStreamUrl"]));
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("PtsCallbackInterval") != m.end() && !m["PtsCallbackInterval"].empty()) {
      ptsCallbackInterval = make_shared<long>(boost::any_cast<long>(m["PtsCallbackInterval"]));
    }
    if (m.find("RepeatNum") != m.end() && !m["RepeatNum"].empty()) {
      repeatNum = make_shared<long>(boost::any_cast<long>(m["RepeatNum"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("VodUrl") != m.end() && !m["VodUrl"].empty()) {
      vodUrl = make_shared<string>(boost::any_cast<string>(m["VodUrl"]));
    }
  }


  virtual ~DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource() = default;
};
class DescribeCasterVideoResourcesResponseBodyVideoResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource>> videoResource{};

  DescribeCasterVideoResourcesResponseBodyVideoResources() {}

  explicit DescribeCasterVideoResourcesResponseBodyVideoResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoResource) {
      vector<boost::any> temp1;
      for(auto item1:*videoResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoResource") != m.end() && !m["VideoResource"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoResource"].type()) {
        vector<DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoResource = make_shared<vector<DescribeCasterVideoResourcesResponseBodyVideoResourcesVideoResource>>(expect1);
      }
    }
  }


  virtual ~DescribeCasterVideoResourcesResponseBodyVideoResources() = default;
};
class DescribeCasterVideoResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<DescribeCasterVideoResourcesResponseBodyVideoResources> videoResources{};

  DescribeCasterVideoResourcesResponseBody() {}

  explicit DescribeCasterVideoResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (videoResources) {
      res["VideoResources"] = videoResources ? boost::any(videoResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("VideoResources") != m.end() && !m["VideoResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoResources"].type()) {
        DescribeCasterVideoResourcesResponseBodyVideoResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoResources"]));
        videoResources = make_shared<DescribeCasterVideoResourcesResponseBodyVideoResources>(model1);
      }
    }
  }


  virtual ~DescribeCasterVideoResourcesResponseBody() = default;
};
class DescribeCasterVideoResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCasterVideoResourcesResponseBody> body{};

  DescribeCasterVideoResourcesResponse() {}

  explicit DescribeCasterVideoResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCasterVideoResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCasterVideoResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCasterVideoResourcesResponse() = default;
};
class DescribeCastersRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCastersRequestTag() {}

  explicit DescribeCastersRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCastersRequestTag() = default;
};
class DescribeCastersRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> casterName{};
  shared_ptr<long> chargeType{};
  shared_ptr<string> endTime{};
  shared_ptr<string> normType{};
  shared_ptr<string> orderByModifyAsc{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> startTime{};
  shared_ptr<long> status{};
  shared_ptr<vector<DescribeCastersRequestTag>> tag{};

  DescribeCastersRequest() {}

  explicit DescribeCastersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (normType) {
      res["NormType"] = boost::any(*normType);
    }
    if (orderByModifyAsc) {
      res["OrderByModifyAsc"] = boost::any(*orderByModifyAsc);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<long>(boost::any_cast<long>(m["ChargeType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("NormType") != m.end() && !m["NormType"].empty()) {
      normType = make_shared<string>(boost::any_cast<string>(m["NormType"]));
    }
    if (m.find("OrderByModifyAsc") != m.end() && !m["OrderByModifyAsc"].empty()) {
      orderByModifyAsc = make_shared<string>(boost::any_cast<string>(m["OrderByModifyAsc"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeCastersRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCastersRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCastersRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeCastersRequest() = default;
};
class DescribeCastersResponseBodyCasterListCasterTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeCastersResponseBodyCasterListCasterTagsTag() {}

  explicit DescribeCastersResponseBodyCasterListCasterTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeCastersResponseBodyCasterListCasterTagsTag() = default;
};
class DescribeCastersResponseBodyCasterListCasterTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCastersResponseBodyCasterListCasterTagsTag>> tag{};

  DescribeCastersResponseBodyCasterListCasterTags() {}

  explicit DescribeCastersResponseBodyCasterListCasterTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tag") != m.end() && !m["tag"].empty()) {
      if (typeid(vector<boost::any>) == m["tag"].type()) {
        vector<DescribeCastersResponseBodyCasterListCasterTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCastersResponseBodyCasterListCasterTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCastersResponseBodyCasterListCasterTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeCastersResponseBodyCasterListCasterTags() = default;
};
class DescribeCastersResponseBodyCasterListCaster : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> casterName{};
  shared_ptr<string> casterTemplate{};
  shared_ptr<long> channelEnable{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clientTokenId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<long> normType{};
  shared_ptr<string> purchaseTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> startTime{};
  shared_ptr<long> status{};
  shared_ptr<DescribeCastersResponseBodyCasterListCasterTags> tags{};

  DescribeCastersResponseBodyCasterListCaster() {}

  explicit DescribeCastersResponseBodyCasterListCaster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (casterTemplate) {
      res["CasterTemplate"] = boost::any(*casterTemplate);
    }
    if (channelEnable) {
      res["ChannelEnable"] = boost::any(*channelEnable);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clientTokenId) {
      res["ClientTokenId"] = boost::any(*clientTokenId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (normType) {
      res["NormType"] = boost::any(*normType);
    }
    if (purchaseTime) {
      res["PurchaseTime"] = boost::any(*purchaseTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("CasterTemplate") != m.end() && !m["CasterTemplate"].empty()) {
      casterTemplate = make_shared<string>(boost::any_cast<string>(m["CasterTemplate"]));
    }
    if (m.find("ChannelEnable") != m.end() && !m["ChannelEnable"].empty()) {
      channelEnable = make_shared<long>(boost::any_cast<long>(m["ChannelEnable"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClientTokenId") != m.end() && !m["ClientTokenId"].empty()) {
      clientTokenId = make_shared<string>(boost::any_cast<string>(m["ClientTokenId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("NormType") != m.end() && !m["NormType"].empty()) {
      normType = make_shared<long>(boost::any_cast<long>(m["NormType"]));
    }
    if (m.find("PurchaseTime") != m.end() && !m["PurchaseTime"].empty()) {
      purchaseTime = make_shared<string>(boost::any_cast<string>(m["PurchaseTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeCastersResponseBodyCasterListCasterTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeCastersResponseBodyCasterListCasterTags>(model1);
      }
    }
  }


  virtual ~DescribeCastersResponseBodyCasterListCaster() = default;
};
class DescribeCastersResponseBodyCasterList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCastersResponseBodyCasterListCaster>> caster{};

  DescribeCastersResponseBodyCasterList() {}

  explicit DescribeCastersResponseBodyCasterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caster) {
      vector<boost::any> temp1;
      for(auto item1:*caster){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Caster"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Caster") != m.end() && !m["Caster"].empty()) {
      if (typeid(vector<boost::any>) == m["Caster"].type()) {
        vector<DescribeCastersResponseBodyCasterListCaster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Caster"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCastersResponseBodyCasterListCaster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        caster = make_shared<vector<DescribeCastersResponseBodyCasterListCaster>>(expect1);
      }
    }
  }


  virtual ~DescribeCastersResponseBodyCasterList() = default;
};
class DescribeCastersResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCastersResponseBodyCasterList> casterList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeCastersResponseBody() {}

  explicit DescribeCastersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterList) {
      res["CasterList"] = casterList ? boost::any(casterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterList") != m.end() && !m["CasterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CasterList"].type()) {
        DescribeCastersResponseBodyCasterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CasterList"]));
        casterList = make_shared<DescribeCastersResponseBodyCasterList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCastersResponseBody() = default;
};
class DescribeCastersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCastersResponseBody> body{};

  DescribeCastersResponse() {}

  explicit DescribeCastersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCastersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCastersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCastersResponse() = default;
};
class DescribeChannelParticipantsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  DescribeChannelParticipantsRequest() {}

  explicit DescribeChannelParticipantsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeChannelParticipantsRequest() = default;
};
class DescribeChannelParticipantsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> times{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};
  shared_ptr<vector<string>> userList{};

  DescribeChannelParticipantsResponseBody() {}

  explicit DescribeChannelParticipantsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    if (userList) {
      res["UserList"] = boost::any(*userList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeChannelParticipantsResponseBody() = default;
};
class DescribeChannelParticipantsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeChannelParticipantsResponseBody> body{};

  DescribeChannelParticipantsResponse() {}

  explicit DescribeChannelParticipantsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeChannelParticipantsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeChannelParticipantsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeChannelParticipantsResponse() = default;
};
class DescribeChannelUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};

  DescribeChannelUsersRequest() {}

  explicit DescribeChannelUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
  }


  virtual ~DescribeChannelUsersRequest() = default;
};
class DescribeChannelUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> interactiveUserList{};
  shared_ptr<long> interactiveUserNumber{};
  shared_ptr<bool> isChannelExists{};
  shared_ptr<vector<string>> liveUserList{};
  shared_ptr<long> liveUserNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> timestamp{};

  DescribeChannelUsersResponseBody() {}

  explicit DescribeChannelUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interactiveUserList) {
      res["InteractiveUserList"] = boost::any(*interactiveUserList);
    }
    if (interactiveUserNumber) {
      res["InteractiveUserNumber"] = boost::any(*interactiveUserNumber);
    }
    if (isChannelExists) {
      res["IsChannelExists"] = boost::any(*isChannelExists);
    }
    if (liveUserList) {
      res["LiveUserList"] = boost::any(*liveUserList);
    }
    if (liveUserNumber) {
      res["LiveUserNumber"] = boost::any(*liveUserNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InteractiveUserList") != m.end() && !m["InteractiveUserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InteractiveUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InteractiveUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      interactiveUserList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InteractiveUserNumber") != m.end() && !m["InteractiveUserNumber"].empty()) {
      interactiveUserNumber = make_shared<long>(boost::any_cast<long>(m["InteractiveUserNumber"]));
    }
    if (m.find("IsChannelExists") != m.end() && !m["IsChannelExists"].empty()) {
      isChannelExists = make_shared<bool>(boost::any_cast<bool>(m["IsChannelExists"]));
    }
    if (m.find("LiveUserList") != m.end() && !m["LiveUserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LiveUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LiveUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      liveUserList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LiveUserNumber") != m.end() && !m["LiveUserNumber"].empty()) {
      liveUserNumber = make_shared<long>(boost::any_cast<long>(m["LiveUserNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeChannelUsersResponseBody() = default;
};
class DescribeChannelUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeChannelUsersResponseBody> body{};

  DescribeChannelUsersResponse() {}

  explicit DescribeChannelUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeChannelUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeChannelUsersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeChannelUsersResponse() = default;
};
class DescribeDomainUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> dataProtocol{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> field{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  DescribeDomainUsageDataRequest() {}

  explicit DescribeDomainUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (dataProtocol) {
      res["DataProtocol"] = boost::any(*dataProtocol);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DataProtocol") != m.end() && !m["DataProtocol"].empty()) {
      dataProtocol = make_shared<string>(boost::any_cast<string>(m["DataProtocol"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDomainUsageDataRequest() = default;
};
class DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule() {}

  explicit DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule() = default;
};
class DescribeDomainUsageDataResponseBodyUsageDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule>> dataModule{};

  DescribeDomainUsageDataResponseBodyUsageDataPerInterval() {}

  explicit DescribeDomainUsageDataResponseBodyUsageDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainUsageDataResponseBodyUsageDataPerInterval() = default;
};
class DescribeDomainUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};
  shared_ptr<DescribeDomainUsageDataResponseBodyUsageDataPerInterval> usageDataPerInterval{};

  DescribeDomainUsageDataResponseBody() {}

  explicit DescribeDomainUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usageDataPerInterval) {
      res["UsageDataPerInterval"] = usageDataPerInterval ? boost::any(usageDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UsageDataPerInterval") != m.end() && !m["UsageDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["UsageDataPerInterval"].type()) {
        DescribeDomainUsageDataResponseBodyUsageDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UsageDataPerInterval"]));
        usageDataPerInterval = make_shared<DescribeDomainUsageDataResponseBodyUsageDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDomainUsageDataResponseBody() = default;
};
class DescribeDomainUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainUsageDataResponseBody> body{};

  DescribeDomainUsageDataResponse() {}

  explicit DescribeDomainUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainUsageDataResponse() = default;
};
class DescribeDomainWithIntegrityRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<double> integrity{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeDomainWithIntegrityRequest() {}

  explicit DescribeDomainWithIntegrityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (integrity) {
      res["Integrity"] = boost::any(*integrity);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Integrity") != m.end() && !m["Integrity"].empty()) {
      integrity = make_shared<double>(boost::any_cast<double>(m["Integrity"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainWithIntegrityRequest() = default;
};
class DescribeDomainWithIntegrityResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<string>> columns{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> points{};

  DescribeDomainWithIntegrityResponseBodyContent() {}

  explicit DescribeDomainWithIntegrityResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Columns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      columns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Points"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Points"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      points = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDomainWithIntegrityResponseBodyContent() = default;
};
class DescribeDomainWithIntegrityResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainWithIntegrityResponseBodyContent>> content{};
  shared_ptr<string> requestId{};

  DescribeDomainWithIntegrityResponseBody() {}

  explicit DescribeDomainWithIntegrityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeDomainWithIntegrityResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainWithIntegrityResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeDomainWithIntegrityResponseBodyContent>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainWithIntegrityResponseBody() = default;
};
class DescribeDomainWithIntegrityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainWithIntegrityResponseBody> body{};

  DescribeDomainWithIntegrityResponse() {}

  explicit DescribeDomainWithIntegrityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainWithIntegrityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainWithIntegrityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainWithIntegrityResponse() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> time{};

  DescribeHlsLiveStreamRealTimeBpsDataRequest() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataRequest() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos : public Darabonba::Model {
public:
  shared_ptr<double> downFlow{};
  shared_ptr<double> online{};
  shared_ptr<string> rate{};

  DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downFlow) {
      res["DownFlow"] = boost::any(*downFlow);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownFlow") != m.end() && !m["DownFlow"].empty()) {
      downFlow = make_shared<double>(boost::any_cast<double>(m["DownFlow"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<double>(boost::any_cast<double>(m["Online"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos>> infos{};
  shared_ptr<string> streamName{};

  DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infos) {
      vector<boost::any> temp1;
      for(auto item1:*infos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Infos"] = boost::any(temp1);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Infos") != m.end() && !m["Infos"].empty()) {
      if (typeid(vector<boost::any>) == m["Infos"].type()) {
        vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        infos = make_shared<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfosInfos>>(expect1);
      }
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos>> streamInfos{};

  DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (streamInfos) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfos"].type()) {
        vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfos = make_shared<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageDataStreamInfos>>(expect1);
      }
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> time{};
  shared_ptr<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData>> usageData{};

  DescribeHlsLiveStreamRealTimeBpsDataResponseBody() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeHlsLiveStreamRealTimeBpsDataResponseBodyUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataResponseBody() = default;
};
class DescribeHlsLiveStreamRealTimeBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHlsLiveStreamRealTimeBpsDataResponseBody> body{};

  DescribeHlsLiveStreamRealTimeBpsDataResponse() {}

  explicit DescribeHlsLiveStreamRealTimeBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHlsLiveStreamRealTimeBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHlsLiveStreamRealTimeBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHlsLiveStreamRealTimeBpsDataResponse() = default;
};
class DescribeLiveAIProduceRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> rulesId{};
  shared_ptr<string> suffixName{};

  DescribeLiveAIProduceRulesRequest() {}

  explicit DescribeLiveAIProduceRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rulesId) {
      res["RulesId"] = boost::any(*rulesId);
    }
    if (suffixName) {
      res["SuffixName"] = boost::any(*suffixName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RulesId") != m.end() && !m["RulesId"].empty()) {
      rulesId = make_shared<string>(boost::any_cast<string>(m["RulesId"]));
    }
    if (m.find("SuffixName") != m.end() && !m["SuffixName"].empty()) {
      suffixName = make_shared<string>(boost::any_cast<string>(m["SuffixName"]));
    }
  }


  virtual ~DescribeLiveAIProduceRulesRequest() = default;
};
class DescribeLiveAIProduceRulesResponseBodyRuleInfoListRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> gmtModifyTime{};
  shared_ptr<bool> isLazy{};
  shared_ptr<string> liveTemplate{};
  shared_ptr<string> rulesId{};
  shared_ptr<string> studioName{};
  shared_ptr<string> subtitleName{};
  shared_ptr<string> suffixName{};

  DescribeLiveAIProduceRulesResponseBodyRuleInfoListRuleInfo() {}

  explicit DescribeLiveAIProduceRulesResponseBodyRuleInfoListRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (gmtModifyTime) {
      res["GmtModifyTime"] = boost::any(*gmtModifyTime);
    }
    if (isLazy) {
      res["IsLazy"] = boost::any(*isLazy);
    }
    if (liveTemplate) {
      res["LiveTemplate"] = boost::any(*liveTemplate);
    }
    if (rulesId) {
      res["RulesId"] = boost::any(*rulesId);
    }
    if (studioName) {
      res["StudioName"] = boost::any(*studioName);
    }
    if (subtitleName) {
      res["SubtitleName"] = boost::any(*subtitleName);
    }
    if (suffixName) {
      res["SuffixName"] = boost::any(*suffixName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("GmtModifyTime") != m.end() && !m["GmtModifyTime"].empty()) {
      gmtModifyTime = make_shared<string>(boost::any_cast<string>(m["GmtModifyTime"]));
    }
    if (m.find("IsLazy") != m.end() && !m["IsLazy"].empty()) {
      isLazy = make_shared<bool>(boost::any_cast<bool>(m["IsLazy"]));
    }
    if (m.find("LiveTemplate") != m.end() && !m["LiveTemplate"].empty()) {
      liveTemplate = make_shared<string>(boost::any_cast<string>(m["LiveTemplate"]));
    }
    if (m.find("RulesId") != m.end() && !m["RulesId"].empty()) {
      rulesId = make_shared<string>(boost::any_cast<string>(m["RulesId"]));
    }
    if (m.find("StudioName") != m.end() && !m["StudioName"].empty()) {
      studioName = make_shared<string>(boost::any_cast<string>(m["StudioName"]));
    }
    if (m.find("SubtitleName") != m.end() && !m["SubtitleName"].empty()) {
      subtitleName = make_shared<string>(boost::any_cast<string>(m["SubtitleName"]));
    }
    if (m.find("SuffixName") != m.end() && !m["SuffixName"].empty()) {
      suffixName = make_shared<string>(boost::any_cast<string>(m["SuffixName"]));
    }
  }


  virtual ~DescribeLiveAIProduceRulesResponseBodyRuleInfoListRuleInfo() = default;
};
class DescribeLiveAIProduceRulesResponseBodyRuleInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveAIProduceRulesResponseBodyRuleInfoListRuleInfo>> ruleInfo{};

  DescribeLiveAIProduceRulesResponseBodyRuleInfoList() {}

  explicit DescribeLiveAIProduceRulesResponseBodyRuleInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleInfo") != m.end() && !m["RuleInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleInfo"].type()) {
        vector<DescribeLiveAIProduceRulesResponseBodyRuleInfoListRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveAIProduceRulesResponseBodyRuleInfoListRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfo = make_shared<vector<DescribeLiveAIProduceRulesResponseBodyRuleInfoListRuleInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveAIProduceRulesResponseBodyRuleInfoList() = default;
};
class DescribeLiveAIProduceRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveAIProduceRulesResponseBodyRuleInfoList> ruleInfoList{};

  DescribeLiveAIProduceRulesResponseBody() {}

  explicit DescribeLiveAIProduceRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleInfoList) {
      res["RuleInfoList"] = ruleInfoList ? boost::any(ruleInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleInfoList") != m.end() && !m["RuleInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleInfoList"].type()) {
        DescribeLiveAIProduceRulesResponseBodyRuleInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleInfoList"]));
        ruleInfoList = make_shared<DescribeLiveAIProduceRulesResponseBodyRuleInfoList>(model1);
      }
    }
  }


  virtual ~DescribeLiveAIProduceRulesResponseBody() = default;
};
class DescribeLiveAIProduceRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveAIProduceRulesResponseBody> body{};

  DescribeLiveAIProduceRulesResponse() {}

  explicit DescribeLiveAIProduceRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveAIProduceRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveAIProduceRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveAIProduceRulesResponse() = default;
};
class DescribeLiveAIStudioRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> studioId{};
  shared_ptr<string> studioName{};

  DescribeLiveAIStudioRequest() {}

  explicit DescribeLiveAIStudioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (studioId) {
      res["StudioId"] = boost::any(*studioId);
    }
    if (studioName) {
      res["StudioName"] = boost::any(*studioName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StudioId") != m.end() && !m["StudioId"].empty()) {
      studioId = make_shared<string>(boost::any_cast<string>(m["StudioId"]));
    }
    if (m.find("StudioName") != m.end() && !m["StudioName"].empty()) {
      studioName = make_shared<string>(boost::any_cast<string>(m["StudioName"]));
    }
  }


  virtual ~DescribeLiveAIStudioRequest() = default;
};
class DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfigRuleIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ruleId{};

  DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfigRuleIds() {}

  explicit DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfigRuleIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["ruleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ruleId") != m.end() && !m["ruleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ruleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ruleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfigRuleIds() = default;
};
class DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<string> backgroundResourceId{};
  shared_ptr<string> backgroundResourceUrl{};
  shared_ptr<string> backgroundType{};
  shared_ptr<string> description{};
  shared_ptr<string> height{};
  shared_ptr<string> mattingLayout{};
  shared_ptr<string> mattingType{};
  shared_ptr<string> mediaLayout{};
  shared_ptr<string> mediaResourceId{};
  shared_ptr<string> mediaResourceUrl{};
  shared_ptr<string> mediaType{};
  shared_ptr<DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfigRuleIds> ruleIds{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> width{};

  DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfig() {}

  explicit DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundResourceId) {
      res["BackgroundResourceId"] = boost::any(*backgroundResourceId);
    }
    if (backgroundResourceUrl) {
      res["BackgroundResourceUrl"] = boost::any(*backgroundResourceUrl);
    }
    if (backgroundType) {
      res["BackgroundType"] = boost::any(*backgroundType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mattingLayout) {
      res["MattingLayout"] = boost::any(*mattingLayout);
    }
    if (mattingType) {
      res["MattingType"] = boost::any(*mattingType);
    }
    if (mediaLayout) {
      res["MediaLayout"] = boost::any(*mediaLayout);
    }
    if (mediaResourceId) {
      res["MediaResourceId"] = boost::any(*mediaResourceId);
    }
    if (mediaResourceUrl) {
      res["MediaResourceUrl"] = boost::any(*mediaResourceUrl);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (ruleIds) {
      res["RuleIds"] = ruleIds ? boost::any(ruleIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundResourceId") != m.end() && !m["BackgroundResourceId"].empty()) {
      backgroundResourceId = make_shared<string>(boost::any_cast<string>(m["BackgroundResourceId"]));
    }
    if (m.find("BackgroundResourceUrl") != m.end() && !m["BackgroundResourceUrl"].empty()) {
      backgroundResourceUrl = make_shared<string>(boost::any_cast<string>(m["BackgroundResourceUrl"]));
    }
    if (m.find("BackgroundType") != m.end() && !m["BackgroundType"].empty()) {
      backgroundType = make_shared<string>(boost::any_cast<string>(m["BackgroundType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MattingLayout") != m.end() && !m["MattingLayout"].empty()) {
      mattingLayout = make_shared<string>(boost::any_cast<string>(m["MattingLayout"]));
    }
    if (m.find("MattingType") != m.end() && !m["MattingType"].empty()) {
      mattingType = make_shared<string>(boost::any_cast<string>(m["MattingType"]));
    }
    if (m.find("MediaLayout") != m.end() && !m["MediaLayout"].empty()) {
      mediaLayout = make_shared<string>(boost::any_cast<string>(m["MediaLayout"]));
    }
    if (m.find("MediaResourceId") != m.end() && !m["MediaResourceId"].empty()) {
      mediaResourceId = make_shared<string>(boost::any_cast<string>(m["MediaResourceId"]));
    }
    if (m.find("MediaResourceUrl") != m.end() && !m["MediaResourceUrl"].empty()) {
      mediaResourceUrl = make_shared<string>(boost::any_cast<string>(m["MediaResourceUrl"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleIds"].type()) {
        DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfigRuleIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleIds"]));
        ruleIds = make_shared<DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfigRuleIds>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfig() = default;
};
class DescribeLiveAIStudioResponseBodyStudioConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfig>> subtitleConfig{};

  DescribeLiveAIStudioResponseBodyStudioConfigs() {}

  explicit DescribeLiveAIStudioResponseBodyStudioConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleConfig) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleConfig"].type()) {
        vector<DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleConfig = make_shared<vector<DescribeLiveAIStudioResponseBodyStudioConfigsSubtitleConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveAIStudioResponseBodyStudioConfigs() = default;
};
class DescribeLiveAIStudioResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveAIStudioResponseBodyStudioConfigs> studioConfigs{};
  shared_ptr<long> total{};

  DescribeLiveAIStudioResponseBody() {}

  explicit DescribeLiveAIStudioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (studioConfigs) {
      res["StudioConfigs"] = studioConfigs ? boost::any(studioConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StudioConfigs") != m.end() && !m["StudioConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["StudioConfigs"].type()) {
        DescribeLiveAIStudioResponseBodyStudioConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StudioConfigs"]));
        studioConfigs = make_shared<DescribeLiveAIStudioResponseBodyStudioConfigs>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveAIStudioResponseBody() = default;
};
class DescribeLiveAIStudioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveAIStudioResponseBody> body{};

  DescribeLiveAIStudioResponse() {}

  explicit DescribeLiveAIStudioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveAIStudioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveAIStudioResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveAIStudioResponse() = default;
};
class DescribeLiveAISubtitleRequest : public Darabonba::Model {
public:
  shared_ptr<bool> isDefault{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subtitleId{};
  shared_ptr<string> subtitleName{};

  DescribeLiveAISubtitleRequest() {}

  explicit DescribeLiveAISubtitleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subtitleId) {
      res["SubtitleId"] = boost::any(*subtitleId);
    }
    if (subtitleName) {
      res["SubtitleName"] = boost::any(*subtitleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubtitleId") != m.end() && !m["SubtitleId"].empty()) {
      subtitleId = make_shared<string>(boost::any_cast<string>(m["SubtitleId"]));
    }
    if (m.find("SubtitleName") != m.end() && !m["SubtitleName"].empty()) {
      subtitleName = make_shared<string>(boost::any_cast<string>(m["SubtitleName"]));
    }
  }


  virtual ~DescribeLiveAISubtitleRequest() = default;
};
class DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigPositionNormalized : public Darabonba::Model {
public:
  shared_ptr<vector<double>> position{};

  DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigPositionNormalized() {}

  explicit DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigPositionNormalized(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (position) {
      res["Position"] = boost::any(*position);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["Position"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Position"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      position = make_shared<vector<double>>(toVec1);
    }
  }


  virtual ~DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigPositionNormalized() = default;
};
class DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigRulesRefer : public Darabonba::Model {
public:
  shared_ptr<vector<string>> rulesId{};

  DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigRulesRefer() {}

  explicit DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigRulesRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rulesId) {
      res["RulesId"] = boost::any(*rulesId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RulesId") != m.end() && !m["RulesId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RulesId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RulesId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rulesId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigRulesRefer() = default;
};
class DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<double> bgWidthNormalized{};
  shared_ptr<double> borderWidthNormalized{};
  shared_ptr<string> description{};
  shared_ptr<string> dstLanguage{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<string> fontSizeNormalized{};
  shared_ptr<string> height{};
  shared_ptr<long> maxLines{};
  shared_ptr<DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigPositionNormalized> positionNormalized{};
  shared_ptr<DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigRulesRefer> rulesRefer{};
  shared_ptr<long> showSourceLan{};
  shared_ptr<string> srcLanguage{};
  shared_ptr<string> subtitleId{};
  shared_ptr<string> subtitleName{};
  shared_ptr<string> width{};
  shared_ptr<long> wordPerline{};

  DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfig() {}

  explicit DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (bgWidthNormalized) {
      res["BgWidthNormalized"] = boost::any(*bgWidthNormalized);
    }
    if (borderWidthNormalized) {
      res["BorderWidthNormalized"] = boost::any(*borderWidthNormalized);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dstLanguage) {
      res["DstLanguage"] = boost::any(*dstLanguage);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSizeNormalized) {
      res["FontSizeNormalized"] = boost::any(*fontSizeNormalized);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxLines) {
      res["MaxLines"] = boost::any(*maxLines);
    }
    if (positionNormalized) {
      res["PositionNormalized"] = positionNormalized ? boost::any(positionNormalized->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rulesRefer) {
      res["RulesRefer"] = rulesRefer ? boost::any(rulesRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (showSourceLan) {
      res["ShowSourceLan"] = boost::any(*showSourceLan);
    }
    if (srcLanguage) {
      res["SrcLanguage"] = boost::any(*srcLanguage);
    }
    if (subtitleId) {
      res["SubtitleId"] = boost::any(*subtitleId);
    }
    if (subtitleName) {
      res["SubtitleName"] = boost::any(*subtitleName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (wordPerline) {
      res["WordPerline"] = boost::any(*wordPerline);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("BgWidthNormalized") != m.end() && !m["BgWidthNormalized"].empty()) {
      bgWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BgWidthNormalized"]));
    }
    if (m.find("BorderWidthNormalized") != m.end() && !m["BorderWidthNormalized"].empty()) {
      borderWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BorderWidthNormalized"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DstLanguage") != m.end() && !m["DstLanguage"].empty()) {
      dstLanguage = make_shared<string>(boost::any_cast<string>(m["DstLanguage"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSizeNormalized") != m.end() && !m["FontSizeNormalized"].empty()) {
      fontSizeNormalized = make_shared<string>(boost::any_cast<string>(m["FontSizeNormalized"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxLines") != m.end() && !m["MaxLines"].empty()) {
      maxLines = make_shared<long>(boost::any_cast<long>(m["MaxLines"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      if (typeid(map<string, boost::any>) == m["PositionNormalized"].type()) {
        DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigPositionNormalized model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PositionNormalized"]));
        positionNormalized = make_shared<DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigPositionNormalized>(model1);
      }
    }
    if (m.find("RulesRefer") != m.end() && !m["RulesRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RulesRefer"].type()) {
        DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigRulesRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RulesRefer"]));
        rulesRefer = make_shared<DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfigRulesRefer>(model1);
      }
    }
    if (m.find("ShowSourceLan") != m.end() && !m["ShowSourceLan"].empty()) {
      showSourceLan = make_shared<long>(boost::any_cast<long>(m["ShowSourceLan"]));
    }
    if (m.find("SrcLanguage") != m.end() && !m["SrcLanguage"].empty()) {
      srcLanguage = make_shared<string>(boost::any_cast<string>(m["SrcLanguage"]));
    }
    if (m.find("SubtitleId") != m.end() && !m["SubtitleId"].empty()) {
      subtitleId = make_shared<string>(boost::any_cast<string>(m["SubtitleId"]));
    }
    if (m.find("SubtitleName") != m.end() && !m["SubtitleName"].empty()) {
      subtitleName = make_shared<string>(boost::any_cast<string>(m["SubtitleName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("WordPerline") != m.end() && !m["WordPerline"].empty()) {
      wordPerline = make_shared<long>(boost::any_cast<long>(m["WordPerline"]));
    }
  }


  virtual ~DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfig() = default;
};
class DescribeLiveAISubtitleResponseBodySubtitleConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfig>> subtitleConfig{};

  DescribeLiveAISubtitleResponseBodySubtitleConfigs() {}

  explicit DescribeLiveAISubtitleResponseBodySubtitleConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleConfig) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleConfig"].type()) {
        vector<DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleConfig = make_shared<vector<DescribeLiveAISubtitleResponseBodySubtitleConfigsSubtitleConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveAISubtitleResponseBodySubtitleConfigs() = default;
};
class DescribeLiveAISubtitleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveAISubtitleResponseBodySubtitleConfigs> subtitleConfigs{};

  DescribeLiveAISubtitleResponseBody() {}

  explicit DescribeLiveAISubtitleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subtitleConfigs) {
      res["SubtitleConfigs"] = subtitleConfigs ? boost::any(subtitleConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubtitleConfigs") != m.end() && !m["SubtitleConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfigs"].type()) {
        DescribeLiveAISubtitleResponseBodySubtitleConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfigs"]));
        subtitleConfigs = make_shared<DescribeLiveAISubtitleResponseBodySubtitleConfigs>(model1);
      }
    }
  }


  virtual ~DescribeLiveAISubtitleResponseBody() = default;
};
class DescribeLiveAISubtitleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveAISubtitleResponseBody> body{};

  DescribeLiveAISubtitleResponse() {}

  explicit DescribeLiveAISubtitleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveAISubtitleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveAISubtitleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveAISubtitleResponse() = default;
};
class DescribeLiveAudioAuditConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DescribeLiveAudioAuditConfigRequest() {}

  explicit DescribeLiveAudioAuditConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveAudioAuditConfigRequest() = default;
};
class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> scene{};

  DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes() {}

  explicit DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["scene"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["scene"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scene = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes() = default;
};
class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> bizType{};
  shared_ptr<string> domainName{};
  shared_ptr<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes> scenes{};
  shared_ptr<string> streamName{};

  DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig() {}

  explicit DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (scenes) {
      res["Scenes"] = scenes ? boost::any(scenes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Scenes") != m.end() && !m["Scenes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scenes"].type()) {
        DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scenes"]));
        scenes = make_shared<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfigScenes>(model1);
      }
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig() = default;
};
class DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig>> liveAudioAuditConfig{};

  DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList() {}

  explicit DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAudioAuditConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveAudioAuditConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveAudioAuditConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAudioAuditConfig") != m.end() && !m["LiveAudioAuditConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveAudioAuditConfig"].type()) {
        vector<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveAudioAuditConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveAudioAuditConfig = make_shared<vector<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigListLiveAudioAuditConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList() = default;
};
class DescribeLiveAudioAuditConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList> liveAudioAuditConfigList{};
  shared_ptr<string> requestId{};

  DescribeLiveAudioAuditConfigResponseBody() {}

  explicit DescribeLiveAudioAuditConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAudioAuditConfigList) {
      res["LiveAudioAuditConfigList"] = liveAudioAuditConfigList ? boost::any(liveAudioAuditConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAudioAuditConfigList") != m.end() && !m["LiveAudioAuditConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveAudioAuditConfigList"].type()) {
        DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveAudioAuditConfigList"]));
        liveAudioAuditConfigList = make_shared<DescribeLiveAudioAuditConfigResponseBodyLiveAudioAuditConfigList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveAudioAuditConfigResponseBody() = default;
};
class DescribeLiveAudioAuditConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveAudioAuditConfigResponseBody> body{};

  DescribeLiveAudioAuditConfigResponse() {}

  explicit DescribeLiveAudioAuditConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveAudioAuditConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveAudioAuditConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveAudioAuditConfigResponse() = default;
};
class DescribeLiveAudioAuditNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveAudioAuditNotifyConfigRequest() {}

  explicit DescribeLiveAudioAuditNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveAudioAuditNotifyConfigRequest() = default;
};
class DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> callback{};
  shared_ptr<string> callbackTemplate{};
  shared_ptr<string> domainName{};

  DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig() {}

  explicit DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (callbackTemplate) {
      res["CallbackTemplate"] = boost::any(*callbackTemplate);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CallbackTemplate") != m.end() && !m["CallbackTemplate"].empty()) {
      callbackTemplate = make_shared<string>(boost::any_cast<string>(m["CallbackTemplate"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig() = default;
};
class DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig>> liveAudioAuditNotifyConfig{};

  DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList() {}

  explicit DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAudioAuditNotifyConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveAudioAuditNotifyConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveAudioAuditNotifyConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAudioAuditNotifyConfig") != m.end() && !m["LiveAudioAuditNotifyConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveAudioAuditNotifyConfig"].type()) {
        vector<DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveAudioAuditNotifyConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveAudioAuditNotifyConfig = make_shared<vector<DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigListLiveAudioAuditNotifyConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList() = default;
};
class DescribeLiveAudioAuditNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList> liveAudioAuditNotifyConfigList{};
  shared_ptr<string> requestId{};

  DescribeLiveAudioAuditNotifyConfigResponseBody() {}

  explicit DescribeLiveAudioAuditNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAudioAuditNotifyConfigList) {
      res["LiveAudioAuditNotifyConfigList"] = liveAudioAuditNotifyConfigList ? boost::any(liveAudioAuditNotifyConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAudioAuditNotifyConfigList") != m.end() && !m["LiveAudioAuditNotifyConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveAudioAuditNotifyConfigList"].type()) {
        DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveAudioAuditNotifyConfigList"]));
        liveAudioAuditNotifyConfigList = make_shared<DescribeLiveAudioAuditNotifyConfigResponseBodyLiveAudioAuditNotifyConfigList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveAudioAuditNotifyConfigResponseBody() = default;
};
class DescribeLiveAudioAuditNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveAudioAuditNotifyConfigResponseBody> body{};

  DescribeLiveAudioAuditNotifyConfigResponse() {}

  explicit DescribeLiveAudioAuditNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveAudioAuditNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveAudioAuditNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveAudioAuditNotifyConfigResponse() = default;
};
class DescribeLiveCdnDiagnoseInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<long> endTime{};
  shared_ptr<string> intervalType{};
  shared_ptr<long> phase{};
  shared_ptr<string> requestType{};
  shared_ptr<long> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> streamSuffix{};

  DescribeLiveCdnDiagnoseInfoRequest() {}

  explicit DescribeLiveCdnDiagnoseInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (app) {
      res["app"] = boost::any(*app);
    }
    if (domain) {
      res["domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (intervalType) {
      res["intervalType"] = boost::any(*intervalType);
    }
    if (phase) {
      res["phase"] = boost::any(*phase);
    }
    if (requestType) {
      res["requestType"] = boost::any(*requestType);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["streamName"] = boost::any(*streamName);
    }
    if (streamSuffix) {
      res["streamSuffix"] = boost::any(*streamSuffix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("app") != m.end() && !m["app"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["app"]));
    }
    if (m.find("domain") != m.end() && !m["domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["domain"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("intervalType") != m.end() && !m["intervalType"].empty()) {
      intervalType = make_shared<string>(boost::any_cast<string>(m["intervalType"]));
    }
    if (m.find("phase") != m.end() && !m["phase"].empty()) {
      phase = make_shared<long>(boost::any_cast<long>(m["phase"]));
    }
    if (m.find("requestType") != m.end() && !m["requestType"].empty()) {
      requestType = make_shared<string>(boost::any_cast<string>(m["requestType"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("streamName") != m.end() && !m["streamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["streamName"]));
    }
    if (m.find("streamSuffix") != m.end() && !m["streamSuffix"].empty()) {
      streamSuffix = make_shared<string>(boost::any_cast<string>(m["streamSuffix"]));
    }
  }


  virtual ~DescribeLiveCdnDiagnoseInfoRequest() = default;
};
class DescribeLiveCdnDiagnoseInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DescribeLiveCdnDiagnoseInfoResponseBody() {}

  explicit DescribeLiveCdnDiagnoseInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveCdnDiagnoseInfoResponseBody() = default;
};
class DescribeLiveCdnDiagnoseInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveCdnDiagnoseInfoResponseBody> body{};

  DescribeLiveCdnDiagnoseInfoResponse() {}

  explicit DescribeLiveCdnDiagnoseInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveCdnDiagnoseInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveCdnDiagnoseInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveCdnDiagnoseInfoResponse() = default;
};
class DescribeLiveCenterStreamRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveCenterStreamRateDataRequest() {}

  explicit DescribeLiveCenterStreamRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveCenterStreamRateDataRequest() = default;
};
class DescribeLiveCenterStreamRateDataResponseBodyRateDatas : public Darabonba::Model {
public:
  shared_ptr<string> audioFps{};
  shared_ptr<string> audioRate{};
  shared_ptr<string> time{};
  shared_ptr<string> videoFps{};
  shared_ptr<string> videoRate{};

  DescribeLiveCenterStreamRateDataResponseBodyRateDatas() {}

  explicit DescribeLiveCenterStreamRateDataResponseBodyRateDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFps) {
      res["AudioFps"] = boost::any(*audioFps);
    }
    if (audioRate) {
      res["AudioRate"] = boost::any(*audioRate);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (videoFps) {
      res["VideoFps"] = boost::any(*videoFps);
    }
    if (videoRate) {
      res["VideoRate"] = boost::any(*videoRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFps") != m.end() && !m["AudioFps"].empty()) {
      audioFps = make_shared<string>(boost::any_cast<string>(m["AudioFps"]));
    }
    if (m.find("AudioRate") != m.end() && !m["AudioRate"].empty()) {
      audioRate = make_shared<string>(boost::any_cast<string>(m["AudioRate"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("VideoFps") != m.end() && !m["VideoFps"].empty()) {
      videoFps = make_shared<string>(boost::any_cast<string>(m["VideoFps"]));
    }
    if (m.find("VideoRate") != m.end() && !m["VideoRate"].empty()) {
      videoRate = make_shared<string>(boost::any_cast<string>(m["VideoRate"]));
    }
  }


  virtual ~DescribeLiveCenterStreamRateDataResponseBodyRateDatas() = default;
};
class DescribeLiveCenterStreamRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveCenterStreamRateDataResponseBodyRateDatas>> rateDatas{};
  shared_ptr<string> requestId{};

  DescribeLiveCenterStreamRateDataResponseBody() {}

  explicit DescribeLiveCenterStreamRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rateDatas) {
      vector<boost::any> temp1;
      for(auto item1:*rateDatas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RateDatas"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RateDatas") != m.end() && !m["RateDatas"].empty()) {
      if (typeid(vector<boost::any>) == m["RateDatas"].type()) {
        vector<DescribeLiveCenterStreamRateDataResponseBodyRateDatas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RateDatas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveCenterStreamRateDataResponseBodyRateDatas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rateDatas = make_shared<vector<DescribeLiveCenterStreamRateDataResponseBodyRateDatas>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveCenterStreamRateDataResponseBody() = default;
};
class DescribeLiveCenterStreamRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveCenterStreamRateDataResponseBody> body{};

  DescribeLiveCenterStreamRateDataResponse() {}

  explicit DescribeLiveCenterStreamRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveCenterStreamRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveCenterStreamRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveCenterStreamRateDataResponse() = default;
};
class DescribeLiveCenterTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dstUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DescribeLiveCenterTransferRequest() {}

  explicit DescribeLiveCenterTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dstUrl) {
      res["DstUrl"] = boost::any(*dstUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DstUrl") != m.end() && !m["DstUrl"].empty()) {
      dstUrl = make_shared<string>(boost::any_cast<string>(m["DstUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveCenterTransferRequest() = default;
};
class DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoListLiveCenterTransferInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dstUrl{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> transferArgs{};

  DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoListLiveCenterTransferInfo() {}

  explicit DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoListLiveCenterTransferInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dstUrl) {
      res["DstUrl"] = boost::any(*dstUrl);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transferArgs) {
      res["TransferArgs"] = boost::any(*transferArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DstUrl") != m.end() && !m["DstUrl"].empty()) {
      dstUrl = make_shared<string>(boost::any_cast<string>(m["DstUrl"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TransferArgs") != m.end() && !m["TransferArgs"].empty()) {
      transferArgs = make_shared<string>(boost::any_cast<string>(m["TransferArgs"]));
    }
  }


  virtual ~DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoListLiveCenterTransferInfo() = default;
};
class DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoListLiveCenterTransferInfo>> liveCenterTransferInfo{};

  DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoList() {}

  explicit DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveCenterTransferInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveCenterTransferInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveCenterTransferInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveCenterTransferInfo") != m.end() && !m["LiveCenterTransferInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveCenterTransferInfo"].type()) {
        vector<DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoListLiveCenterTransferInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveCenterTransferInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoListLiveCenterTransferInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveCenterTransferInfo = make_shared<vector<DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoListLiveCenterTransferInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoList() = default;
};
class DescribeLiveCenterTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoList> liveCenterTransferInfoList{};
  shared_ptr<string> requestId{};

  DescribeLiveCenterTransferResponseBody() {}

  explicit DescribeLiveCenterTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveCenterTransferInfoList) {
      res["LiveCenterTransferInfoList"] = liveCenterTransferInfoList ? boost::any(liveCenterTransferInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveCenterTransferInfoList") != m.end() && !m["LiveCenterTransferInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveCenterTransferInfoList"].type()) {
        DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveCenterTransferInfoList"]));
        liveCenterTransferInfoList = make_shared<DescribeLiveCenterTransferResponseBodyLiveCenterTransferInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveCenterTransferResponseBody() = default;
};
class DescribeLiveCenterTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveCenterTransferResponseBody> body{};

  DescribeLiveCenterTransferResponse() {}

  explicit DescribeLiveCenterTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveCenterTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveCenterTransferResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveCenterTransferResponse() = default;
};
class DescribeLiveCertificateDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveCertificateDetailRequest() {}

  explicit DescribeLiveCertificateDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveCertificateDetailRequest() = default;
};
class DescribeLiveCertificateDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cert{};
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> requestId{};

  DescribeLiveCertificateDetailResponseBody() {}

  explicit DescribeLiveCertificateDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      res["Cert"] = boost::any(*cert);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      cert = make_shared<string>(boost::any_cast<string>(m["Cert"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveCertificateDetailResponseBody() = default;
};
class DescribeLiveCertificateDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveCertificateDetailResponseBody> body{};

  DescribeLiveCertificateDetailResponse() {}

  explicit DescribeLiveCertificateDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveCertificateDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveCertificateDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveCertificateDetailResponse() = default;
};
class DescribeLiveCertificateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveCertificateListRequest() {}

  explicit DescribeLiveCertificateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveCertificateListRequest() = default;
};
class DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert : public Darabonba::Model {
public:
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> common{};
  shared_ptr<string> fingerprint{};
  shared_ptr<string> issuer{};
  shared_ptr<long> lastTime{};

  DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert() {}

  explicit DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (common) {
      res["Common"] = boost::any(*common);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<string>(boost::any_cast<string>(m["Common"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
  }


  virtual ~DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert() = default;
};
class DescribeLiveCertificateListResponseBodyCertificateListModelCertList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert>> cert{};

  DescribeLiveCertificateListResponseBodyCertificateListModelCertList() {}

  explicit DescribeLiveCertificateListResponseBodyCertificateListModelCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      vector<boost::any> temp1;
      for(auto item1:*cert){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cert"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      if (typeid(vector<boost::any>) == m["Cert"].type()) {
        vector<DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cert"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cert = make_shared<vector<DescribeLiveCertificateListResponseBodyCertificateListModelCertListCert>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveCertificateListResponseBodyCertificateListModelCertList() = default;
};
class DescribeLiveCertificateListResponseBodyCertificateListModel : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveCertificateListResponseBodyCertificateListModelCertList> certList{};
  shared_ptr<long> count{};

  DescribeLiveCertificateListResponseBodyCertificateListModel() {}

  explicit DescribeLiveCertificateListResponseBodyCertificateListModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certList) {
      res["CertList"] = certList ? boost::any(certList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertList") != m.end() && !m["CertList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertList"].type()) {
        DescribeLiveCertificateListResponseBodyCertificateListModelCertList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertList"]));
        certList = make_shared<DescribeLiveCertificateListResponseBodyCertificateListModelCertList>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeLiveCertificateListResponseBodyCertificateListModel() = default;
};
class DescribeLiveCertificateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveCertificateListResponseBodyCertificateListModel> certificateListModel{};
  shared_ptr<string> requestId{};

  DescribeLiveCertificateListResponseBody() {}

  explicit DescribeLiveCertificateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateListModel) {
      res["CertificateListModel"] = certificateListModel ? boost::any(certificateListModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateListModel") != m.end() && !m["CertificateListModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertificateListModel"].type()) {
        DescribeLiveCertificateListResponseBodyCertificateListModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertificateListModel"]));
        certificateListModel = make_shared<DescribeLiveCertificateListResponseBodyCertificateListModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveCertificateListResponseBody() = default;
};
class DescribeLiveCertificateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveCertificateListResponseBody> body{};

  DescribeLiveCertificateListResponse() {}

  explicit DescribeLiveCertificateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveCertificateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveCertificateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveCertificateListResponse() = default;
};
class DescribeLiveDelayConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stream{};

  DescribeLiveDelayConfigRequest() {}

  explicit DescribeLiveDelayConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~DescribeLiveDelayConfigRequest() = default;
};
class DescribeLiveDelayConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> delayTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> requestId{};
  shared_ptr<string> stream{};
  shared_ptr<string> taskTriggerMode{};

  DescribeLiveDelayConfigResponseBody() {}

  explicit DescribeLiveDelayConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (delayTime) {
      res["DelayTime"] = boost::any(*delayTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (taskTriggerMode) {
      res["TaskTriggerMode"] = boost::any(*taskTriggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("DelayTime") != m.end() && !m["DelayTime"].empty()) {
      delayTime = make_shared<string>(boost::any_cast<string>(m["DelayTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TaskTriggerMode") != m.end() && !m["TaskTriggerMode"].empty()) {
      taskTriggerMode = make_shared<string>(boost::any_cast<string>(m["TaskTriggerMode"]));
    }
  }


  virtual ~DescribeLiveDelayConfigResponseBody() = default;
};
class DescribeLiveDelayConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDelayConfigResponseBody> body{};

  DescribeLiveDelayConfigResponse() {}

  explicit DescribeLiveDelayConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDelayConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDelayConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDelayConfigResponse() = default;
};
class DescribeLiveDelayedStreamingUsageRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveDelayedStreamingUsageRequest() {}

  explicit DescribeLiveDelayedStreamingUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveDelayedStreamingUsageRequest() = default;
};
class DescribeLiveDelayedStreamingUsageResponseBodyDelayDataDelayDataItem : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> duration{};
  shared_ptr<string> region{};
  shared_ptr<string> streamName{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDelayedStreamingUsageResponseBodyDelayDataDelayDataItem() {}

  explicit DescribeLiveDelayedStreamingUsageResponseBodyDelayDataDelayDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDelayedStreamingUsageResponseBodyDelayDataDelayDataItem() = default;
};
class DescribeLiveDelayedStreamingUsageResponseBodyDelayData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDelayedStreamingUsageResponseBodyDelayDataDelayDataItem>> delayDataItem{};

  DescribeLiveDelayedStreamingUsageResponseBodyDelayData() {}

  explicit DescribeLiveDelayedStreamingUsageResponseBodyDelayData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delayDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*delayDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DelayDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DelayDataItem") != m.end() && !m["DelayDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DelayDataItem"].type()) {
        vector<DescribeLiveDelayedStreamingUsageResponseBodyDelayDataDelayDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DelayDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDelayedStreamingUsageResponseBodyDelayDataDelayDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        delayDataItem = make_shared<vector<DescribeLiveDelayedStreamingUsageResponseBodyDelayDataDelayDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDelayedStreamingUsageResponseBodyDelayData() = default;
};
class DescribeLiveDelayedStreamingUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDelayedStreamingUsageResponseBodyDelayData> delayData{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDelayedStreamingUsageResponseBody() {}

  explicit DescribeLiveDelayedStreamingUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delayData) {
      res["DelayData"] = delayData ? boost::any(delayData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DelayData") != m.end() && !m["DelayData"].empty()) {
      if (typeid(map<string, boost::any>) == m["DelayData"].type()) {
        DescribeLiveDelayedStreamingUsageResponseBodyDelayData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DelayData"]));
        delayData = make_shared<DescribeLiveDelayedStreamingUsageResponseBodyDelayData>(model1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDelayedStreamingUsageResponseBody() = default;
};
class DescribeLiveDelayedStreamingUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDelayedStreamingUsageResponseBody> body{};

  DescribeLiveDelayedStreamingUsageResponse() {}

  explicit DescribeLiveDelayedStreamingUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDelayedStreamingUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDelayedStreamingUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDelayedStreamingUsageResponse() = default;
};
class DescribeLiveDetectNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveDetectNotifyConfigRequest() {}

  explicit DescribeLiveDetectNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveDetectNotifyConfigRequest() = default;
};
class DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyUrl{};

  DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig() {}

  explicit DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
  }


  virtual ~DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig() = default;
};
class DescribeLiveDetectNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig> liveDetectNotifyConfig{};
  shared_ptr<string> requestId{};

  DescribeLiveDetectNotifyConfigResponseBody() {}

  explicit DescribeLiveDetectNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveDetectNotifyConfig) {
      res["LiveDetectNotifyConfig"] = liveDetectNotifyConfig ? boost::any(liveDetectNotifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveDetectNotifyConfig") != m.end() && !m["LiveDetectNotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveDetectNotifyConfig"].type()) {
        DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveDetectNotifyConfig"]));
        liveDetectNotifyConfig = make_shared<DescribeLiveDetectNotifyConfigResponseBodyLiveDetectNotifyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDetectNotifyConfigResponseBody() = default;
};
class DescribeLiveDetectNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDetectNotifyConfigResponseBody> body{};

  DescribeLiveDetectNotifyConfigResponse() {}

  explicit DescribeLiveDetectNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDetectNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDetectNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDetectNotifyConfigResponse() = default;
};
class DescribeLiveDetectPornDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> fee{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scene{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> stream{};

  DescribeLiveDetectPornDataRequest() {}

  explicit DescribeLiveDetectPornDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fee) {
      res["Fee"] = boost::any(*fee);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Fee") != m.end() && !m["Fee"].empty()) {
      fee = make_shared<string>(boost::any_cast<string>(m["Fee"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~DescribeLiveDetectPornDataRequest() = default;
};
class DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<long> count{};
  shared_ptr<string> domain{};
  shared_ptr<string> fee{};
  shared_ptr<string> region{};
  shared_ptr<string> scene{};
  shared_ptr<string> stream{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule() {}

  explicit DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (fee) {
      res["Fee"] = boost::any(*fee);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Fee") != m.end() && !m["Fee"].empty()) {
      fee = make_shared<string>(boost::any_cast<string>(m["Fee"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule() = default;
};
class DescribeLiveDetectPornDataResponseBodyDetectPornData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule>> dataModule{};

  DescribeLiveDetectPornDataResponseBodyDetectPornData() {}

  explicit DescribeLiveDetectPornDataResponseBodyDetectPornData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDetectPornDataResponseBodyDetectPornDataDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDetectPornDataResponseBodyDetectPornData() = default;
};
class DescribeLiveDetectPornDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDetectPornDataResponseBodyDetectPornData> detectPornData{};
  shared_ptr<string> requestId{};

  DescribeLiveDetectPornDataResponseBody() {}

  explicit DescribeLiveDetectPornDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detectPornData) {
      res["DetectPornData"] = detectPornData ? boost::any(detectPornData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DetectPornData") != m.end() && !m["DetectPornData"].empty()) {
      if (typeid(map<string, boost::any>) == m["DetectPornData"].type()) {
        DescribeLiveDetectPornDataResponseBodyDetectPornData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DetectPornData"]));
        detectPornData = make_shared<DescribeLiveDetectPornDataResponseBodyDetectPornData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDetectPornDataResponseBody() = default;
};
class DescribeLiveDetectPornDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDetectPornDataResponseBody> body{};

  DescribeLiveDetectPornDataResponse() {}

  explicit DescribeLiveDetectPornDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDetectPornDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDetectPornDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDetectPornDataResponse() = default;
};
class DescribeLiveDomainBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainBpsDataRequest() {}

  explicit DescribeLiveDomainBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataRequest() = default;
};
class DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> bpsValue{};
  shared_ptr<string> httpBpsValue{};
  shared_ptr<string> httpsBpsValue{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsValue) {
      res["BpsValue"] = boost::any(*bpsValue);
    }
    if (httpBpsValue) {
      res["HttpBpsValue"] = boost::any(*httpBpsValue);
    }
    if (httpsBpsValue) {
      res["HttpsBpsValue"] = boost::any(*httpsBpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsValue") != m.end() && !m["BpsValue"].empty()) {
      bpsValue = make_shared<string>(boost::any_cast<string>(m["BpsValue"]));
    }
    if (m.find("HttpBpsValue") != m.end() && !m["HttpBpsValue"].empty()) {
      httpBpsValue = make_shared<string>(boost::any_cast<string>(m["HttpBpsValue"]));
    }
    if (m.find("HttpsBpsValue") != m.end() && !m["HttpsBpsValue"].empty()) {
      httpsBpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsBpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeLiveDomainBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainBpsDataResponseBody() {}

  explicit DescribeLiveDomainBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeLiveDomainBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataResponseBody() = default;
};
class DescribeLiveDomainBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainBpsDataResponseBody> body{};

  DescribeLiveDomainBpsDataResponse() {}

  explicit DescribeLiveDomainBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainBpsDataResponse() = default;
};
class DescribeLiveDomainBpsDataByLayerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> layer{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainBpsDataByLayerRequest() {}

  explicit DescribeLiveDomainBpsDataByLayerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataByLayerRequest() = default;
};
class DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> trafficValue{};
  shared_ptr<string> value{};

  DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule() {}

  explicit DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<string>(boost::any_cast<string>(m["TrafficValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule() = default;
};
class DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule>> dataModule{};

  DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval() {}

  explicit DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval() = default;
};
class DescribeLiveDomainBpsDataByLayerResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval> bpsDataInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainBpsDataByLayerResponseBody() {}

  explicit DescribeLiveDomainBpsDataByLayerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataInterval) {
      res["BpsDataInterval"] = bpsDataInterval ? boost::any(bpsDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataInterval") != m.end() && !m["BpsDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataInterval"].type()) {
        DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataInterval"]));
        bpsDataInterval = make_shared<DescribeLiveDomainBpsDataByLayerResponseBodyBpsDataInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainBpsDataByLayerResponseBody() = default;
};
class DescribeLiveDomainBpsDataByLayerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainBpsDataByLayerResponseBody> body{};

  DescribeLiveDomainBpsDataByLayerResponse() {}

  explicit DescribeLiveDomainBpsDataByLayerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainBpsDataByLayerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainBpsDataByLayerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainBpsDataByLayerResponse() = default;
};
class DescribeLiveDomainByCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> SSLPub{};
  shared_ptr<bool> SSLStatus{};

  DescribeLiveDomainByCertificateRequest() {}

  explicit DescribeLiveDomainByCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (SSLStatus) {
      res["SSLStatus"] = boost::any(*SSLStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SSLStatus") != m.end() && !m["SSLStatus"].empty()) {
      SSLStatus = make_shared<bool>(boost::any_cast<bool>(m["SSLStatus"]));
    }
  }


  virtual ~DescribeLiveDomainByCertificateRequest() = default;
};
class DescribeLiveDomainByCertificateResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certCaIsLegacy{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certExpired{};
  shared_ptr<string> certStartTime{};
  shared_ptr<string> certSubjectCommonName{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainList{};
  shared_ptr<string> domainNames{};
  shared_ptr<string> issuer{};

  DescribeLiveDomainByCertificateResponseBodyCertInfosCertInfo() {}

  explicit DescribeLiveDomainByCertificateResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certCaIsLegacy) {
      res["CertCaIsLegacy"] = boost::any(*certCaIsLegacy);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certExpired) {
      res["CertExpired"] = boost::any(*certExpired);
    }
    if (certStartTime) {
      res["CertStartTime"] = boost::any(*certStartTime);
    }
    if (certSubjectCommonName) {
      res["CertSubjectCommonName"] = boost::any(*certSubjectCommonName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainList) {
      res["DomainList"] = boost::any(*domainList);
    }
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertCaIsLegacy") != m.end() && !m["CertCaIsLegacy"].empty()) {
      certCaIsLegacy = make_shared<string>(boost::any_cast<string>(m["CertCaIsLegacy"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertExpired") != m.end() && !m["CertExpired"].empty()) {
      certExpired = make_shared<string>(boost::any_cast<string>(m["CertExpired"]));
    }
    if (m.find("CertStartTime") != m.end() && !m["CertStartTime"].empty()) {
      certStartTime = make_shared<string>(boost::any_cast<string>(m["CertStartTime"]));
    }
    if (m.find("CertSubjectCommonName") != m.end() && !m["CertSubjectCommonName"].empty()) {
      certSubjectCommonName = make_shared<string>(boost::any_cast<string>(m["CertSubjectCommonName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainList") != m.end() && !m["DomainList"].empty()) {
      domainList = make_shared<string>(boost::any_cast<string>(m["DomainList"]));
    }
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
  }


  virtual ~DescribeLiveDomainByCertificateResponseBodyCertInfosCertInfo() = default;
};
class DescribeLiveDomainByCertificateResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainByCertificateResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeLiveDomainByCertificateResponseBodyCertInfos() {}

  explicit DescribeLiveDomainByCertificateResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeLiveDomainByCertificateResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainByCertificateResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeLiveDomainByCertificateResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainByCertificateResponseBodyCertInfos() = default;
};
class DescribeLiveDomainByCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainByCertificateResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainByCertificateResponseBody() {}

  explicit DescribeLiveDomainByCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeLiveDomainByCertificateResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeLiveDomainByCertificateResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainByCertificateResponseBody() = default;
};
class DescribeLiveDomainByCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainByCertificateResponseBody> body{};

  DescribeLiveDomainByCertificateResponse() {}

  explicit DescribeLiveDomainByCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainByCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainByCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainByCertificateResponse() = default;
};
class DescribeLiveDomainCertificateInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveDomainCertificateInfoRequest() {}

  explicit DescribeLiveDomainCertificateInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveDomainCertificateInfoRequest() = default;
};
class DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certDomainName{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certLife{};
  shared_ptr<string> certName{};
  shared_ptr<string> certOrg{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> status{};

  DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo() {}

  explicit DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certDomainName) {
      res["CertDomainName"] = boost::any(*certDomainName);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certLife) {
      res["CertLife"] = boost::any(*certLife);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certOrg) {
      res["CertOrg"] = boost::any(*certOrg);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertDomainName") != m.end() && !m["CertDomainName"].empty()) {
      certDomainName = make_shared<string>(boost::any_cast<string>(m["CertDomainName"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertLife") != m.end() && !m["CertLife"].empty()) {
      certLife = make_shared<string>(boost::any_cast<string>(m["CertLife"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertOrg") != m.end() && !m["CertOrg"].empty()) {
      certOrg = make_shared<string>(boost::any_cast<string>(m["CertOrg"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo() = default;
};
class DescribeLiveDomainCertificateInfoResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeLiveDomainCertificateInfoResponseBodyCertInfos() {}

  explicit DescribeLiveDomainCertificateInfoResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeLiveDomainCertificateInfoResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainCertificateInfoResponseBodyCertInfos() = default;
};
class DescribeLiveDomainCertificateInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainCertificateInfoResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainCertificateInfoResponseBody() {}

  explicit DescribeLiveDomainCertificateInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeLiveDomainCertificateInfoResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeLiveDomainCertificateInfoResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainCertificateInfoResponseBody() = default;
};
class DescribeLiveDomainCertificateInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainCertificateInfoResponseBody> body{};

  DescribeLiveDomainCertificateInfoResponse() {}

  explicit DescribeLiveDomainCertificateInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainCertificateInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainCertificateInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainCertificateInfoResponse() = default;
};
class DescribeLiveDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveDomainConfigsRequest() {}

  explicit DescribeLiveDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveDomainConfigsRequest() = default;
};
class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() {}

  explicit DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() = default;
};
class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>> functionArg{};

  DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() {}

  explicit DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionArg) {
      vector<boost::any> temp1;
      for(auto item1:*functionArg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArg"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionArg") != m.end() && !m["FunctionArg"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArg"].type()) {
        vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArg = make_shared<vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() = default;
};
class DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> status{};

  DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig() {}

  explicit DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      res["FunctionArgs"] = functionArgs ? boost::any(functionArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionArgs"].type()) {
        DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionArgs"]));
        functionArgs = make_shared<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs>(model1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig() = default;
};
class DescribeLiveDomainConfigsResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig>> domainConfig{};

  DescribeLiveDomainConfigsResponseBodyDomainConfigs() {}

  explicit DescribeLiveDomainConfigsResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfig) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfig") != m.end() && !m["DomainConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfig"].type()) {
        vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfig = make_shared<vector<DescribeLiveDomainConfigsResponseBodyDomainConfigsDomainConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainConfigsResponseBodyDomainConfigs() = default;
};
class DescribeLiveDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainConfigsResponseBodyDomainConfigs> domainConfigs{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainConfigsResponseBody() {}

  explicit DescribeLiveDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      res["DomainConfigs"] = domainConfigs ? boost::any(domainConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainConfigs"].type()) {
        DescribeLiveDomainConfigsResponseBodyDomainConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainConfigs"]));
        domainConfigs = make_shared<DescribeLiveDomainConfigsResponseBodyDomainConfigs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainConfigsResponseBody() = default;
};
class DescribeLiveDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainConfigsResponseBody> body{};

  DescribeLiveDomainConfigsResponse() {}

  explicit DescribeLiveDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainConfigsResponse() = default;
};
class DescribeLiveDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveDomainDetailRequest() {}

  explicit DescribeLiveDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveDomainDetailRequest() = default;
};
class DescribeLiveDomainDetailResponseBodyDomainDetail : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> liveDomainType{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> scope{};

  DescribeLiveDomainDetailResponseBodyDomainDetail() {}

  explicit DescribeLiveDomainDetailResponseBodyDomainDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (liveDomainType) {
      res["LiveDomainType"] = boost::any(*liveDomainType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("LiveDomainType") != m.end() && !m["LiveDomainType"].empty()) {
      liveDomainType = make_shared<string>(boost::any_cast<string>(m["LiveDomainType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~DescribeLiveDomainDetailResponseBodyDomainDetail() = default;
};
class DescribeLiveDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainDetailResponseBodyDomainDetail> domainDetail{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainDetailResponseBody() {}

  explicit DescribeLiveDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainDetail) {
      res["DomainDetail"] = domainDetail ? boost::any(domainDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainDetail") != m.end() && !m["DomainDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainDetail"].type()) {
        DescribeLiveDomainDetailResponseBodyDomainDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainDetail"]));
        domainDetail = make_shared<DescribeLiveDomainDetailResponseBodyDomainDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainDetailResponseBody() = default;
};
class DescribeLiveDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainDetailResponseBody> body{};

  DescribeLiveDomainDetailResponse() {}

  explicit DescribeLiveDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainDetailResponse() = default;
};
class DescribeLiveDomainEdgeLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainEdgeLogRequest() {}

  explicit DescribeLiveDomainEdgeLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainEdgeLogRequest() = default;
};
class DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() {}

  explicit DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() = default;
};
class DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>> logInfoDetail{};

  DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() {}

  explicit DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfoDetail) {
      vector<boost::any> temp1;
      for(auto item1:*logInfoDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfoDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfoDetail") != m.end() && !m["LogInfoDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfoDetail"].type()) {
        vector<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfoDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfoDetail = make_shared<vector<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() = default;
};
class DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() {}

  explicit DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() = default;
};
class DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetail : public Darabonba::Model {
public:
  shared_ptr<long> logCount{};
  shared_ptr<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos> logInfos{};
  shared_ptr<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos> pageInfos{};

  DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetail() {}

  explicit DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos>(model1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetail() = default;
};
class DescribeLiveDomainEdgeLogResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetail>> domainLogDetail{};

  DescribeLiveDomainEdgeLogResponseBodyDomainLogDetails() {}

  explicit DescribeLiveDomainEdgeLogResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetail") != m.end() && !m["DomainLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetail"].type()) {
        vector<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetail = make_shared<vector<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetailsDomainLogDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainEdgeLogResponseBodyDomainLogDetails() = default;
};
class DescribeLiveDomainEdgeLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetails> domainLogDetails{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainEdgeLogResponseBody() {}

  explicit DescribeLiveDomainEdgeLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetails) {
      res["DomainLogDetails"] = domainLogDetails ? boost::any(domainLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogDetails"].type()) {
        DescribeLiveDomainEdgeLogResponseBodyDomainLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogDetails"]));
        domainLogDetails = make_shared<DescribeLiveDomainEdgeLogResponseBodyDomainLogDetails>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainEdgeLogResponseBody() = default;
};
class DescribeLiveDomainEdgeLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainEdgeLogResponseBody> body{};

  DescribeLiveDomainEdgeLogResponse() {}

  explicit DescribeLiveDomainEdgeLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainEdgeLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainEdgeLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainEdgeLogResponse() = default;
};
class DescribeLiveDomainFrameRateAndBitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> queryTime{};
  shared_ptr<string> regionId{};

  DescribeLiveDomainFrameRateAndBitRateDataRequest() {}

  explicit DescribeLiveDomainFrameRateAndBitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<string>(boost::any_cast<string>(m["QueryTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveDomainFrameRateAndBitRateDataRequest() = default;
};
class DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo : public Darabonba::Model {
public:
  shared_ptr<double> audioFrameRate{};
  shared_ptr<double> bitRate{};
  shared_ptr<string> streamUrl{};
  shared_ptr<double> videoFrameRate{};

  DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo() {}

  explicit DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFrameRate) {
      res["AudioFrameRate"] = boost::any(*audioFrameRate);
    }
    if (bitRate) {
      res["BitRate"] = boost::any(*bitRate);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    if (videoFrameRate) {
      res["VideoFrameRate"] = boost::any(*videoFrameRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFrameRate") != m.end() && !m["AudioFrameRate"].empty()) {
      audioFrameRate = make_shared<double>(boost::any_cast<double>(m["AudioFrameRate"]));
    }
    if (m.find("BitRate") != m.end() && !m["BitRate"].empty()) {
      bitRate = make_shared<double>(boost::any_cast<double>(m["BitRate"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
    if (m.find("VideoFrameRate") != m.end() && !m["VideoFrameRate"].empty()) {
      videoFrameRate = make_shared<double>(boost::any_cast<double>(m["VideoFrameRate"]));
    }
  }


  virtual ~DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo() = default;
};
class DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo>> frameRateAndBitRateInfo{};

  DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos() {}

  explicit DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameRateAndBitRateInfo) {
      vector<boost::any> temp1;
      for(auto item1:*frameRateAndBitRateInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrameRateAndBitRateInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameRateAndBitRateInfo") != m.end() && !m["FrameRateAndBitRateInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["FrameRateAndBitRateInfo"].type()) {
        vector<DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrameRateAndBitRateInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frameRateAndBitRateInfo = make_shared<vector<DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos() = default;
};
class DescribeLiveDomainFrameRateAndBitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos> frameRateAndBitRateInfos{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainFrameRateAndBitRateDataResponseBody() {}

  explicit DescribeLiveDomainFrameRateAndBitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameRateAndBitRateInfos) {
      res["FrameRateAndBitRateInfos"] = frameRateAndBitRateInfos ? boost::any(frameRateAndBitRateInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameRateAndBitRateInfos") != m.end() && !m["FrameRateAndBitRateInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["FrameRateAndBitRateInfos"].type()) {
        DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FrameRateAndBitRateInfos"]));
        frameRateAndBitRateInfos = make_shared<DescribeLiveDomainFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainFrameRateAndBitRateDataResponseBody() = default;
};
class DescribeLiveDomainFrameRateAndBitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainFrameRateAndBitRateDataResponseBody> body{};

  DescribeLiveDomainFrameRateAndBitRateDataResponse() {}

  explicit DescribeLiveDomainFrameRateAndBitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainFrameRateAndBitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainFrameRateAndBitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainFrameRateAndBitRateDataResponse() = default;
};
class DescribeLiveDomainLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveDomainLimitRequest() {}

  explicit DescribeLiveDomainLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveDomainLimitRequest() = default;
};
class DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit : public Darabonba::Model {
public:
  shared_ptr<long> currentNum{};
  shared_ptr<long> currentTranscodeNum{};
  shared_ptr<long> currentTransferNum{};
  shared_ptr<string> domainName{};
  shared_ptr<long> limitNum{};
  shared_ptr<long> limitTranscodeNum{};
  shared_ptr<long> limitTransferNum{};

  DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit() {}

  explicit DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentNum) {
      res["CurrentNum"] = boost::any(*currentNum);
    }
    if (currentTranscodeNum) {
      res["CurrentTranscodeNum"] = boost::any(*currentTranscodeNum);
    }
    if (currentTransferNum) {
      res["CurrentTransferNum"] = boost::any(*currentTransferNum);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (limitNum) {
      res["LimitNum"] = boost::any(*limitNum);
    }
    if (limitTranscodeNum) {
      res["LimitTranscodeNum"] = boost::any(*limitTranscodeNum);
    }
    if (limitTransferNum) {
      res["LimitTransferNum"] = boost::any(*limitTransferNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentNum") != m.end() && !m["CurrentNum"].empty()) {
      currentNum = make_shared<long>(boost::any_cast<long>(m["CurrentNum"]));
    }
    if (m.find("CurrentTranscodeNum") != m.end() && !m["CurrentTranscodeNum"].empty()) {
      currentTranscodeNum = make_shared<long>(boost::any_cast<long>(m["CurrentTranscodeNum"]));
    }
    if (m.find("CurrentTransferNum") != m.end() && !m["CurrentTransferNum"].empty()) {
      currentTransferNum = make_shared<long>(boost::any_cast<long>(m["CurrentTransferNum"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LimitNum") != m.end() && !m["LimitNum"].empty()) {
      limitNum = make_shared<long>(boost::any_cast<long>(m["LimitNum"]));
    }
    if (m.find("LimitTranscodeNum") != m.end() && !m["LimitTranscodeNum"].empty()) {
      limitTranscodeNum = make_shared<long>(boost::any_cast<long>(m["LimitTranscodeNum"]));
    }
    if (m.find("LimitTransferNum") != m.end() && !m["LimitTransferNum"].empty()) {
      limitTransferNum = make_shared<long>(boost::any_cast<long>(m["LimitTransferNum"]));
    }
  }


  virtual ~DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit() = default;
};
class DescribeLiveDomainLimitResponseBodyLiveDomainLimitList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit>> liveDomainLimit{};

  DescribeLiveDomainLimitResponseBodyLiveDomainLimitList() {}

  explicit DescribeLiveDomainLimitResponseBodyLiveDomainLimitList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveDomainLimit) {
      vector<boost::any> temp1;
      for(auto item1:*liveDomainLimit){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveDomainLimit"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveDomainLimit") != m.end() && !m["LiveDomainLimit"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveDomainLimit"].type()) {
        vector<DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveDomainLimit"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveDomainLimit = make_shared<vector<DescribeLiveDomainLimitResponseBodyLiveDomainLimitListLiveDomainLimit>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainLimitResponseBodyLiveDomainLimitList() = default;
};
class DescribeLiveDomainLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainLimitResponseBodyLiveDomainLimitList> liveDomainLimitList{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainLimitResponseBody() {}

  explicit DescribeLiveDomainLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveDomainLimitList) {
      res["LiveDomainLimitList"] = liveDomainLimitList ? boost::any(liveDomainLimitList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveDomainLimitList") != m.end() && !m["LiveDomainLimitList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveDomainLimitList"].type()) {
        DescribeLiveDomainLimitResponseBodyLiveDomainLimitList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveDomainLimitList"]));
        liveDomainLimitList = make_shared<DescribeLiveDomainLimitResponseBodyLiveDomainLimitList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainLimitResponseBody() = default;
};
class DescribeLiveDomainLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainLimitResponseBody> body{};

  DescribeLiveDomainLimitResponse() {}

  explicit DescribeLiveDomainLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainLimitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainLimitResponse() = default;
};
class DescribeLiveDomainLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainLogRequest() {}

  explicit DescribeLiveDomainLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainLogRequest() = default;
};
class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() {}

  explicit DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() = default;
};
class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>> logInfoDetail{};

  DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() {}

  explicit DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfoDetail) {
      vector<boost::any> temp1;
      for(auto item1:*logInfoDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfoDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfoDetail") != m.end() && !m["LogInfoDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfoDetail"].type()) {
        vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfoDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfoDetail = make_shared<vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() = default;
};
class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() {}

  explicit DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() = default;
};
class DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail : public Darabonba::Model {
public:
  shared_ptr<long> logCount{};
  shared_ptr<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos> logInfos{};
  shared_ptr<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos> pageInfos{};

  DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail() {}

  explicit DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos>(model1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail() = default;
};
class DescribeLiveDomainLogResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail>> domainLogDetail{};

  DescribeLiveDomainLogResponseBodyDomainLogDetails() {}

  explicit DescribeLiveDomainLogResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetail") != m.end() && !m["DomainLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetail"].type()) {
        vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetail = make_shared<vector<DescribeLiveDomainLogResponseBodyDomainLogDetailsDomainLogDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogResponseBodyDomainLogDetails() = default;
};
class DescribeLiveDomainLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainLogResponseBodyDomainLogDetails> domainLogDetails{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainLogResponseBody() {}

  explicit DescribeLiveDomainLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetails) {
      res["DomainLogDetails"] = domainLogDetails ? boost::any(domainLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogDetails"].type()) {
        DescribeLiveDomainLogResponseBodyDomainLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogDetails"]));
        domainLogDetails = make_shared<DescribeLiveDomainLogResponseBodyDomainLogDetails>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainLogResponseBody() = default;
};
class DescribeLiveDomainLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainLogResponseBody> body{};

  DescribeLiveDomainLogResponse() {}

  explicit DescribeLiveDomainLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogResponse() = default;
};
class DescribeLiveDomainLogExTtlRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainLogExTtlRequest() {}

  explicit DescribeLiveDomainLogExTtlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainLogExTtlRequest() = default;
};
class DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() {}

  explicit DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() = default;
};
class DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>> logInfoDetail{};

  DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos() {}

  explicit DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfoDetail) {
      vector<boost::any> temp1;
      for(auto item1:*logInfoDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfoDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfoDetail") != m.end() && !m["LogInfoDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfoDetail"].type()) {
        vector<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfoDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfoDetail = make_shared<vector<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos() = default;
};
class DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos() {}

  explicit DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos() = default;
};
class DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail : public Darabonba::Model {
public:
  shared_ptr<long> logCount{};
  shared_ptr<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos> logInfos{};
  shared_ptr<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos> pageInfos{};

  DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail() {}

  explicit DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos>(model1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail() = default;
};
class DescribeLiveDomainLogExTtlResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail>> domainLogDetail{};

  DescribeLiveDomainLogExTtlResponseBodyDomainLogDetails() {}

  explicit DescribeLiveDomainLogExTtlResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetail") != m.end() && !m["DomainLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetail"].type()) {
        vector<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetail = make_shared<vector<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogExTtlResponseBodyDomainLogDetails() = default;
};
class DescribeLiveDomainLogExTtlResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetails> domainLogDetails{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainLogExTtlResponseBody() {}

  explicit DescribeLiveDomainLogExTtlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetails) {
      res["DomainLogDetails"] = domainLogDetails ? boost::any(domainLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogDetails"].type()) {
        DescribeLiveDomainLogExTtlResponseBodyDomainLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogDetails"]));
        domainLogDetails = make_shared<DescribeLiveDomainLogExTtlResponseBodyDomainLogDetails>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainLogExTtlResponseBody() = default;
};
class DescribeLiveDomainLogExTtlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainLogExTtlResponseBody> body{};

  DescribeLiveDomainLogExTtlResponse() {}

  explicit DescribeLiveDomainLogExTtlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainLogExTtlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainLogExTtlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainLogExTtlResponse() = default;
};
class DescribeLiveDomainMappingRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveDomainMappingRequest() {}

  explicit DescribeLiveDomainMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveDomainMappingRequest() = default;
};
class DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> type{};

  DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel() {}

  explicit DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel() = default;
};
class DescribeLiveDomainMappingResponseBodyLiveDomainModels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel>> liveDomainModel{};

  DescribeLiveDomainMappingResponseBodyLiveDomainModels() {}

  explicit DescribeLiveDomainMappingResponseBodyLiveDomainModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveDomainModel) {
      vector<boost::any> temp1;
      for(auto item1:*liveDomainModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveDomainModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveDomainModel") != m.end() && !m["LiveDomainModel"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveDomainModel"].type()) {
        vector<DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveDomainModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveDomainModel = make_shared<vector<DescribeLiveDomainMappingResponseBodyLiveDomainModelsLiveDomainModel>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainMappingResponseBodyLiveDomainModels() = default;
};
class DescribeLiveDomainMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainMappingResponseBodyLiveDomainModels> liveDomainModels{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainMappingResponseBody() {}

  explicit DescribeLiveDomainMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveDomainModels) {
      res["LiveDomainModels"] = liveDomainModels ? boost::any(liveDomainModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveDomainModels") != m.end() && !m["LiveDomainModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveDomainModels"].type()) {
        DescribeLiveDomainMappingResponseBodyLiveDomainModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveDomainModels"]));
        liveDomainModels = make_shared<DescribeLiveDomainMappingResponseBodyLiveDomainModels>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainMappingResponseBody() = default;
};
class DescribeLiveDomainMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainMappingResponseBody> body{};

  DescribeLiveDomainMappingResponse() {}

  explicit DescribeLiveDomainMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainMappingResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainMappingResponse() = default;
};
class DescribeLiveDomainMonitoringUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainMonitoringUsageDataRequest() {}

  explicit DescribeLiveDomainMonitoringUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainMonitoringUsageDataRequest() = default;
};
class DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringDataMonitoringDataItem : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> duration{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> region{};
  shared_ptr<string> resolution{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringDataMonitoringDataItem() {}

  explicit DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringDataMonitoringDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resolution) {
      res["Resolution"] = boost::any(*resolution);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Resolution") != m.end() && !m["Resolution"].empty()) {
      resolution = make_shared<string>(boost::any_cast<string>(m["Resolution"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringDataMonitoringDataItem() = default;
};
class DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringDataMonitoringDataItem>> monitoringDataItem{};

  DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringData() {}

  explicit DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitoringDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitoringDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitoringDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitoringDataItem") != m.end() && !m["MonitoringDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitoringDataItem"].type()) {
        vector<DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringDataMonitoringDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitoringDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringDataMonitoringDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitoringDataItem = make_shared<vector<DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringDataMonitoringDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringData() = default;
};
class DescribeLiveDomainMonitoringUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringData> monitoringData{};
  shared_ptr<string> region{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainMonitoringUsageDataResponseBody() {}

  explicit DescribeLiveDomainMonitoringUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (monitoringData) {
      res["MonitoringData"] = monitoringData ? boost::any(monitoringData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MonitoringData") != m.end() && !m["MonitoringData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitoringData"].type()) {
        DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitoringData"]));
        monitoringData = make_shared<DescribeLiveDomainMonitoringUsageDataResponseBodyMonitoringData>(model1);
      }
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainMonitoringUsageDataResponseBody() = default;
};
class DescribeLiveDomainMonitoringUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainMonitoringUsageDataResponseBody> body{};

  DescribeLiveDomainMonitoringUsageDataResponse() {}

  explicit DescribeLiveDomainMonitoringUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainMonitoringUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainMonitoringUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainMonitoringUsageDataResponse() = default;
};
class DescribeLiveDomainMultiStreamConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};

  DescribeLiveDomainMultiStreamConfigRequest() {}

  explicit DescribeLiveDomainMultiStreamConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeLiveDomainMultiStreamConfigRequest() = default;
};
class DescribeLiveDomainMultiStreamConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> switch_{};

  DescribeLiveDomainMultiStreamConfigResponseBody() {}

  explicit DescribeLiveDomainMultiStreamConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (switch_) {
      res["Switch"] = boost::any(*switch_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Switch") != m.end() && !m["Switch"].empty()) {
      switch_ = make_shared<string>(boost::any_cast<string>(m["Switch"]));
    }
  }


  virtual ~DescribeLiveDomainMultiStreamConfigResponseBody() = default;
};
class DescribeLiveDomainMultiStreamConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainMultiStreamConfigResponseBody> body{};

  DescribeLiveDomainMultiStreamConfigResponse() {}

  explicit DescribeLiveDomainMultiStreamConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainMultiStreamConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainMultiStreamConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainMultiStreamConfigResponse() = default;
};
class DescribeLiveDomainOnlineUserNumRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> queryTime{};
  shared_ptr<string> regionId{};

  DescribeLiveDomainOnlineUserNumRequest() {}

  explicit DescribeLiveDomainOnlineUserNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<string>(boost::any_cast<string>(m["QueryTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumRequest() = default;
};
class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo : public Darabonba::Model {
public:
  shared_ptr<string> transcodeTemplate{};
  shared_ptr<long> userNumber{};

  DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo() {}

  explicit DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeTemplate) {
      res["TranscodeTemplate"] = boost::any(*transcodeTemplate);
    }
    if (userNumber) {
      res["UserNumber"] = boost::any(*userNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeTemplate") != m.end() && !m["TranscodeTemplate"].empty()) {
      transcodeTemplate = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplate"]));
    }
    if (m.find("UserNumber") != m.end() && !m["UserNumber"].empty()) {
      userNumber = make_shared<long>(boost::any_cast<long>(m["UserNumber"]));
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo() = default;
};
class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo>> info{};

  DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos() {}

  explicit DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(vector<boost::any>) == m["Info"].type()) {
        vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfosInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos() = default;
};
class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos> infos{};
  shared_ptr<string> streamName{};

  DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo() {}

  explicit DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infos) {
      res["Infos"] = infos ? boost::any(infos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Infos") != m.end() && !m["Infos"].empty()) {
      if (typeid(map<string, boost::any>) == m["Infos"].type()) {
        DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Infos"]));
        infos = make_shared<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfoInfos>(model1);
      }
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo() = default;
};
class DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo>> liveStreamOnlineUserNumInfo{};

  DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo() {}

  explicit DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamOnlineUserNumInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamOnlineUserNumInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamOnlineUserNumInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamOnlineUserNumInfo") != m.end() && !m["LiveStreamOnlineUserNumInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamOnlineUserNumInfo"].type()) {
        vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamOnlineUserNumInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamOnlineUserNumInfo = make_shared<vector<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfoLiveStreamOnlineUserNumInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo() = default;
};
class DescribeLiveDomainOnlineUserNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo> onlineUserInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<long> streamCount{};
  shared_ptr<long> userCount{};

  DescribeLiveDomainOnlineUserNumResponseBody() {}

  explicit DescribeLiveDomainOnlineUserNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onlineUserInfo) {
      res["OnlineUserInfo"] = onlineUserInfo ? boost::any(onlineUserInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamCount) {
      res["StreamCount"] = boost::any(*streamCount);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnlineUserInfo") != m.end() && !m["OnlineUserInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineUserInfo"].type()) {
        DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineUserInfo"]));
        onlineUserInfo = make_shared<DescribeLiveDomainOnlineUserNumResponseBodyOnlineUserInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamCount") != m.end() && !m["StreamCount"].empty()) {
      streamCount = make_shared<long>(boost::any_cast<long>(m["StreamCount"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponseBody() = default;
};
class DescribeLiveDomainOnlineUserNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainOnlineUserNumResponseBody> body{};

  DescribeLiveDomainOnlineUserNumResponse() {}

  explicit DescribeLiveDomainOnlineUserNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainOnlineUserNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainOnlineUserNumResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainOnlineUserNumResponse() = default;
};
class DescribeLiveDomainPublishErrorCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPublishErrorCodeRequest() {}

  explicit DescribeLiveDomainPublishErrorCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPublishErrorCodeRequest() = default;
};
class DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeDataCodeData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> proportion{};

  DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeDataCodeData() {}

  explicit DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeDataCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
  }


  virtual ~DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeDataCodeData() = default;
};
class DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeDataCodeData>> codeData{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeData() {}

  explicit DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeData) {
      vector<boost::any> temp1;
      for(auto item1:*codeData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CodeData"] = boost::any(temp1);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeData") != m.end() && !m["CodeData"].empty()) {
      if (typeid(vector<boost::any>) == m["CodeData"].type()) {
        vector<DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeDataCodeData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CodeData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeDataCodeData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        codeData = make_shared<vector<DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeDataCodeData>>(expect1);
      }
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeData() = default;
};
class DescribeLiveDomainPublishErrorCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<vector<DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeData>> realTimeCodeData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPublishErrorCodeResponseBody() {}

  explicit DescribeLiveDomainPublishErrorCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeCodeData) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeCodeData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeCodeData"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeCodeData") != m.end() && !m["RealTimeCodeData"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeCodeData"].type()) {
        vector<DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeCodeData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeCodeData = make_shared<vector<DescribeLiveDomainPublishErrorCodeResponseBodyRealTimeCodeData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPublishErrorCodeResponseBody() = default;
};
class DescribeLiveDomainPublishErrorCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainPublishErrorCodeResponseBody> body{};

  DescribeLiveDomainPublishErrorCodeResponse() {}

  explicit DescribeLiveDomainPublishErrorCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainPublishErrorCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainPublishErrorCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainPublishErrorCodeResponse() = default;
};
class DescribeLiveDomainPushBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPushBpsDataRequest() {}

  explicit DescribeLiveDomainPushBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPushBpsDataRequest() = default;
};
class DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> bpsValue{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsValue) {
      res["BpsValue"] = boost::any(*bpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsValue") != m.end() && !m["BpsValue"].empty()) {
      bpsValue = make_shared<string>(boost::any_cast<string>(m["BpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeLiveDomainPushBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPushBpsDataResponseBody() {}

  explicit DescribeLiveDomainPushBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeLiveDomainPushBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPushBpsDataResponseBody() = default;
};
class DescribeLiveDomainPushBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainPushBpsDataResponseBody> body{};

  DescribeLiveDomainPushBpsDataResponse() {}

  explicit DescribeLiveDomainPushBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainPushBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainPushBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainPushBpsDataResponse() = default;
};
class DescribeLiveDomainPushTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPushTrafficDataRequest() {}

  explicit DescribeLiveDomainPushTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPushTrafficDataRequest() = default;
};
class DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> trafficValue{};

  DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<string>(boost::any_cast<string>(m["TrafficValue"]));
    }
  }


  virtual ~DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeLiveDomainPushTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeLiveDomainPushTrafficDataResponseBody() {}

  explicit DescribeLiveDomainPushTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeLiveDomainPushTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainPushTrafficDataResponseBody() = default;
};
class DescribeLiveDomainPushTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainPushTrafficDataResponseBody> body{};

  DescribeLiveDomainPushTrafficDataResponse() {}

  explicit DescribeLiveDomainPushTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainPushTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainPushTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainPushTrafficDataResponse() = default;
};
class DescribeLiveDomainPvUvDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPvUvDataRequest() {}

  explicit DescribeLiveDomainPvUvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPvUvDataRequest() = default;
};
class DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> PV{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> UV{};

  DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo() {}

  explicit DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (PV) {
      res["PV"] = boost::any(*PV);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (UV) {
      res["UV"] = boost::any(*UV);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PV") != m.end() && !m["PV"].empty()) {
      PV = make_shared<string>(boost::any_cast<string>(m["PV"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("UV") != m.end() && !m["UV"].empty()) {
      UV = make_shared<string>(boost::any_cast<string>(m["UV"]));
    }
  }


  virtual ~DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo() = default;
};
class DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo>> pvUvDataInfo{};

  DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos() {}

  explicit DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pvUvDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*pvUvDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PvUvDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PvUvDataInfo") != m.end() && !m["PvUvDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PvUvDataInfo"].type()) {
        vector<DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PvUvDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pvUvDataInfo = make_shared<vector<DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos() = default;
};
class DescribeLiveDomainPvUvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos> pvUvDataInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainPvUvDataResponseBody() {}

  explicit DescribeLiveDomainPvUvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pvUvDataInfos) {
      res["PvUvDataInfos"] = pvUvDataInfos ? boost::any(pvUvDataInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PvUvDataInfos") != m.end() && !m["PvUvDataInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PvUvDataInfos"].type()) {
        DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PvUvDataInfos"]));
        pvUvDataInfos = make_shared<DescribeLiveDomainPvUvDataResponseBodyPvUvDataInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainPvUvDataResponseBody() = default;
};
class DescribeLiveDomainPvUvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainPvUvDataResponseBody> body{};

  DescribeLiveDomainPvUvDataResponse() {}

  explicit DescribeLiveDomainPvUvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainPvUvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainPvUvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainPvUvDataResponse() = default;
};
class DescribeLiveDomainRealTimeBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeBpsDataRequest() {}

  explicit DescribeLiveDomainRealTimeBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeBpsDataRequest() = default;
};
class DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval() {}

  explicit DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval() = default;
};
class DescribeLiveDomainRealTimeBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval> realTimeBpsDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeBpsDataResponseBody() {}

  explicit DescribeLiveDomainRealTimeBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeBpsDataPerInterval) {
      res["RealTimeBpsDataPerInterval"] = realTimeBpsDataPerInterval ? boost::any(realTimeBpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeBpsDataPerInterval") != m.end() && !m["RealTimeBpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeBpsDataPerInterval"].type()) {
        DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeBpsDataPerInterval"]));
        realTimeBpsDataPerInterval = make_shared<DescribeLiveDomainRealTimeBpsDataResponseBodyRealTimeBpsDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeBpsDataResponseBody() = default;
};
class DescribeLiveDomainRealTimeBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainRealTimeBpsDataResponseBody> body{};

  DescribeLiveDomainRealTimeBpsDataResponse() {}

  explicit DescribeLiveDomainRealTimeBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainRealTimeBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainRealTimeBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeBpsDataResponse() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeHttpCodeDataRequest() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataRequest() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> proportion{};

  DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData>> realTimeCodeProportionData{};

  DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeCodeProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeCodeProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeCodeProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeCodeProportionData") != m.end() && !m["RealTimeCodeProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeCodeProportionData"].type()) {
        vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeCodeProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeCodeProportionData = make_shared<vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue> value{};

  DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData>> usageData{};

  DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData> realTimeHttpCodeData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeHttpCodeDataResponseBody() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeHttpCodeData) {
      res["RealTimeHttpCodeData"] = realTimeHttpCodeData ? boost::any(realTimeHttpCodeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeHttpCodeData") != m.end() && !m["RealTimeHttpCodeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeHttpCodeData"].type()) {
        DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeHttpCodeData"]));
        realTimeHttpCodeData = make_shared<DescribeLiveDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponseBody() = default;
};
class DescribeLiveDomainRealTimeHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainRealTimeHttpCodeDataResponseBody> body{};

  DescribeLiveDomainRealTimeHttpCodeDataResponse() {}

  explicit DescribeLiveDomainRealTimeHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainRealTimeHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainRealTimeHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeHttpCodeDataResponse() = default;
};
class DescribeLiveDomainRealTimeTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeTrafficDataRequest() {}

  explicit DescribeLiveDomainRealTimeTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeTrafficDataRequest() = default;
};
class DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval() {}

  explicit DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval() = default;
};
class DescribeLiveDomainRealTimeTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval> realTimeTrafficDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRealTimeTrafficDataResponseBody() {}

  explicit DescribeLiveDomainRealTimeTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeTrafficDataPerInterval) {
      res["RealTimeTrafficDataPerInterval"] = realTimeTrafficDataPerInterval ? boost::any(realTimeTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeTrafficDataPerInterval") != m.end() && !m["RealTimeTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeTrafficDataPerInterval"].type()) {
        DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeTrafficDataPerInterval"]));
        realTimeTrafficDataPerInterval = make_shared<DescribeLiveDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRealTimeTrafficDataResponseBody() = default;
};
class DescribeLiveDomainRealTimeTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainRealTimeTrafficDataResponseBody> body{};

  DescribeLiveDomainRealTimeTrafficDataResponse() {}

  explicit DescribeLiveDomainRealTimeTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainRealTimeTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainRealTimeTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealTimeTrafficDataResponse() = default;
};
class DescribeLiveDomainRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveDomainRealtimeLogDeliveryRequest() {}

  explicit DescribeLiveDomainRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveDomainRealtimeLogDeliveryRequest() = default;
};
class DescribeLiveDomainRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeLiveDomainRealtimeLogDeliveryResponseBody() {}

  explicit DescribeLiveDomainRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeLiveDomainRealtimeLogDeliveryResponseBody() = default;
};
class DescribeLiveDomainRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainRealtimeLogDeliveryResponseBody> body{};

  DescribeLiveDomainRealtimeLogDeliveryResponse() {}

  explicit DescribeLiveDomainRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRealtimeLogDeliveryResponse() = default;
};
class DescribeLiveDomainRecordUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRecordUsageDataRequest() {}

  explicit DescribeLiveDomainRecordUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRecordUsageDataRequest() = default;
};
class DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> domain{};
  shared_ptr<long> duration{};
  shared_ptr<string> region{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> type{};

  DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule() {}

  explicit DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule() = default;
};
class DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule>> dataModule{};

  DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData() {}

  explicit DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageDataDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData() = default;
};
class DescribeLiveDomainRecordUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData> recordUsageData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainRecordUsageDataResponseBody() {}

  explicit DescribeLiveDomainRecordUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (recordUsageData) {
      res["RecordUsageData"] = recordUsageData ? boost::any(recordUsageData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RecordUsageData") != m.end() && !m["RecordUsageData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordUsageData"].type()) {
        DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordUsageData"]));
        recordUsageData = make_shared<DescribeLiveDomainRecordUsageDataResponseBodyRecordUsageData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainRecordUsageDataResponseBody() = default;
};
class DescribeLiveDomainRecordUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainRecordUsageDataResponseBody> body{};

  DescribeLiveDomainRecordUsageDataResponse() {}

  explicit DescribeLiveDomainRecordUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainRecordUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainRecordUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainRecordUsageDataResponse() = default;
};
class DescribeLiveDomainSnapshotDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainSnapshotDataRequest() {}

  explicit DescribeLiveDomainSnapshotDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainSnapshotDataRequest() = default;
};
class DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<long> total{};

  DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo() {}

  explicit DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo() = default;
};
class DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo>> snapshotDataInfo{};

  DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos() {}

  explicit DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*snapshotDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnapshotDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotDataInfo") != m.end() && !m["SnapshotDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SnapshotDataInfo"].type()) {
        vector<DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnapshotDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshotDataInfo = make_shared<vector<DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfosSnapshotDataInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos() = default;
};
class DescribeLiveDomainSnapshotDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos> snapshotDataInfos{};

  DescribeLiveDomainSnapshotDataResponseBody() {}

  explicit DescribeLiveDomainSnapshotDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotDataInfos) {
      res["SnapshotDataInfos"] = snapshotDataInfos ? boost::any(snapshotDataInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotDataInfos") != m.end() && !m["SnapshotDataInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotDataInfos"].type()) {
        DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotDataInfos"]));
        snapshotDataInfos = make_shared<DescribeLiveDomainSnapshotDataResponseBodySnapshotDataInfos>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainSnapshotDataResponseBody() = default;
};
class DescribeLiveDomainSnapshotDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainSnapshotDataResponseBody> body{};

  DescribeLiveDomainSnapshotDataResponse() {}

  explicit DescribeLiveDomainSnapshotDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainSnapshotDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainSnapshotDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainSnapshotDataResponse() = default;
};
class DescribeLiveDomainStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveDomainStagingConfigRequest() {}

  explicit DescribeLiveDomainStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveDomainStagingConfigRequest() = default;
};
class DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs() {}

  explicit DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs() = default;
};
class DescribeLiveDomainStagingConfigResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs>> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> status{};

  DescribeLiveDomainStagingConfigResponseBodyDomainConfigs() {}

  explicit DescribeLiveDomainStagingConfigResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      vector<boost::any> temp1;
      for(auto item1:*functionArgs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArgs"] = boost::any(temp1);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArgs"].type()) {
        vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArgs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArgs = make_shared<vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigsFunctionArgs>>(expect1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeLiveDomainStagingConfigResponseBodyDomainConfigs() = default;
};
class DescribeLiveDomainStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigs>> domainConfigs{};
  shared_ptr<string> requestId{};

  DescribeLiveDomainStagingConfigResponseBody() {}

  explicit DescribeLiveDomainStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfigs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfigs"].type()) {
        vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainStagingConfigResponseBodyDomainConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfigs = make_shared<vector<DescribeLiveDomainStagingConfigResponseBodyDomainConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainStagingConfigResponseBody() = default;
};
class DescribeLiveDomainStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainStagingConfigResponseBody> body{};

  DescribeLiveDomainStagingConfigResponse() {}

  explicit DescribeLiveDomainStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainStagingConfigResponse() = default;
};
class DescribeLiveDomainStreamTranscodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> precision{};
  shared_ptr<string> regionId{};
  shared_ptr<string> split{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainStreamTranscodeDataRequest() {}

  explicit DescribeLiveDomainStreamTranscodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (precision) {
      res["Precision"] = boost::any(*precision);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (split) {
      res["Split"] = boost::any(*split);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Precision") != m.end() && !m["Precision"].empty()) {
      precision = make_shared<string>(boost::any_cast<string>(m["Precision"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Split") != m.end() && !m["Split"].empty()) {
      split = make_shared<string>(boost::any_cast<string>(m["Split"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainStreamTranscodeDataRequest() = default;
};
class DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> region{};
  shared_ptr<string> resolution{};
  shared_ptr<string> tanscodeType{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData() {}

  explicit DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resolution) {
      res["Resolution"] = boost::any(*resolution);
    }
    if (tanscodeType) {
      res["TanscodeType"] = boost::any(*tanscodeType);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Resolution") != m.end() && !m["Resolution"].empty()) {
      resolution = make_shared<string>(boost::any_cast<string>(m["Resolution"]));
    }
    if (m.find("TanscodeType") != m.end() && !m["TanscodeType"].empty()) {
      tanscodeType = make_shared<string>(boost::any_cast<string>(m["TanscodeType"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData() = default;
};
class DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData>> transcodeData{};

  DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList() {}

  explicit DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeData) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeData") != m.end() && !m["TranscodeData"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeData"].type()) {
        vector<DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeData = make_shared<vector<DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataListTranscodeData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList() = default;
};
class DescribeLiveDomainStreamTranscodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList> transcodeDataList{};

  DescribeLiveDomainStreamTranscodeDataResponseBody() {}

  explicit DescribeLiveDomainStreamTranscodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeDataList) {
      res["TranscodeDataList"] = transcodeDataList ? boost::any(transcodeDataList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeDataList") != m.end() && !m["TranscodeDataList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeDataList"].type()) {
        DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeDataList"]));
        transcodeDataList = make_shared<DescribeLiveDomainStreamTranscodeDataResponseBodyTranscodeDataList>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainStreamTranscodeDataResponseBody() = default;
};
class DescribeLiveDomainStreamTranscodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainStreamTranscodeDataResponseBody> body{};

  DescribeLiveDomainStreamTranscodeDataResponse() {}

  explicit DescribeLiveDomainStreamTranscodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainStreamTranscodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainStreamTranscodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainStreamTranscodeDataResponse() = default;
};
class DescribeLiveDomainTimeShiftDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainTimeShiftDataRequest() {}

  explicit DescribeLiveDomainTimeShiftDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainTimeShiftDataRequest() = default;
};
class DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule : public Darabonba::Model {
public:
  shared_ptr<string> size{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> type{};

  DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule() {}

  explicit DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule() = default;
};
class DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule>> dataModule{};

  DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData() {}

  explicit DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftDataDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData() = default;
};
class DescribeLiveDomainTimeShiftDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData> timeShiftData{};

  DescribeLiveDomainTimeShiftDataResponseBody() {}

  explicit DescribeLiveDomainTimeShiftDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeShiftData) {
      res["TimeShiftData"] = timeShiftData ? boost::any(timeShiftData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeShiftData") != m.end() && !m["TimeShiftData"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeShiftData"].type()) {
        DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeShiftData"]));
        timeShiftData = make_shared<DescribeLiveDomainTimeShiftDataResponseBodyTimeShiftData>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainTimeShiftDataResponseBody() = default;
};
class DescribeLiveDomainTimeShiftDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainTimeShiftDataResponseBody> body{};

  DescribeLiveDomainTimeShiftDataResponse() {}

  explicit DescribeLiveDomainTimeShiftDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainTimeShiftDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainTimeShiftDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainTimeShiftDataResponse() = default;
};
class DescribeLiveDomainTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveDomainTrafficDataRequest() {}

  explicit DescribeLiveDomainTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDomainTrafficDataRequest() = default;
};
class DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> httpTrafficValue{};
  shared_ptr<string> httpsTrafficValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> trafficValue{};

  DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpTrafficValue) {
      res["HttpTrafficValue"] = boost::any(*httpTrafficValue);
    }
    if (httpsTrafficValue) {
      res["HttpsTrafficValue"] = boost::any(*httpsTrafficValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpTrafficValue") != m.end() && !m["HttpTrafficValue"].empty()) {
      httpTrafficValue = make_shared<string>(boost::any_cast<string>(m["HttpTrafficValue"]));
    }
    if (m.find("HttpsTrafficValue") != m.end() && !m["HttpsTrafficValue"].empty()) {
      httpsTrafficValue = make_shared<string>(boost::any_cast<string>(m["HttpsTrafficValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<string>(boost::any_cast<string>(m["TrafficValue"]));
    }
  }


  virtual ~DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeLiveDomainTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeLiveDomainTrafficDataResponseBody() {}

  explicit DescribeLiveDomainTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeLiveDomainTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainTrafficDataResponseBody() = default;
};
class DescribeLiveDomainTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainTrafficDataResponseBody> body{};

  DescribeLiveDomainTrafficDataResponse() {}

  explicit DescribeLiveDomainTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainTrafficDataResponse() = default;
};
class DescribeLiveDomainTranscodeParamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> app{};
  shared_ptr<string> pushdomain{};
  shared_ptr<string> templateName{};

  DescribeLiveDomainTranscodeParamsRequest() {}

  explicit DescribeLiveDomainTranscodeParamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (app) {
      res["app"] = boost::any(*app);
    }
    if (pushdomain) {
      res["pushdomain"] = boost::any(*pushdomain);
    }
    if (templateName) {
      res["template_name"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("app") != m.end() && !m["app"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["app"]));
    }
    if (m.find("pushdomain") != m.end() && !m["pushdomain"].empty()) {
      pushdomain = make_shared<string>(boost::any_cast<string>(m["pushdomain"]));
    }
    if (m.find("template_name") != m.end() && !m["template_name"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["template_name"]));
    }
  }


  virtual ~DescribeLiveDomainTranscodeParamsRequest() = default;
};
class DescribeLiveDomainTranscodeParamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DescribeLiveDomainTranscodeParamsResponseBody() {}

  explicit DescribeLiveDomainTranscodeParamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDomainTranscodeParamsResponseBody() = default;
};
class DescribeLiveDomainTranscodeParamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDomainTranscodeParamsResponseBody> body{};

  DescribeLiveDomainTranscodeParamsResponse() {}

  explicit DescribeLiveDomainTranscodeParamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDomainTranscodeParamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDomainTranscodeParamsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDomainTranscodeParamsResponse() = default;
};
class DescribeLiveDrmUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};

  DescribeLiveDrmUsageDataRequest() {}

  explicit DescribeLiveDrmUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveDrmUsageDataRequest() = default;
};
class DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> domain{};
  shared_ptr<string> drmType{};
  shared_ptr<string> region{};
  shared_ptr<string> timeStamp{};

  DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule() {}

  explicit DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (drmType) {
      res["DrmType"] = boost::any(*drmType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DrmType") != m.end() && !m["DrmType"].empty()) {
      drmType = make_shared<string>(boost::any_cast<string>(m["DrmType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule() = default;
};
class DescribeLiveDrmUsageDataResponseBodyDrmUsageData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule>> dataModule{};

  DescribeLiveDrmUsageDataResponseBodyDrmUsageData() {}

  explicit DescribeLiveDrmUsageDataResponseBodyDrmUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeLiveDrmUsageDataResponseBodyDrmUsageDataDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveDrmUsageDataResponseBodyDrmUsageData() = default;
};
class DescribeLiveDrmUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveDrmUsageDataResponseBodyDrmUsageData> drmUsageData{};
  shared_ptr<string> requestId{};

  DescribeLiveDrmUsageDataResponseBody() {}

  explicit DescribeLiveDrmUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (drmUsageData) {
      res["DrmUsageData"] = drmUsageData ? boost::any(drmUsageData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DrmUsageData") != m.end() && !m["DrmUsageData"].empty()) {
      if (typeid(map<string, boost::any>) == m["DrmUsageData"].type()) {
        DescribeLiveDrmUsageDataResponseBodyDrmUsageData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DrmUsageData"]));
        drmUsageData = make_shared<DescribeLiveDrmUsageDataResponseBodyDrmUsageData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveDrmUsageDataResponseBody() = default;
};
class DescribeLiveDrmUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveDrmUsageDataResponseBody> body{};

  DescribeLiveDrmUsageDataResponse() {}

  explicit DescribeLiveDrmUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveDrmUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveDrmUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveDrmUsageDataResponse() = default;
};
class DescribeLiveEdgeTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveEdgeTransferRequest() {}

  explicit DescribeLiveEdgeTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveEdgeTransferRequest() = default;
};
class DescribeLiveEdgeTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> httpDns{};
  shared_ptr<string> requestId{};
  shared_ptr<string> streamName{};
  shared_ptr<string> targetDomainList{};
  shared_ptr<string> transferArgs{};

  DescribeLiveEdgeTransferResponseBody() {}

  explicit DescribeLiveEdgeTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (httpDns) {
      res["HttpDns"] = boost::any(*httpDns);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (targetDomainList) {
      res["TargetDomainList"] = boost::any(*targetDomainList);
    }
    if (transferArgs) {
      res["TransferArgs"] = boost::any(*transferArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("HttpDns") != m.end() && !m["HttpDns"].empty()) {
      httpDns = make_shared<string>(boost::any_cast<string>(m["HttpDns"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TargetDomainList") != m.end() && !m["TargetDomainList"].empty()) {
      targetDomainList = make_shared<string>(boost::any_cast<string>(m["TargetDomainList"]));
    }
    if (m.find("TransferArgs") != m.end() && !m["TransferArgs"].empty()) {
      transferArgs = make_shared<string>(boost::any_cast<string>(m["TransferArgs"]));
    }
  }


  virtual ~DescribeLiveEdgeTransferResponseBody() = default;
};
class DescribeLiveEdgeTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveEdgeTransferResponseBody> body{};

  DescribeLiveEdgeTransferResponse() {}

  explicit DescribeLiveEdgeTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveEdgeTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveEdgeTransferResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveEdgeTransferResponse() = default;
};
class DescribeLiveGrtnDurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> area{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveGrtnDurationRequest() {}

  explicit DescribeLiveGrtnDurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveGrtnDurationRequest() = default;
};
class DescribeLiveGrtnDurationResponseBodyStreamDetailDataStreamData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> duration{};
  shared_ptr<string> mediaProfile{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> timeStamp{};

  DescribeLiveGrtnDurationResponseBodyStreamDetailDataStreamData() {}

  explicit DescribeLiveGrtnDurationResponseBodyStreamDetailDataStreamData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mediaProfile) {
      res["MediaProfile"] = boost::any(*mediaProfile);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("MediaProfile") != m.end() && !m["MediaProfile"].empty()) {
      mediaProfile = make_shared<string>(boost::any_cast<string>(m["MediaProfile"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveGrtnDurationResponseBodyStreamDetailDataStreamData() = default;
};
class DescribeLiveGrtnDurationResponseBodyStreamDetailData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveGrtnDurationResponseBodyStreamDetailDataStreamData>> streamData{};

  DescribeLiveGrtnDurationResponseBodyStreamDetailData() {}

  explicit DescribeLiveGrtnDurationResponseBodyStreamDetailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamData) {
      vector<boost::any> temp1;
      for(auto item1:*streamData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamData") != m.end() && !m["StreamData"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamData"].type()) {
        vector<DescribeLiveGrtnDurationResponseBodyStreamDetailDataStreamData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveGrtnDurationResponseBodyStreamDetailDataStreamData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamData = make_shared<vector<DescribeLiveGrtnDurationResponseBodyStreamDetailDataStreamData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveGrtnDurationResponseBodyStreamDetailData() = default;
};
class DescribeLiveGrtnDurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveGrtnDurationResponseBodyStreamDetailData> streamDetailData{};

  DescribeLiveGrtnDurationResponseBody() {}

  explicit DescribeLiveGrtnDurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamDetailData) {
      res["StreamDetailData"] = streamDetailData ? boost::any(streamDetailData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamDetailData") != m.end() && !m["StreamDetailData"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamDetailData"].type()) {
        DescribeLiveGrtnDurationResponseBodyStreamDetailData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamDetailData"]));
        streamDetailData = make_shared<DescribeLiveGrtnDurationResponseBodyStreamDetailData>(model1);
      }
    }
  }


  virtual ~DescribeLiveGrtnDurationResponseBody() = default;
};
class DescribeLiveGrtnDurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveGrtnDurationResponseBody> body{};

  DescribeLiveGrtnDurationResponse() {}

  explicit DescribeLiveGrtnDurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveGrtnDurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveGrtnDurationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveGrtnDurationResponse() = default;
};
class DescribeLiveHttpsDomainListRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeLiveHttpsDomainListRequest() {}

  explicit DescribeLiveHttpsDomainListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveHttpsDomainListRequest() = default;
};
class DescribeLiveHttpsDomainListResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certCommonName{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certName{};
  shared_ptr<string> certStartTime{};
  shared_ptr<string> certStatus{};
  shared_ptr<string> certType{};
  shared_ptr<string> certUpdateTime{};
  shared_ptr<string> domainName{};

  DescribeLiveHttpsDomainListResponseBodyCertInfosCertInfo() {}

  explicit DescribeLiveHttpsDomainListResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certCommonName) {
      res["CertCommonName"] = boost::any(*certCommonName);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certStartTime) {
      res["CertStartTime"] = boost::any(*certStartTime);
    }
    if (certStatus) {
      res["CertStatus"] = boost::any(*certStatus);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (certUpdateTime) {
      res["CertUpdateTime"] = boost::any(*certUpdateTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertCommonName") != m.end() && !m["CertCommonName"].empty()) {
      certCommonName = make_shared<string>(boost::any_cast<string>(m["CertCommonName"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertStartTime") != m.end() && !m["CertStartTime"].empty()) {
      certStartTime = make_shared<string>(boost::any_cast<string>(m["CertStartTime"]));
    }
    if (m.find("CertStatus") != m.end() && !m["CertStatus"].empty()) {
      certStatus = make_shared<string>(boost::any_cast<string>(m["CertStatus"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("CertUpdateTime") != m.end() && !m["CertUpdateTime"].empty()) {
      certUpdateTime = make_shared<string>(boost::any_cast<string>(m["CertUpdateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeLiveHttpsDomainListResponseBodyCertInfosCertInfo() = default;
};
class DescribeLiveHttpsDomainListResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveHttpsDomainListResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeLiveHttpsDomainListResponseBodyCertInfos() {}

  explicit DescribeLiveHttpsDomainListResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeLiveHttpsDomainListResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveHttpsDomainListResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeLiveHttpsDomainListResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveHttpsDomainListResponseBodyCertInfos() = default;
};
class DescribeLiveHttpsDomainListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveHttpsDomainListResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLiveHttpsDomainListResponseBody() {}

  explicit DescribeLiveHttpsDomainListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeLiveHttpsDomainListResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeLiveHttpsDomainListResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLiveHttpsDomainListResponseBody() = default;
};
class DescribeLiveHttpsDomainListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveHttpsDomainListResponseBody> body{};

  DescribeLiveHttpsDomainListResponse() {}

  explicit DescribeLiveHttpsDomainListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveHttpsDomainListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveHttpsDomainListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveHttpsDomainListResponse() = default;
};
class DescribeLiveInteractionMetricDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> beginTs{};
  shared_ptr<long> endTs{};
  shared_ptr<string> metricType{};
  shared_ptr<string> os{};
  shared_ptr<string> terminalType{};

  DescribeLiveInteractionMetricDataRequest() {}

  explicit DescribeLiveInteractionMetricDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (beginTs) {
      res["BeginTs"] = boost::any(*beginTs);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (terminalType) {
      res["TerminalType"] = boost::any(*terminalType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BeginTs") != m.end() && !m["BeginTs"].empty()) {
      beginTs = make_shared<long>(boost::any_cast<long>(m["BeginTs"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("TerminalType") != m.end() && !m["TerminalType"].empty()) {
      terminalType = make_shared<string>(boost::any_cast<string>(m["TerminalType"]));
    }
  }


  virtual ~DescribeLiveInteractionMetricDataRequest() = default;
};
class DescribeLiveInteractionMetricDataResponseBodyNodes : public Darabonba::Model {
public:
  shared_ptr<string> timestamp{};
  shared_ptr<string> value{};

  DescribeLiveInteractionMetricDataResponseBodyNodes() {}

  explicit DescribeLiveInteractionMetricDataResponseBodyNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLiveInteractionMetricDataResponseBodyNodes() = default;
};
class DescribeLiveInteractionMetricDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveInteractionMetricDataResponseBodyNodes>> nodes{};
  shared_ptr<string> requestId{};
  shared_ptr<string> summaryData{};

  DescribeLiveInteractionMetricDataResponseBody() {}

  explicit DescribeLiveInteractionMetricDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (summaryData) {
      res["SummaryData"] = boost::any(*summaryData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<DescribeLiveInteractionMetricDataResponseBodyNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveInteractionMetricDataResponseBodyNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<DescribeLiveInteractionMetricDataResponseBodyNodes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SummaryData") != m.end() && !m["SummaryData"].empty()) {
      summaryData = make_shared<string>(boost::any_cast<string>(m["SummaryData"]));
    }
  }


  virtual ~DescribeLiveInteractionMetricDataResponseBody() = default;
};
class DescribeLiveInteractionMetricDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveInteractionMetricDataResponseBody> body{};

  DescribeLiveInteractionMetricDataResponse() {}

  explicit DescribeLiveInteractionMetricDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveInteractionMetricDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveInteractionMetricDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveInteractionMetricDataResponse() = default;
};
class DescribeLiveIpInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> IP{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveIpInfoRequest() {}

  explicit DescribeLiveIpInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveIpInfoRequest() = default;
};
class DescribeLiveIpInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ISP{};
  shared_ptr<string> ispEname{};
  shared_ptr<string> region{};
  shared_ptr<string> regionEname{};
  shared_ptr<string> requestId{};

  DescribeLiveIpInfoResponseBody() {}

  explicit DescribeLiveIpInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (ispEname) {
      res["IspEname"] = boost::any(*ispEname);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionEname) {
      res["RegionEname"] = boost::any(*regionEname);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("IspEname") != m.end() && !m["IspEname"].empty()) {
      ispEname = make_shared<string>(boost::any_cast<string>(m["IspEname"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionEname") != m.end() && !m["RegionEname"].empty()) {
      regionEname = make_shared<string>(boost::any_cast<string>(m["RegionEname"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveIpInfoResponseBody() = default;
};
class DescribeLiveIpInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveIpInfoResponseBody> body{};

  DescribeLiveIpInfoResponse() {}

  explicit DescribeLiveIpInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveIpInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveIpInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveIpInfoResponse() = default;
};
class DescribeLiveLazyPullStreamConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveLazyPullStreamConfigRequest() {}

  explicit DescribeLiveLazyPullStreamConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveLazyPullStreamConfigRequest() = default;
};
class DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> pullAppName{};
  shared_ptr<string> pullArgs{};
  shared_ptr<string> pullDomainName{};
  shared_ptr<string> pullProtocol{};
  shared_ptr<string> transcodeLazy{};

  DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig() {}

  explicit DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (pullAppName) {
      res["PullAppName"] = boost::any(*pullAppName);
    }
    if (pullArgs) {
      res["PullArgs"] = boost::any(*pullArgs);
    }
    if (pullDomainName) {
      res["PullDomainName"] = boost::any(*pullDomainName);
    }
    if (pullProtocol) {
      res["PullProtocol"] = boost::any(*pullProtocol);
    }
    if (transcodeLazy) {
      res["TranscodeLazy"] = boost::any(*transcodeLazy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("PullAppName") != m.end() && !m["PullAppName"].empty()) {
      pullAppName = make_shared<string>(boost::any_cast<string>(m["PullAppName"]));
    }
    if (m.find("PullArgs") != m.end() && !m["PullArgs"].empty()) {
      pullArgs = make_shared<string>(boost::any_cast<string>(m["PullArgs"]));
    }
    if (m.find("PullDomainName") != m.end() && !m["PullDomainName"].empty()) {
      pullDomainName = make_shared<string>(boost::any_cast<string>(m["PullDomainName"]));
    }
    if (m.find("PullProtocol") != m.end() && !m["PullProtocol"].empty()) {
      pullProtocol = make_shared<string>(boost::any_cast<string>(m["PullProtocol"]));
    }
    if (m.find("TranscodeLazy") != m.end() && !m["TranscodeLazy"].empty()) {
      transcodeLazy = make_shared<string>(boost::any_cast<string>(m["TranscodeLazy"]));
    }
  }


  virtual ~DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig() = default;
};
class DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig>> liveLazyPullConfig{};

  DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList() {}

  explicit DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveLazyPullConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveLazyPullConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveLazyPullConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveLazyPullConfig") != m.end() && !m["LiveLazyPullConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveLazyPullConfig"].type()) {
        vector<DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveLazyPullConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveLazyPullConfig = make_shared<vector<DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigListLiveLazyPullConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList() = default;
};
class DescribeLiveLazyPullStreamConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList> liveLazyPullConfigList{};
  shared_ptr<string> requestId{};

  DescribeLiveLazyPullStreamConfigResponseBody() {}

  explicit DescribeLiveLazyPullStreamConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveLazyPullConfigList) {
      res["LiveLazyPullConfigList"] = liveLazyPullConfigList ? boost::any(liveLazyPullConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveLazyPullConfigList") != m.end() && !m["LiveLazyPullConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveLazyPullConfigList"].type()) {
        DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveLazyPullConfigList"]));
        liveLazyPullConfigList = make_shared<DescribeLiveLazyPullStreamConfigResponseBodyLiveLazyPullConfigList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveLazyPullStreamConfigResponseBody() = default;
};
class DescribeLiveLazyPullStreamConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveLazyPullStreamConfigResponseBody> body{};

  DescribeLiveLazyPullStreamConfigResponse() {}

  explicit DescribeLiveLazyPullStreamConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveLazyPullStreamConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveLazyPullStreamConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveLazyPullStreamConfigResponse() = default;
};
class DescribeLiveMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};

  DescribeLiveMessageAppRequest() {}

  explicit DescribeLiveMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
  }


  virtual ~DescribeLiveMessageAppRequest() = default;
};
class DescribeLiveMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appName{};
  shared_ptr<string> appSign{};
  shared_ptr<long> auditType{};
  shared_ptr<string> auditUrl{};
  shared_ptr<long> createTime{};
  shared_ptr<string> dataCenter{};
  shared_ptr<bool> disable{};
  shared_ptr<string> eventCallbackUrl{};
  shared_ptr<long> modifyTime{};
  shared_ptr<long> msgLifeCycle{};
  shared_ptr<string> requestId{};

  DescribeLiveMessageAppResponseBody() {}

  explicit DescribeLiveMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appSign) {
      res["AppSign"] = boost::any(*appSign);
    }
    if (auditType) {
      res["AuditType"] = boost::any(*auditType);
    }
    if (auditUrl) {
      res["AuditUrl"] = boost::any(*auditUrl);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (disable) {
      res["Disable"] = boost::any(*disable);
    }
    if (eventCallbackUrl) {
      res["EventCallbackUrl"] = boost::any(*eventCallbackUrl);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (msgLifeCycle) {
      res["MsgLifeCycle"] = boost::any(*msgLifeCycle);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppSign") != m.end() && !m["AppSign"].empty()) {
      appSign = make_shared<string>(boost::any_cast<string>(m["AppSign"]));
    }
    if (m.find("AuditType") != m.end() && !m["AuditType"].empty()) {
      auditType = make_shared<long>(boost::any_cast<long>(m["AuditType"]));
    }
    if (m.find("AuditUrl") != m.end() && !m["AuditUrl"].empty()) {
      auditUrl = make_shared<string>(boost::any_cast<string>(m["AuditUrl"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("Disable") != m.end() && !m["Disable"].empty()) {
      disable = make_shared<bool>(boost::any_cast<bool>(m["Disable"]));
    }
    if (m.find("EventCallbackUrl") != m.end() && !m["EventCallbackUrl"].empty()) {
      eventCallbackUrl = make_shared<string>(boost::any_cast<string>(m["EventCallbackUrl"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("MsgLifeCycle") != m.end() && !m["MsgLifeCycle"].empty()) {
      msgLifeCycle = make_shared<long>(boost::any_cast<long>(m["MsgLifeCycle"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveMessageAppResponseBody() = default;
};
class DescribeLiveMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveMessageAppResponseBody> body{};

  DescribeLiveMessageAppResponse() {}

  explicit DescribeLiveMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveMessageAppResponse() = default;
};
class DescribeLiveMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};

  DescribeLiveMessageGroupRequest() {}

  explicit DescribeLiveMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~DescribeLiveMessageGroupRequest() = default;
};
class DescribeLiveMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> adminList{};
  shared_ptr<long> createtime{};
  shared_ptr<string> creatorId{};
  shared_ptr<long> deletatime{};
  shared_ptr<bool> delete_{};
  shared_ptr<string> deletor{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupInfo{};
  shared_ptr<string> groupName{};
  shared_ptr<map<string, long>> msgAmount{};
  shared_ptr<long> onlineUserCounts{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> superLargeGroup{};
  shared_ptr<long> totalTimes{};

  DescribeLiveMessageGroupResponseBody() {}

  explicit DescribeLiveMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminList) {
      res["AdminList"] = boost::any(*adminList);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (deletatime) {
      res["Deletatime"] = boost::any(*deletatime);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (deletor) {
      res["Deletor"] = boost::any(*deletor);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupInfo) {
      res["GroupInfo"] = boost::any(*groupInfo);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (msgAmount) {
      res["MsgAmount"] = boost::any(*msgAmount);
    }
    if (onlineUserCounts) {
      res["OnlineUserCounts"] = boost::any(*onlineUserCounts);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (superLargeGroup) {
      res["SuperLargeGroup"] = boost::any(*superLargeGroup);
    }
    if (totalTimes) {
      res["TotalTimes"] = boost::any(*totalTimes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdminList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      adminList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Deletatime") != m.end() && !m["Deletatime"].empty()) {
      deletatime = make_shared<long>(boost::any_cast<long>(m["Deletatime"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("Deletor") != m.end() && !m["Deletor"].empty()) {
      deletor = make_shared<string>(boost::any_cast<string>(m["Deletor"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      groupInfo = make_shared<string>(boost::any_cast<string>(m["GroupInfo"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("MsgAmount") != m.end() && !m["MsgAmount"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["MsgAmount"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      msgAmount = make_shared<map<string, long>>(toMap1);
    }
    if (m.find("OnlineUserCounts") != m.end() && !m["OnlineUserCounts"].empty()) {
      onlineUserCounts = make_shared<long>(boost::any_cast<long>(m["OnlineUserCounts"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuperLargeGroup") != m.end() && !m["SuperLargeGroup"].empty()) {
      superLargeGroup = make_shared<bool>(boost::any_cast<bool>(m["SuperLargeGroup"]));
    }
    if (m.find("TotalTimes") != m.end() && !m["TotalTimes"].empty()) {
      totalTimes = make_shared<long>(boost::any_cast<long>(m["TotalTimes"]));
    }
  }


  virtual ~DescribeLiveMessageGroupResponseBody() = default;
};
class DescribeLiveMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveMessageGroupResponseBody> body{};

  DescribeLiveMessageGroupResponse() {}

  explicit DescribeLiveMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveMessageGroupResponse() = default;
};
class DescribeLiveMessageGroupBandRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};

  DescribeLiveMessageGroupBandRequest() {}

  explicit DescribeLiveMessageGroupBandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~DescribeLiveMessageGroupBandRequest() = default;
};
class DescribeLiveMessageGroupBandResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> bannedUserList{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> isbannedAll{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> unbannedUserList{};

  DescribeLiveMessageGroupBandResponseBody() {}

  explicit DescribeLiveMessageGroupBandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bannedUserList) {
      res["BannedUserList"] = boost::any(*bannedUserList);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isbannedAll) {
      res["IsbannedAll"] = boost::any(*isbannedAll);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (unbannedUserList) {
      res["UnbannedUserList"] = boost::any(*unbannedUserList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BannedUserList") != m.end() && !m["BannedUserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BannedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BannedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bannedUserList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsbannedAll") != m.end() && !m["IsbannedAll"].empty()) {
      isbannedAll = make_shared<bool>(boost::any_cast<bool>(m["IsbannedAll"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UnbannedUserList") != m.end() && !m["UnbannedUserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UnbannedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UnbannedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      unbannedUserList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveMessageGroupBandResponseBody() = default;
};
class DescribeLiveMessageGroupBandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveMessageGroupBandResponseBody> body{};

  DescribeLiveMessageGroupBandResponse() {}

  explicit DescribeLiveMessageGroupBandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveMessageGroupBandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveMessageGroupBandResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveMessageGroupBandResponse() = default;
};
class DescribeLivePackageConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DescribeLivePackageConfigRequest() {}

  explicit DescribeLivePackageConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLivePackageConfigRequest() = default;
};
class DescribeLivePackageConfigResponseBodyLivePackageConfigListLivePackageConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<bool> ignoreTranscode{};
  shared_ptr<long> partDuration{};
  shared_ptr<string> protocol{};
  shared_ptr<long> segmentDuration{};
  shared_ptr<long> segmentNum{};
  shared_ptr<string> streamName{};

  DescribeLivePackageConfigResponseBodyLivePackageConfigListLivePackageConfig() {}

  explicit DescribeLivePackageConfigResponseBodyLivePackageConfigListLivePackageConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ignoreTranscode) {
      res["IgnoreTranscode"] = boost::any(*ignoreTranscode);
    }
    if (partDuration) {
      res["PartDuration"] = boost::any(*partDuration);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    if (segmentNum) {
      res["SegmentNum"] = boost::any(*segmentNum);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IgnoreTranscode") != m.end() && !m["IgnoreTranscode"].empty()) {
      ignoreTranscode = make_shared<bool>(boost::any_cast<bool>(m["IgnoreTranscode"]));
    }
    if (m.find("PartDuration") != m.end() && !m["PartDuration"].empty()) {
      partDuration = make_shared<long>(boost::any_cast<long>(m["PartDuration"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
    if (m.find("SegmentNum") != m.end() && !m["SegmentNum"].empty()) {
      segmentNum = make_shared<long>(boost::any_cast<long>(m["SegmentNum"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLivePackageConfigResponseBodyLivePackageConfigListLivePackageConfig() = default;
};
class DescribeLivePackageConfigResponseBodyLivePackageConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLivePackageConfigResponseBodyLivePackageConfigListLivePackageConfig>> livePackageConfig{};

  DescribeLivePackageConfigResponseBodyLivePackageConfigList() {}

  explicit DescribeLivePackageConfigResponseBodyLivePackageConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageConfig) {
      vector<boost::any> temp1;
      for(auto item1:*livePackageConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LivePackageConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageConfig") != m.end() && !m["LivePackageConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LivePackageConfig"].type()) {
        vector<DescribeLivePackageConfigResponseBodyLivePackageConfigListLivePackageConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LivePackageConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLivePackageConfigResponseBodyLivePackageConfigListLivePackageConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        livePackageConfig = make_shared<vector<DescribeLivePackageConfigResponseBodyLivePackageConfigListLivePackageConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLivePackageConfigResponseBodyLivePackageConfigList() = default;
};
class DescribeLivePackageConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLivePackageConfigResponseBodyLivePackageConfigList> livePackageConfigList{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLivePackageConfigResponseBody() {}

  explicit DescribeLivePackageConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageConfigList) {
      res["LivePackageConfigList"] = livePackageConfigList ? boost::any(livePackageConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageConfigList") != m.end() && !m["LivePackageConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackageConfigList"].type()) {
        DescribeLivePackageConfigResponseBodyLivePackageConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackageConfigList"]));
        livePackageConfigList = make_shared<DescribeLivePackageConfigResponseBodyLivePackageConfigList>(model1);
      }
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLivePackageConfigResponseBody() = default;
};
class DescribeLivePackageConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLivePackageConfigResponseBody> body{};

  DescribeLivePackageConfigResponse() {}

  explicit DescribeLivePackageConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLivePackageConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLivePackageConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLivePackageConfigResponse() = default;
};
class DescribeLivePrivateLineAreasRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLivePrivateLineAreasRequest() {}

  explicit DescribeLivePrivateLineAreasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLivePrivateLineAreasRequest() = default;
};
class DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegionsRegion : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegionsRegion() {}

  explicit DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegionsRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegionsRegion() = default;
};
class DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegionsRegion>> region{};

  DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegions() {}

  explicit DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      vector<boost::any> temp1;
      for(auto item1:*region){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Region"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegionsRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Region"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegionsRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        region = make_shared<vector<DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegionsRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegions() = default;
};
class DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveArea : public Darabonba::Model {
public:
  shared_ptr<string> regionType{};
  shared_ptr<DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegions> regions{};

  DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveArea() {}

  explicit DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveArea(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionType) {
      res["RegionType"] = boost::any(*regionType);
    }
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionType") != m.end() && !m["RegionType"].empty()) {
      regionType = make_shared<string>(boost::any_cast<string>(m["RegionType"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveAreaRegions>(model1);
      }
    }
  }


  virtual ~DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveArea() = default;
};
class DescribeLivePrivateLineAreasResponseBodyLiveAreasList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveArea>> liveArea{};

  DescribeLivePrivateLineAreasResponseBodyLiveAreasList() {}

  explicit DescribeLivePrivateLineAreasResponseBodyLiveAreasList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveArea) {
      vector<boost::any> temp1;
      for(auto item1:*liveArea){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveArea"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveArea") != m.end() && !m["LiveArea"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveArea"].type()) {
        vector<DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveArea> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveArea"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveArea model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveArea = make_shared<vector<DescribeLivePrivateLineAreasResponseBodyLiveAreasListLiveArea>>(expect1);
      }
    }
  }


  virtual ~DescribeLivePrivateLineAreasResponseBodyLiveAreasList() = default;
};
class DescribeLivePrivateLineAreasResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLivePrivateLineAreasResponseBodyLiveAreasList> liveAreasList{};
  shared_ptr<string> requestId{};

  DescribeLivePrivateLineAreasResponseBody() {}

  explicit DescribeLivePrivateLineAreasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAreasList) {
      res["LiveAreasList"] = liveAreasList ? boost::any(liveAreasList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAreasList") != m.end() && !m["LiveAreasList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveAreasList"].type()) {
        DescribeLivePrivateLineAreasResponseBodyLiveAreasList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveAreasList"]));
        liveAreasList = make_shared<DescribeLivePrivateLineAreasResponseBodyLiveAreasList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLivePrivateLineAreasResponseBody() = default;
};
class DescribeLivePrivateLineAreasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLivePrivateLineAreasResponseBody> body{};

  DescribeLivePrivateLineAreasResponse() {}

  explicit DescribeLivePrivateLineAreasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLivePrivateLineAreasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLivePrivateLineAreasResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLivePrivateLineAreasResponse() = default;
};
class DescribeLivePrivateLineAvailGARequest : public Darabonba::Model {
public:
  shared_ptr<string> accelerationArea{};
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> isGaInstance{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};
  shared_ptr<string> videoCenter{};

  DescribeLivePrivateLineAvailGARequest() {}

  explicit DescribeLivePrivateLineAvailGARequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerationArea) {
      res["AccelerationArea"] = boost::any(*accelerationArea);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (isGaInstance) {
      res["IsGaInstance"] = boost::any(*isGaInstance);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (videoCenter) {
      res["VideoCenter"] = boost::any(*videoCenter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerationArea") != m.end() && !m["AccelerationArea"].empty()) {
      accelerationArea = make_shared<string>(boost::any_cast<string>(m["AccelerationArea"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IsGaInstance") != m.end() && !m["IsGaInstance"].empty()) {
      isGaInstance = make_shared<string>(boost::any_cast<string>(m["IsGaInstance"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("VideoCenter") != m.end() && !m["VideoCenter"].empty()) {
      videoCenter = make_shared<string>(boost::any_cast<string>(m["VideoCenter"]));
    }
  }


  virtual ~DescribeLivePrivateLineAvailGARequest() = default;
};
class DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAsLivePrivateLineAvailGA : public Darabonba::Model {
public:
  shared_ptr<string> accelerationArea{};
  shared_ptr<string> accelerationType{};
  shared_ptr<string> appName{};
  shared_ptr<string> bindingStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> status{};
  shared_ptr<string> streamName{};
  shared_ptr<string> uid{};
  shared_ptr<string> videoCenter{};

  DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAsLivePrivateLineAvailGA() {}

  explicit DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAsLivePrivateLineAvailGA(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerationArea) {
      res["AccelerationArea"] = boost::any(*accelerationArea);
    }
    if (accelerationType) {
      res["AccelerationType"] = boost::any(*accelerationType);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bindingStatus) {
      res["BindingStatus"] = boost::any(*bindingStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (videoCenter) {
      res["VideoCenter"] = boost::any(*videoCenter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerationArea") != m.end() && !m["AccelerationArea"].empty()) {
      accelerationArea = make_shared<string>(boost::any_cast<string>(m["AccelerationArea"]));
    }
    if (m.find("AccelerationType") != m.end() && !m["AccelerationType"].empty()) {
      accelerationType = make_shared<string>(boost::any_cast<string>(m["AccelerationType"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BindingStatus") != m.end() && !m["BindingStatus"].empty()) {
      bindingStatus = make_shared<string>(boost::any_cast<string>(m["BindingStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("VideoCenter") != m.end() && !m["VideoCenter"].empty()) {
      videoCenter = make_shared<string>(boost::any_cast<string>(m["VideoCenter"]));
    }
  }


  virtual ~DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAsLivePrivateLineAvailGA() = default;
};
class DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAsLivePrivateLineAvailGA>> livePrivateLineAvailGA{};

  DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAs() {}

  explicit DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePrivateLineAvailGA) {
      vector<boost::any> temp1;
      for(auto item1:*livePrivateLineAvailGA){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LivePrivateLineAvailGA"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePrivateLineAvailGA") != m.end() && !m["LivePrivateLineAvailGA"].empty()) {
      if (typeid(vector<boost::any>) == m["LivePrivateLineAvailGA"].type()) {
        vector<DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAsLivePrivateLineAvailGA> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LivePrivateLineAvailGA"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAsLivePrivateLineAvailGA model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        livePrivateLineAvailGA = make_shared<vector<DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAsLivePrivateLineAvailGA>>(expect1);
      }
    }
  }


  virtual ~DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAs() = default;
};
class DescribeLivePrivateLineAvailGAResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAs> livePrivateLineAvailGAs{};
  shared_ptr<string> requestId{};

  DescribeLivePrivateLineAvailGAResponseBody() {}

  explicit DescribeLivePrivateLineAvailGAResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePrivateLineAvailGAs) {
      res["LivePrivateLineAvailGAs"] = livePrivateLineAvailGAs ? boost::any(livePrivateLineAvailGAs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePrivateLineAvailGAs") != m.end() && !m["LivePrivateLineAvailGAs"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePrivateLineAvailGAs"].type()) {
        DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePrivateLineAvailGAs"]));
        livePrivateLineAvailGAs = make_shared<DescribeLivePrivateLineAvailGAResponseBodyLivePrivateLineAvailGAs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLivePrivateLineAvailGAResponseBody() = default;
};
class DescribeLivePrivateLineAvailGAResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLivePrivateLineAvailGAResponseBody> body{};

  DescribeLivePrivateLineAvailGAResponse() {}

  explicit DescribeLivePrivateLineAvailGAResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLivePrivateLineAvailGAResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLivePrivateLineAvailGAResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLivePrivateLineAvailGAResponse() = default;
};
class DescribeLiveProducerUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instance{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};
  shared_ptr<string> app{};

  DescribeLiveProducerUsageDataRequest() {}

  explicit DescribeLiveProducerUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (app) {
      res["app"] = boost::any(*app);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("app") != m.end() && !m["app"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["app"]));
    }
  }


  virtual ~DescribeLiveProducerUsageDataRequest() = default;
};
class DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> instance{};
  shared_ptr<long> outputHdDuration{};
  shared_ptr<long> outputLdDuration{};
  shared_ptr<long> outputSdDuration{};
  shared_ptr<string> region{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> tranHdDuration{};
  shared_ptr<long> tranLdDuration{};
  shared_ptr<long> tranSdDuration{};
  shared_ptr<string> type{};

  DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem() {}

  explicit DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (outputHdDuration) {
      res["OutputHdDuration"] = boost::any(*outputHdDuration);
    }
    if (outputLdDuration) {
      res["OutputLdDuration"] = boost::any(*outputLdDuration);
    }
    if (outputSdDuration) {
      res["OutputSdDuration"] = boost::any(*outputSdDuration);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (tranHdDuration) {
      res["TranHdDuration"] = boost::any(*tranHdDuration);
    }
    if (tranLdDuration) {
      res["TranLdDuration"] = boost::any(*tranLdDuration);
    }
    if (tranSdDuration) {
      res["TranSdDuration"] = boost::any(*tranSdDuration);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("OutputHdDuration") != m.end() && !m["OutputHdDuration"].empty()) {
      outputHdDuration = make_shared<long>(boost::any_cast<long>(m["OutputHdDuration"]));
    }
    if (m.find("OutputLdDuration") != m.end() && !m["OutputLdDuration"].empty()) {
      outputLdDuration = make_shared<long>(boost::any_cast<long>(m["OutputLdDuration"]));
    }
    if (m.find("OutputSdDuration") != m.end() && !m["OutputSdDuration"].empty()) {
      outputSdDuration = make_shared<long>(boost::any_cast<long>(m["OutputSdDuration"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TranHdDuration") != m.end() && !m["TranHdDuration"].empty()) {
      tranHdDuration = make_shared<long>(boost::any_cast<long>(m["TranHdDuration"]));
    }
    if (m.find("TranLdDuration") != m.end() && !m["TranLdDuration"].empty()) {
      tranLdDuration = make_shared<long>(boost::any_cast<long>(m["TranLdDuration"]));
    }
    if (m.find("TranSdDuration") != m.end() && !m["TranSdDuration"].empty()) {
      tranSdDuration = make_shared<long>(boost::any_cast<long>(m["TranSdDuration"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem() = default;
};
class DescribeLiveProducerUsageDataResponseBodyBillProducerData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem>> billProducerDataItem{};

  DescribeLiveProducerUsageDataResponseBodyBillProducerData() {}

  explicit DescribeLiveProducerUsageDataResponseBodyBillProducerData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billProducerDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billProducerDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillProducerDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillProducerDataItem") != m.end() && !m["BillProducerDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillProducerDataItem"].type()) {
        vector<DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillProducerDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billProducerDataItem = make_shared<vector<DescribeLiveProducerUsageDataResponseBodyBillProducerDataBillProducerDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveProducerUsageDataResponseBodyBillProducerData() = default;
};
class DescribeLiveProducerUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveProducerUsageDataResponseBodyBillProducerData> billProducerData{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveProducerUsageDataResponseBody() {}

  explicit DescribeLiveProducerUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billProducerData) {
      res["BillProducerData"] = billProducerData ? boost::any(billProducerData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillProducerData") != m.end() && !m["BillProducerData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillProducerData"].type()) {
        DescribeLiveProducerUsageDataResponseBodyBillProducerData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillProducerData"]));
        billProducerData = make_shared<DescribeLiveProducerUsageDataResponseBodyBillProducerData>(model1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveProducerUsageDataResponseBody() = default;
};
class DescribeLiveProducerUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveProducerUsageDataResponseBody> body{};

  DescribeLiveProducerUsageDataResponse() {}

  explicit DescribeLiveProducerUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveProducerUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveProducerUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveProducerUsageDataResponse() = default;
};
class DescribeLivePullStreamConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLivePullStreamConfigRequest() {}

  explicit DescribeLivePullStreamConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLivePullStreamConfigRequest() = default;
};
class DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> sourceUsing{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord() {}

  explicit DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (sourceUsing) {
      res["SourceUsing"] = boost::any(*sourceUsing);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("SourceUsing") != m.end() && !m["SourceUsing"].empty()) {
      sourceUsing = make_shared<string>(boost::any_cast<string>(m["SourceUsing"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord() = default;
};
class DescribeLivePullStreamConfigResponseBodyLiveAppRecordList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord>> liveAppRecord{};

  DescribeLivePullStreamConfigResponseBodyLiveAppRecordList() {}

  explicit DescribeLivePullStreamConfigResponseBodyLiveAppRecordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAppRecord) {
      vector<boost::any> temp1;
      for(auto item1:*liveAppRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveAppRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAppRecord") != m.end() && !m["LiveAppRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveAppRecord"].type()) {
        vector<DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveAppRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveAppRecord = make_shared<vector<DescribeLivePullStreamConfigResponseBodyLiveAppRecordListLiveAppRecord>>(expect1);
      }
    }
  }


  virtual ~DescribeLivePullStreamConfigResponseBodyLiveAppRecordList() = default;
};
class DescribeLivePullStreamConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLivePullStreamConfigResponseBodyLiveAppRecordList> liveAppRecordList{};
  shared_ptr<string> requestId{};

  DescribeLivePullStreamConfigResponseBody() {}

  explicit DescribeLivePullStreamConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAppRecordList) {
      res["LiveAppRecordList"] = liveAppRecordList ? boost::any(liveAppRecordList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAppRecordList") != m.end() && !m["LiveAppRecordList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveAppRecordList"].type()) {
        DescribeLivePullStreamConfigResponseBodyLiveAppRecordList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveAppRecordList"]));
        liveAppRecordList = make_shared<DescribeLivePullStreamConfigResponseBodyLiveAppRecordList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLivePullStreamConfigResponseBody() = default;
};
class DescribeLivePullStreamConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLivePullStreamConfigResponseBody> body{};

  DescribeLivePullStreamConfigResponse() {}

  explicit DescribeLivePullStreamConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLivePullStreamConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLivePullStreamConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLivePullStreamConfigResponse() = default;
};
class DescribeLivePullToPushRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  DescribeLivePullToPushRequest() {}

  explicit DescribeLivePullToPushRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeLivePullToPushRequest() = default;
};
class DescribeLivePullToPushResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> callbackURL{};
  shared_ptr<string> dstUrl{};
  shared_ptr<string> endTime{};
  shared_ptr<long> fileIndex{};
  shared_ptr<long> offset{};
  shared_ptr<long> repeatNumber{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> sourceProtocol{};
  shared_ptr<string> sourceType{};
  shared_ptr<vector<string>> sourceUrls{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  DescribeLivePullToPushResponseBodyTaskInfo() {}

  explicit DescribeLivePullToPushResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackURL) {
      res["CallbackURL"] = boost::any(*callbackURL);
    }
    if (dstUrl) {
      res["DstUrl"] = boost::any(*dstUrl);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileIndex) {
      res["FileIndex"] = boost::any(*fileIndex);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (repeatNumber) {
      res["RepeatNumber"] = boost::any(*repeatNumber);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (sourceProtocol) {
      res["SourceProtocol"] = boost::any(*sourceProtocol);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceUrls) {
      res["SourceUrls"] = boost::any(*sourceUrls);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackURL") != m.end() && !m["CallbackURL"].empty()) {
      callbackURL = make_shared<string>(boost::any_cast<string>(m["CallbackURL"]));
    }
    if (m.find("DstUrl") != m.end() && !m["DstUrl"].empty()) {
      dstUrl = make_shared<string>(boost::any_cast<string>(m["DstUrl"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FileIndex") != m.end() && !m["FileIndex"].empty()) {
      fileIndex = make_shared<long>(boost::any_cast<long>(m["FileIndex"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("RepeatNumber") != m.end() && !m["RepeatNumber"].empty()) {
      repeatNumber = make_shared<long>(boost::any_cast<long>(m["RepeatNumber"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("SourceProtocol") != m.end() && !m["SourceProtocol"].empty()) {
      sourceProtocol = make_shared<string>(boost::any_cast<string>(m["SourceProtocol"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceUrls") != m.end() && !m["SourceUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~DescribeLivePullToPushResponseBodyTaskInfo() = default;
};
class DescribeLivePullToPushResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentFileIndex{};
  shared_ptr<long> currentOffset{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};
  shared_ptr<string> taskExitReason{};
  shared_ptr<long> taskExitTime{};
  shared_ptr<string> taskId{};
  shared_ptr<DescribeLivePullToPushResponseBodyTaskInfo> taskInfo{};
  shared_ptr<string> taskInvalidReason{};
  shared_ptr<long> taskStatus{};

  DescribeLivePullToPushResponseBody() {}

  explicit DescribeLivePullToPushResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentFileIndex) {
      res["CurrentFileIndex"] = boost::any(*currentFileIndex);
    }
    if (currentOffset) {
      res["CurrentOffset"] = boost::any(*currentOffset);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    if (taskExitReason) {
      res["TaskExitReason"] = boost::any(*taskExitReason);
    }
    if (taskExitTime) {
      res["TaskExitTime"] = boost::any(*taskExitTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskInvalidReason) {
      res["TaskInvalidReason"] = boost::any(*taskInvalidReason);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentFileIndex") != m.end() && !m["CurrentFileIndex"].empty()) {
      currentFileIndex = make_shared<long>(boost::any_cast<long>(m["CurrentFileIndex"]));
    }
    if (m.find("CurrentOffset") != m.end() && !m["CurrentOffset"].empty()) {
      currentOffset = make_shared<long>(boost::any_cast<long>(m["CurrentOffset"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
    if (m.find("TaskExitReason") != m.end() && !m["TaskExitReason"].empty()) {
      taskExitReason = make_shared<string>(boost::any_cast<string>(m["TaskExitReason"]));
    }
    if (m.find("TaskExitTime") != m.end() && !m["TaskExitTime"].empty()) {
      taskExitTime = make_shared<long>(boost::any_cast<long>(m["TaskExitTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        DescribeLivePullToPushResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<DescribeLivePullToPushResponseBodyTaskInfo>(model1);
      }
    }
    if (m.find("TaskInvalidReason") != m.end() && !m["TaskInvalidReason"].empty()) {
      taskInvalidReason = make_shared<string>(boost::any_cast<string>(m["TaskInvalidReason"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
  }


  virtual ~DescribeLivePullToPushResponseBody() = default;
};
class DescribeLivePullToPushResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLivePullToPushResponseBody> body{};

  DescribeLivePullToPushResponse() {}

  explicit DescribeLivePullToPushResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLivePullToPushResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLivePullToPushResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLivePullToPushResponse() = default;
};
class DescribeLivePullToPushListRequest : public Darabonba::Model {
public:
  shared_ptr<string> dstUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  DescribeLivePullToPushListRequest() {}

  explicit DescribeLivePullToPushListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstUrl) {
      res["DstUrl"] = boost::any(*dstUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstUrl") != m.end() && !m["DstUrl"].empty()) {
      dstUrl = make_shared<string>(boost::any_cast<string>(m["DstUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~DescribeLivePullToPushListRequest() = default;
};
class DescribeLivePullToPushListResponseBodyTaskListTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> callbackURL{};
  shared_ptr<string> dstUrl{};
  shared_ptr<string> endTime{};
  shared_ptr<long> fileIndex{};
  shared_ptr<long> offset{};
  shared_ptr<long> repeatNumber{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> sourceProtocol{};
  shared_ptr<string> sourceType{};
  shared_ptr<vector<string>> sourceUrls{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  DescribeLivePullToPushListResponseBodyTaskListTaskInfo() {}

  explicit DescribeLivePullToPushListResponseBodyTaskListTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackURL) {
      res["CallbackURL"] = boost::any(*callbackURL);
    }
    if (dstUrl) {
      res["DstUrl"] = boost::any(*dstUrl);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileIndex) {
      res["FileIndex"] = boost::any(*fileIndex);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (repeatNumber) {
      res["RepeatNumber"] = boost::any(*repeatNumber);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (sourceProtocol) {
      res["SourceProtocol"] = boost::any(*sourceProtocol);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceUrls) {
      res["SourceUrls"] = boost::any(*sourceUrls);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackURL") != m.end() && !m["CallbackURL"].empty()) {
      callbackURL = make_shared<string>(boost::any_cast<string>(m["CallbackURL"]));
    }
    if (m.find("DstUrl") != m.end() && !m["DstUrl"].empty()) {
      dstUrl = make_shared<string>(boost::any_cast<string>(m["DstUrl"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FileIndex") != m.end() && !m["FileIndex"].empty()) {
      fileIndex = make_shared<long>(boost::any_cast<long>(m["FileIndex"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("RepeatNumber") != m.end() && !m["RepeatNumber"].empty()) {
      repeatNumber = make_shared<long>(boost::any_cast<long>(m["RepeatNumber"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("SourceProtocol") != m.end() && !m["SourceProtocol"].empty()) {
      sourceProtocol = make_shared<string>(boost::any_cast<string>(m["SourceProtocol"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceUrls") != m.end() && !m["SourceUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~DescribeLivePullToPushListResponseBodyTaskListTaskInfo() = default;
};
class DescribeLivePullToPushListResponseBodyTaskList : public Darabonba::Model {
public:
  shared_ptr<long> currentFileIndex{};
  shared_ptr<long> currentOffset{};
  shared_ptr<string> taskExitReason{};
  shared_ptr<long> taskExitTime{};
  shared_ptr<string> taskId{};
  shared_ptr<DescribeLivePullToPushListResponseBodyTaskListTaskInfo> taskInfo{};
  shared_ptr<string> taskInvalidReason{};
  shared_ptr<long> taskStatus{};

  DescribeLivePullToPushListResponseBodyTaskList() {}

  explicit DescribeLivePullToPushListResponseBodyTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentFileIndex) {
      res["CurrentFileIndex"] = boost::any(*currentFileIndex);
    }
    if (currentOffset) {
      res["CurrentOffset"] = boost::any(*currentOffset);
    }
    if (taskExitReason) {
      res["TaskExitReason"] = boost::any(*taskExitReason);
    }
    if (taskExitTime) {
      res["TaskExitTime"] = boost::any(*taskExitTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskInvalidReason) {
      res["TaskInvalidReason"] = boost::any(*taskInvalidReason);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentFileIndex") != m.end() && !m["CurrentFileIndex"].empty()) {
      currentFileIndex = make_shared<long>(boost::any_cast<long>(m["CurrentFileIndex"]));
    }
    if (m.find("CurrentOffset") != m.end() && !m["CurrentOffset"].empty()) {
      currentOffset = make_shared<long>(boost::any_cast<long>(m["CurrentOffset"]));
    }
    if (m.find("TaskExitReason") != m.end() && !m["TaskExitReason"].empty()) {
      taskExitReason = make_shared<string>(boost::any_cast<string>(m["TaskExitReason"]));
    }
    if (m.find("TaskExitTime") != m.end() && !m["TaskExitTime"].empty()) {
      taskExitTime = make_shared<long>(boost::any_cast<long>(m["TaskExitTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        DescribeLivePullToPushListResponseBodyTaskListTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<DescribeLivePullToPushListResponseBodyTaskListTaskInfo>(model1);
      }
    }
    if (m.find("TaskInvalidReason") != m.end() && !m["TaskInvalidReason"].empty()) {
      taskInvalidReason = make_shared<string>(boost::any_cast<string>(m["TaskInvalidReason"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
  }


  virtual ~DescribeLivePullToPushListResponseBodyTaskList() = default;
};
class DescribeLivePullToPushListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeLivePullToPushListResponseBodyTaskList>> taskList{};
  shared_ptr<long> total{};

  DescribeLivePullToPushListResponseBody() {}

  explicit DescribeLivePullToPushListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskList) {
      vector<boost::any> temp1;
      for(auto item1:*taskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskList"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskList"].type()) {
        vector<DescribeLivePullToPushListResponseBodyTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLivePullToPushListResponseBodyTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskList = make_shared<vector<DescribeLivePullToPushListResponseBodyTaskList>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLivePullToPushListResponseBody() = default;
};
class DescribeLivePullToPushListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLivePullToPushListResponseBody> body{};

  DescribeLivePullToPushListResponse() {}

  explicit DescribeLivePullToPushListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLivePullToPushListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLivePullToPushListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLivePullToPushListResponse() = default;
};
class DescribeLivePushProxyLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLivePushProxyLogRequest() {}

  explicit DescribeLivePushProxyLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLivePushProxyLogRequest() = default;
};
class DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};

  DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() {}

  explicit DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() = default;
};
class DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>> logInfoDetail{};

  DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() {}

  explicit DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfoDetail) {
      vector<boost::any> temp1;
      for(auto item1:*logInfoDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfoDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfoDetail") != m.end() && !m["LogInfoDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfoDetail"].type()) {
        vector<DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfoDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfoDetail = make_shared<vector<DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() = default;
};
class DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() {}

  explicit DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() = default;
};
class DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetail : public Darabonba::Model {
public:
  shared_ptr<long> logCount{};
  shared_ptr<DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos> logInfos{};
  shared_ptr<DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos> pageInfos{};

  DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetail() {}

  explicit DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos>(model1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetail() = default;
};
class DescribeLivePushProxyLogResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetail>> domainLogDetail{};

  DescribeLivePushProxyLogResponseBodyDomainLogDetails() {}

  explicit DescribeLivePushProxyLogResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetail") != m.end() && !m["DomainLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetail"].type()) {
        vector<DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetail = make_shared<vector<DescribeLivePushProxyLogResponseBodyDomainLogDetailsDomainLogDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLivePushProxyLogResponseBodyDomainLogDetails() = default;
};
class DescribeLivePushProxyLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLivePushProxyLogResponseBodyDomainLogDetails> domainLogDetails{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  DescribeLivePushProxyLogResponseBody() {}

  explicit DescribeLivePushProxyLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetails) {
      res["DomainLogDetails"] = domainLogDetails ? boost::any(domainLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogDetails"].type()) {
        DescribeLivePushProxyLogResponseBodyDomainLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogDetails"]));
        domainLogDetails = make_shared<DescribeLivePushProxyLogResponseBodyDomainLogDetails>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLivePushProxyLogResponseBody() = default;
};
class DescribeLivePushProxyLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLivePushProxyLogResponseBody> body{};

  DescribeLivePushProxyLogResponse() {}

  explicit DescribeLivePushProxyLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLivePushProxyLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLivePushProxyLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLivePushProxyLogResponse() = default;
};
class DescribeLivePushProxyUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};

  DescribeLivePushProxyUsageDataRequest() {}

  explicit DescribeLivePushProxyUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLivePushProxyUsageDataRequest() = default;
};
class DescribeLivePushProxyUsageDataResponseBodyPushProxyDataPushProxyDataItem : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> region{};
  shared_ptr<long> streamCount{};
  shared_ptr<string> timeStamp{};

  DescribeLivePushProxyUsageDataResponseBodyPushProxyDataPushProxyDataItem() {}

  explicit DescribeLivePushProxyUsageDataResponseBodyPushProxyDataPushProxyDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (streamCount) {
      res["StreamCount"] = boost::any(*streamCount);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StreamCount") != m.end() && !m["StreamCount"].empty()) {
      streamCount = make_shared<long>(boost::any_cast<long>(m["StreamCount"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLivePushProxyUsageDataResponseBodyPushProxyDataPushProxyDataItem() = default;
};
class DescribeLivePushProxyUsageDataResponseBodyPushProxyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLivePushProxyUsageDataResponseBodyPushProxyDataPushProxyDataItem>> pushProxyDataItem{};

  DescribeLivePushProxyUsageDataResponseBodyPushProxyData() {}

  explicit DescribeLivePushProxyUsageDataResponseBodyPushProxyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushProxyDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*pushProxyDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PushProxyDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushProxyDataItem") != m.end() && !m["PushProxyDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["PushProxyDataItem"].type()) {
        vector<DescribeLivePushProxyUsageDataResponseBodyPushProxyDataPushProxyDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PushProxyDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLivePushProxyUsageDataResponseBodyPushProxyDataPushProxyDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pushProxyDataItem = make_shared<vector<DescribeLivePushProxyUsageDataResponseBodyPushProxyDataPushProxyDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeLivePushProxyUsageDataResponseBodyPushProxyData() = default;
};
class DescribeLivePushProxyUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<DescribeLivePushProxyUsageDataResponseBodyPushProxyData> pushProxyData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLivePushProxyUsageDataResponseBody() {}

  explicit DescribeLivePushProxyUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pushProxyData) {
      res["PushProxyData"] = pushProxyData ? boost::any(pushProxyData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PushProxyData") != m.end() && !m["PushProxyData"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushProxyData"].type()) {
        DescribeLivePushProxyUsageDataResponseBodyPushProxyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushProxyData"]));
        pushProxyData = make_shared<DescribeLivePushProxyUsageDataResponseBodyPushProxyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLivePushProxyUsageDataResponseBody() = default;
};
class DescribeLivePushProxyUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLivePushProxyUsageDataResponseBody> body{};

  DescribeLivePushProxyUsageDataResponse() {}

  explicit DescribeLivePushProxyUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLivePushProxyUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLivePushProxyUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLivePushProxyUsageDataResponse() = default;
};
class DescribeLiveRealtimeDeliveryAccRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> logStore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveRealtimeDeliveryAccRequest() {}

  explicit DescribeLiveRealtimeDeliveryAccRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (logStore) {
      res["LogStore"] = boost::any(*logStore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("LogStore") != m.end() && !m["LogStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["LogStore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveRealtimeDeliveryAccRequest() = default;
};
class DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData : public Darabonba::Model {
public:
  shared_ptr<long> failedNum{};
  shared_ptr<long> successNum{};
  shared_ptr<string> timeStamp{};

  DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData() {}

  explicit DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedNum) {
      res["FailedNum"] = boost::any(*failedNum);
    }
    if (successNum) {
      res["SuccessNum"] = boost::any(*successNum);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedNum") != m.end() && !m["FailedNum"].empty()) {
      failedNum = make_shared<long>(boost::any_cast<long>(m["FailedNum"]));
    }
    if (m.find("SuccessNum") != m.end() && !m["SuccessNum"].empty()) {
      successNum = make_shared<long>(boost::any_cast<long>(m["SuccessNum"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData() = default;
};
class DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData>> accData{};

  DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData() {}

  explicit DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accData) {
      vector<boost::any> temp1;
      for(auto item1:*accData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccData") != m.end() && !m["AccData"].empty()) {
      if (typeid(vector<boost::any>) == m["AccData"].type()) {
        vector<DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accData = make_shared<vector<DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccDataAccData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData() = default;
};
class DescribeLiveRealtimeDeliveryAccResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData> realTimeDeliveryAccData{};
  shared_ptr<string> requestId{};

  DescribeLiveRealtimeDeliveryAccResponseBody() {}

  explicit DescribeLiveRealtimeDeliveryAccResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeDeliveryAccData) {
      res["RealTimeDeliveryAccData"] = realTimeDeliveryAccData ? boost::any(realTimeDeliveryAccData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeDeliveryAccData") != m.end() && !m["RealTimeDeliveryAccData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeDeliveryAccData"].type()) {
        DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeDeliveryAccData"]));
        realTimeDeliveryAccData = make_shared<DescribeLiveRealtimeDeliveryAccResponseBodyRealTimeDeliveryAccData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveRealtimeDeliveryAccResponseBody() = default;
};
class DescribeLiveRealtimeDeliveryAccResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveRealtimeDeliveryAccResponseBody> body{};

  DescribeLiveRealtimeDeliveryAccResponse() {}

  explicit DescribeLiveRealtimeDeliveryAccResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveRealtimeDeliveryAccResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveRealtimeDeliveryAccResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveRealtimeDeliveryAccResponse() = default;
};
class DescribeLiveRealtimeLogAuthorizedRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveOpenapiReserve{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveRealtimeLogAuthorizedRequest() {}

  explicit DescribeLiveRealtimeLogAuthorizedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveOpenapiReserve) {
      res["LiveOpenapiReserve"] = boost::any(*liveOpenapiReserve);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveOpenapiReserve") != m.end() && !m["LiveOpenapiReserve"].empty()) {
      liveOpenapiReserve = make_shared<string>(boost::any_cast<string>(m["LiveOpenapiReserve"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveRealtimeLogAuthorizedRequest() = default;
};
class DescribeLiveRealtimeLogAuthorizedResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> authorizedStatus{};
  shared_ptr<string> requestId{};

  DescribeLiveRealtimeLogAuthorizedResponseBody() {}

  explicit DescribeLiveRealtimeLogAuthorizedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedStatus) {
      res["AuthorizedStatus"] = boost::any(*authorizedStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedStatus") != m.end() && !m["AuthorizedStatus"].empty()) {
      authorizedStatus = make_shared<string>(boost::any_cast<string>(m["AuthorizedStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveRealtimeLogAuthorizedResponseBody() = default;
};
class DescribeLiveRealtimeLogAuthorizedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveRealtimeLogAuthorizedResponseBody> body{};

  DescribeLiveRealtimeLogAuthorizedResponse() {}

  explicit DescribeLiveRealtimeLogAuthorizedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveRealtimeLogAuthorizedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveRealtimeLogAuthorizedResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveRealtimeLogAuthorizedResponse() = default;
};
class DescribeLiveRecordConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> streamName{};

  DescribeLiveRecordConfigRequest() {}

  explicit DescribeLiveRecordConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveRecordConfigRequest() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat>> recordFormat{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatListRecordFormat>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat>> recordFormat{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatListRecordFormat>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<string>> templates{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templates) {
      res["Templates"] = boost::any(*templates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Templates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Templates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      templates = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> createTime{};
  shared_ptr<long> delayTime{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> onDemond{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList> recordFormatList{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList> transcodeRecordFormatList{};
  shared_ptr<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates> transcodeTemplates{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (delayTime) {
      res["DelayTime"] = boost::any(*delayTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (onDemond) {
      res["OnDemond"] = boost::any(*onDemond);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (recordFormatList) {
      res["RecordFormatList"] = recordFormatList ? boost::any(recordFormatList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transcodeRecordFormatList) {
      res["TranscodeRecordFormatList"] = transcodeRecordFormatList ? boost::any(transcodeRecordFormatList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transcodeTemplates) {
      res["TranscodeTemplates"] = transcodeTemplates ? boost::any(transcodeTemplates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DelayTime") != m.end() && !m["DelayTime"].empty()) {
      delayTime = make_shared<long>(boost::any_cast<long>(m["DelayTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OnDemond") != m.end() && !m["OnDemond"].empty()) {
      onDemond = make_shared<long>(boost::any_cast<long>(m["OnDemond"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("RecordFormatList") != m.end() && !m["RecordFormatList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordFormatList"].type()) {
        DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordFormatList"]));
        recordFormatList = make_shared<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordRecordFormatList>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TranscodeRecordFormatList") != m.end() && !m["TranscodeRecordFormatList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeRecordFormatList"].type()) {
        DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeRecordFormatList"]));
        transcodeRecordFormatList = make_shared<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeRecordFormatList>(model1);
      }
    }
    if (m.find("TranscodeTemplates") != m.end() && !m["TranscodeTemplates"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeTemplates"].type()) {
        DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeTemplates"]));
        transcodeTemplates = make_shared<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecordTranscodeTemplates>(model1);
      }
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord() = default;
};
class DescribeLiveRecordConfigResponseBodyLiveAppRecordList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord>> liveAppRecord{};

  DescribeLiveRecordConfigResponseBodyLiveAppRecordList() {}

  explicit DescribeLiveRecordConfigResponseBodyLiveAppRecordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAppRecord) {
      vector<boost::any> temp1;
      for(auto item1:*liveAppRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveAppRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAppRecord") != m.end() && !m["LiveAppRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveAppRecord"].type()) {
        vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveAppRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveAppRecord = make_shared<vector<DescribeLiveRecordConfigResponseBodyLiveAppRecordListLiveAppRecord>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBodyLiveAppRecordList() = default;
};
class DescribeLiveRecordConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveRecordConfigResponseBodyLiveAppRecordList> liveAppRecordList{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveRecordConfigResponseBody() {}

  explicit DescribeLiveRecordConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAppRecordList) {
      res["LiveAppRecordList"] = liveAppRecordList ? boost::any(liveAppRecordList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAppRecordList") != m.end() && !m["LiveAppRecordList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveAppRecordList"].type()) {
        DescribeLiveRecordConfigResponseBodyLiveAppRecordList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveAppRecordList"]));
        liveAppRecordList = make_shared<DescribeLiveRecordConfigResponseBodyLiveAppRecordList>(model1);
      }
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveRecordConfigResponseBody() = default;
};
class DescribeLiveRecordConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveRecordConfigResponseBody> body{};

  DescribeLiveRecordConfigResponse() {}

  explicit DescribeLiveRecordConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveRecordConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveRecordConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveRecordConfigResponse() = default;
};
class DescribeLiveRecordNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeLiveRecordNotifyConfigRequest() {}

  explicit DescribeLiveRecordNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveRecordNotifyConfigRequest() = default;
};
class DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<bool> needStatusNotify{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> onDemandUrl{};

  DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig() {}

  explicit DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (needStatusNotify) {
      res["NeedStatusNotify"] = boost::any(*needStatusNotify);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (onDemandUrl) {
      res["OnDemandUrl"] = boost::any(*onDemandUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NeedStatusNotify") != m.end() && !m["NeedStatusNotify"].empty()) {
      needStatusNotify = make_shared<bool>(boost::any_cast<bool>(m["NeedStatusNotify"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OnDemandUrl") != m.end() && !m["OnDemandUrl"].empty()) {
      onDemandUrl = make_shared<string>(boost::any_cast<string>(m["OnDemandUrl"]));
    }
  }


  virtual ~DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig() = default;
};
class DescribeLiveRecordNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig> liveRecordNotifyConfig{};
  shared_ptr<string> requestId{};

  DescribeLiveRecordNotifyConfigResponseBody() {}

  explicit DescribeLiveRecordNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveRecordNotifyConfig) {
      res["LiveRecordNotifyConfig"] = liveRecordNotifyConfig ? boost::any(liveRecordNotifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveRecordNotifyConfig") != m.end() && !m["LiveRecordNotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveRecordNotifyConfig"].type()) {
        DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveRecordNotifyConfig"]));
        liveRecordNotifyConfig = make_shared<DescribeLiveRecordNotifyConfigResponseBodyLiveRecordNotifyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveRecordNotifyConfigResponseBody() = default;
};
class DescribeLiveRecordNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveRecordNotifyConfigResponseBody> body{};

  DescribeLiveRecordNotifyConfigResponse() {}

  explicit DescribeLiveRecordNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveRecordNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveRecordNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveRecordNotifyConfigResponse() = default;
};
class DescribeLiveRecordNotifyRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> streamName{};

  DescribeLiveRecordNotifyRecordsRequest() {}

  explicit DescribeLiveRecordNotifyRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveRecordNotifyRecordsRequest() = default;
};
class DescribeLiveRecordNotifyRecordsResponseBodyCallbackList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyContent{};
  shared_ptr<string> notifyResult{};
  shared_ptr<string> notifyTime{};
  shared_ptr<string> notifyType{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> streamName{};

  DescribeLiveRecordNotifyRecordsResponseBodyCallbackList() {}

  explicit DescribeLiveRecordNotifyRecordsResponseBodyCallbackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyContent) {
      res["NotifyContent"] = boost::any(*notifyContent);
    }
    if (notifyResult) {
      res["NotifyResult"] = boost::any(*notifyResult);
    }
    if (notifyTime) {
      res["NotifyTime"] = boost::any(*notifyTime);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyContent") != m.end() && !m["NotifyContent"].empty()) {
      notifyContent = make_shared<string>(boost::any_cast<string>(m["NotifyContent"]));
    }
    if (m.find("NotifyResult") != m.end() && !m["NotifyResult"].empty()) {
      notifyResult = make_shared<string>(boost::any_cast<string>(m["NotifyResult"]));
    }
    if (m.find("NotifyTime") != m.end() && !m["NotifyTime"].empty()) {
      notifyTime = make_shared<string>(boost::any_cast<string>(m["NotifyTime"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveRecordNotifyRecordsResponseBodyCallbackList() = default;
};
class DescribeLiveRecordNotifyRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveRecordNotifyRecordsResponseBodyCallbackList>> callbackList{};
  shared_ptr<long> code{};
  shared_ptr<string> msg{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveRecordNotifyRecordsResponseBody() {}

  explicit DescribeLiveRecordNotifyRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackList) {
      vector<boost::any> temp1;
      for(auto item1:*callbackList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CallbackList"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackList") != m.end() && !m["CallbackList"].empty()) {
      if (typeid(vector<boost::any>) == m["CallbackList"].type()) {
        vector<DescribeLiveRecordNotifyRecordsResponseBodyCallbackList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CallbackList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveRecordNotifyRecordsResponseBodyCallbackList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        callbackList = make_shared<vector<DescribeLiveRecordNotifyRecordsResponseBodyCallbackList>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveRecordNotifyRecordsResponseBody() = default;
};
class DescribeLiveRecordNotifyRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveRecordNotifyRecordsResponseBody> body{};

  DescribeLiveRecordNotifyRecordsResponse() {}

  explicit DescribeLiveRecordNotifyRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveRecordNotifyRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveRecordNotifyRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveRecordNotifyRecordsResponse() = default;
};
class DescribeLiveRecordVodConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DescribeLiveRecordVodConfigsRequest() {}

  explicit DescribeLiveRecordVodConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveRecordVodConfigsRequest() = default;
};
class DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> autoCompose{};
  shared_ptr<string> composeVodTranscodeGroupId{};
  shared_ptr<string> createTime{};
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> domainName{};
  shared_ptr<long> onDemand{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> streamName{};
  shared_ptr<string> vodTranscodeGroupId{};

  DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig() {}

  explicit DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (autoCompose) {
      res["AutoCompose"] = boost::any(*autoCompose);
    }
    if (composeVodTranscodeGroupId) {
      res["ComposeVodTranscodeGroupId"] = boost::any(*composeVodTranscodeGroupId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (onDemand) {
      res["OnDemand"] = boost::any(*onDemand);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (vodTranscodeGroupId) {
      res["VodTranscodeGroupId"] = boost::any(*vodTranscodeGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AutoCompose") != m.end() && !m["AutoCompose"].empty()) {
      autoCompose = make_shared<string>(boost::any_cast<string>(m["AutoCompose"]));
    }
    if (m.find("ComposeVodTranscodeGroupId") != m.end() && !m["ComposeVodTranscodeGroupId"].empty()) {
      composeVodTranscodeGroupId = make_shared<string>(boost::any_cast<string>(m["ComposeVodTranscodeGroupId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OnDemand") != m.end() && !m["OnDemand"].empty()) {
      onDemand = make_shared<long>(boost::any_cast<long>(m["OnDemand"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("VodTranscodeGroupId") != m.end() && !m["VodTranscodeGroupId"].empty()) {
      vodTranscodeGroupId = make_shared<string>(boost::any_cast<string>(m["VodTranscodeGroupId"]));
    }
  }


  virtual ~DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig() = default;
};
class DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig>> liveRecordVodConfig{};

  DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs() {}

  explicit DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveRecordVodConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveRecordVodConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveRecordVodConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveRecordVodConfig") != m.end() && !m["LiveRecordVodConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveRecordVodConfig"].type()) {
        vector<DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveRecordVodConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveRecordVodConfig = make_shared<vector<DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigsLiveRecordVodConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs() = default;
};
class DescribeLiveRecordVodConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs> liveRecordVodConfigs{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> total{};

  DescribeLiveRecordVodConfigsResponseBody() {}

  explicit DescribeLiveRecordVodConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveRecordVodConfigs) {
      res["LiveRecordVodConfigs"] = liveRecordVodConfigs ? boost::any(liveRecordVodConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveRecordVodConfigs") != m.end() && !m["LiveRecordVodConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveRecordVodConfigs"].type()) {
        DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveRecordVodConfigs"]));
        liveRecordVodConfigs = make_shared<DescribeLiveRecordVodConfigsResponseBodyLiveRecordVodConfigs>(model1);
      }
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["Total"]));
    }
  }


  virtual ~DescribeLiveRecordVodConfigsResponseBody() = default;
};
class DescribeLiveRecordVodConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveRecordVodConfigsResponseBody> body{};

  DescribeLiveRecordVodConfigsResponse() {}

  explicit DescribeLiveRecordVodConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveRecordVodConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveRecordVodConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveRecordVodConfigsResponse() = default;
};
class DescribeLiveShiftConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveShiftConfigsRequest() {}

  explicit DescribeLiveShiftConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveShiftConfigsRequest() = default;
};
class DescribeLiveShiftConfigsResponseBodyContentConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<bool> ignoreTranscode{};
  shared_ptr<string> streamName{};
  shared_ptr<long> vision{};

  DescribeLiveShiftConfigsResponseBodyContentConfig() {}

  explicit DescribeLiveShiftConfigsResponseBodyContentConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ignoreTranscode) {
      res["IgnoreTranscode"] = boost::any(*ignoreTranscode);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (vision) {
      res["Vision"] = boost::any(*vision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IgnoreTranscode") != m.end() && !m["IgnoreTranscode"].empty()) {
      ignoreTranscode = make_shared<bool>(boost::any_cast<bool>(m["IgnoreTranscode"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Vision") != m.end() && !m["Vision"].empty()) {
      vision = make_shared<long>(boost::any_cast<long>(m["Vision"]));
    }
  }


  virtual ~DescribeLiveShiftConfigsResponseBodyContentConfig() = default;
};
class DescribeLiveShiftConfigsResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveShiftConfigsResponseBodyContentConfig>> config{};

  DescribeLiveShiftConfigsResponseBodyContent() {}

  explicit DescribeLiveShiftConfigsResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<DescribeLiveShiftConfigsResponseBodyContentConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveShiftConfigsResponseBodyContentConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<DescribeLiveShiftConfigsResponseBodyContentConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveShiftConfigsResponseBodyContent() = default;
};
class DescribeLiveShiftConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveShiftConfigsResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  DescribeLiveShiftConfigsResponseBody() {}

  explicit DescribeLiveShiftConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        DescribeLiveShiftConfigsResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<DescribeLiveShiftConfigsResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveShiftConfigsResponseBody() = default;
};
class DescribeLiveShiftConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveShiftConfigsResponseBody> body{};

  DescribeLiveShiftConfigsResponse() {}

  explicit DescribeLiveShiftConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveShiftConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveShiftConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveShiftConfigsResponse() = default;
};
class DescribeLiveSnapshotConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeLiveSnapshotConfigRequest() {}

  explicit DescribeLiveSnapshotConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveSnapshotConfigRequest() = default;
};
class DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> callback{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> overwriteOssObject{};
  shared_ptr<string> sequenceOssObject{};
  shared_ptr<long> timeInterval{};

  DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig() {}

  explicit DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (overwriteOssObject) {
      res["OverwriteOssObject"] = boost::any(*overwriteOssObject);
    }
    if (sequenceOssObject) {
      res["SequenceOssObject"] = boost::any(*sequenceOssObject);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OverwriteOssObject") != m.end() && !m["OverwriteOssObject"].empty()) {
      overwriteOssObject = make_shared<string>(boost::any_cast<string>(m["OverwriteOssObject"]));
    }
    if (m.find("SequenceOssObject") != m.end() && !m["SequenceOssObject"].empty()) {
      sequenceOssObject = make_shared<string>(boost::any_cast<string>(m["SequenceOssObject"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig() = default;
};
class DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig>> liveStreamSnapshotConfig{};

  DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList() {}

  explicit DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamSnapshotConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamSnapshotConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamSnapshotConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamSnapshotConfig") != m.end() && !m["LiveStreamSnapshotConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamSnapshotConfig"].type()) {
        vector<DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamSnapshotConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamSnapshotConfig = make_shared<vector<DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigListLiveStreamSnapshotConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList() = default;
};
class DescribeLiveSnapshotConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList> liveStreamSnapshotConfigList{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveSnapshotConfigResponseBody() {}

  explicit DescribeLiveSnapshotConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamSnapshotConfigList) {
      res["LiveStreamSnapshotConfigList"] = liveStreamSnapshotConfigList ? boost::any(liveStreamSnapshotConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamSnapshotConfigList") != m.end() && !m["LiveStreamSnapshotConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamSnapshotConfigList"].type()) {
        DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamSnapshotConfigList"]));
        liveStreamSnapshotConfigList = make_shared<DescribeLiveSnapshotConfigResponseBodyLiveStreamSnapshotConfigList>(model1);
      }
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveSnapshotConfigResponseBody() = default;
};
class DescribeLiveSnapshotConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveSnapshotConfigResponseBody> body{};

  DescribeLiveSnapshotConfigResponse() {}

  explicit DescribeLiveSnapshotConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveSnapshotConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveSnapshotConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotConfigResponse() = default;
};
class DescribeLiveSnapshotDetectPornConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeLiveSnapshotDetectPornConfigRequest() {}

  explicit DescribeLiveSnapshotDetectPornConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigRequest() = default;
};
class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> scene{};

  DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes() {}

  explicit DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["scene"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["scene"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scene = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes() = default;
};
class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> interval{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes> scenes{};

  DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig() {}

  explicit DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (scenes) {
      res["Scenes"] = scenes ? boost::any(scenes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("Scenes") != m.end() && !m["Scenes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scenes"].type()) {
        DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scenes"]));
        scenes = make_shared<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfigScenes>(model1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig() = default;
};
class DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig>> liveSnapshotDetectPornConfig{};

  DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList() {}

  explicit DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveSnapshotDetectPornConfig) {
      vector<boost::any> temp1;
      for(auto item1:*liveSnapshotDetectPornConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveSnapshotDetectPornConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveSnapshotDetectPornConfig") != m.end() && !m["LiveSnapshotDetectPornConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveSnapshotDetectPornConfig"].type()) {
        vector<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveSnapshotDetectPornConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveSnapshotDetectPornConfig = make_shared<vector<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigListLiveSnapshotDetectPornConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList() = default;
};
class DescribeLiveSnapshotDetectPornConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList> liveSnapshotDetectPornConfigList{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveSnapshotDetectPornConfigResponseBody() {}

  explicit DescribeLiveSnapshotDetectPornConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveSnapshotDetectPornConfigList) {
      res["LiveSnapshotDetectPornConfigList"] = liveSnapshotDetectPornConfigList ? boost::any(liveSnapshotDetectPornConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveSnapshotDetectPornConfigList") != m.end() && !m["LiveSnapshotDetectPornConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveSnapshotDetectPornConfigList"].type()) {
        DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveSnapshotDetectPornConfigList"]));
        liveSnapshotDetectPornConfigList = make_shared<DescribeLiveSnapshotDetectPornConfigResponseBodyLiveSnapshotDetectPornConfigList>(model1);
      }
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigResponseBody() = default;
};
class DescribeLiveSnapshotDetectPornConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveSnapshotDetectPornConfigResponseBody> body{};

  DescribeLiveSnapshotDetectPornConfigResponse() {}

  explicit DescribeLiveSnapshotDetectPornConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveSnapshotDetectPornConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveSnapshotDetectPornConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotDetectPornConfigResponse() = default;
};
class DescribeLiveSnapshotNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveSnapshotNotifyConfigRequest() {}

  explicit DescribeLiveSnapshotNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveSnapshotNotifyConfigRequest() = default;
};
class DescribeLiveSnapshotNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyAuthKey{};
  shared_ptr<string> notifyReqAuth{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> requestId{};

  DescribeLiveSnapshotNotifyConfigResponseBody() {}

  explicit DescribeLiveSnapshotNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyAuthKey) {
      res["NotifyAuthKey"] = boost::any(*notifyAuthKey);
    }
    if (notifyReqAuth) {
      res["NotifyReqAuth"] = boost::any(*notifyReqAuth);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyAuthKey") != m.end() && !m["NotifyAuthKey"].empty()) {
      notifyAuthKey = make_shared<string>(boost::any_cast<string>(m["NotifyAuthKey"]));
    }
    if (m.find("NotifyReqAuth") != m.end() && !m["NotifyReqAuth"].empty()) {
      notifyReqAuth = make_shared<string>(boost::any_cast<string>(m["NotifyReqAuth"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveSnapshotNotifyConfigResponseBody() = default;
};
class DescribeLiveSnapshotNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveSnapshotNotifyConfigResponseBody> body{};

  DescribeLiveSnapshotNotifyConfigResponse() {}

  explicit DescribeLiveSnapshotNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveSnapshotNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveSnapshotNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveSnapshotNotifyConfigResponse() = default;
};
class DescribeLiveStreamAuthCheckingRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> url{};

  DescribeLiveStreamAuthCheckingRequest() {}

  explicit DescribeLiveStreamAuthCheckingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeLiveStreamAuthCheckingRequest() = default;
};
class DescribeLiveStreamAuthCheckingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeLiveStreamAuthCheckingResponseBody() {}

  explicit DescribeLiveStreamAuthCheckingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeLiveStreamAuthCheckingResponseBody() = default;
};
class DescribeLiveStreamAuthCheckingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamAuthCheckingResponseBody> body{};

  DescribeLiveStreamAuthCheckingResponse() {}

  explicit DescribeLiveStreamAuthCheckingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamAuthCheckingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamAuthCheckingResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamAuthCheckingResponse() = default;
};
class DescribeLiveStreamBitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamBitRateDataRequest() {}

  explicit DescribeLiveStreamBitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamBitRateDataRequest() = default;
};
class DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo : public Darabonba::Model {
public:
  shared_ptr<double> audioFrameRate{};
  shared_ptr<double> bitRate{};
  shared_ptr<string> streamUrl{};
  shared_ptr<string> time{};
  shared_ptr<double> videoFrameRate{};

  DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo() {}

  explicit DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFrameRate) {
      res["AudioFrameRate"] = boost::any(*audioFrameRate);
    }
    if (bitRate) {
      res["BitRate"] = boost::any(*bitRate);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (videoFrameRate) {
      res["VideoFrameRate"] = boost::any(*videoFrameRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFrameRate") != m.end() && !m["AudioFrameRate"].empty()) {
      audioFrameRate = make_shared<double>(boost::any_cast<double>(m["AudioFrameRate"]));
    }
    if (m.find("BitRate") != m.end() && !m["BitRate"].empty()) {
      bitRate = make_shared<double>(boost::any_cast<double>(m["BitRate"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("VideoFrameRate") != m.end() && !m["VideoFrameRate"].empty()) {
      videoFrameRate = make_shared<double>(boost::any_cast<double>(m["VideoFrameRate"]));
    }
  }


  virtual ~DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo() = default;
};
class DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo>> frameRateAndBitRateInfo{};

  DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos() {}

  explicit DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameRateAndBitRateInfo) {
      vector<boost::any> temp1;
      for(auto item1:*frameRateAndBitRateInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrameRateAndBitRateInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameRateAndBitRateInfo") != m.end() && !m["FrameRateAndBitRateInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["FrameRateAndBitRateInfo"].type()) {
        vector<DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrameRateAndBitRateInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frameRateAndBitRateInfo = make_shared<vector<DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfosFrameRateAndBitRateInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos() = default;
};
class DescribeLiveStreamBitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos> frameRateAndBitRateInfos{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamBitRateDataResponseBody() {}

  explicit DescribeLiveStreamBitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameRateAndBitRateInfos) {
      res["FrameRateAndBitRateInfos"] = frameRateAndBitRateInfos ? boost::any(frameRateAndBitRateInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameRateAndBitRateInfos") != m.end() && !m["FrameRateAndBitRateInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["FrameRateAndBitRateInfos"].type()) {
        DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FrameRateAndBitRateInfos"]));
        frameRateAndBitRateInfos = make_shared<DescribeLiveStreamBitRateDataResponseBodyFrameRateAndBitRateInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamBitRateDataResponseBody() = default;
};
class DescribeLiveStreamBitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamBitRateDataResponseBody> body{};

  DescribeLiveStreamBitRateDataResponse() {}

  explicit DescribeLiveStreamBitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamBitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamBitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamBitRateDataResponse() = default;
};
class DescribeLiveStreamCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveStreamCountRequest() {}

  explicit DescribeLiveStreamCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveStreamCountRequest() = default;
};
class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> format{};
  shared_ptr<long> videoDataRate{};

  DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail() {}

  explicit DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (videoDataRate) {
      res["VideoDataRate"] = boost::any(*videoDataRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("VideoDataRate") != m.end() && !m["VideoDataRate"].empty()) {
      videoDataRate = make_shared<long>(boost::any_cast<long>(m["VideoDataRate"]));
    }
  }


  virtual ~DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail() = default;
};
class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail>> streamCountDetail{};

  DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails() {}

  explicit DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamCountDetail) {
      vector<boost::any> temp1;
      for(auto item1:*streamCountDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamCountDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamCountDetail") != m.end() && !m["StreamCountDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamCountDetail"].type()) {
        vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamCountDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamCountDetail = make_shared<vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetailsStreamCountDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails() = default;
};
class DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> limit{};
  shared_ptr<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails> streamCountDetails{};
  shared_ptr<string> type{};

  DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo() {}

  explicit DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (streamCountDetails) {
      res["StreamCountDetails"] = streamCountDetails ? boost::any(streamCountDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("StreamCountDetails") != m.end() && !m["StreamCountDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamCountDetails"].type()) {
        DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamCountDetails"]));
        streamCountDetails = make_shared<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfoStreamCountDetails>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo() = default;
};
class DescribeLiveStreamCountResponseBodyStreamCountInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo>> streamCountInfo{};

  DescribeLiveStreamCountResponseBodyStreamCountInfos() {}

  explicit DescribeLiveStreamCountResponseBodyStreamCountInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamCountInfo) {
      vector<boost::any> temp1;
      for(auto item1:*streamCountInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamCountInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamCountInfo") != m.end() && !m["StreamCountInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamCountInfo"].type()) {
        vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamCountInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamCountInfo = make_shared<vector<DescribeLiveStreamCountResponseBodyStreamCountInfosStreamCountInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamCountResponseBodyStreamCountInfos() = default;
};
class DescribeLiveStreamCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveStreamCountResponseBodyStreamCountInfos> streamCountInfos{};

  DescribeLiveStreamCountResponseBody() {}

  explicit DescribeLiveStreamCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamCountInfos) {
      res["StreamCountInfos"] = streamCountInfos ? boost::any(streamCountInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamCountInfos") != m.end() && !m["StreamCountInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamCountInfos"].type()) {
        DescribeLiveStreamCountResponseBodyStreamCountInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamCountInfos"]));
        streamCountInfos = make_shared<DescribeLiveStreamCountResponseBodyStreamCountInfos>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamCountResponseBody() = default;
};
class DescribeLiveStreamCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamCountResponseBody> body{};

  DescribeLiveStreamCountResponse() {}

  explicit DescribeLiveStreamCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamCountResponse() = default;
};
class DescribeLiveStreamDelayConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveStreamDelayConfigRequest() {}

  explicit DescribeLiveStreamDelayConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveStreamDelayConfigRequest() = default;
};
class DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig : public Darabonba::Model {
public:
  shared_ptr<long> delay{};
  shared_ptr<string> level{};

  DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig() {}

  explicit DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig() = default;
};
class DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig : public Darabonba::Model {
public:
  shared_ptr<long> delay{};
  shared_ptr<string> level{};

  DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig() {}

  explicit DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig() = default;
};
class DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig : public Darabonba::Model {
public:
  shared_ptr<long> delay{};
  shared_ptr<string> level{};

  DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig() {}

  explicit DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig() = default;
};
class DescribeLiveStreamDelayConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig> liveStreamFlvDelayConfig{};
  shared_ptr<DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig> liveStreamHlsDelayConfig{};
  shared_ptr<DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig> liveStreamRtmpDelayConfig{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamDelayConfigResponseBody() {}

  explicit DescribeLiveStreamDelayConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamFlvDelayConfig) {
      res["LiveStreamFlvDelayConfig"] = liveStreamFlvDelayConfig ? boost::any(liveStreamFlvDelayConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (liveStreamHlsDelayConfig) {
      res["LiveStreamHlsDelayConfig"] = liveStreamHlsDelayConfig ? boost::any(liveStreamHlsDelayConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (liveStreamRtmpDelayConfig) {
      res["LiveStreamRtmpDelayConfig"] = liveStreamRtmpDelayConfig ? boost::any(liveStreamRtmpDelayConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamFlvDelayConfig") != m.end() && !m["LiveStreamFlvDelayConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamFlvDelayConfig"].type()) {
        DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamFlvDelayConfig"]));
        liveStreamFlvDelayConfig = make_shared<DescribeLiveStreamDelayConfigResponseBodyLiveStreamFlvDelayConfig>(model1);
      }
    }
    if (m.find("LiveStreamHlsDelayConfig") != m.end() && !m["LiveStreamHlsDelayConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamHlsDelayConfig"].type()) {
        DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamHlsDelayConfig"]));
        liveStreamHlsDelayConfig = make_shared<DescribeLiveStreamDelayConfigResponseBodyLiveStreamHlsDelayConfig>(model1);
      }
    }
    if (m.find("LiveStreamRtmpDelayConfig") != m.end() && !m["LiveStreamRtmpDelayConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamRtmpDelayConfig"].type()) {
        DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamRtmpDelayConfig"]));
        liveStreamRtmpDelayConfig = make_shared<DescribeLiveStreamDelayConfigResponseBodyLiveStreamRtmpDelayConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamDelayConfigResponseBody() = default;
};
class DescribeLiveStreamDelayConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamDelayConfigResponseBody> body{};

  DescribeLiveStreamDelayConfigResponse() {}

  explicit DescribeLiveStreamDelayConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamDelayConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamDelayConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamDelayConfigResponse() = default;
};
class DescribeLiveStreamDetailFrameRateAndBitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamDetailFrameRateAndBitRateDataRequest() {}

  explicit DescribeLiveStreamDetailFrameRateAndBitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamDetailFrameRateAndBitRateDataRequest() = default;
};
class DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos : public Darabonba::Model {
public:
  shared_ptr<double> audioBitRate{};
  shared_ptr<double> audioFrameRate{};
  shared_ptr<double> bitRate{};
  shared_ptr<string> streamUrl{};
  shared_ptr<string> time{};
  shared_ptr<double> videoBitRate{};
  shared_ptr<double> videoFrameRate{};

  DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos() {}

  explicit DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioBitRate) {
      res["AudioBitRate"] = boost::any(*audioBitRate);
    }
    if (audioFrameRate) {
      res["AudioFrameRate"] = boost::any(*audioFrameRate);
    }
    if (bitRate) {
      res["BitRate"] = boost::any(*bitRate);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (videoBitRate) {
      res["VideoBitRate"] = boost::any(*videoBitRate);
    }
    if (videoFrameRate) {
      res["VideoFrameRate"] = boost::any(*videoFrameRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioBitRate") != m.end() && !m["AudioBitRate"].empty()) {
      audioBitRate = make_shared<double>(boost::any_cast<double>(m["AudioBitRate"]));
    }
    if (m.find("AudioFrameRate") != m.end() && !m["AudioFrameRate"].empty()) {
      audioFrameRate = make_shared<double>(boost::any_cast<double>(m["AudioFrameRate"]));
    }
    if (m.find("BitRate") != m.end() && !m["BitRate"].empty()) {
      bitRate = make_shared<double>(boost::any_cast<double>(m["BitRate"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("VideoBitRate") != m.end() && !m["VideoBitRate"].empty()) {
      videoBitRate = make_shared<double>(boost::any_cast<double>(m["VideoBitRate"]));
    }
    if (m.find("VideoFrameRate") != m.end() && !m["VideoFrameRate"].empty()) {
      videoFrameRate = make_shared<double>(boost::any_cast<double>(m["VideoFrameRate"]));
    }
  }


  virtual ~DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos() = default;
};
class DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos>> frameRateAndBitRateInfos{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody() {}

  explicit DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameRateAndBitRateInfos) {
      vector<boost::any> temp1;
      for(auto item1:*frameRateAndBitRateInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrameRateAndBitRateInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameRateAndBitRateInfos") != m.end() && !m["FrameRateAndBitRateInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["FrameRateAndBitRateInfos"].type()) {
        vector<DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrameRateAndBitRateInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frameRateAndBitRateInfos = make_shared<vector<DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBodyFrameRateAndBitRateInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody() = default;
};
class DescribeLiveStreamDetailFrameRateAndBitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody> body{};

  DescribeLiveStreamDetailFrameRateAndBitRateDataResponse() {}

  explicit DescribeLiveStreamDetailFrameRateAndBitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamDetailFrameRateAndBitRateDataResponse() = default;
};
class DescribeLiveStreamHistoryUserNumRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamHistoryUserNumRequest() {}

  explicit DescribeLiveStreamHistoryUserNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamHistoryUserNumRequest() = default;
};
class DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo : public Darabonba::Model {
public:
  shared_ptr<string> streamTime{};
  shared_ptr<string> userNum{};

  DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo() {}

  explicit DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamTime) {
      res["StreamTime"] = boost::any(*streamTime);
    }
    if (userNum) {
      res["UserNum"] = boost::any(*userNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamTime") != m.end() && !m["StreamTime"].empty()) {
      streamTime = make_shared<string>(boost::any_cast<string>(m["StreamTime"]));
    }
    if (m.find("UserNum") != m.end() && !m["UserNum"].empty()) {
      userNum = make_shared<string>(boost::any_cast<string>(m["UserNum"]));
    }
  }


  virtual ~DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo() = default;
};
class DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo>> liveStreamUserNumInfo{};

  DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos() {}

  explicit DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamUserNumInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamUserNumInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamUserNumInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamUserNumInfo") != m.end() && !m["LiveStreamUserNumInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamUserNumInfo"].type()) {
        vector<DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamUserNumInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamUserNumInfo = make_shared<vector<DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfosLiveStreamUserNumInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos() = default;
};
class DescribeLiveStreamHistoryUserNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos> liveStreamUserNumInfos{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamHistoryUserNumResponseBody() {}

  explicit DescribeLiveStreamHistoryUserNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamUserNumInfos) {
      res["LiveStreamUserNumInfos"] = liveStreamUserNumInfos ? boost::any(liveStreamUserNumInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamUserNumInfos") != m.end() && !m["LiveStreamUserNumInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamUserNumInfos"].type()) {
        DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamUserNumInfos"]));
        liveStreamUserNumInfos = make_shared<DescribeLiveStreamHistoryUserNumResponseBodyLiveStreamUserNumInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamHistoryUserNumResponseBody() = default;
};
class DescribeLiveStreamHistoryUserNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamHistoryUserNumResponseBody> body{};

  DescribeLiveStreamHistoryUserNumResponse() {}

  explicit DescribeLiveStreamHistoryUserNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamHistoryUserNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamHistoryUserNumResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamHistoryUserNumResponse() = default;
};
class DescribeLiveStreamMergeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamMergeRequest() {}

  explicit DescribeLiveStreamMergeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamMergeRequest() = default;
};
class DescribeLiveStreamMergeResponseBodyLiveStreamMergeListLiveStreamMerge : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appUsing{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> extraInAppStreams{};
  shared_ptr<string> inAppName1{};
  shared_ptr<string> inAppName2{};
  shared_ptr<string> inStreamName1{};
  shared_ptr<string> inStreamName2{};
  shared_ptr<string> liveMerger{};
  shared_ptr<string> mergeParameters{};
  shared_ptr<string> protocol{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> streamUsing{};

  DescribeLiveStreamMergeResponseBodyLiveStreamMergeListLiveStreamMerge() {}

  explicit DescribeLiveStreamMergeResponseBodyLiveStreamMergeListLiveStreamMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appUsing) {
      res["AppUsing"] = boost::any(*appUsing);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (extraInAppStreams) {
      res["ExtraInAppStreams"] = boost::any(*extraInAppStreams);
    }
    if (inAppName1) {
      res["InAppName1"] = boost::any(*inAppName1);
    }
    if (inAppName2) {
      res["InAppName2"] = boost::any(*inAppName2);
    }
    if (inStreamName1) {
      res["InStreamName1"] = boost::any(*inStreamName1);
    }
    if (inStreamName2) {
      res["InStreamName2"] = boost::any(*inStreamName2);
    }
    if (liveMerger) {
      res["LiveMerger"] = boost::any(*liveMerger);
    }
    if (mergeParameters) {
      res["MergeParameters"] = boost::any(*mergeParameters);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streamUsing) {
      res["StreamUsing"] = boost::any(*streamUsing);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppUsing") != m.end() && !m["AppUsing"].empty()) {
      appUsing = make_shared<string>(boost::any_cast<string>(m["AppUsing"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExtraInAppStreams") != m.end() && !m["ExtraInAppStreams"].empty()) {
      extraInAppStreams = make_shared<string>(boost::any_cast<string>(m["ExtraInAppStreams"]));
    }
    if (m.find("InAppName1") != m.end() && !m["InAppName1"].empty()) {
      inAppName1 = make_shared<string>(boost::any_cast<string>(m["InAppName1"]));
    }
    if (m.find("InAppName2") != m.end() && !m["InAppName2"].empty()) {
      inAppName2 = make_shared<string>(boost::any_cast<string>(m["InAppName2"]));
    }
    if (m.find("InStreamName1") != m.end() && !m["InStreamName1"].empty()) {
      inStreamName1 = make_shared<string>(boost::any_cast<string>(m["InStreamName1"]));
    }
    if (m.find("InStreamName2") != m.end() && !m["InStreamName2"].empty()) {
      inStreamName2 = make_shared<string>(boost::any_cast<string>(m["InStreamName2"]));
    }
    if (m.find("LiveMerger") != m.end() && !m["LiveMerger"].empty()) {
      liveMerger = make_shared<string>(boost::any_cast<string>(m["LiveMerger"]));
    }
    if (m.find("MergeParameters") != m.end() && !m["MergeParameters"].empty()) {
      mergeParameters = make_shared<string>(boost::any_cast<string>(m["MergeParameters"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("StreamUsing") != m.end() && !m["StreamUsing"].empty()) {
      streamUsing = make_shared<string>(boost::any_cast<string>(m["StreamUsing"]));
    }
  }


  virtual ~DescribeLiveStreamMergeResponseBodyLiveStreamMergeListLiveStreamMerge() = default;
};
class DescribeLiveStreamMergeResponseBodyLiveStreamMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamMergeResponseBodyLiveStreamMergeListLiveStreamMerge>> liveStreamMerge{};

  DescribeLiveStreamMergeResponseBodyLiveStreamMergeList() {}

  explicit DescribeLiveStreamMergeResponseBodyLiveStreamMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamMerge) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamMerge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamMerge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamMerge") != m.end() && !m["LiveStreamMerge"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamMerge"].type()) {
        vector<DescribeLiveStreamMergeResponseBodyLiveStreamMergeListLiveStreamMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamMerge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamMergeResponseBodyLiveStreamMergeListLiveStreamMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamMerge = make_shared<vector<DescribeLiveStreamMergeResponseBodyLiveStreamMergeListLiveStreamMerge>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamMergeResponseBodyLiveStreamMergeList() = default;
};
class DescribeLiveStreamMergeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamMergeResponseBodyLiveStreamMergeList> liveStreamMergeList{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamMergeResponseBody() {}

  explicit DescribeLiveStreamMergeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamMergeList) {
      res["LiveStreamMergeList"] = liveStreamMergeList ? boost::any(liveStreamMergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamMergeList") != m.end() && !m["LiveStreamMergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamMergeList"].type()) {
        DescribeLiveStreamMergeResponseBodyLiveStreamMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamMergeList"]));
        liveStreamMergeList = make_shared<DescribeLiveStreamMergeResponseBodyLiveStreamMergeList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamMergeResponseBody() = default;
};
class DescribeLiveStreamMergeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamMergeResponseBody> body{};

  DescribeLiveStreamMergeResponse() {}

  explicit DescribeLiveStreamMergeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamMergeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamMergeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamMergeResponse() = default;
};
class DescribeLiveStreamMetricDetailDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamMetricDetailDataRequest() {}

  explicit DescribeLiveStreamMetricDetailDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamMetricDetailDataRequest() = default;
};
class DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<double> bps{};
  shared_ptr<long> count{};
  shared_ptr<double> flvBps{};
  shared_ptr<long> flvCount{};
  shared_ptr<long> flvTraffic{};
  shared_ptr<double> hlsBps{};
  shared_ptr<long> hlsCount{};
  shared_ptr<long> hlsTraffic{};
  shared_ptr<string> newConns{};
  shared_ptr<double> p2pBps{};
  shared_ptr<long> p2pCount{};
  shared_ptr<long> p2pTraffic{};
  shared_ptr<double> rtmpBps{};
  shared_ptr<long> rtmpCount{};
  shared_ptr<long> rtmpTraffic{};
  shared_ptr<double> rtsBps{};
  shared_ptr<long> rtsCount{};
  shared_ptr<long> rtsTraffic{};
  shared_ptr<string> streamName{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> traffic{};

  DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData() {}

  explicit DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (flvBps) {
      res["FlvBps"] = boost::any(*flvBps);
    }
    if (flvCount) {
      res["FlvCount"] = boost::any(*flvCount);
    }
    if (flvTraffic) {
      res["FlvTraffic"] = boost::any(*flvTraffic);
    }
    if (hlsBps) {
      res["HlsBps"] = boost::any(*hlsBps);
    }
    if (hlsCount) {
      res["HlsCount"] = boost::any(*hlsCount);
    }
    if (hlsTraffic) {
      res["HlsTraffic"] = boost::any(*hlsTraffic);
    }
    if (newConns) {
      res["NewConns"] = boost::any(*newConns);
    }
    if (p2pBps) {
      res["P2pBps"] = boost::any(*p2pBps);
    }
    if (p2pCount) {
      res["P2pCount"] = boost::any(*p2pCount);
    }
    if (p2pTraffic) {
      res["P2pTraffic"] = boost::any(*p2pTraffic);
    }
    if (rtmpBps) {
      res["RtmpBps"] = boost::any(*rtmpBps);
    }
    if (rtmpCount) {
      res["RtmpCount"] = boost::any(*rtmpCount);
    }
    if (rtmpTraffic) {
      res["RtmpTraffic"] = boost::any(*rtmpTraffic);
    }
    if (rtsBps) {
      res["RtsBps"] = boost::any(*rtsBps);
    }
    if (rtsCount) {
      res["RtsCount"] = boost::any(*rtsCount);
    }
    if (rtsTraffic) {
      res["RtsTraffic"] = boost::any(*rtsTraffic);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (traffic) {
      res["Traffic"] = boost::any(*traffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("FlvBps") != m.end() && !m["FlvBps"].empty()) {
      flvBps = make_shared<double>(boost::any_cast<double>(m["FlvBps"]));
    }
    if (m.find("FlvCount") != m.end() && !m["FlvCount"].empty()) {
      flvCount = make_shared<long>(boost::any_cast<long>(m["FlvCount"]));
    }
    if (m.find("FlvTraffic") != m.end() && !m["FlvTraffic"].empty()) {
      flvTraffic = make_shared<long>(boost::any_cast<long>(m["FlvTraffic"]));
    }
    if (m.find("HlsBps") != m.end() && !m["HlsBps"].empty()) {
      hlsBps = make_shared<double>(boost::any_cast<double>(m["HlsBps"]));
    }
    if (m.find("HlsCount") != m.end() && !m["HlsCount"].empty()) {
      hlsCount = make_shared<long>(boost::any_cast<long>(m["HlsCount"]));
    }
    if (m.find("HlsTraffic") != m.end() && !m["HlsTraffic"].empty()) {
      hlsTraffic = make_shared<long>(boost::any_cast<long>(m["HlsTraffic"]));
    }
    if (m.find("NewConns") != m.end() && !m["NewConns"].empty()) {
      newConns = make_shared<string>(boost::any_cast<string>(m["NewConns"]));
    }
    if (m.find("P2pBps") != m.end() && !m["P2pBps"].empty()) {
      p2pBps = make_shared<double>(boost::any_cast<double>(m["P2pBps"]));
    }
    if (m.find("P2pCount") != m.end() && !m["P2pCount"].empty()) {
      p2pCount = make_shared<long>(boost::any_cast<long>(m["P2pCount"]));
    }
    if (m.find("P2pTraffic") != m.end() && !m["P2pTraffic"].empty()) {
      p2pTraffic = make_shared<long>(boost::any_cast<long>(m["P2pTraffic"]));
    }
    if (m.find("RtmpBps") != m.end() && !m["RtmpBps"].empty()) {
      rtmpBps = make_shared<double>(boost::any_cast<double>(m["RtmpBps"]));
    }
    if (m.find("RtmpCount") != m.end() && !m["RtmpCount"].empty()) {
      rtmpCount = make_shared<long>(boost::any_cast<long>(m["RtmpCount"]));
    }
    if (m.find("RtmpTraffic") != m.end() && !m["RtmpTraffic"].empty()) {
      rtmpTraffic = make_shared<long>(boost::any_cast<long>(m["RtmpTraffic"]));
    }
    if (m.find("RtsBps") != m.end() && !m["RtsBps"].empty()) {
      rtsBps = make_shared<double>(boost::any_cast<double>(m["RtsBps"]));
    }
    if (m.find("RtsCount") != m.end() && !m["RtsCount"].empty()) {
      rtsCount = make_shared<long>(boost::any_cast<long>(m["RtsCount"]));
    }
    if (m.find("RtsTraffic") != m.end() && !m["RtsTraffic"].empty()) {
      rtsTraffic = make_shared<long>(boost::any_cast<long>(m["RtsTraffic"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Traffic") != m.end() && !m["Traffic"].empty()) {
      traffic = make_shared<long>(boost::any_cast<long>(m["Traffic"]));
    }
  }


  virtual ~DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData() = default;
};
class DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData>> streamData{};

  DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData() {}

  explicit DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamData) {
      vector<boost::any> temp1;
      for(auto item1:*streamData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamData") != m.end() && !m["StreamData"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamData"].type()) {
        vector<DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamData = make_shared<vector<DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailDataStreamData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData() = default;
};
class DescribeLiveStreamMetricDetailDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData> streamDetailData{};

  DescribeLiveStreamMetricDetailDataResponseBody() {}

  explicit DescribeLiveStreamMetricDetailDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamDetailData) {
      res["StreamDetailData"] = streamDetailData ? boost::any(streamDetailData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamDetailData") != m.end() && !m["StreamDetailData"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamDetailData"].type()) {
        DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamDetailData"]));
        streamDetailData = make_shared<DescribeLiveStreamMetricDetailDataResponseBodyStreamDetailData>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamMetricDetailDataResponseBody() = default;
};
class DescribeLiveStreamMetricDetailDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamMetricDetailDataResponseBody> body{};

  DescribeLiveStreamMetricDetailDataResponse() {}

  explicit DescribeLiveStreamMetricDetailDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamMetricDetailDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamMetricDetailDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamMetricDetailDataResponse() = default;
};
class DescribeLiveStreamMonitorListRequest : public Darabonba::Model {
public:
  shared_ptr<string> monitorId{};
  shared_ptr<long> orderRule{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> status{};

  DescribeLiveStreamMonitorListRequest() {}

  explicit DescribeLiveStreamMonitorListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (orderRule) {
      res["OrderRule"] = boost::any(*orderRule);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("OrderRule") != m.end() && !m["OrderRule"].empty()) {
      orderRule = make_shared<long>(boost::any_cast<long>(m["OrderRule"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListRequest() = default;
};
class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig : public Darabonba::Model {
public:
  shared_ptr<string> fillMode{};
  shared_ptr<vector<double>> positionNormalized{};
  shared_ptr<string> positionRefer{};
  shared_ptr<vector<double>> sizeNormalized{};

  DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig() {}

  explicit DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fillMode) {
      res["FillMode"] = boost::any(*fillMode);
    }
    if (positionNormalized) {
      res["PositionNormalized"] = boost::any(*positionNormalized);
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (sizeNormalized) {
      res["SizeNormalized"] = boost::any(*sizeNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FillMode") != m.end() && !m["FillMode"].empty()) {
      fillMode = make_shared<string>(boost::any_cast<string>(m["FillMode"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["PositionNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PositionNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      positionNormalized = make_shared<vector<double>>(toVec1);
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("SizeNormalized") != m.end() && !m["SizeNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["SizeNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SizeNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      sizeNormalized = make_shared<vector<double>>(toVec1);
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig() = default;
};
class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig : public Darabonba::Model {
public:
  shared_ptr<double> volumeRate{};

  DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig() {}

  explicit DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig() = default;
};
class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<string> inputUrl{};
  shared_ptr<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig> layoutConfig{};
  shared_ptr<long> layoutId{};
  shared_ptr<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig> playConfig{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList() {}

  explicit DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (layoutConfig) {
      res["LayoutConfig"] = layoutConfig ? boost::any(layoutConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (playConfig) {
      res["PlayConfig"] = playConfig ? boost::any(playConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("LayoutConfig") != m.end() && !m["LayoutConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LayoutConfig"].type()) {
        DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LayoutConfig"]));
        layoutConfig = make_shared<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListLayoutConfig>(model1);
      }
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<long>(boost::any_cast<long>(m["LayoutId"]));
    }
    if (m.find("PlayConfig") != m.end() && !m["PlayConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlayConfig"].type()) {
        DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlayConfig"]));
        playConfig = make_shared<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputListPlayConfig>(model1);
      }
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList() = default;
};
class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls : public Darabonba::Model {
public:
  shared_ptr<string> flvUrl{};
  shared_ptr<string> rtmpUrl{};

  DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls() {}

  explicit DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flvUrl) {
      res["FlvUrl"] = boost::any(*flvUrl);
    }
    if (rtmpUrl) {
      res["RtmpUrl"] = boost::any(*rtmpUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlvUrl") != m.end() && !m["FlvUrl"].empty()) {
      flvUrl = make_shared<string>(boost::any_cast<string>(m["FlvUrl"]));
    }
    if (m.find("RtmpUrl") != m.end() && !m["RtmpUrl"].empty()) {
      rtmpUrl = make_shared<string>(boost::any_cast<string>(m["RtmpUrl"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls() = default;
};
class DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList : public Darabonba::Model {
public:
  shared_ptr<long> audioFrom{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> dingTalkWebHookUrl{};
  shared_ptr<string> domain{};
  shared_ptr<vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList>> inputList{};
  shared_ptr<string> monitorConfig{};
  shared_ptr<string> monitorId{};
  shared_ptr<string> monitorName{};
  shared_ptr<string> outputTemplate{};
  shared_ptr<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls> outputUrls{};
  shared_ptr<string> region{};
  shared_ptr<string> startTime{};
  shared_ptr<long> status{};
  shared_ptr<string> stopTime{};

  DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList() {}

  explicit DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFrom) {
      res["AudioFrom"] = boost::any(*audioFrom);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (dingTalkWebHookUrl) {
      res["DingTalkWebHookUrl"] = boost::any(*dingTalkWebHookUrl);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (inputList) {
      vector<boost::any> temp1;
      for(auto item1:*inputList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputList"] = boost::any(temp1);
    }
    if (monitorConfig) {
      res["MonitorConfig"] = boost::any(*monitorConfig);
    }
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (monitorName) {
      res["MonitorName"] = boost::any(*monitorName);
    }
    if (outputTemplate) {
      res["OutputTemplate"] = boost::any(*outputTemplate);
    }
    if (outputUrls) {
      res["OutputUrls"] = outputUrls ? boost::any(outputUrls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFrom") != m.end() && !m["AudioFrom"].empty()) {
      audioFrom = make_shared<long>(boost::any_cast<long>(m["AudioFrom"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("DingTalkWebHookUrl") != m.end() && !m["DingTalkWebHookUrl"].empty()) {
      dingTalkWebHookUrl = make_shared<string>(boost::any_cast<string>(m["DingTalkWebHookUrl"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      if (typeid(vector<boost::any>) == m["InputList"].type()) {
        vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputList = make_shared<vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListInputList>>(expect1);
      }
    }
    if (m.find("MonitorConfig") != m.end() && !m["MonitorConfig"].empty()) {
      monitorConfig = make_shared<string>(boost::any_cast<string>(m["MonitorConfig"]));
    }
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("MonitorName") != m.end() && !m["MonitorName"].empty()) {
      monitorName = make_shared<string>(boost::any_cast<string>(m["MonitorName"]));
    }
    if (m.find("OutputTemplate") != m.end() && !m["OutputTemplate"].empty()) {
      outputTemplate = make_shared<string>(boost::any_cast<string>(m["OutputTemplate"]));
    }
    if (m.find("OutputUrls") != m.end() && !m["OutputUrls"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputUrls"].type()) {
        DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputUrls"]));
        outputUrls = make_shared<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorListOutputUrls>(model1);
      }
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["StopTime"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList() = default;
};
class DescribeLiveStreamMonitorListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList>> liveStreamMonitorList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeLiveStreamMonitorListResponseBody() {}

  explicit DescribeLiveStreamMonitorListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamMonitorList) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamMonitorList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamMonitorList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamMonitorList") != m.end() && !m["LiveStreamMonitorList"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamMonitorList"].type()) {
        vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamMonitorList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamMonitorList = make_shared<vector<DescribeLiveStreamMonitorListResponseBodyLiveStreamMonitorList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponseBody() = default;
};
class DescribeLiveStreamMonitorListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamMonitorListResponseBody> body{};

  DescribeLiveStreamMonitorListResponse() {}

  explicit DescribeLiveStreamMonitorListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamMonitorListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamMonitorListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamMonitorListResponse() = default;
};
class DescribeLiveStreamPreloadTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> playUrl{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeLiveStreamPreloadTasksRequest() {}

  explicit DescribeLiveStreamPreloadTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (playUrl) {
      res["PlayUrl"] = boost::any(*playUrl);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PlayUrl") != m.end() && !m["PlayUrl"].empty()) {
      playUrl = make_shared<string>(boost::any_cast<string>(m["PlayUrl"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeLiveStreamPreloadTasksRequest() = default;
};
class DescribeLiveStreamPreloadTasksResponseBodyPreloadTasksPreloadTask : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> playUrl{};
  shared_ptr<string> preloadedEndTime{};
  shared_ptr<string> preloadedStartTime{};
  shared_ptr<string> process{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeLiveStreamPreloadTasksResponseBodyPreloadTasksPreloadTask() {}

  explicit DescribeLiveStreamPreloadTasksResponseBodyPreloadTasksPreloadTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (playUrl) {
      res["PlayUrl"] = boost::any(*playUrl);
    }
    if (preloadedEndTime) {
      res["PreloadedEndTime"] = boost::any(*preloadedEndTime);
    }
    if (preloadedStartTime) {
      res["PreloadedStartTime"] = boost::any(*preloadedStartTime);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("PlayUrl") != m.end() && !m["PlayUrl"].empty()) {
      playUrl = make_shared<string>(boost::any_cast<string>(m["PlayUrl"]));
    }
    if (m.find("PreloadedEndTime") != m.end() && !m["PreloadedEndTime"].empty()) {
      preloadedEndTime = make_shared<string>(boost::any_cast<string>(m["PreloadedEndTime"]));
    }
    if (m.find("PreloadedStartTime") != m.end() && !m["PreloadedStartTime"].empty()) {
      preloadedStartTime = make_shared<string>(boost::any_cast<string>(m["PreloadedStartTime"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeLiveStreamPreloadTasksResponseBodyPreloadTasksPreloadTask() = default;
};
class DescribeLiveStreamPreloadTasksResponseBodyPreloadTasks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamPreloadTasksResponseBodyPreloadTasksPreloadTask>> preloadTask{};

  DescribeLiveStreamPreloadTasksResponseBodyPreloadTasks() {}

  explicit DescribeLiveStreamPreloadTasksResponseBodyPreloadTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTask) {
      vector<boost::any> temp1;
      for(auto item1:*preloadTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PreloadTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTask") != m.end() && !m["PreloadTask"].empty()) {
      if (typeid(vector<boost::any>) == m["PreloadTask"].type()) {
        vector<DescribeLiveStreamPreloadTasksResponseBodyPreloadTasksPreloadTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PreloadTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamPreloadTasksResponseBodyPreloadTasksPreloadTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preloadTask = make_shared<vector<DescribeLiveStreamPreloadTasksResponseBodyPreloadTasksPreloadTask>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamPreloadTasksResponseBodyPreloadTasks() = default;
};
class DescribeLiveStreamPreloadTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeLiveStreamPreloadTasksResponseBodyPreloadTasks> preloadTasks{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveStreamPreloadTasksResponseBody() {}

  explicit DescribeLiveStreamPreloadTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (preloadTasks) {
      res["PreloadTasks"] = preloadTasks ? boost::any(preloadTasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PreloadTasks") != m.end() && !m["PreloadTasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["PreloadTasks"].type()) {
        DescribeLiveStreamPreloadTasksResponseBodyPreloadTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PreloadTasks"]));
        preloadTasks = make_shared<DescribeLiveStreamPreloadTasksResponseBodyPreloadTasks>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveStreamPreloadTasksResponseBody() = default;
};
class DescribeLiveStreamPreloadTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamPreloadTasksResponseBody> body{};

  DescribeLiveStreamPreloadTasksResponse() {}

  explicit DescribeLiveStreamPreloadTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamPreloadTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamPreloadTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamPreloadTasksResponse() = default;
};
class DescribeLiveStreamPushMetricDetailDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamPushMetricDetailDataRequest() {}

  explicit DescribeLiveStreamPushMetricDetailDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamPushMetricDetailDataRequest() = default;
};
class DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailDataStreamData : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<double> reqBps{};
  shared_ptr<long> reqTraffic{};
  shared_ptr<string> streamName{};
  shared_ptr<string> timeStamp{};

  DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailDataStreamData() {}

  explicit DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailDataStreamData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (reqBps) {
      res["ReqBps"] = boost::any(*reqBps);
    }
    if (reqTraffic) {
      res["ReqTraffic"] = boost::any(*reqTraffic);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ReqBps") != m.end() && !m["ReqBps"].empty()) {
      reqBps = make_shared<double>(boost::any_cast<double>(m["ReqBps"]));
    }
    if (m.find("ReqTraffic") != m.end() && !m["ReqTraffic"].empty()) {
      reqTraffic = make_shared<long>(boost::any_cast<long>(m["ReqTraffic"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailDataStreamData() = default;
};
class DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailDataStreamData>> streamData{};

  DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailData() {}

  explicit DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamData) {
      vector<boost::any> temp1;
      for(auto item1:*streamData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamData") != m.end() && !m["StreamData"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamData"].type()) {
        vector<DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailDataStreamData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailDataStreamData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamData = make_shared<vector<DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailDataStreamData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailData() = default;
};
class DescribeLiveStreamPushMetricDetailDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailData> streamDetailData{};

  DescribeLiveStreamPushMetricDetailDataResponseBody() {}

  explicit DescribeLiveStreamPushMetricDetailDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamDetailData) {
      res["StreamDetailData"] = streamDetailData ? boost::any(streamDetailData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamDetailData") != m.end() && !m["StreamDetailData"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamDetailData"].type()) {
        DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamDetailData"]));
        streamDetailData = make_shared<DescribeLiveStreamPushMetricDetailDataResponseBodyStreamDetailData>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamPushMetricDetailDataResponseBody() = default;
};
class DescribeLiveStreamPushMetricDetailDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamPushMetricDetailDataResponseBody> body{};

  DescribeLiveStreamPushMetricDetailDataResponse() {}

  explicit DescribeLiveStreamPushMetricDetailDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamPushMetricDetailDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamPushMetricDetailDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamPushMetricDetailDataResponse() = default;
};
class DescribeLiveStreamRecordContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamRecordContentRequest() {}

  explicit DescribeLiveStreamRecordContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamRecordContentRequest() = default;
};
class DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo : public Darabonba::Model {
public:
  shared_ptr<double> duration{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<string> startTime{};

  DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo() {}

  explicit DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo() = default;
};
class DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo>> recordContentInfo{};

  DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList() {}

  explicit DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordContentInfo) {
      vector<boost::any> temp1;
      for(auto item1:*recordContentInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordContentInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordContentInfo") != m.end() && !m["RecordContentInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordContentInfo"].type()) {
        vector<DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordContentInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordContentInfo = make_shared<vector<DescribeLiveStreamRecordContentResponseBodyRecordContentInfoListRecordContentInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList() = default;
};
class DescribeLiveStreamRecordContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList> recordContentInfoList{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamRecordContentResponseBody() {}

  explicit DescribeLiveStreamRecordContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordContentInfoList) {
      res["RecordContentInfoList"] = recordContentInfoList ? boost::any(recordContentInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordContentInfoList") != m.end() && !m["RecordContentInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordContentInfoList"].type()) {
        DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordContentInfoList"]));
        recordContentInfoList = make_shared<DescribeLiveStreamRecordContentResponseBodyRecordContentInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamRecordContentResponseBody() = default;
};
class DescribeLiveStreamRecordContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamRecordContentResponseBody> body{};

  DescribeLiveStreamRecordContentResponse() {}

  explicit DescribeLiveStreamRecordContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamRecordContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamRecordContentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamRecordContentResponse() = default;
};
class DescribeLiveStreamRecordIndexFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> recordId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamRecordIndexFileRequest() {}

  explicit DescribeLiveStreamRecordIndexFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFileRequest() = default;
};
class DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainName{};
  shared_ptr<double> duration{};
  shared_ptr<string> endTime{};
  shared_ptr<string> format{};
  shared_ptr<long> height{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<string> recordId{};
  shared_ptr<string> recordUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<long> width{};

  DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo() {}

  explicit DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordUrl) {
      res["RecordUrl"] = boost::any(*recordUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RecordUrl") != m.end() && !m["RecordUrl"].empty()) {
      recordUrl = make_shared<string>(boost::any_cast<string>(m["RecordUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo() = default;
};
class DescribeLiveStreamRecordIndexFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo> recordIndexInfo{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamRecordIndexFileResponseBody() {}

  explicit DescribeLiveStreamRecordIndexFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordIndexInfo) {
      res["RecordIndexInfo"] = recordIndexInfo ? boost::any(recordIndexInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordIndexInfo") != m.end() && !m["RecordIndexInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordIndexInfo"].type()) {
        DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordIndexInfo"]));
        recordIndexInfo = make_shared<DescribeLiveStreamRecordIndexFileResponseBodyRecordIndexInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFileResponseBody() = default;
};
class DescribeLiveStreamRecordIndexFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamRecordIndexFileResponseBody> body{};

  DescribeLiveStreamRecordIndexFileResponse() {}

  explicit DescribeLiveStreamRecordIndexFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamRecordIndexFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamRecordIndexFileResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFileResponse() = default;
};
class DescribeLiveStreamRecordIndexFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamRecordIndexFilesRequest() {}

  explicit DescribeLiveStreamRecordIndexFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFilesRequest() = default;
};
class DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainName{};
  shared_ptr<double> duration{};
  shared_ptr<string> endTime{};
  shared_ptr<string> format{};
  shared_ptr<long> height{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<string> recordId{};
  shared_ptr<string> recordUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<long> width{};

  DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo() {}

  explicit DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordUrl) {
      res["RecordUrl"] = boost::any(*recordUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RecordUrl") != m.end() && !m["RecordUrl"].empty()) {
      recordUrl = make_shared<string>(boost::any_cast<string>(m["RecordUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo() = default;
};
class DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo>> recordIndexInfo{};

  DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList() {}

  explicit DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordIndexInfo) {
      vector<boost::any> temp1;
      for(auto item1:*recordIndexInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordIndexInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordIndexInfo") != m.end() && !m["RecordIndexInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordIndexInfo"].type()) {
        vector<DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordIndexInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordIndexInfo = make_shared<vector<DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoListRecordIndexInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList() = default;
};
class DescribeLiveStreamRecordIndexFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> order{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList> recordIndexInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveStreamRecordIndexFilesResponseBody() {}

  explicit DescribeLiveStreamRecordIndexFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordIndexInfoList) {
      res["RecordIndexInfoList"] = recordIndexInfoList ? boost::any(recordIndexInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordIndexInfoList") != m.end() && !m["RecordIndexInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordIndexInfoList"].type()) {
        DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordIndexInfoList"]));
        recordIndexInfoList = make_shared<DescribeLiveStreamRecordIndexFilesResponseBodyRecordIndexInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFilesResponseBody() = default;
};
class DescribeLiveStreamRecordIndexFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamRecordIndexFilesResponseBody> body{};

  DescribeLiveStreamRecordIndexFilesResponse() {}

  explicit DescribeLiveStreamRecordIndexFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamRecordIndexFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamRecordIndexFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamRecordIndexFilesResponse() = default;
};
class DescribeLiveStreamSnapshotInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> limit{};
  shared_ptr<string> order{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamSnapshotInfoRequest() {}

  explicit DescribeLiveStreamSnapshotInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamSnapshotInfoRequest() = default;
};
class DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<bool> isOverlay{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};

  DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo() {}

  explicit DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (isOverlay) {
      res["IsOverlay"] = boost::any(*isOverlay);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("IsOverlay") != m.end() && !m["IsOverlay"].empty()) {
      isOverlay = make_shared<bool>(boost::any_cast<bool>(m["IsOverlay"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
  }


  virtual ~DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo() = default;
};
class DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo>> liveStreamSnapshotInfo{};

  DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList() {}

  explicit DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamSnapshotInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamSnapshotInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamSnapshotInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamSnapshotInfo") != m.end() && !m["LiveStreamSnapshotInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamSnapshotInfo"].type()) {
        vector<DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamSnapshotInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamSnapshotInfo = make_shared<vector<DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoListLiveStreamSnapshotInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList() = default;
};
class DescribeLiveStreamSnapshotInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList> liveStreamSnapshotInfoList{};
  shared_ptr<string> nextStartTime{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamSnapshotInfoResponseBody() {}

  explicit DescribeLiveStreamSnapshotInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamSnapshotInfoList) {
      res["LiveStreamSnapshotInfoList"] = liveStreamSnapshotInfoList ? boost::any(liveStreamSnapshotInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextStartTime) {
      res["NextStartTime"] = boost::any(*nextStartTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamSnapshotInfoList") != m.end() && !m["LiveStreamSnapshotInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamSnapshotInfoList"].type()) {
        DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamSnapshotInfoList"]));
        liveStreamSnapshotInfoList = make_shared<DescribeLiveStreamSnapshotInfoResponseBodyLiveStreamSnapshotInfoList>(model1);
      }
    }
    if (m.find("NextStartTime") != m.end() && !m["NextStartTime"].empty()) {
      nextStartTime = make_shared<string>(boost::any_cast<string>(m["NextStartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamSnapshotInfoResponseBody() = default;
};
class DescribeLiveStreamSnapshotInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamSnapshotInfoResponseBody> body{};

  DescribeLiveStreamSnapshotInfoResponse() {}

  explicit DescribeLiveStreamSnapshotInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamSnapshotInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamSnapshotInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamSnapshotInfoResponse() = default;
};
class DescribeLiveStreamStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamStateRequest() {}

  explicit DescribeLiveStreamStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamStateRequest() = default;
};
class DescribeLiveStreamStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> streamState{};
  shared_ptr<string> type{};

  DescribeLiveStreamStateResponseBody() {}

  explicit DescribeLiveStreamStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamState) {
      res["StreamState"] = boost::any(*streamState);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamState") != m.end() && !m["StreamState"].empty()) {
      streamState = make_shared<string>(boost::any_cast<string>(m["StreamState"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLiveStreamStateResponseBody() = default;
};
class DescribeLiveStreamStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamStateResponseBody> body{};

  DescribeLiveStreamStateResponse() {}

  explicit DescribeLiveStreamStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamStateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamStateResponse() = default;
};
class DescribeLiveStreamTranscodeInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainTranscodeName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveStreamTranscodeInfoRequest() {}

  explicit DescribeLiveStreamTranscodeInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainTranscodeName) {
      res["DomainTranscodeName"] = boost::any(*domainTranscodeName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainTranscodeName") != m.end() && !m["DomainTranscodeName"].empty()) {
      domainTranscodeName = make_shared<string>(boost::any_cast<string>(m["DomainTranscodeName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoRequest() = default;
};
class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters : public Darabonba::Model {
public:
  shared_ptr<long> audioBitrate{};
  shared_ptr<long> audioChannelNum{};
  shared_ptr<string> audioCodec{};
  shared_ptr<string> audioProfile{};
  shared_ptr<long> audioRate{};
  shared_ptr<string> bframes{};
  shared_ptr<map<string, boost::any>> bitrateWithSource{};
  shared_ptr<map<string, boost::any>> extWithSource{};
  shared_ptr<long> FPS{};
  shared_ptr<map<string, boost::any>> fpsWithSource{};
  shared_ptr<string> gop{};
  shared_ptr<long> height{};
  shared_ptr<map<string, boost::any>> resWithSource{};
  shared_ptr<string> rtsFlag{};
  shared_ptr<string> templateType{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<string> videoProfile{};
  shared_ptr<long> width{};

  DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters() {}

  explicit DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannelNum) {
      res["AudioChannelNum"] = boost::any(*audioChannelNum);
    }
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioProfile) {
      res["AudioProfile"] = boost::any(*audioProfile);
    }
    if (audioRate) {
      res["AudioRate"] = boost::any(*audioRate);
    }
    if (bframes) {
      res["Bframes"] = boost::any(*bframes);
    }
    if (bitrateWithSource) {
      res["BitrateWithSource"] = boost::any(*bitrateWithSource);
    }
    if (extWithSource) {
      res["ExtWithSource"] = boost::any(*extWithSource);
    }
    if (FPS) {
      res["FPS"] = boost::any(*FPS);
    }
    if (fpsWithSource) {
      res["FpsWithSource"] = boost::any(*fpsWithSource);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (resWithSource) {
      res["ResWithSource"] = boost::any(*resWithSource);
    }
    if (rtsFlag) {
      res["RtsFlag"] = boost::any(*rtsFlag);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (videoProfile) {
      res["VideoProfile"] = boost::any(*videoProfile);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<long>(boost::any_cast<long>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannelNum") != m.end() && !m["AudioChannelNum"].empty()) {
      audioChannelNum = make_shared<long>(boost::any_cast<long>(m["AudioChannelNum"]));
    }
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioProfile") != m.end() && !m["AudioProfile"].empty()) {
      audioProfile = make_shared<string>(boost::any_cast<string>(m["AudioProfile"]));
    }
    if (m.find("AudioRate") != m.end() && !m["AudioRate"].empty()) {
      audioRate = make_shared<long>(boost::any_cast<long>(m["AudioRate"]));
    }
    if (m.find("Bframes") != m.end() && !m["Bframes"].empty()) {
      bframes = make_shared<string>(boost::any_cast<string>(m["Bframes"]));
    }
    if (m.find("BitrateWithSource") != m.end() && !m["BitrateWithSource"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["BitrateWithSource"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bitrateWithSource = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ExtWithSource") != m.end() && !m["ExtWithSource"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtWithSource"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extWithSource = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("FPS") != m.end() && !m["FPS"].empty()) {
      FPS = make_shared<long>(boost::any_cast<long>(m["FPS"]));
    }
    if (m.find("FpsWithSource") != m.end() && !m["FpsWithSource"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FpsWithSource"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      fpsWithSource = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("ResWithSource") != m.end() && !m["ResWithSource"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ResWithSource"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      resWithSource = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RtsFlag") != m.end() && !m["RtsFlag"].empty()) {
      rtsFlag = make_shared<string>(boost::any_cast<string>(m["RtsFlag"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("VideoProfile") != m.end() && !m["VideoProfile"].empty()) {
      videoProfile = make_shared<string>(boost::any_cast<string>(m["VideoProfile"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters() = default;
};
class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters : public Darabonba::Model {
public:
  shared_ptr<string> encryptType{};
  shared_ptr<string> kmsKeyExpireInterval{};
  shared_ptr<string> kmsKeyID{};

  DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters() {}

  explicit DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (kmsKeyExpireInterval) {
      res["KmsKeyExpireInterval"] = boost::any(*kmsKeyExpireInterval);
    }
    if (kmsKeyID) {
      res["KmsKeyID"] = boost::any(*kmsKeyID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
    if (m.find("KmsKeyExpireInterval") != m.end() && !m["KmsKeyExpireInterval"].empty()) {
      kmsKeyExpireInterval = make_shared<string>(boost::any_cast<string>(m["KmsKeyExpireInterval"]));
    }
    if (m.find("KmsKeyID") != m.end() && !m["KmsKeyID"].empty()) {
      kmsKeyID = make_shared<string>(boost::any_cast<string>(m["KmsKeyID"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters() = default;
};
class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters> customTranscodeParameters{};
  shared_ptr<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters> encryptParameters{};
  shared_ptr<bool> isLazy{};
  shared_ptr<string> transcodeApp{};
  shared_ptr<string> transcodeName{};
  shared_ptr<string> transcodeTemplate{};

  DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo() {}

  explicit DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTranscodeParameters) {
      res["CustomTranscodeParameters"] = customTranscodeParameters ? boost::any(customTranscodeParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryptParameters) {
      res["EncryptParameters"] = encryptParameters ? boost::any(encryptParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isLazy) {
      res["IsLazy"] = boost::any(*isLazy);
    }
    if (transcodeApp) {
      res["TranscodeApp"] = boost::any(*transcodeApp);
    }
    if (transcodeName) {
      res["TranscodeName"] = boost::any(*transcodeName);
    }
    if (transcodeTemplate) {
      res["TranscodeTemplate"] = boost::any(*transcodeTemplate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTranscodeParameters") != m.end() && !m["CustomTranscodeParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomTranscodeParameters"].type()) {
        DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomTranscodeParameters"]));
        customTranscodeParameters = make_shared<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoCustomTranscodeParameters>(model1);
      }
    }
    if (m.find("EncryptParameters") != m.end() && !m["EncryptParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["EncryptParameters"].type()) {
        DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EncryptParameters"]));
        encryptParameters = make_shared<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfoEncryptParameters>(model1);
      }
    }
    if (m.find("IsLazy") != m.end() && !m["IsLazy"].empty()) {
      isLazy = make_shared<bool>(boost::any_cast<bool>(m["IsLazy"]));
    }
    if (m.find("TranscodeApp") != m.end() && !m["TranscodeApp"].empty()) {
      transcodeApp = make_shared<string>(boost::any_cast<string>(m["TranscodeApp"]));
    }
    if (m.find("TranscodeName") != m.end() && !m["TranscodeName"].empty()) {
      transcodeName = make_shared<string>(boost::any_cast<string>(m["TranscodeName"]));
    }
    if (m.find("TranscodeTemplate") != m.end() && !m["TranscodeTemplate"].empty()) {
      transcodeTemplate = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplate"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo() = default;
};
class DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo>> domainTranscodeInfo{};

  DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList() {}

  explicit DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainTranscodeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*domainTranscodeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainTranscodeInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainTranscodeInfo") != m.end() && !m["DomainTranscodeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainTranscodeInfo"].type()) {
        vector<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainTranscodeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainTranscodeInfo = make_shared<vector<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeListDomainTranscodeInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList() = default;
};
class DescribeLiveStreamTranscodeInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList> domainTranscodeList{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamTranscodeInfoResponseBody() {}

  explicit DescribeLiveStreamTranscodeInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainTranscodeList) {
      res["DomainTranscodeList"] = domainTranscodeList ? boost::any(domainTranscodeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainTranscodeList") != m.end() && !m["DomainTranscodeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainTranscodeList"].type()) {
        DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainTranscodeList"]));
        domainTranscodeList = make_shared<DescribeLiveStreamTranscodeInfoResponseBodyDomainTranscodeList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponseBody() = default;
};
class DescribeLiveStreamTranscodeInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamTranscodeInfoResponseBody> body{};

  DescribeLiveStreamTranscodeInfoResponse() {}

  explicit DescribeLiveStreamTranscodeInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamTranscodeInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamTranscodeInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamTranscodeInfoResponse() = default;
};
class DescribeLiveStreamTranscodeMetricDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamTranscodeMetricDataRequest() {}

  explicit DescribeLiveStreamTranscodeMetricDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeMetricDataRequest() = default;
};
class DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailDataStreamData : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> region{};
  shared_ptr<string> resolution{};
  shared_ptr<string> streamName{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> transcodeType{};

  DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailDataStreamData() {}

  explicit DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailDataStreamData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resolution) {
      res["Resolution"] = boost::any(*resolution);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (transcodeType) {
      res["TranscodeType"] = boost::any(*transcodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Resolution") != m.end() && !m["Resolution"].empty()) {
      resolution = make_shared<string>(boost::any_cast<string>(m["Resolution"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TranscodeType") != m.end() && !m["TranscodeType"].empty()) {
      transcodeType = make_shared<string>(boost::any_cast<string>(m["TranscodeType"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailDataStreamData() = default;
};
class DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailDataStreamData>> streamData{};

  DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailData() {}

  explicit DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamData) {
      vector<boost::any> temp1;
      for(auto item1:*streamData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamData") != m.end() && !m["StreamData"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamData"].type()) {
        vector<DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailDataStreamData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailDataStreamData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamData = make_shared<vector<DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailDataStreamData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailData() = default;
};
class DescribeLiveStreamTranscodeMetricDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailData> streamDetailData{};

  DescribeLiveStreamTranscodeMetricDataResponseBody() {}

  explicit DescribeLiveStreamTranscodeMetricDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamDetailData) {
      res["StreamDetailData"] = streamDetailData ? boost::any(streamDetailData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamDetailData") != m.end() && !m["StreamDetailData"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamDetailData"].type()) {
        DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamDetailData"]));
        streamDetailData = make_shared<DescribeLiveStreamTranscodeMetricDataResponseBodyStreamDetailData>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamTranscodeMetricDataResponseBody() = default;
};
class DescribeLiveStreamTranscodeMetricDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamTranscodeMetricDataResponseBody> body{};

  DescribeLiveStreamTranscodeMetricDataResponse() {}

  explicit DescribeLiveStreamTranscodeMetricDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamTranscodeMetricDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamTranscodeMetricDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamTranscodeMetricDataResponse() = default;
};
class DescribeLiveStreamTranscodeStreamNumRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> splitType{};

  DescribeLiveStreamTranscodeStreamNumRequest() {}

  explicit DescribeLiveStreamTranscodeStreamNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (splitType) {
      res["SplitType"] = boost::any(*splitType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SplitType") != m.end() && !m["SplitType"].empty()) {
      splitType = make_shared<string>(boost::any_cast<string>(m["SplitType"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeStreamNumRequest() = default;
};
class DescribeLiveStreamTranscodeStreamNumResponseBodyTranscodeStreamCountDetails : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> template_{};

  DescribeLiveStreamTranscodeStreamNumResponseBodyTranscodeStreamCountDetails() {}

  explicit DescribeLiveStreamTranscodeStreamNumResponseBodyTranscodeStreamCountDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeStreamNumResponseBodyTranscodeStreamCountDetails() = default;
};
class DescribeLiveStreamTranscodeStreamNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> lazyTranscodedNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<vector<DescribeLiveStreamTranscodeStreamNumResponseBodyTranscodeStreamCountDetails>> transcodeStreamCountDetails{};
  shared_ptr<long> transcodedNumber{};
  shared_ptr<long> untranscodeNumber{};

  DescribeLiveStreamTranscodeStreamNumResponseBody() {}

  explicit DescribeLiveStreamTranscodeStreamNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lazyTranscodedNumber) {
      res["LazyTranscodedNumber"] = boost::any(*lazyTranscodedNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (transcodeStreamCountDetails) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeStreamCountDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeStreamCountDetails"] = boost::any(temp1);
    }
    if (transcodedNumber) {
      res["TranscodedNumber"] = boost::any(*transcodedNumber);
    }
    if (untranscodeNumber) {
      res["UntranscodeNumber"] = boost::any(*untranscodeNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LazyTranscodedNumber") != m.end() && !m["LazyTranscodedNumber"].empty()) {
      lazyTranscodedNumber = make_shared<long>(boost::any_cast<long>(m["LazyTranscodedNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TranscodeStreamCountDetails") != m.end() && !m["TranscodeStreamCountDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeStreamCountDetails"].type()) {
        vector<DescribeLiveStreamTranscodeStreamNumResponseBodyTranscodeStreamCountDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeStreamCountDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamTranscodeStreamNumResponseBodyTranscodeStreamCountDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeStreamCountDetails = make_shared<vector<DescribeLiveStreamTranscodeStreamNumResponseBodyTranscodeStreamCountDetails>>(expect1);
      }
    }
    if (m.find("TranscodedNumber") != m.end() && !m["TranscodedNumber"].empty()) {
      transcodedNumber = make_shared<long>(boost::any_cast<long>(m["TranscodedNumber"]));
    }
    if (m.find("UntranscodeNumber") != m.end() && !m["UntranscodeNumber"].empty()) {
      untranscodeNumber = make_shared<long>(boost::any_cast<long>(m["UntranscodeNumber"]));
    }
  }


  virtual ~DescribeLiveStreamTranscodeStreamNumResponseBody() = default;
};
class DescribeLiveStreamTranscodeStreamNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamTranscodeStreamNumResponseBody> body{};

  DescribeLiveStreamTranscodeStreamNumResponse() {}

  explicit DescribeLiveStreamTranscodeStreamNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamTranscodeStreamNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamTranscodeStreamNumResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamTranscodeStreamNumResponse() = default;
};
class DescribeLiveStreamWatermarkRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeLiveStreamWatermarkRulesRequest() {}

  explicit DescribeLiveStreamWatermarkRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveStreamWatermarkRulesRequest() = default;
};
class DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> name{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> stream{};
  shared_ptr<string> templateId{};

  DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo() {}

  explicit DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo() = default;
};
class DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo>> ruleInfo{};

  DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList() {}

  explicit DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ruleInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleInfo") != m.end() && !m["RuleInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleInfo"].type()) {
        vector<DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleInfo = make_shared<vector<DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoListRuleInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList() = default;
};
class DescribeLiveStreamWatermarkRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList> ruleInfoList{};
  shared_ptr<long> total{};

  DescribeLiveStreamWatermarkRulesResponseBody() {}

  explicit DescribeLiveStreamWatermarkRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleInfoList) {
      res["RuleInfoList"] = ruleInfoList ? boost::any(ruleInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleInfoList") != m.end() && !m["RuleInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleInfoList"].type()) {
        DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleInfoList"]));
        ruleInfoList = make_shared<DescribeLiveStreamWatermarkRulesResponseBodyRuleInfoList>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveStreamWatermarkRulesResponseBody() = default;
};
class DescribeLiveStreamWatermarkRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamWatermarkRulesResponseBody> body{};

  DescribeLiveStreamWatermarkRulesResponse() {}

  explicit DescribeLiveStreamWatermarkRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamWatermarkRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamWatermarkRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamWatermarkRulesResponse() = default;
};
class DescribeLiveStreamWatermarksRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> keyWord{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeLiveStreamWatermarksRequest() {}

  explicit DescribeLiveStreamWatermarksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveStreamWatermarksRequest() = default;
};
class DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> height{};
  shared_ptr<string> name{};
  shared_ptr<string> offsetCorner{};
  shared_ptr<string> pictureUrl{};
  shared_ptr<long> refHeight{};
  shared_ptr<long> refWidth{};
  shared_ptr<long> ruleCount{};
  shared_ptr<string> templateId{};
  shared_ptr<long> transparency{};
  shared_ptr<long> type{};
  shared_ptr<double> XOffset{};
  shared_ptr<double> YOffset{};

  DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark() {}

  explicit DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (offsetCorner) {
      res["OffsetCorner"] = boost::any(*offsetCorner);
    }
    if (pictureUrl) {
      res["PictureUrl"] = boost::any(*pictureUrl);
    }
    if (refHeight) {
      res["RefHeight"] = boost::any(*refHeight);
    }
    if (refWidth) {
      res["RefWidth"] = boost::any(*refWidth);
    }
    if (ruleCount) {
      res["RuleCount"] = boost::any(*ruleCount);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transparency) {
      res["Transparency"] = boost::any(*transparency);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (XOffset) {
      res["XOffset"] = boost::any(*XOffset);
    }
    if (YOffset) {
      res["YOffset"] = boost::any(*YOffset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OffsetCorner") != m.end() && !m["OffsetCorner"].empty()) {
      offsetCorner = make_shared<string>(boost::any_cast<string>(m["OffsetCorner"]));
    }
    if (m.find("PictureUrl") != m.end() && !m["PictureUrl"].empty()) {
      pictureUrl = make_shared<string>(boost::any_cast<string>(m["PictureUrl"]));
    }
    if (m.find("RefHeight") != m.end() && !m["RefHeight"].empty()) {
      refHeight = make_shared<long>(boost::any_cast<long>(m["RefHeight"]));
    }
    if (m.find("RefWidth") != m.end() && !m["RefWidth"].empty()) {
      refWidth = make_shared<long>(boost::any_cast<long>(m["RefWidth"]));
    }
    if (m.find("RuleCount") != m.end() && !m["RuleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["RuleCount"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Transparency") != m.end() && !m["Transparency"].empty()) {
      transparency = make_shared<long>(boost::any_cast<long>(m["Transparency"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("XOffset") != m.end() && !m["XOffset"].empty()) {
      XOffset = make_shared<double>(boost::any_cast<double>(m["XOffset"]));
    }
    if (m.find("YOffset") != m.end() && !m["YOffset"].empty()) {
      YOffset = make_shared<double>(boost::any_cast<double>(m["YOffset"]));
    }
  }


  virtual ~DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark() = default;
};
class DescribeLiveStreamWatermarksResponseBodyWatermarkList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark>> watermark{};

  DescribeLiveStreamWatermarksResponseBodyWatermarkList() {}

  explicit DescribeLiveStreamWatermarksResponseBodyWatermarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (watermark) {
      vector<boost::any> temp1;
      for(auto item1:*watermark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Watermark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Watermark") != m.end() && !m["Watermark"].empty()) {
      if (typeid(vector<boost::any>) == m["Watermark"].type()) {
        vector<DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Watermark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        watermark = make_shared<vector<DescribeLiveStreamWatermarksResponseBodyWatermarkListWatermark>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamWatermarksResponseBodyWatermarkList() = default;
};
class DescribeLiveStreamWatermarksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<DescribeLiveStreamWatermarksResponseBodyWatermarkList> watermarkList{};

  DescribeLiveStreamWatermarksResponseBody() {}

  explicit DescribeLiveStreamWatermarksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (watermarkList) {
      res["WatermarkList"] = watermarkList ? boost::any(watermarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("WatermarkList") != m.end() && !m["WatermarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WatermarkList"].type()) {
        DescribeLiveStreamWatermarksResponseBodyWatermarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WatermarkList"]));
        watermarkList = make_shared<DescribeLiveStreamWatermarksResponseBodyWatermarkList>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamWatermarksResponseBody() = default;
};
class DescribeLiveStreamWatermarksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamWatermarksResponseBody> body{};

  DescribeLiveStreamWatermarksResponse() {}

  explicit DescribeLiveStreamWatermarksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamWatermarksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamWatermarksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamWatermarksResponse() = default;
};
class DescribeLiveStreamsBlockListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeLiveStreamsBlockListRequest() {}

  explicit DescribeLiveStreamsBlockListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLiveStreamsBlockListRequest() = default;
};
class DescribeLiveStreamsBlockListResponseBodyStreamUrls : public Darabonba::Model {
public:
  shared_ptr<vector<string>> streamUrl{};

  DescribeLiveStreamsBlockListResponseBodyStreamUrls() {}

  explicit DescribeLiveStreamsBlockListResponseBodyStreamUrls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StreamUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StreamUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      streamUrl = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveStreamsBlockListResponseBodyStreamUrls() = default;
};
class DescribeLiveStreamsBlockListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveStreamsBlockListResponseBodyStreamUrls> streamUrls{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveStreamsBlockListResponseBody() {}

  explicit DescribeLiveStreamsBlockListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamUrls) {
      res["StreamUrls"] = streamUrls ? boost::any(streamUrls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamUrls") != m.end() && !m["StreamUrls"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamUrls"].type()) {
        DescribeLiveStreamsBlockListResponseBodyStreamUrls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamUrls"]));
        streamUrls = make_shared<DescribeLiveStreamsBlockListResponseBodyStreamUrls>(model1);
      }
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveStreamsBlockListResponseBody() = default;
};
class DescribeLiveStreamsBlockListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsBlockListResponseBody> body{};

  DescribeLiveStreamsBlockListResponse() {}

  explicit DescribeLiveStreamsBlockListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsBlockListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsBlockListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsBlockListResponse() = default;
};
class DescribeLiveStreamsControlHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveStreamsControlHistoryRequest() {}

  explicit DescribeLiveStreamsControlHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveStreamsControlHistoryRequest() = default;
};
class DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> clientIP{};
  shared_ptr<string> streamName{};
  shared_ptr<string> timeStamp{};

  DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo() {}

  explicit DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (clientIP) {
      res["ClientIP"] = boost::any(*clientIP);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("ClientIP") != m.end() && !m["ClientIP"].empty()) {
      clientIP = make_shared<string>(boost::any_cast<string>(m["ClientIP"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo() = default;
};
class DescribeLiveStreamsControlHistoryResponseBodyControlInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo>> liveStreamControlInfo{};

  DescribeLiveStreamsControlHistoryResponseBodyControlInfo() {}

  explicit DescribeLiveStreamsControlHistoryResponseBodyControlInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamControlInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamControlInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamControlInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamControlInfo") != m.end() && !m["LiveStreamControlInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamControlInfo"].type()) {
        vector<DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamControlInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamControlInfo = make_shared<vector<DescribeLiveStreamsControlHistoryResponseBodyControlInfoLiveStreamControlInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamsControlHistoryResponseBodyControlInfo() = default;
};
class DescribeLiveStreamsControlHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamsControlHistoryResponseBodyControlInfo> controlInfo{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamsControlHistoryResponseBody() {}

  explicit DescribeLiveStreamsControlHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (controlInfo) {
      res["ControlInfo"] = controlInfo ? boost::any(controlInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ControlInfo") != m.end() && !m["ControlInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ControlInfo"].type()) {
        DescribeLiveStreamsControlHistoryResponseBodyControlInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ControlInfo"]));
        controlInfo = make_shared<DescribeLiveStreamsControlHistoryResponseBodyControlInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamsControlHistoryResponseBody() = default;
};
class DescribeLiveStreamsControlHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsControlHistoryResponseBody> body{};

  DescribeLiveStreamsControlHistoryResponse() {}

  explicit DescribeLiveStreamsControlHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsControlHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsControlHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsControlHistoryResponse() = default;
};
class DescribeLiveStreamsNotifyRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamsNotifyRecordsRequest() {}

  explicit DescribeLiveStreamsNotifyRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyRecordsRequest() = default;
};
class DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyContent{};
  shared_ptr<string> notifyResponse{};
  shared_ptr<string> notifyResult{};
  shared_ptr<string> notifyTime{};
  shared_ptr<string> notifyType{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> streamName{};

  DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo() {}

  explicit DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyContent) {
      res["NotifyContent"] = boost::any(*notifyContent);
    }
    if (notifyResponse) {
      res["NotifyResponse"] = boost::any(*notifyResponse);
    }
    if (notifyResult) {
      res["NotifyResult"] = boost::any(*notifyResult);
    }
    if (notifyTime) {
      res["NotifyTime"] = boost::any(*notifyTime);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyContent") != m.end() && !m["NotifyContent"].empty()) {
      notifyContent = make_shared<string>(boost::any_cast<string>(m["NotifyContent"]));
    }
    if (m.find("NotifyResponse") != m.end() && !m["NotifyResponse"].empty()) {
      notifyResponse = make_shared<string>(boost::any_cast<string>(m["NotifyResponse"]));
    }
    if (m.find("NotifyResult") != m.end() && !m["NotifyResult"].empty()) {
      notifyResult = make_shared<string>(boost::any_cast<string>(m["NotifyResult"]));
    }
    if (m.find("NotifyTime") != m.end() && !m["NotifyTime"].empty()) {
      notifyTime = make_shared<string>(boost::any_cast<string>(m["NotifyTime"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<string>(boost::any_cast<string>(m["NotifyType"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo() = default;
};
class DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo>> liveStreamNotifyRecordsInfo{};

  DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo() {}

  explicit DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamNotifyRecordsInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamNotifyRecordsInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamNotifyRecordsInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamNotifyRecordsInfo") != m.end() && !m["LiveStreamNotifyRecordsInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamNotifyRecordsInfo"].type()) {
        vector<DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamNotifyRecordsInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamNotifyRecordsInfo = make_shared<vector<DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfoLiveStreamNotifyRecordsInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo() = default;
};
class DescribeLiveStreamsNotifyRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo> notifyRecordsInfo{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveStreamsNotifyRecordsResponseBody() {}

  explicit DescribeLiveStreamsNotifyRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyRecordsInfo) {
      res["NotifyRecordsInfo"] = notifyRecordsInfo ? boost::any(notifyRecordsInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyRecordsInfo") != m.end() && !m["NotifyRecordsInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyRecordsInfo"].type()) {
        DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyRecordsInfo"]));
        notifyRecordsInfo = make_shared<DescribeLiveStreamsNotifyRecordsResponseBodyNotifyRecordsInfo>(model1);
      }
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyRecordsResponseBody() = default;
};
class DescribeLiveStreamsNotifyRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsNotifyRecordsResponseBody> body{};

  DescribeLiveStreamsNotifyRecordsResponse() {}

  explicit DescribeLiveStreamsNotifyRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsNotifyRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsNotifyRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsNotifyRecordsResponse() = default;
};
class DescribeLiveStreamsNotifyUrlConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveStreamsNotifyUrlConfigRequest() {}

  explicit DescribeLiveStreamsNotifyUrlConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyUrlConfigRequest() = default;
};
class DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> exceptionNotifyUrl{};
  shared_ptr<string> notifyAuthKey{};
  shared_ptr<string> notifyReqAuth{};
  shared_ptr<string> notifyUrl{};

  DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig() {}

  explicit DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (exceptionNotifyUrl) {
      res["ExceptionNotifyUrl"] = boost::any(*exceptionNotifyUrl);
    }
    if (notifyAuthKey) {
      res["NotifyAuthKey"] = boost::any(*notifyAuthKey);
    }
    if (notifyReqAuth) {
      res["NotifyReqAuth"] = boost::any(*notifyReqAuth);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ExceptionNotifyUrl") != m.end() && !m["ExceptionNotifyUrl"].empty()) {
      exceptionNotifyUrl = make_shared<string>(boost::any_cast<string>(m["ExceptionNotifyUrl"]));
    }
    if (m.find("NotifyAuthKey") != m.end() && !m["NotifyAuthKey"].empty()) {
      notifyAuthKey = make_shared<string>(boost::any_cast<string>(m["NotifyAuthKey"]));
    }
    if (m.find("NotifyReqAuth") != m.end() && !m["NotifyReqAuth"].empty()) {
      notifyReqAuth = make_shared<string>(boost::any_cast<string>(m["NotifyReqAuth"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig() = default;
};
class DescribeLiveStreamsNotifyUrlConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig> liveStreamsNotifyConfig{};
  shared_ptr<string> requestId{};

  DescribeLiveStreamsNotifyUrlConfigResponseBody() {}

  explicit DescribeLiveStreamsNotifyUrlConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamsNotifyConfig) {
      res["LiveStreamsNotifyConfig"] = liveStreamsNotifyConfig ? boost::any(liveStreamsNotifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamsNotifyConfig") != m.end() && !m["LiveStreamsNotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamsNotifyConfig"].type()) {
        DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamsNotifyConfig"]));
        liveStreamsNotifyConfig = make_shared<DescribeLiveStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveStreamsNotifyUrlConfigResponseBody() = default;
};
class DescribeLiveStreamsNotifyUrlConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsNotifyUrlConfigResponseBody> body{};

  DescribeLiveStreamsNotifyUrlConfigResponse() {}

  explicit DescribeLiveStreamsNotifyUrlConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsNotifyUrlConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsNotifyUrlConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsNotifyUrlConfigResponse() = default;
};
class DescribeLiveStreamsOnlineListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> onlyStream{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};
  shared_ptr<string> streamType{};

  DescribeLiveStreamsOnlineListRequest() {}

  explicit DescribeLiveStreamsOnlineListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (onlyStream) {
      res["OnlyStream"] = boost::any(*onlyStream);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OnlyStream") != m.end() && !m["OnlyStream"].empty()) {
      onlyStream = make_shared<string>(boost::any_cast<string>(m["OnlyStream"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
  }


  virtual ~DescribeLiveStreamsOnlineListRequest() = default;
};
class DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> audioCodecId{};
  shared_ptr<long> audioDataRate{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> domainName{};
  shared_ptr<long> frameRate{};
  shared_ptr<long> height{};
  shared_ptr<string> publishDomain{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> publishType{};
  shared_ptr<string> publishUrl{};
  shared_ptr<string> serverIp{};
  shared_ptr<string> streamName{};
  shared_ptr<string> transcoded{};
  shared_ptr<long> videoCodecId{};
  shared_ptr<long> videoDataRate{};
  shared_ptr<long> width{};

  DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo() {}

  explicit DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (audioCodecId) {
      res["AudioCodecId"] = boost::any(*audioCodecId);
    }
    if (audioDataRate) {
      res["AudioDataRate"] = boost::any(*audioDataRate);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (frameRate) {
      res["FrameRate"] = boost::any(*frameRate);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (publishDomain) {
      res["PublishDomain"] = boost::any(*publishDomain);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (publishUrl) {
      res["PublishUrl"] = boost::any(*publishUrl);
    }
    if (serverIp) {
      res["ServerIp"] = boost::any(*serverIp);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transcoded) {
      res["Transcoded"] = boost::any(*transcoded);
    }
    if (videoCodecId) {
      res["VideoCodecId"] = boost::any(*videoCodecId);
    }
    if (videoDataRate) {
      res["VideoDataRate"] = boost::any(*videoDataRate);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AudioCodecId") != m.end() && !m["AudioCodecId"].empty()) {
      audioCodecId = make_shared<long>(boost::any_cast<long>(m["AudioCodecId"]));
    }
    if (m.find("AudioDataRate") != m.end() && !m["AudioDataRate"].empty()) {
      audioDataRate = make_shared<long>(boost::any_cast<long>(m["AudioDataRate"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FrameRate") != m.end() && !m["FrameRate"].empty()) {
      frameRate = make_shared<long>(boost::any_cast<long>(m["FrameRate"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("PublishDomain") != m.end() && !m["PublishDomain"].empty()) {
      publishDomain = make_shared<string>(boost::any_cast<string>(m["PublishDomain"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<string>(boost::any_cast<string>(m["PublishType"]));
    }
    if (m.find("PublishUrl") != m.end() && !m["PublishUrl"].empty()) {
      publishUrl = make_shared<string>(boost::any_cast<string>(m["PublishUrl"]));
    }
    if (m.find("ServerIp") != m.end() && !m["ServerIp"].empty()) {
      serverIp = make_shared<string>(boost::any_cast<string>(m["ServerIp"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Transcoded") != m.end() && !m["Transcoded"].empty()) {
      transcoded = make_shared<string>(boost::any_cast<string>(m["Transcoded"]));
    }
    if (m.find("VideoCodecId") != m.end() && !m["VideoCodecId"].empty()) {
      videoCodecId = make_shared<long>(boost::any_cast<long>(m["VideoCodecId"]));
    }
    if (m.find("VideoDataRate") != m.end() && !m["VideoDataRate"].empty()) {
      videoDataRate = make_shared<long>(boost::any_cast<long>(m["VideoDataRate"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo() = default;
};
class DescribeLiveStreamsOnlineListResponseBodyOnlineInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo>> liveStreamOnlineInfo{};

  DescribeLiveStreamsOnlineListResponseBodyOnlineInfo() {}

  explicit DescribeLiveStreamsOnlineListResponseBodyOnlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamOnlineInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamOnlineInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamOnlineInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamOnlineInfo") != m.end() && !m["LiveStreamOnlineInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamOnlineInfo"].type()) {
        vector<DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamOnlineInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamOnlineInfo = make_shared<vector<DescribeLiveStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamsOnlineListResponseBodyOnlineInfo() = default;
};
class DescribeLiveStreamsOnlineListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveStreamsOnlineListResponseBodyOnlineInfo> onlineInfo{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveStreamsOnlineListResponseBody() {}

  explicit DescribeLiveStreamsOnlineListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onlineInfo) {
      res["OnlineInfo"] = onlineInfo ? boost::any(onlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnlineInfo") != m.end() && !m["OnlineInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineInfo"].type()) {
        DescribeLiveStreamsOnlineListResponseBodyOnlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineInfo"]));
        onlineInfo = make_shared<DescribeLiveStreamsOnlineListResponseBodyOnlineInfo>(model1);
      }
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveStreamsOnlineListResponseBody() = default;
};
class DescribeLiveStreamsOnlineListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsOnlineListResponseBody> body{};

  DescribeLiveStreamsOnlineListResponse() {}

  explicit DescribeLiveStreamsOnlineListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsOnlineListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsOnlineListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsOnlineListResponse() = default;
};
class DescribeLiveStreamsPublishListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> streamType{};

  DescribeLiveStreamsPublishListRequest() {}

  explicit DescribeLiveStreamsPublishListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
  }


  virtual ~DescribeLiveStreamsPublishListRequest() = default;
};
class DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo : public Darabonba::Model {
public:
  shared_ptr<string> aliInnerErrorFlags{};
  shared_ptr<string> appName{};
  shared_ptr<string> clientAddr{};
  shared_ptr<string> domainName{};
  shared_ptr<string> edgeNodeAddr{};
  shared_ptr<string> publishDomain{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> publishType{};
  shared_ptr<string> publishUrl{};
  shared_ptr<string> stopTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> streamUrl{};
  shared_ptr<string> transcodeId{};
  shared_ptr<string> transcoded{};

  DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo() {}

  explicit DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliInnerErrorFlags) {
      res["AliInnerErrorFlags"] = boost::any(*aliInnerErrorFlags);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clientAddr) {
      res["ClientAddr"] = boost::any(*clientAddr);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (edgeNodeAddr) {
      res["EdgeNodeAddr"] = boost::any(*edgeNodeAddr);
    }
    if (publishDomain) {
      res["PublishDomain"] = boost::any(*publishDomain);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (publishUrl) {
      res["PublishUrl"] = boost::any(*publishUrl);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    if (transcodeId) {
      res["TranscodeId"] = boost::any(*transcodeId);
    }
    if (transcoded) {
      res["Transcoded"] = boost::any(*transcoded);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliInnerErrorFlags") != m.end() && !m["AliInnerErrorFlags"].empty()) {
      aliInnerErrorFlags = make_shared<string>(boost::any_cast<string>(m["AliInnerErrorFlags"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClientAddr") != m.end() && !m["ClientAddr"].empty()) {
      clientAddr = make_shared<string>(boost::any_cast<string>(m["ClientAddr"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EdgeNodeAddr") != m.end() && !m["EdgeNodeAddr"].empty()) {
      edgeNodeAddr = make_shared<string>(boost::any_cast<string>(m["EdgeNodeAddr"]));
    }
    if (m.find("PublishDomain") != m.end() && !m["PublishDomain"].empty()) {
      publishDomain = make_shared<string>(boost::any_cast<string>(m["PublishDomain"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<string>(boost::any_cast<string>(m["PublishType"]));
    }
    if (m.find("PublishUrl") != m.end() && !m["PublishUrl"].empty()) {
      publishUrl = make_shared<string>(boost::any_cast<string>(m["PublishUrl"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["StopTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
    if (m.find("TranscodeId") != m.end() && !m["TranscodeId"].empty()) {
      transcodeId = make_shared<string>(boost::any_cast<string>(m["TranscodeId"]));
    }
    if (m.find("Transcoded") != m.end() && !m["Transcoded"].empty()) {
      transcoded = make_shared<string>(boost::any_cast<string>(m["Transcoded"]));
    }
  }


  virtual ~DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo() = default;
};
class DescribeLiveStreamsPublishListResponseBodyPublishInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo>> liveStreamPublishInfo{};

  DescribeLiveStreamsPublishListResponseBodyPublishInfo() {}

  explicit DescribeLiveStreamsPublishListResponseBodyPublishInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamPublishInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamPublishInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamPublishInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamPublishInfo") != m.end() && !m["LiveStreamPublishInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamPublishInfo"].type()) {
        vector<DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamPublishInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamPublishInfo = make_shared<vector<DescribeLiveStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamsPublishListResponseBodyPublishInfo() = default;
};
class DescribeLiveStreamsPublishListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeLiveStreamsPublishListResponseBodyPublishInfo> publishInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeLiveStreamsPublishListResponseBody() {}

  explicit DescribeLiveStreamsPublishListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (publishInfo) {
      res["PublishInfo"] = publishInfo ? boost::any(publishInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PublishInfo") != m.end() && !m["PublishInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublishInfo"].type()) {
        DescribeLiveStreamsPublishListResponseBodyPublishInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublishInfo"]));
        publishInfo = make_shared<DescribeLiveStreamsPublishListResponseBodyPublishInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeLiveStreamsPublishListResponseBody() = default;
};
class DescribeLiveStreamsPublishListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsPublishListResponseBody> body{};

  DescribeLiveStreamsPublishListResponse() {}

  explicit DescribeLiveStreamsPublishListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsPublishListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsPublishListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsPublishListResponse() = default;
};
class DescribeLiveStreamsTotalCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> typ{};

  DescribeLiveStreamsTotalCountRequest() {}

  explicit DescribeLiveStreamsTotalCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (typ) {
      res["Typ"] = boost::any(*typ);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Typ") != m.end() && !m["Typ"].empty()) {
      typ = make_shared<string>(boost::any_cast<string>(m["Typ"]));
    }
  }


  virtual ~DescribeLiveStreamsTotalCountRequest() = default;
};
class DescribeLiveStreamsTotalCountResponseBodyStreamCountListStreamCountInfos : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> timestamp{};

  DescribeLiveStreamsTotalCountResponseBodyStreamCountListStreamCountInfos() {}

  explicit DescribeLiveStreamsTotalCountResponseBodyStreamCountListStreamCountInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~DescribeLiveStreamsTotalCountResponseBodyStreamCountListStreamCountInfos() = default;
};
class DescribeLiveStreamsTotalCountResponseBodyStreamCountList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveStreamsTotalCountResponseBodyStreamCountListStreamCountInfos>> streamCountInfos{};

  DescribeLiveStreamsTotalCountResponseBodyStreamCountList() {}

  explicit DescribeLiveStreamsTotalCountResponseBodyStreamCountList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamCountInfos) {
      vector<boost::any> temp1;
      for(auto item1:*streamCountInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamCountInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamCountInfos") != m.end() && !m["StreamCountInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamCountInfos"].type()) {
        vector<DescribeLiveStreamsTotalCountResponseBodyStreamCountListStreamCountInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamCountInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveStreamsTotalCountResponseBodyStreamCountListStreamCountInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamCountInfos = make_shared<vector<DescribeLiveStreamsTotalCountResponseBodyStreamCountListStreamCountInfos>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveStreamsTotalCountResponseBodyStreamCountList() = default;
};
class DescribeLiveStreamsTotalCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveStreamsTotalCountResponseBodyStreamCountList> streamCountList{};

  DescribeLiveStreamsTotalCountResponseBody() {}

  explicit DescribeLiveStreamsTotalCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamCountList) {
      res["StreamCountList"] = streamCountList ? boost::any(streamCountList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamCountList") != m.end() && !m["StreamCountList"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamCountList"].type()) {
        DescribeLiveStreamsTotalCountResponseBodyStreamCountList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamCountList"]));
        streamCountList = make_shared<DescribeLiveStreamsTotalCountResponseBodyStreamCountList>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsTotalCountResponseBody() = default;
};
class DescribeLiveStreamsTotalCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveStreamsTotalCountResponseBody> body{};

  DescribeLiveStreamsTotalCountResponse() {}

  explicit DescribeLiveStreamsTotalCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveStreamsTotalCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveStreamsTotalCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveStreamsTotalCountResponse() = default;
};
class DescribeLiveTopDomainsByFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> limit{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveTopDomainsByFlowRequest() {}

  explicit DescribeLiveTopDomainsByFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveTopDomainsByFlowRequest() = default;
};
class DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> maxBps{};
  shared_ptr<string> maxBpsTime{};
  shared_ptr<long> rank{};
  shared_ptr<long> totalAccess{};
  shared_ptr<string> totalTraffic{};
  shared_ptr<string> trafficPercent{};

  DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain() {}

  explicit DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (maxBps) {
      res["MaxBps"] = boost::any(*maxBps);
    }
    if (maxBpsTime) {
      res["MaxBpsTime"] = boost::any(*maxBpsTime);
    }
    if (rank) {
      res["Rank"] = boost::any(*rank);
    }
    if (totalAccess) {
      res["TotalAccess"] = boost::any(*totalAccess);
    }
    if (totalTraffic) {
      res["TotalTraffic"] = boost::any(*totalTraffic);
    }
    if (trafficPercent) {
      res["TrafficPercent"] = boost::any(*trafficPercent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MaxBps") != m.end() && !m["MaxBps"].empty()) {
      maxBps = make_shared<long>(boost::any_cast<long>(m["MaxBps"]));
    }
    if (m.find("MaxBpsTime") != m.end() && !m["MaxBpsTime"].empty()) {
      maxBpsTime = make_shared<string>(boost::any_cast<string>(m["MaxBpsTime"]));
    }
    if (m.find("Rank") != m.end() && !m["Rank"].empty()) {
      rank = make_shared<long>(boost::any_cast<long>(m["Rank"]));
    }
    if (m.find("TotalAccess") != m.end() && !m["TotalAccess"].empty()) {
      totalAccess = make_shared<long>(boost::any_cast<long>(m["TotalAccess"]));
    }
    if (m.find("TotalTraffic") != m.end() && !m["TotalTraffic"].empty()) {
      totalTraffic = make_shared<string>(boost::any_cast<string>(m["TotalTraffic"]));
    }
    if (m.find("TrafficPercent") != m.end() && !m["TrafficPercent"].empty()) {
      trafficPercent = make_shared<string>(boost::any_cast<string>(m["TrafficPercent"]));
    }
  }


  virtual ~DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain() = default;
};
class DescribeLiveTopDomainsByFlowResponseBodyTopDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain>> topDomain{};

  DescribeLiveTopDomainsByFlowResponseBodyTopDomains() {}

  explicit DescribeLiveTopDomainsByFlowResponseBodyTopDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topDomain) {
      vector<boost::any> temp1;
      for(auto item1:*topDomain){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopDomain"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopDomain") != m.end() && !m["TopDomain"].empty()) {
      if (typeid(vector<boost::any>) == m["TopDomain"].type()) {
        vector<DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopDomain"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topDomain = make_shared<vector<DescribeLiveTopDomainsByFlowResponseBodyTopDomainsTopDomain>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveTopDomainsByFlowResponseBodyTopDomains() = default;
};
class DescribeLiveTopDomainsByFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> domainCount{};
  shared_ptr<long> domainOnlineCount{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeLiveTopDomainsByFlowResponseBodyTopDomains> topDomains{};

  DescribeLiveTopDomainsByFlowResponseBody() {}

  explicit DescribeLiveTopDomainsByFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (domainOnlineCount) {
      res["DomainOnlineCount"] = boost::any(*domainOnlineCount);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (topDomains) {
      res["TopDomains"] = topDomains ? boost::any(topDomains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("DomainOnlineCount") != m.end() && !m["DomainOnlineCount"].empty()) {
      domainOnlineCount = make_shared<long>(boost::any_cast<long>(m["DomainOnlineCount"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TopDomains") != m.end() && !m["TopDomains"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopDomains"].type()) {
        DescribeLiveTopDomainsByFlowResponseBodyTopDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopDomains"]));
        topDomains = make_shared<DescribeLiveTopDomainsByFlowResponseBodyTopDomains>(model1);
      }
    }
  }


  virtual ~DescribeLiveTopDomainsByFlowResponseBody() = default;
};
class DescribeLiveTopDomainsByFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveTopDomainsByFlowResponseBody> body{};

  DescribeLiveTopDomainsByFlowResponse() {}

  explicit DescribeLiveTopDomainsByFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveTopDomainsByFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveTopDomainsByFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveTopDomainsByFlowResponse() = default;
};
class DescribeLiveTrafficDomainLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveTrafficDomainLogRequest() {}

  explicit DescribeLiveTrafficDomainLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveTrafficDomainLogRequest() = default;
};
class DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};

  DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() {}

  explicit DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() = default;
};
class DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>> logInfoDetail{};

  DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() {}

  explicit DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfoDetail) {
      vector<boost::any> temp1;
      for(auto item1:*logInfoDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfoDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfoDetail") != m.end() && !m["LogInfoDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfoDetail"].type()) {
        vector<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfoDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfoDetail = make_shared<vector<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() = default;
};
class DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() {}

  explicit DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() = default;
};
class DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetail : public Darabonba::Model {
public:
  shared_ptr<long> logCount{};
  shared_ptr<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos> logInfos{};
  shared_ptr<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos> pageInfos{};

  DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetail() {}

  explicit DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos>(model1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetail() = default;
};
class DescribeLiveTrafficDomainLogResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetail>> domainLogDetail{};

  DescribeLiveTrafficDomainLogResponseBodyDomainLogDetails() {}

  explicit DescribeLiveTrafficDomainLogResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetail") != m.end() && !m["DomainLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetail"].type()) {
        vector<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetail = make_shared<vector<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetailsDomainLogDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveTrafficDomainLogResponseBodyDomainLogDetails() = default;
};
class DescribeLiveTrafficDomainLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetails> domainLogDetails{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  DescribeLiveTrafficDomainLogResponseBody() {}

  explicit DescribeLiveTrafficDomainLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetails) {
      res["DomainLogDetails"] = domainLogDetails ? boost::any(domainLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogDetails"].type()) {
        DescribeLiveTrafficDomainLogResponseBodyDomainLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogDetails"]));
        domainLogDetails = make_shared<DescribeLiveTrafficDomainLogResponseBodyDomainLogDetails>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveTrafficDomainLogResponseBody() = default;
};
class DescribeLiveTrafficDomainLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveTrafficDomainLogResponseBody> body{};

  DescribeLiveTrafficDomainLogResponse() {}

  explicit DescribeLiveTrafficDomainLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveTrafficDomainLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveTrafficDomainLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveTrafficDomainLogResponse() = default;
};
class DescribeLiveUpVideoAudioInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> stream{};

  DescribeLiveUpVideoAudioInfoRequest() {}

  explicit DescribeLiveUpVideoAudioInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoRequest() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeadersAacHeaders : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeadersAacHeaders() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeadersAacHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeadersAacHeaders() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeadersAacHeaders>> aacHeaders{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeaders() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aacHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*aacHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AacHeaders"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AacHeaders") != m.end() && !m["AacHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["AacHeaders"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeadersAacHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AacHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeadersAacHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aacHeaders = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeadersAacHeaders>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeaders() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRateAudioBitRate : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRateAudioBitRate() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRateAudioBitRate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRateAudioBitRate() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRate : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRateAudioBitRate>> audioBitRate{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRate() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioBitRate) {
      vector<boost::any> temp1;
      for(auto item1:*audioBitRate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioBitRate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioBitRate") != m.end() && !m["AudioBitRate"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioBitRate"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRateAudioBitRate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioBitRate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRateAudioBitRate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioBitRate = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRateAudioBitRate>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRate() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFramesAudioFrames : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFramesAudioFrames() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFramesAudioFrames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFramesAudioFrames() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFrames : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFramesAudioFrames>> audioFrames{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFrames() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFrames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFrames) {
      vector<boost::any> temp1;
      for(auto item1:*audioFrames){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioFrames"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFrames") != m.end() && !m["AudioFrames"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioFrames"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFramesAudioFrames> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioFrames"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFramesAudioFrames model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioFrames = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFramesAudioFrames>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFrames() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioIntervalAudioInterval : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioIntervalAudioInterval() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioIntervalAudioInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioIntervalAudioInterval() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioIntervalAudioInterval>> audioInterval{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioInterval() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioInterval) {
      vector<boost::any> temp1;
      for(auto item1:*audioInterval){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioInterval"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioInterval") != m.end() && !m["AudioInterval"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioInterval"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioIntervalAudioInterval> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioInterval"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioIntervalAudioInterval model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioInterval = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioIntervalAudioInterval>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioInterval() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStampsAudioStamps : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStampsAudioStamps() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStampsAudioStamps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStampsAudioStamps() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStamps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStampsAudioStamps>> audioStamps{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStamps() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStamps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStamps) {
      vector<boost::any> temp1;
      for(auto item1:*audioStamps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStamps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStamps") != m.end() && !m["AudioStamps"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStamps"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStampsAudioStamps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStamps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStampsAudioStamps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStamps = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStampsAudioStamps>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStamps() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeadersAvcHeaders : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeadersAvcHeaders() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeadersAvcHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeadersAvcHeaders() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeadersAvcHeaders>> avcHeaders{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeaders() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avcHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*avcHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvcHeaders"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvcHeaders") != m.end() && !m["AvcHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["AvcHeaders"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeadersAvcHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvcHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeadersAvcHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        avcHeaders = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeadersAvcHeaders>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeaders() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlagsErrorFlags : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlagsErrorFlags() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlagsErrorFlags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlagsErrorFlags() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlagsErrorFlags>> errorFlags{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlags() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorFlags) {
      vector<boost::any> temp1;
      for(auto item1:*errorFlags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorFlags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorFlags") != m.end() && !m["ErrorFlags"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorFlags"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlagsErrorFlags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorFlags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlagsErrorFlags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorFlags = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlagsErrorFlags>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlags() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStampVAStamp : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStampVAStamp() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStampVAStamp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStampVAStamp() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStamp : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStampVAStamp>> vAStamp{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStamp() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStamp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vAStamp) {
      vector<boost::any> temp1;
      for(auto item1:*vAStamp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["V_AStamp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("V_AStamp") != m.end() && !m["V_AStamp"].empty()) {
      if (typeid(vector<boost::any>) == m["V_AStamp"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStampVAStamp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["V_AStamp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStampVAStamp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vAStamp = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStampVAStamp>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStamp() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRateVideoBitRate : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRateVideoBitRate() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRateVideoBitRate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRateVideoBitRate() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRate : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRateVideoBitRate>> videoBitRate{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRate() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoBitRate) {
      vector<boost::any> temp1;
      for(auto item1:*videoBitRate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoBitRate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoBitRate") != m.end() && !m["VideoBitRate"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoBitRate"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRateVideoBitRate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoBitRate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRateVideoBitRate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoBitRate = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRateVideoBitRate>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRate() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFramesVideoFrames : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFramesVideoFrames() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFramesVideoFrames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFramesVideoFrames() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFrames : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFramesVideoFrames>> videoFrames{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFrames() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFrames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoFrames) {
      vector<boost::any> temp1;
      for(auto item1:*videoFrames){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoFrames"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoFrames") != m.end() && !m["VideoFrames"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoFrames"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFramesVideoFrames> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoFrames"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFramesVideoFrames model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoFrames = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFramesVideoFrames>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFrames() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoIntervalVideoInterval : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoIntervalVideoInterval() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoIntervalVideoInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoIntervalVideoInterval() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoIntervalVideoInterval>> videoInterval{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoInterval() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoInterval) {
      vector<boost::any> temp1;
      for(auto item1:*videoInterval){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoInterval"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoInterval") != m.end() && !m["VideoInterval"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoInterval"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoIntervalVideoInterval> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoInterval"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoIntervalVideoInterval model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoInterval = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoIntervalVideoInterval>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoInterval() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStampsVideoStamps : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<long> value{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStampsVideoStamps() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStampsVideoStamps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStampsVideoStamps() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStamps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStampsVideoStamps>> videoStamps{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStamps() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStamps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStamps) {
      vector<boost::any> temp1;
      for(auto item1:*videoStamps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStamps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStamps") != m.end() && !m["VideoStamps"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStamps"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStampsVideoStamps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStamps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStampsVideoStamps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStamps = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStampsVideoStamps>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStamps() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItem : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeaders> aacHeaders{};
  shared_ptr<string> appName{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRate> audioBitRate{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFrames> audioFrames{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioInterval> audioInterval{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStamps> audioStamps{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeaders> avcHeaders{};
  shared_ptr<string> codecInfo{};
  shared_ptr<string> domainName{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlags> errorFlags{};
  shared_ptr<string> publishInterval{};
  shared_ptr<string> publishIp{};
  shared_ptr<string> publishStatus{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> stopTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> uniqueId{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStamp> videoAndAudioStamp{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRate> videoBitRate{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFrames> videoFrames{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoInterval> videoInterval{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStamps> videoStamps{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItem() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aacHeaders) {
      res["AacHeaders"] = aacHeaders ? boost::any(aacHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (audioBitRate) {
      res["AudioBitRate"] = audioBitRate ? boost::any(audioBitRate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioFrames) {
      res["AudioFrames"] = audioFrames ? boost::any(audioFrames->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioInterval) {
      res["AudioInterval"] = audioInterval ? boost::any(audioInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStamps) {
      res["AudioStamps"] = audioStamps ? boost::any(audioStamps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (avcHeaders) {
      res["AvcHeaders"] = avcHeaders ? boost::any(avcHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (codecInfo) {
      res["CodecInfo"] = boost::any(*codecInfo);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (errorFlags) {
      res["ErrorFlags"] = errorFlags ? boost::any(errorFlags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publishInterval) {
      res["PublishInterval"] = boost::any(*publishInterval);
    }
    if (publishIp) {
      res["PublishIp"] = boost::any(*publishIp);
    }
    if (publishStatus) {
      res["PublishStatus"] = boost::any(*publishStatus);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (uniqueId) {
      res["UniqueId"] = boost::any(*uniqueId);
    }
    if (videoAndAudioStamp) {
      res["VideoAndAudioStamp"] = videoAndAudioStamp ? boost::any(videoAndAudioStamp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoBitRate) {
      res["VideoBitRate"] = videoBitRate ? boost::any(videoBitRate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoFrames) {
      res["VideoFrames"] = videoFrames ? boost::any(videoFrames->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoInterval) {
      res["VideoInterval"] = videoInterval ? boost::any(videoInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStamps) {
      res["VideoStamps"] = videoStamps ? boost::any(videoStamps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AacHeaders") != m.end() && !m["AacHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["AacHeaders"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AacHeaders"]));
        aacHeaders = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAacHeaders>(model1);
      }
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AudioBitRate") != m.end() && !m["AudioBitRate"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioBitRate"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioBitRate"]));
        audioBitRate = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioBitRate>(model1);
      }
    }
    if (m.find("AudioFrames") != m.end() && !m["AudioFrames"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioFrames"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFrames model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioFrames"]));
        audioFrames = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioFrames>(model1);
      }
    }
    if (m.find("AudioInterval") != m.end() && !m["AudioInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioInterval"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioInterval"]));
        audioInterval = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioInterval>(model1);
      }
    }
    if (m.find("AudioStamps") != m.end() && !m["AudioStamps"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStamps"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStamps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStamps"]));
        audioStamps = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAudioStamps>(model1);
      }
    }
    if (m.find("AvcHeaders") != m.end() && !m["AvcHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvcHeaders"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvcHeaders"]));
        avcHeaders = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemAvcHeaders>(model1);
      }
    }
    if (m.find("CodecInfo") != m.end() && !m["CodecInfo"].empty()) {
      codecInfo = make_shared<string>(boost::any_cast<string>(m["CodecInfo"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ErrorFlags") != m.end() && !m["ErrorFlags"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorFlags"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorFlags"]));
        errorFlags = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemErrorFlags>(model1);
      }
    }
    if (m.find("PublishInterval") != m.end() && !m["PublishInterval"].empty()) {
      publishInterval = make_shared<string>(boost::any_cast<string>(m["PublishInterval"]));
    }
    if (m.find("PublishIp") != m.end() && !m["PublishIp"].empty()) {
      publishIp = make_shared<string>(boost::any_cast<string>(m["PublishIp"]));
    }
    if (m.find("PublishStatus") != m.end() && !m["PublishStatus"].empty()) {
      publishStatus = make_shared<string>(boost::any_cast<string>(m["PublishStatus"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["StopTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("UniqueId") != m.end() && !m["UniqueId"].empty()) {
      uniqueId = make_shared<string>(boost::any_cast<string>(m["UniqueId"]));
    }
    if (m.find("VideoAndAudioStamp") != m.end() && !m["VideoAndAudioStamp"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoAndAudioStamp"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStamp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoAndAudioStamp"]));
        videoAndAudioStamp = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoAndAudioStamp>(model1);
      }
    }
    if (m.find("VideoBitRate") != m.end() && !m["VideoBitRate"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoBitRate"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoBitRate"]));
        videoBitRate = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoBitRate>(model1);
      }
    }
    if (m.find("VideoFrames") != m.end() && !m["VideoFrames"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoFrames"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFrames model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoFrames"]));
        videoFrames = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoFrames>(model1);
      }
    }
    if (m.find("VideoInterval") != m.end() && !m["VideoInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoInterval"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoInterval"]));
        videoInterval = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoInterval>(model1);
      }
    }
    if (m.find("VideoStamps") != m.end() && !m["VideoStamps"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStamps"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStamps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStamps"]));
        videoStamps = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItemVideoStamps>(model1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItem() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBodyUpItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItem>> publishItem{};

  DescribeLiveUpVideoAudioInfoResponseBodyUpItems() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBodyUpItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publishItem) {
      vector<boost::any> temp1;
      for(auto item1:*publishItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublishItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublishItem") != m.end() && !m["PublishItem"].empty()) {
      if (typeid(vector<boost::any>) == m["PublishItem"].type()) {
        vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublishItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publishItem = make_shared<vector<DescribeLiveUpVideoAudioInfoResponseBodyUpItemsPublishItem>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBodyUpItems() = default;
};
class DescribeLiveUpVideoAudioInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBodyUpItems> upItems{};

  DescribeLiveUpVideoAudioInfoResponseBody() {}

  explicit DescribeLiveUpVideoAudioInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (upItems) {
      res["UpItems"] = upItems ? boost::any(upItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UpItems") != m.end() && !m["UpItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpItems"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBodyUpItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpItems"]));
        upItems = make_shared<DescribeLiveUpVideoAudioInfoResponseBodyUpItems>(model1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponseBody() = default;
};
class DescribeLiveUpVideoAudioInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveUpVideoAudioInfoResponseBody> body{};

  DescribeLiveUpVideoAudioInfoResponse() {}

  explicit DescribeLiveUpVideoAudioInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveUpVideoAudioInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveUpVideoAudioInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveUpVideoAudioInfoResponse() = default;
};
class DescribeLiveUserBillPredictionRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveUserBillPredictionRequest() {}

  explicit DescribeLiveUserBillPredictionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveUserBillPredictionRequest() = default;
};
class DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> timeStp{};
  shared_ptr<double> value{};

  DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem() {}

  explicit DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (timeStp) {
      res["TimeStp"] = boost::any(*timeStp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("TimeStp") != m.end() && !m["TimeStp"].empty()) {
      timeStp = make_shared<string>(boost::any_cast<string>(m["TimeStp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem() = default;
};
class DescribeLiveUserBillPredictionResponseBodyBillPredictionData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem>> billPredictionDataItem{};

  DescribeLiveUserBillPredictionResponseBodyBillPredictionData() {}

  explicit DescribeLiveUserBillPredictionResponseBodyBillPredictionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billPredictionDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billPredictionDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillPredictionDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillPredictionDataItem") != m.end() && !m["BillPredictionDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillPredictionDataItem"].type()) {
        vector<DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillPredictionDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billPredictionDataItem = make_shared<vector<DescribeLiveUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUserBillPredictionResponseBodyBillPredictionData() = default;
};
class DescribeLiveUserBillPredictionResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveUserBillPredictionResponseBodyBillPredictionData> billPredictionData{};
  shared_ptr<string> billType{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeLiveUserBillPredictionResponseBody() {}

  explicit DescribeLiveUserBillPredictionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billPredictionData) {
      res["BillPredictionData"] = billPredictionData ? boost::any(billPredictionData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (billType) {
      res["BillType"] = boost::any(*billType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillPredictionData") != m.end() && !m["BillPredictionData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillPredictionData"].type()) {
        DescribeLiveUserBillPredictionResponseBodyBillPredictionData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillPredictionData"]));
        billPredictionData = make_shared<DescribeLiveUserBillPredictionResponseBodyBillPredictionData>(model1);
      }
    }
    if (m.find("BillType") != m.end() && !m["BillType"].empty()) {
      billType = make_shared<string>(boost::any_cast<string>(m["BillType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveUserBillPredictionResponseBody() = default;
};
class DescribeLiveUserBillPredictionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveUserBillPredictionResponseBody> body{};

  DescribeLiveUserBillPredictionResponse() {}

  explicit DescribeLiveUserBillPredictionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveUserBillPredictionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveUserBillPredictionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveUserBillPredictionResponse() = default;
};
class DescribeLiveUserDomainsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeLiveUserDomainsRequestTag() {}

  explicit DescribeLiveUserDomainsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLiveUserDomainsRequestTag() = default;
};
class DescribeLiveUserDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSearchType{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> liveDomainType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeLiveUserDomainsRequestTag>> tag{};

  DescribeLiveUserDomainsRequest() {}

  explicit DescribeLiveUserDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSearchType) {
      res["DomainSearchType"] = boost::any(*domainSearchType);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (liveDomainType) {
      res["LiveDomainType"] = boost::any(*liveDomainType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSearchType") != m.end() && !m["DomainSearchType"].empty()) {
      domainSearchType = make_shared<string>(boost::any_cast<string>(m["DomainSearchType"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("LiveDomainType") != m.end() && !m["LiveDomainType"].empty()) {
      liveDomainType = make_shared<string>(boost::any_cast<string>(m["LiveDomainType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeLiveUserDomainsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUserDomainsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeLiveUserDomainsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUserDomainsRequest() = default;
};
class DescribeLiveUserDomainsResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> liveDomainStatus{};
  shared_ptr<string> liveDomainType{};
  shared_ptr<string> regionName{};
  shared_ptr<string> resourceGroupId{};

  DescribeLiveUserDomainsResponseBodyDomainsPageData() {}

  explicit DescribeLiveUserDomainsResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (liveDomainStatus) {
      res["LiveDomainStatus"] = boost::any(*liveDomainStatus);
    }
    if (liveDomainType) {
      res["LiveDomainType"] = boost::any(*liveDomainType);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("LiveDomainStatus") != m.end() && !m["LiveDomainStatus"].empty()) {
      liveDomainStatus = make_shared<string>(boost::any_cast<string>(m["LiveDomainStatus"]));
    }
    if (m.find("LiveDomainType") != m.end() && !m["LiveDomainType"].empty()) {
      liveDomainType = make_shared<string>(boost::any_cast<string>(m["LiveDomainType"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeLiveUserDomainsResponseBodyDomainsPageData() = default;
};
class DescribeLiveUserDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUserDomainsResponseBodyDomainsPageData>> pageData{};

  DescribeLiveUserDomainsResponseBodyDomains() {}

  explicit DescribeLiveUserDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeLiveUserDomainsResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUserDomainsResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeLiveUserDomainsResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUserDomainsResponseBodyDomains() = default;
};
class DescribeLiveUserDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveUserDomainsResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLiveUserDomainsResponseBody() {}

  explicit DescribeLiveUserDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeLiveUserDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeLiveUserDomainsResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLiveUserDomainsResponseBody() = default;
};
class DescribeLiveUserDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveUserDomainsResponseBody> body{};

  DescribeLiveUserDomainsResponse() {}

  explicit DescribeLiveUserDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveUserDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveUserDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveUserDomainsResponse() = default;
};
class DescribeLiveUserStreamMetricDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> protocol{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeLiveUserStreamMetricDataRequest() {}

  explicit DescribeLiveUserStreamMetricDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeLiveUserStreamMetricDataRequest() = default;
};
class DescribeLiveUserStreamMetricDataResponseBodyStreamDetailData : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<double> bps{};
  shared_ptr<long> count{};
  shared_ptr<double> flvBps{};
  shared_ptr<long> flvCount{};
  shared_ptr<double> flvTraffic{};
  shared_ptr<double> hlsBps{};
  shared_ptr<long> hlsCount{};
  shared_ptr<double> hlsTraffic{};
  shared_ptr<long> newConns{};
  shared_ptr<double> p2pBps{};
  shared_ptr<long> p2pCount{};
  shared_ptr<double> p2pTraffic{};
  shared_ptr<double> rtmpBps{};
  shared_ptr<long> rtmpCount{};
  shared_ptr<double> rtmpTraffic{};
  shared_ptr<double> rtsBps{};
  shared_ptr<long> rtsCount{};
  shared_ptr<double> rtsTraffic{};
  shared_ptr<string> streamName{};
  shared_ptr<string> timeStamp{};
  shared_ptr<double> traffic{};

  DescribeLiveUserStreamMetricDataResponseBodyStreamDetailData() {}

  explicit DescribeLiveUserStreamMetricDataResponseBodyStreamDetailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (flvBps) {
      res["FlvBps"] = boost::any(*flvBps);
    }
    if (flvCount) {
      res["FlvCount"] = boost::any(*flvCount);
    }
    if (flvTraffic) {
      res["FlvTraffic"] = boost::any(*flvTraffic);
    }
    if (hlsBps) {
      res["HlsBps"] = boost::any(*hlsBps);
    }
    if (hlsCount) {
      res["HlsCount"] = boost::any(*hlsCount);
    }
    if (hlsTraffic) {
      res["HlsTraffic"] = boost::any(*hlsTraffic);
    }
    if (newConns) {
      res["NewConns"] = boost::any(*newConns);
    }
    if (p2pBps) {
      res["P2pBps"] = boost::any(*p2pBps);
    }
    if (p2pCount) {
      res["P2pCount"] = boost::any(*p2pCount);
    }
    if (p2pTraffic) {
      res["P2pTraffic"] = boost::any(*p2pTraffic);
    }
    if (rtmpBps) {
      res["RtmpBps"] = boost::any(*rtmpBps);
    }
    if (rtmpCount) {
      res["RtmpCount"] = boost::any(*rtmpCount);
    }
    if (rtmpTraffic) {
      res["RtmpTraffic"] = boost::any(*rtmpTraffic);
    }
    if (rtsBps) {
      res["RtsBps"] = boost::any(*rtsBps);
    }
    if (rtsCount) {
      res["RtsCount"] = boost::any(*rtsCount);
    }
    if (rtsTraffic) {
      res["RtsTraffic"] = boost::any(*rtsTraffic);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (traffic) {
      res["Traffic"] = boost::any(*traffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("FlvBps") != m.end() && !m["FlvBps"].empty()) {
      flvBps = make_shared<double>(boost::any_cast<double>(m["FlvBps"]));
    }
    if (m.find("FlvCount") != m.end() && !m["FlvCount"].empty()) {
      flvCount = make_shared<long>(boost::any_cast<long>(m["FlvCount"]));
    }
    if (m.find("FlvTraffic") != m.end() && !m["FlvTraffic"].empty()) {
      flvTraffic = make_shared<double>(boost::any_cast<double>(m["FlvTraffic"]));
    }
    if (m.find("HlsBps") != m.end() && !m["HlsBps"].empty()) {
      hlsBps = make_shared<double>(boost::any_cast<double>(m["HlsBps"]));
    }
    if (m.find("HlsCount") != m.end() && !m["HlsCount"].empty()) {
      hlsCount = make_shared<long>(boost::any_cast<long>(m["HlsCount"]));
    }
    if (m.find("HlsTraffic") != m.end() && !m["HlsTraffic"].empty()) {
      hlsTraffic = make_shared<double>(boost::any_cast<double>(m["HlsTraffic"]));
    }
    if (m.find("NewConns") != m.end() && !m["NewConns"].empty()) {
      newConns = make_shared<long>(boost::any_cast<long>(m["NewConns"]));
    }
    if (m.find("P2pBps") != m.end() && !m["P2pBps"].empty()) {
      p2pBps = make_shared<double>(boost::any_cast<double>(m["P2pBps"]));
    }
    if (m.find("P2pCount") != m.end() && !m["P2pCount"].empty()) {
      p2pCount = make_shared<long>(boost::any_cast<long>(m["P2pCount"]));
    }
    if (m.find("P2pTraffic") != m.end() && !m["P2pTraffic"].empty()) {
      p2pTraffic = make_shared<double>(boost::any_cast<double>(m["P2pTraffic"]));
    }
    if (m.find("RtmpBps") != m.end() && !m["RtmpBps"].empty()) {
      rtmpBps = make_shared<double>(boost::any_cast<double>(m["RtmpBps"]));
    }
    if (m.find("RtmpCount") != m.end() && !m["RtmpCount"].empty()) {
      rtmpCount = make_shared<long>(boost::any_cast<long>(m["RtmpCount"]));
    }
    if (m.find("RtmpTraffic") != m.end() && !m["RtmpTraffic"].empty()) {
      rtmpTraffic = make_shared<double>(boost::any_cast<double>(m["RtmpTraffic"]));
    }
    if (m.find("RtsBps") != m.end() && !m["RtsBps"].empty()) {
      rtsBps = make_shared<double>(boost::any_cast<double>(m["RtsBps"]));
    }
    if (m.find("RtsCount") != m.end() && !m["RtsCount"].empty()) {
      rtsCount = make_shared<long>(boost::any_cast<long>(m["RtsCount"]));
    }
    if (m.find("RtsTraffic") != m.end() && !m["RtsTraffic"].empty()) {
      rtsTraffic = make_shared<double>(boost::any_cast<double>(m["RtsTraffic"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Traffic") != m.end() && !m["Traffic"].empty()) {
      traffic = make_shared<double>(boost::any_cast<double>(m["Traffic"]));
    }
  }


  virtual ~DescribeLiveUserStreamMetricDataResponseBodyStreamDetailData() = default;
};
class DescribeLiveUserStreamMetricDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<vector<DescribeLiveUserStreamMetricDataResponseBodyStreamDetailData>> streamDetailData{};
  shared_ptr<long> totalCount{};

  DescribeLiveUserStreamMetricDataResponseBody() {}

  explicit DescribeLiveUserStreamMetricDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamDetailData) {
      vector<boost::any> temp1;
      for(auto item1:*streamDetailData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamDetailData"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamDetailData") != m.end() && !m["StreamDetailData"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamDetailData"].type()) {
        vector<DescribeLiveUserStreamMetricDataResponseBodyStreamDetailData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamDetailData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUserStreamMetricDataResponseBodyStreamDetailData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamDetailData = make_shared<vector<DescribeLiveUserStreamMetricDataResponseBodyStreamDetailData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLiveUserStreamMetricDataResponseBody() = default;
};
class DescribeLiveUserStreamMetricDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveUserStreamMetricDataResponseBody> body{};

  DescribeLiveUserStreamMetricDataResponse() {}

  explicit DescribeLiveUserStreamMetricDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveUserStreamMetricDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveUserStreamMetricDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveUserStreamMetricDataResponse() = default;
};
class DescribeLiveUserTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveUserTagsRequest() {}

  explicit DescribeLiveUserTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveUserTagsRequest() = default;
};
class DescribeLiveUserTagsResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeLiveUserTagsResponseBodyTags() {}

  explicit DescribeLiveUserTagsResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLiveUserTagsResponseBodyTags() = default;
};
class DescribeLiveUserTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeLiveUserTagsResponseBodyTags>> tags{};

  DescribeLiveUserTagsResponseBody() {}

  explicit DescribeLiveUserTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeLiveUserTagsResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUserTagsResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeLiveUserTagsResponseBodyTags>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUserTagsResponseBody() = default;
};
class DescribeLiveUserTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveUserTagsResponseBody> body{};

  DescribeLiveUserTagsResponse() {}

  explicit DescribeLiveUserTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveUserTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveUserTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveUserTagsResponse() = default;
};
class DescribeLiveUserTrafficLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeLiveUserTrafficLogRequest() {}

  explicit DescribeLiveUserTrafficLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveUserTrafficLogRequest() = default;
};
class DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};

  DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() {}

  explicit DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() = default;
};
class DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>> logInfoDetail{};

  DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() {}

  explicit DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfoDetail) {
      vector<boost::any> temp1;
      for(auto item1:*logInfoDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfoDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfoDetail") != m.end() && !m["LogInfoDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfoDetail"].type()) {
        vector<DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfoDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfoDetail = make_shared<vector<DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() = default;
};
class DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() {}

  explicit DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() = default;
};
class DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetail : public Darabonba::Model {
public:
  shared_ptr<long> logCount{};
  shared_ptr<DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos> logInfos{};
  shared_ptr<DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos> pageInfos{};

  DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetail() {}

  explicit DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos>(model1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetail() = default;
};
class DescribeLiveUserTrafficLogResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetail>> domainLogDetail{};

  DescribeLiveUserTrafficLogResponseBodyDomainLogDetails() {}

  explicit DescribeLiveUserTrafficLogResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetail") != m.end() && !m["DomainLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetail"].type()) {
        vector<DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetail = make_shared<vector<DescribeLiveUserTrafficLogResponseBodyDomainLogDetailsDomainLogDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeLiveUserTrafficLogResponseBodyDomainLogDetails() = default;
};
class DescribeLiveUserTrafficLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLiveUserTrafficLogResponseBodyDomainLogDetails> domainLogDetails{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  DescribeLiveUserTrafficLogResponseBody() {}

  explicit DescribeLiveUserTrafficLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetails) {
      res["DomainLogDetails"] = domainLogDetails ? boost::any(domainLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogDetails"].type()) {
        DescribeLiveUserTrafficLogResponseBodyDomainLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogDetails"]));
        domainLogDetails = make_shared<DescribeLiveUserTrafficLogResponseBodyDomainLogDetails>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveUserTrafficLogResponseBody() = default;
};
class DescribeLiveUserTrafficLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveUserTrafficLogResponseBody> body{};

  DescribeLiveUserTrafficLogResponse() {}

  explicit DescribeLiveUserTrafficLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveUserTrafficLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveUserTrafficLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveUserTrafficLogResponse() = default;
};
class DescribeLiveVerifyContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeLiveVerifyContentRequest() {}

  explicit DescribeLiveVerifyContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLiveVerifyContentRequest() = default;
};
class DescribeLiveVerifyContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeLiveVerifyContentResponseBody() {}

  explicit DescribeLiveVerifyContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLiveVerifyContentResponseBody() = default;
};
class DescribeLiveVerifyContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLiveVerifyContentResponseBody> body{};

  DescribeLiveVerifyContentResponse() {}

  explicit DescribeLiveVerifyContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLiveVerifyContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLiveVerifyContentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLiveVerifyContentResponse() = default;
};
class DescribeMeterLiveBypassDurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};

  DescribeMeterLiveBypassDurationRequest() {}

  explicit DescribeMeterLiveBypassDurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeMeterLiveBypassDurationRequest() = default;
};
class DescribeMeterLiveBypassDurationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> audioDuration{};
  shared_ptr<long> singleAudio{};
  shared_ptr<long> singleVideo{};
  shared_ptr<string> timestamp{};
  shared_ptr<long> totalDuration{};
  shared_ptr<long> v1080Duration{};
  shared_ptr<long> v480Duration{};
  shared_ptr<long> v720Duration{};

  DescribeMeterLiveBypassDurationResponseBodyData() {}

  explicit DescribeMeterLiveBypassDurationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioDuration) {
      res["AudioDuration"] = boost::any(*audioDuration);
    }
    if (singleAudio) {
      res["Single_Audio"] = boost::any(*singleAudio);
    }
    if (singleVideo) {
      res["Single_Video"] = boost::any(*singleVideo);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (totalDuration) {
      res["TotalDuration"] = boost::any(*totalDuration);
    }
    if (v1080Duration) {
      res["V1080Duration"] = boost::any(*v1080Duration);
    }
    if (v480Duration) {
      res["V480Duration"] = boost::any(*v480Duration);
    }
    if (v720Duration) {
      res["V720Duration"] = boost::any(*v720Duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioDuration") != m.end() && !m["AudioDuration"].empty()) {
      audioDuration = make_shared<long>(boost::any_cast<long>(m["AudioDuration"]));
    }
    if (m.find("Single_Audio") != m.end() && !m["Single_Audio"].empty()) {
      singleAudio = make_shared<long>(boost::any_cast<long>(m["Single_Audio"]));
    }
    if (m.find("Single_Video") != m.end() && !m["Single_Video"].empty()) {
      singleVideo = make_shared<long>(boost::any_cast<long>(m["Single_Video"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("TotalDuration") != m.end() && !m["TotalDuration"].empty()) {
      totalDuration = make_shared<long>(boost::any_cast<long>(m["TotalDuration"]));
    }
    if (m.find("V1080Duration") != m.end() && !m["V1080Duration"].empty()) {
      v1080Duration = make_shared<long>(boost::any_cast<long>(m["V1080Duration"]));
    }
    if (m.find("V480Duration") != m.end() && !m["V480Duration"].empty()) {
      v480Duration = make_shared<long>(boost::any_cast<long>(m["V480Duration"]));
    }
    if (m.find("V720Duration") != m.end() && !m["V720Duration"].empty()) {
      v720Duration = make_shared<long>(boost::any_cast<long>(m["V720Duration"]));
    }
  }


  virtual ~DescribeMeterLiveBypassDurationResponseBodyData() = default;
};
class DescribeMeterLiveBypassDurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> audioSummaryDuration{};
  shared_ptr<vector<DescribeMeterLiveBypassDurationResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> singleAudioSummaryDuration{};
  shared_ptr<long> singleVideoSummaryDuration{};
  shared_ptr<long> totalSummaryDuration{};
  shared_ptr<long> v1080SummaryDuration{};
  shared_ptr<long> v480SummaryDuration{};
  shared_ptr<long> v720SummaryDuration{};

  DescribeMeterLiveBypassDurationResponseBody() {}

  explicit DescribeMeterLiveBypassDurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSummaryDuration) {
      res["AudioSummaryDuration"] = boost::any(*audioSummaryDuration);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (singleAudioSummaryDuration) {
      res["SingleAudioSummaryDuration"] = boost::any(*singleAudioSummaryDuration);
    }
    if (singleVideoSummaryDuration) {
      res["SingleVideoSummaryDuration"] = boost::any(*singleVideoSummaryDuration);
    }
    if (totalSummaryDuration) {
      res["TotalSummaryDuration"] = boost::any(*totalSummaryDuration);
    }
    if (v1080SummaryDuration) {
      res["V1080SummaryDuration"] = boost::any(*v1080SummaryDuration);
    }
    if (v480SummaryDuration) {
      res["V480SummaryDuration"] = boost::any(*v480SummaryDuration);
    }
    if (v720SummaryDuration) {
      res["V720SummaryDuration"] = boost::any(*v720SummaryDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSummaryDuration") != m.end() && !m["AudioSummaryDuration"].empty()) {
      audioSummaryDuration = make_shared<long>(boost::any_cast<long>(m["AudioSummaryDuration"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterLiveBypassDurationResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterLiveBypassDurationResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterLiveBypassDurationResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SingleAudioSummaryDuration") != m.end() && !m["SingleAudioSummaryDuration"].empty()) {
      singleAudioSummaryDuration = make_shared<long>(boost::any_cast<long>(m["SingleAudioSummaryDuration"]));
    }
    if (m.find("SingleVideoSummaryDuration") != m.end() && !m["SingleVideoSummaryDuration"].empty()) {
      singleVideoSummaryDuration = make_shared<long>(boost::any_cast<long>(m["SingleVideoSummaryDuration"]));
    }
    if (m.find("TotalSummaryDuration") != m.end() && !m["TotalSummaryDuration"].empty()) {
      totalSummaryDuration = make_shared<long>(boost::any_cast<long>(m["TotalSummaryDuration"]));
    }
    if (m.find("V1080SummaryDuration") != m.end() && !m["V1080SummaryDuration"].empty()) {
      v1080SummaryDuration = make_shared<long>(boost::any_cast<long>(m["V1080SummaryDuration"]));
    }
    if (m.find("V480SummaryDuration") != m.end() && !m["V480SummaryDuration"].empty()) {
      v480SummaryDuration = make_shared<long>(boost::any_cast<long>(m["V480SummaryDuration"]));
    }
    if (m.find("V720SummaryDuration") != m.end() && !m["V720SummaryDuration"].empty()) {
      v720SummaryDuration = make_shared<long>(boost::any_cast<long>(m["V720SummaryDuration"]));
    }
  }


  virtual ~DescribeMeterLiveBypassDurationResponseBody() = default;
};
class DescribeMeterLiveBypassDurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterLiveBypassDurationResponseBody> body{};

  DescribeMeterLiveBypassDurationResponse() {}

  explicit DescribeMeterLiveBypassDurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterLiveBypassDurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterLiveBypassDurationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterLiveBypassDurationResponse() = default;
};
class DescribeMixStreamListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> mixStreamId{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeMixStreamListRequest() {}

  explicit DescribeMixStreamListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeMixStreamListRequest() = default;
};
class DescribeMixStreamListResponseBodyMixStreamList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> inputStreamNumber{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> mixStreamTemplate{};
  shared_ptr<string> mixstreamId{};
  shared_ptr<string> streamName{};

  DescribeMixStreamListResponseBodyMixStreamList() {}

  explicit DescribeMixStreamListResponseBodyMixStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (inputStreamNumber) {
      res["InputStreamNumber"] = boost::any(*inputStreamNumber);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (mixStreamTemplate) {
      res["MixStreamTemplate"] = boost::any(*mixStreamTemplate);
    }
    if (mixstreamId) {
      res["MixstreamId"] = boost::any(*mixstreamId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("InputStreamNumber") != m.end() && !m["InputStreamNumber"].empty()) {
      inputStreamNumber = make_shared<long>(boost::any_cast<long>(m["InputStreamNumber"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("MixStreamTemplate") != m.end() && !m["MixStreamTemplate"].empty()) {
      mixStreamTemplate = make_shared<string>(boost::any_cast<string>(m["MixStreamTemplate"]));
    }
    if (m.find("MixstreamId") != m.end() && !m["MixstreamId"].empty()) {
      mixstreamId = make_shared<string>(boost::any_cast<string>(m["MixstreamId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeMixStreamListResponseBodyMixStreamList() = default;
};
class DescribeMixStreamListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMixStreamListResponseBodyMixStreamList>> mixStreamList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeMixStreamListResponseBody() {}

  explicit DescribeMixStreamListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixStreamList) {
      vector<boost::any> temp1;
      for(auto item1:*mixStreamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MixStreamList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixStreamList") != m.end() && !m["MixStreamList"].empty()) {
      if (typeid(vector<boost::any>) == m["MixStreamList"].type()) {
        vector<DescribeMixStreamListResponseBodyMixStreamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MixStreamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMixStreamListResponseBodyMixStreamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mixStreamList = make_shared<vector<DescribeMixStreamListResponseBodyMixStreamList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeMixStreamListResponseBody() = default;
};
class DescribeMixStreamListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMixStreamListResponseBody> body{};

  DescribeMixStreamListResponse() {}

  explicit DescribeMixStreamListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMixStreamListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMixStreamListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMixStreamListResponse() = default;
};
class DescribeRTSNativeSDKFirstFrameCostRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameCostRequest() {}

  explicit DescribeRTSNativeSDKFirstFrameCostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameCostRequest() = default;
};
class DescribeRTSNativeSDKFirstFrameCostShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainNameListShrink{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameCostShrinkRequest() {}

  explicit DescribeRTSNativeSDKFirstFrameCostShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameListShrink) {
      res["DomainNameList"] = boost::any(*domainNameListShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      domainNameListShrink = make_shared<string>(boost::any_cast<string>(m["DomainNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameCostShrinkRequest() = default;
};
class DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData : public Darabonba::Model {
public:
  shared_ptr<string> connected{};
  shared_ptr<string> finishGetStreamInfo{};
  shared_ptr<string> firstFrameComplete{};
  shared_ptr<string> firstPacket{};
  shared_ptr<string> initialized{};
  shared_ptr<string> timeStamp{};

  DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData() {}

  explicit DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connected) {
      res["Connected"] = boost::any(*connected);
    }
    if (finishGetStreamInfo) {
      res["FinishGetStreamInfo"] = boost::any(*finishGetStreamInfo);
    }
    if (firstFrameComplete) {
      res["FirstFrameComplete"] = boost::any(*firstFrameComplete);
    }
    if (firstPacket) {
      res["FirstPacket"] = boost::any(*firstPacket);
    }
    if (initialized) {
      res["Initialized"] = boost::any(*initialized);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Connected") != m.end() && !m["Connected"].empty()) {
      connected = make_shared<string>(boost::any_cast<string>(m["Connected"]));
    }
    if (m.find("FinishGetStreamInfo") != m.end() && !m["FinishGetStreamInfo"].empty()) {
      finishGetStreamInfo = make_shared<string>(boost::any_cast<string>(m["FinishGetStreamInfo"]));
    }
    if (m.find("FirstFrameComplete") != m.end() && !m["FirstFrameComplete"].empty()) {
      firstFrameComplete = make_shared<string>(boost::any_cast<string>(m["FirstFrameComplete"]));
    }
    if (m.find("FirstPacket") != m.end() && !m["FirstPacket"].empty()) {
      firstPacket = make_shared<string>(boost::any_cast<string>(m["FirstPacket"]));
    }
    if (m.find("Initialized") != m.end() && !m["Initialized"].empty()) {
      initialized = make_shared<string>(boost::any_cast<string>(m["Initialized"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData() = default;
};
class DescribeRTSNativeSDKFirstFrameCostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<vector<DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData>> firstFrameCostData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameCostResponseBody() {}

  explicit DescribeRTSNativeSDKFirstFrameCostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (firstFrameCostData) {
      vector<boost::any> temp1;
      for(auto item1:*firstFrameCostData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FirstFrameCostData"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FirstFrameCostData") != m.end() && !m["FirstFrameCostData"].empty()) {
      if (typeid(vector<boost::any>) == m["FirstFrameCostData"].type()) {
        vector<DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FirstFrameCostData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        firstFrameCostData = make_shared<vector<DescribeRTSNativeSDKFirstFrameCostResponseBodyFirstFrameCostData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameCostResponseBody() = default;
};
class DescribeRTSNativeSDKFirstFrameCostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRTSNativeSDKFirstFrameCostResponseBody> body{};

  DescribeRTSNativeSDKFirstFrameCostResponse() {}

  explicit DescribeRTSNativeSDKFirstFrameCostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRTSNativeSDKFirstFrameCostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRTSNativeSDKFirstFrameCostResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameCostResponse() = default;
};
class DescribeRTSNativeSDKFirstFrameDelayRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameDelayRequest() {}

  explicit DescribeRTSNativeSDKFirstFrameDelayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameDelayRequest() = default;
};
class DescribeRTSNativeSDKFirstFrameDelayShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainNameListShrink{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameDelayShrinkRequest() {}

  explicit DescribeRTSNativeSDKFirstFrameDelayShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameListShrink) {
      res["DomainNameList"] = boost::any(*domainNameListShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      domainNameListShrink = make_shared<string>(boost::any_cast<string>(m["DomainNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameDelayShrinkRequest() = default;
};
class DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData : public Darabonba::Model {
public:
  shared_ptr<string> frameDelay{};
  shared_ptr<string> timeStamp{};

  DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData() {}

  explicit DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameDelay) {
      res["FrameDelay"] = boost::any(*frameDelay);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameDelay") != m.end() && !m["FrameDelay"].empty()) {
      frameDelay = make_shared<string>(boost::any_cast<string>(m["FrameDelay"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData() = default;
};
class DescribeRTSNativeSDKFirstFrameDelayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<vector<DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData>> frameDelayData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKFirstFrameDelayResponseBody() {}

  explicit DescribeRTSNativeSDKFirstFrameDelayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (frameDelayData) {
      vector<boost::any> temp1;
      for(auto item1:*frameDelayData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrameDelayData"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FrameDelayData") != m.end() && !m["FrameDelayData"].empty()) {
      if (typeid(vector<boost::any>) == m["FrameDelayData"].type()) {
        vector<DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrameDelayData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frameDelayData = make_shared<vector<DescribeRTSNativeSDKFirstFrameDelayResponseBodyFrameDelayData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameDelayResponseBody() = default;
};
class DescribeRTSNativeSDKFirstFrameDelayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRTSNativeSDKFirstFrameDelayResponseBody> body{};

  DescribeRTSNativeSDKFirstFrameDelayResponse() {}

  explicit DescribeRTSNativeSDKFirstFrameDelayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRTSNativeSDKFirstFrameDelayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRTSNativeSDKFirstFrameDelayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKFirstFrameDelayResponse() = default;
};
class DescribeRTSNativeSDKPlayFailStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayFailStatusRequest() {}

  explicit DescribeRTSNativeSDKPlayFailStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayFailStatusRequest() = default;
};
class DescribeRTSNativeSDKPlayFailStatusShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainNameListShrink{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayFailStatusShrinkRequest() {}

  explicit DescribeRTSNativeSDKPlayFailStatusShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameListShrink) {
      res["DomainNameList"] = boost::any(*domainNameListShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      domainNameListShrink = make_shared<string>(boost::any_cast<string>(m["DomainNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayFailStatusShrinkRequest() = default;
};
class DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> v20001{};
  shared_ptr<string> v20002{};
  shared_ptr<string> v20011{};
  shared_ptr<string> v20012{};
  shared_ptr<string> v20013{};
  shared_ptr<string> v20052{};

  DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus() {}

  explicit DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (v20001) {
      res["V20001"] = boost::any(*v20001);
    }
    if (v20002) {
      res["V20002"] = boost::any(*v20002);
    }
    if (v20011) {
      res["V20011"] = boost::any(*v20011);
    }
    if (v20012) {
      res["V20012"] = boost::any(*v20012);
    }
    if (v20013) {
      res["V20013"] = boost::any(*v20013);
    }
    if (v20052) {
      res["V20052"] = boost::any(*v20052);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("V20001") != m.end() && !m["V20001"].empty()) {
      v20001 = make_shared<string>(boost::any_cast<string>(m["V20001"]));
    }
    if (m.find("V20002") != m.end() && !m["V20002"].empty()) {
      v20002 = make_shared<string>(boost::any_cast<string>(m["V20002"]));
    }
    if (m.find("V20011") != m.end() && !m["V20011"].empty()) {
      v20011 = make_shared<string>(boost::any_cast<string>(m["V20011"]));
    }
    if (m.find("V20012") != m.end() && !m["V20012"].empty()) {
      v20012 = make_shared<string>(boost::any_cast<string>(m["V20012"]));
    }
    if (m.find("V20013") != m.end() && !m["V20013"].empty()) {
      v20013 = make_shared<string>(boost::any_cast<string>(m["V20013"]));
    }
    if (m.find("V20052") != m.end() && !m["V20052"].empty()) {
      v20052 = make_shared<string>(boost::any_cast<string>(m["V20052"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus() = default;
};
class DescribeRTSNativeSDKPlayFailStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<vector<DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus>> playFailStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayFailStatusResponseBody() {}

  explicit DescribeRTSNativeSDKPlayFailStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (playFailStatus) {
      vector<boost::any> temp1;
      for(auto item1:*playFailStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlayFailStatus"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PlayFailStatus") != m.end() && !m["PlayFailStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["PlayFailStatus"].type()) {
        vector<DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlayFailStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        playFailStatus = make_shared<vector<DescribeRTSNativeSDKPlayFailStatusResponseBodyPlayFailStatus>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayFailStatusResponseBody() = default;
};
class DescribeRTSNativeSDKPlayFailStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRTSNativeSDKPlayFailStatusResponseBody> body{};

  DescribeRTSNativeSDKPlayFailStatusResponse() {}

  explicit DescribeRTSNativeSDKPlayFailStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRTSNativeSDKPlayFailStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRTSNativeSDKPlayFailStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKPlayFailStatusResponse() = default;
};
class DescribeRTSNativeSDKPlayTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayTimeRequest() {}

  explicit DescribeRTSNativeSDKPlayTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayTimeRequest() = default;
};
class DescribeRTSNativeSDKPlayTimeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainNameListShrink{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayTimeShrinkRequest() {}

  explicit DescribeRTSNativeSDKPlayTimeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameListShrink) {
      res["DomainNameList"] = boost::any(*domainNameListShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      domainNameListShrink = make_shared<string>(boost::any_cast<string>(m["DomainNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayTimeShrinkRequest() = default;
};
class DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData : public Darabonba::Model {
public:
  shared_ptr<string> playTime{};
  shared_ptr<string> stallTime{};
  shared_ptr<string> timeStamp{};

  DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData() {}

  explicit DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (playTime) {
      res["PlayTime"] = boost::any(*playTime);
    }
    if (stallTime) {
      res["StallTime"] = boost::any(*stallTime);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlayTime") != m.end() && !m["PlayTime"].empty()) {
      playTime = make_shared<string>(boost::any_cast<string>(m["PlayTime"]));
    }
    if (m.find("StallTime") != m.end() && !m["StallTime"].empty()) {
      stallTime = make_shared<string>(boost::any_cast<string>(m["StallTime"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData() = default;
};
class DescribeRTSNativeSDKPlayTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<vector<DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData>> playTimeData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKPlayTimeResponseBody() {}

  explicit DescribeRTSNativeSDKPlayTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (playTimeData) {
      vector<boost::any> temp1;
      for(auto item1:*playTimeData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlayTimeData"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PlayTimeData") != m.end() && !m["PlayTimeData"].empty()) {
      if (typeid(vector<boost::any>) == m["PlayTimeData"].type()) {
        vector<DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlayTimeData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        playTimeData = make_shared<vector<DescribeRTSNativeSDKPlayTimeResponseBodyPlayTimeData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKPlayTimeResponseBody() = default;
};
class DescribeRTSNativeSDKPlayTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRTSNativeSDKPlayTimeResponseBody> body{};

  DescribeRTSNativeSDKPlayTimeResponse() {}

  explicit DescribeRTSNativeSDKPlayTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRTSNativeSDKPlayTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRTSNativeSDKPlayTimeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKPlayTimeResponse() = default;
};
class DescribeRTSNativeSDKVvDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKVvDataRequest() {}

  explicit DescribeRTSNativeSDKVvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKVvDataRequest() = default;
};
class DescribeRTSNativeSDKVvDataShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainNameListShrink{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeRTSNativeSDKVvDataShrinkRequest() {}

  explicit DescribeRTSNativeSDKVvDataShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainNameListShrink) {
      res["DomainNameList"] = boost::any(*domainNameListShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      domainNameListShrink = make_shared<string>(boost::any_cast<string>(m["DomainNameList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRTSNativeSDKVvDataShrinkRequest() = default;
};
class DescribeRTSNativeSDKVvDataResponseBodyVvData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> vvSuccess{};
  shared_ptr<string> vvTotal{};

  DescribeRTSNativeSDKVvDataResponseBodyVvData() {}

  explicit DescribeRTSNativeSDKVvDataResponseBodyVvData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (vvSuccess) {
      res["VvSuccess"] = boost::any(*vvSuccess);
    }
    if (vvTotal) {
      res["VvTotal"] = boost::any(*vvTotal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("VvSuccess") != m.end() && !m["VvSuccess"].empty()) {
      vvSuccess = make_shared<string>(boost::any_cast<string>(m["VvSuccess"]));
    }
    if (m.find("VvTotal") != m.end() && !m["VvTotal"].empty()) {
      vvTotal = make_shared<string>(boost::any_cast<string>(m["VvTotal"]));
    }
  }


  virtual ~DescribeRTSNativeSDKVvDataResponseBodyVvData() = default;
};
class DescribeRTSNativeSDKVvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<vector<DescribeRTSNativeSDKVvDataResponseBodyVvData>> vvData{};

  DescribeRTSNativeSDKVvDataResponseBody() {}

  explicit DescribeRTSNativeSDKVvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (vvData) {
      vector<boost::any> temp1;
      for(auto item1:*vvData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VvData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("VvData") != m.end() && !m["VvData"].empty()) {
      if (typeid(vector<boost::any>) == m["VvData"].type()) {
        vector<DescribeRTSNativeSDKVvDataResponseBodyVvData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VvData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRTSNativeSDKVvDataResponseBodyVvData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vvData = make_shared<vector<DescribeRTSNativeSDKVvDataResponseBodyVvData>>(expect1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKVvDataResponseBody() = default;
};
class DescribeRTSNativeSDKVvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRTSNativeSDKVvDataResponseBody> body{};

  DescribeRTSNativeSDKVvDataResponse() {}

  explicit DescribeRTSNativeSDKVvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRTSNativeSDKVvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRTSNativeSDKVvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRTSNativeSDKVvDataResponse() = default;
};
class DescribeRtcCloudRecordingFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  DescribeRtcCloudRecordingFilesRequest() {}

  explicit DescribeRtcCloudRecordingFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeRtcCloudRecordingFilesRequest() = default;
};
class DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hlsFileList{};
  shared_ptr<vector<string>> mp3FileList{};
  shared_ptr<vector<string>> mp4FileList{};

  DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileList() {}

  explicit DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hlsFileList) {
      res["HlsFileList"] = boost::any(*hlsFileList);
    }
    if (mp3FileList) {
      res["Mp3FileList"] = boost::any(*mp3FileList);
    }
    if (mp4FileList) {
      res["Mp4FileList"] = boost::any(*mp4FileList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HlsFileList") != m.end() && !m["HlsFileList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HlsFileList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HlsFileList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hlsFileList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Mp3FileList") != m.end() && !m["Mp3FileList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Mp3FileList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Mp3FileList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mp3FileList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Mp4FileList") != m.end() && !m["Mp4FileList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Mp4FileList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Mp4FileList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mp4FileList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileList() = default;
};
class DescribeRtcCloudRecordingFilesResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileList> recordFileList{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeRtcCloudRecordingFilesResponseBodyTaskInfo() {}

  explicit DescribeRtcCloudRecordingFilesResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordFileList) {
      res["RecordFileList"] = recordFileList ? boost::any(recordFileList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordFileList") != m.end() && !m["RecordFileList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordFileList"].type()) {
        DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordFileList"]));
        recordFileList = make_shared<DescribeRtcCloudRecordingFilesResponseBodyTaskInfoRecordFileList>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeRtcCloudRecordingFilesResponseBodyTaskInfo() = default;
};
class DescribeRtcCloudRecordingFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRtcCloudRecordingFilesResponseBodyTaskInfo> taskInfo{};

  DescribeRtcCloudRecordingFilesResponseBody() {}

  explicit DescribeRtcCloudRecordingFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        DescribeRtcCloudRecordingFilesResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<DescribeRtcCloudRecordingFilesResponseBodyTaskInfo>(model1);
      }
    }
  }


  virtual ~DescribeRtcCloudRecordingFilesResponseBody() = default;
};
class DescribeRtcCloudRecordingFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRtcCloudRecordingFilesResponseBody> body{};

  DescribeRtcCloudRecordingFilesResponse() {}

  explicit DescribeRtcCloudRecordingFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRtcCloudRecordingFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRtcCloudRecordingFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRtcCloudRecordingFilesResponse() = default;
};
class DescribeRtcMPUEventSubRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DescribeRtcMPUEventSubRequest() {}

  explicit DescribeRtcMPUEventSubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DescribeRtcMPUEventSubRequest() = default;
};
class DescribeRtcMPUEventSubResponseBodySubInfo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> channelIds{};
  shared_ptr<string> createTime{};
  shared_ptr<string> subId{};

  DescribeRtcMPUEventSubResponseBodySubInfo() {}

  explicit DescribeRtcMPUEventSubResponseBodySubInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (channelIds) {
      res["ChannelIds"] = boost::any(*channelIds);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (subId) {
      res["SubId"] = boost::any(*subId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("ChannelIds") != m.end() && !m["ChannelIds"].empty()) {
      channelIds = make_shared<string>(boost::any_cast<string>(m["ChannelIds"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("SubId") != m.end() && !m["SubId"].empty()) {
      subId = make_shared<string>(boost::any_cast<string>(m["SubId"]));
    }
  }


  virtual ~DescribeRtcMPUEventSubResponseBodySubInfo() = default;
};
class DescribeRtcMPUEventSubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRtcMPUEventSubResponseBodySubInfo> subInfo{};

  DescribeRtcMPUEventSubResponseBody() {}

  explicit DescribeRtcMPUEventSubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subInfo) {
      res["SubInfo"] = subInfo ? boost::any(subInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubInfo") != m.end() && !m["SubInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubInfo"].type()) {
        DescribeRtcMPUEventSubResponseBodySubInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubInfo"]));
        subInfo = make_shared<DescribeRtcMPUEventSubResponseBodySubInfo>(model1);
      }
    }
  }


  virtual ~DescribeRtcMPUEventSubResponseBody() = default;
};
class DescribeRtcMPUEventSubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRtcMPUEventSubResponseBody> body{};

  DescribeRtcMPUEventSubResponse() {}

  explicit DescribeRtcMPUEventSubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRtcMPUEventSubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRtcMPUEventSubResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRtcMPUEventSubResponse() = default;
};
class DescribeShowListRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeShowListRequest() {}

  explicit DescribeShowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeShowListRequest() = default;
};
class DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo : public Darabonba::Model {
public:
  shared_ptr<long> liveInputType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceUrl{};

  DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo() {}

  explicit DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveInputType) {
      res["LiveInputType"] = boost::any(*liveInputType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceUrl) {
      res["ResourceUrl"] = boost::any(*resourceUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveInputType") != m.end() && !m["LiveInputType"].empty()) {
      liveInputType = make_shared<long>(boost::any_cast<long>(m["LiveInputType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceUrl") != m.end() && !m["ResourceUrl"].empty()) {
      resourceUrl = make_shared<string>(boost::any_cast<string>(m["ResourceUrl"]));
    }
  }


  virtual ~DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo() = default;
};
class DescribeShowListResponseBodyShowListInfoShowListShow : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> repeatTimes{};
  shared_ptr<DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo> resourceInfo{};
  shared_ptr<string> showId{};
  shared_ptr<string> showName{};

  DescribeShowListResponseBodyShowListInfoShowListShow() {}

  explicit DescribeShowListResponseBodyShowListInfoShowListShow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (repeatTimes) {
      res["RepeatTimes"] = boost::any(*repeatTimes);
    }
    if (resourceInfo) {
      res["ResourceInfo"] = resourceInfo ? boost::any(resourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("RepeatTimes") != m.end() && !m["RepeatTimes"].empty()) {
      repeatTimes = make_shared<long>(boost::any_cast<long>(m["RepeatTimes"]));
    }
    if (m.find("ResourceInfo") != m.end() && !m["ResourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceInfo"].type()) {
        DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceInfo"]));
        resourceInfo = make_shared<DescribeShowListResponseBodyShowListInfoShowListShowResourceInfo>(model1);
      }
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
  }


  virtual ~DescribeShowListResponseBodyShowListInfoShowListShow() = default;
};
class DescribeShowListResponseBodyShowListInfoShowList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeShowListResponseBodyShowListInfoShowListShow>> show{};

  DescribeShowListResponseBodyShowListInfoShowList() {}

  explicit DescribeShowListResponseBodyShowListInfoShowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (show) {
      vector<boost::any> temp1;
      for(auto item1:*show){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Show"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      if (typeid(vector<boost::any>) == m["Show"].type()) {
        vector<DescribeShowListResponseBodyShowListInfoShowListShow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Show"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeShowListResponseBodyShowListInfoShowListShow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        show = make_shared<vector<DescribeShowListResponseBodyShowListInfoShowListShow>>(expect1);
      }
    }
  }


  virtual ~DescribeShowListResponseBodyShowListInfoShowList() = default;
};
class DescribeShowListResponseBodyShowListInfo : public Darabonba::Model {
public:
  shared_ptr<string> background{};
  shared_ptr<string> currentShowId{};
  shared_ptr<string> highPriorityShowId{};
  shared_ptr<string> highPriorityShowStartTime{};
  shared_ptr<DescribeShowListResponseBodyShowListInfoShowList> showList{};
  shared_ptr<long> showListRepeatTimes{};
  shared_ptr<long> totalShowListRepeatTimes{};

  DescribeShowListResponseBodyShowListInfo() {}

  explicit DescribeShowListResponseBodyShowListInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (background) {
      res["Background"] = boost::any(*background);
    }
    if (currentShowId) {
      res["CurrentShowId"] = boost::any(*currentShowId);
    }
    if (highPriorityShowId) {
      res["HighPriorityShowId"] = boost::any(*highPriorityShowId);
    }
    if (highPriorityShowStartTime) {
      res["HighPriorityShowStartTime"] = boost::any(*highPriorityShowStartTime);
    }
    if (showList) {
      res["ShowList"] = showList ? boost::any(showList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (showListRepeatTimes) {
      res["ShowListRepeatTimes"] = boost::any(*showListRepeatTimes);
    }
    if (totalShowListRepeatTimes) {
      res["TotalShowListRepeatTimes"] = boost::any(*totalShowListRepeatTimes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Background") != m.end() && !m["Background"].empty()) {
      background = make_shared<string>(boost::any_cast<string>(m["Background"]));
    }
    if (m.find("CurrentShowId") != m.end() && !m["CurrentShowId"].empty()) {
      currentShowId = make_shared<string>(boost::any_cast<string>(m["CurrentShowId"]));
    }
    if (m.find("HighPriorityShowId") != m.end() && !m["HighPriorityShowId"].empty()) {
      highPriorityShowId = make_shared<string>(boost::any_cast<string>(m["HighPriorityShowId"]));
    }
    if (m.find("HighPriorityShowStartTime") != m.end() && !m["HighPriorityShowStartTime"].empty()) {
      highPriorityShowStartTime = make_shared<string>(boost::any_cast<string>(m["HighPriorityShowStartTime"]));
    }
    if (m.find("ShowList") != m.end() && !m["ShowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ShowList"].type()) {
        DescribeShowListResponseBodyShowListInfoShowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ShowList"]));
        showList = make_shared<DescribeShowListResponseBodyShowListInfoShowList>(model1);
      }
    }
    if (m.find("ShowListRepeatTimes") != m.end() && !m["ShowListRepeatTimes"].empty()) {
      showListRepeatTimes = make_shared<long>(boost::any_cast<long>(m["ShowListRepeatTimes"]));
    }
    if (m.find("TotalShowListRepeatTimes") != m.end() && !m["TotalShowListRepeatTimes"].empty()) {
      totalShowListRepeatTimes = make_shared<long>(boost::any_cast<long>(m["TotalShowListRepeatTimes"]));
    }
  }


  virtual ~DescribeShowListResponseBodyShowListInfo() = default;
};
class DescribeShowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> showList{};
  shared_ptr<DescribeShowListResponseBodyShowListInfo> showListInfo{};

  DescribeShowListResponseBody() {}

  explicit DescribeShowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (showList) {
      res["ShowList"] = boost::any(*showList);
    }
    if (showListInfo) {
      res["ShowListInfo"] = showListInfo ? boost::any(showListInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShowList") != m.end() && !m["ShowList"].empty()) {
      showList = make_shared<string>(boost::any_cast<string>(m["ShowList"]));
    }
    if (m.find("ShowListInfo") != m.end() && !m["ShowListInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ShowListInfo"].type()) {
        DescribeShowListResponseBodyShowListInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ShowListInfo"]));
        showListInfo = make_shared<DescribeShowListResponseBodyShowListInfo>(model1);
      }
    }
  }


  virtual ~DescribeShowListResponseBody() = default;
};
class DescribeShowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeShowListResponseBody> body{};

  DescribeShowListResponse() {}

  explicit DescribeShowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeShowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeShowListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeShowListResponse() = default;
};
class DescribeStreamLocationBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> blockType{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  DescribeStreamLocationBlockRequest() {}

  explicit DescribeStreamLocationBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<string>(boost::any_cast<string>(m["BlockType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeStreamLocationBlockRequest() = default;
};
class DescribeStreamLocationBlockResponseBodyStreamBlockListStreamBlock : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> blockType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> locationList{};
  shared_ptr<string> releaseTime{};
  shared_ptr<long> status{};
  shared_ptr<string> streamName{};
  shared_ptr<string> updateTime{};

  DescribeStreamLocationBlockResponseBodyStreamBlockListStreamBlock() {}

  explicit DescribeStreamLocationBlockResponseBodyStreamBlockListStreamBlock(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (locationList) {
      res["LocationList"] = boost::any(*locationList);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<string>(boost::any_cast<string>(m["BlockType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LocationList") != m.end() && !m["LocationList"].empty()) {
      locationList = make_shared<string>(boost::any_cast<string>(m["LocationList"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<string>(boost::any_cast<string>(m["ReleaseTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeStreamLocationBlockResponseBodyStreamBlockListStreamBlock() = default;
};
class DescribeStreamLocationBlockResponseBodyStreamBlockList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeStreamLocationBlockResponseBodyStreamBlockListStreamBlock>> streamBlock{};

  DescribeStreamLocationBlockResponseBodyStreamBlockList() {}

  explicit DescribeStreamLocationBlockResponseBodyStreamBlockList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamBlock) {
      vector<boost::any> temp1;
      for(auto item1:*streamBlock){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamBlock"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamBlock") != m.end() && !m["StreamBlock"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamBlock"].type()) {
        vector<DescribeStreamLocationBlockResponseBodyStreamBlockListStreamBlock> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamBlock"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStreamLocationBlockResponseBodyStreamBlockListStreamBlock model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamBlock = make_shared<vector<DescribeStreamLocationBlockResponseBodyStreamBlockListStreamBlock>>(expect1);
      }
    }
  }


  virtual ~DescribeStreamLocationBlockResponseBodyStreamBlockList() = default;
};
class DescribeStreamLocationBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeStreamLocationBlockResponseBodyStreamBlockList> streamBlockList{};
  shared_ptr<long> totalPage{};

  DescribeStreamLocationBlockResponseBody() {}

  explicit DescribeStreamLocationBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamBlockList) {
      res["StreamBlockList"] = streamBlockList ? boost::any(streamBlockList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamBlockList") != m.end() && !m["StreamBlockList"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamBlockList"].type()) {
        DescribeStreamLocationBlockResponseBodyStreamBlockList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamBlockList"]));
        streamBlockList = make_shared<DescribeStreamLocationBlockResponseBodyStreamBlockList>(model1);
      }
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeStreamLocationBlockResponseBody() = default;
};
class DescribeStreamLocationBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStreamLocationBlockResponseBody> body{};

  DescribeStreamLocationBlockResponse() {}

  explicit DescribeStreamLocationBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStreamLocationBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStreamLocationBlockResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStreamLocationBlockResponse() = default;
};
class DescribeStudioLayoutsRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeStudioLayoutsRequest() {}

  explicit DescribeStudioLayoutsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeStudioLayoutsRequest() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> locationId{};
  shared_ptr<string> materialId{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<string>(boost::any_cast<string>(m["LocationId"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> videoResourceId{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (videoResourceId) {
      res["VideoResourceId"] = boost::any(*videoResourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("VideoResourceId") != m.end() && !m["VideoResourceId"].empty()) {
      videoResourceId = make_shared<string>(boost::any_cast<string>(m["VideoResourceId"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> fillMode{};
  shared_ptr<double> heightNormalized{};
  shared_ptr<string> id{};
  shared_ptr<string> imageMaterialId{};
  shared_ptr<long> index{};
  shared_ptr<vector<double>> positionNormalized{};
  shared_ptr<string> positionRefer{};
  shared_ptr<string> videoResourceId{};
  shared_ptr<double> widthNormalized{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (fillMode) {
      res["FillMode"] = boost::any(*fillMode);
    }
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (imageMaterialId) {
      res["ImageMaterialId"] = boost::any(*imageMaterialId);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (positionNormalized) {
      res["PositionNormalized"] = boost::any(*positionNormalized);
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (videoResourceId) {
      res["VideoResourceId"] = boost::any(*videoResourceId);
    }
    if (widthNormalized) {
      res["WidthNormalized"] = boost::any(*widthNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("FillMode") != m.end() && !m["FillMode"].empty()) {
      fillMode = make_shared<string>(boost::any_cast<string>(m["FillMode"]));
    }
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ImageMaterialId") != m.end() && !m["ImageMaterialId"].empty()) {
      imageMaterialId = make_shared<string>(boost::any_cast<string>(m["ImageMaterialId"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["PositionNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PositionNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      positionNormalized = make_shared<vector<double>>(toVec1);
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("VideoResourceId") != m.end() && !m["VideoResourceId"].empty()) {
      videoResourceId = make_shared<string>(boost::any_cast<string>(m["VideoResourceId"]));
    }
    if (m.find("WidthNormalized") != m.end() && !m["WidthNormalized"].empty()) {
      widthNormalized = make_shared<double>(boost::any_cast<double>(m["WidthNormalized"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig : public Darabonba::Model {
public:
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList : public Darabonba::Model {
public:
  shared_ptr<DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig> audioConfig{};
  shared_ptr<string> channelId{};
  shared_ptr<string> color{};
  shared_ptr<double> heightNormalized{};
  shared_ptr<string> id{};
  shared_ptr<long> index{};
  shared_ptr<bool> onlyAudio{};
  shared_ptr<long> portraitType{};
  shared_ptr<string> positionX{};
  shared_ptr<string> positionY{};
  shared_ptr<string> videoResourceId{};

  DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioConfig) {
      res["AudioConfig"] = audioConfig ? boost::any(audioConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (onlyAudio) {
      res["OnlyAudio"] = boost::any(*onlyAudio);
    }
    if (portraitType) {
      res["PortraitType"] = boost::any(*portraitType);
    }
    if (positionX) {
      res["PositionX"] = boost::any(*positionX);
    }
    if (positionY) {
      res["PositionY"] = boost::any(*positionY);
    }
    if (videoResourceId) {
      res["VideoResourceId"] = boost::any(*videoResourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioConfig") != m.end() && !m["AudioConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioConfig"].type()) {
        DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioConfig"]));
        audioConfig = make_shared<DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigListAudioConfig>(model1);
      }
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("OnlyAudio") != m.end() && !m["OnlyAudio"].empty()) {
      onlyAudio = make_shared<bool>(boost::any_cast<bool>(m["OnlyAudio"]));
    }
    if (m.find("PortraitType") != m.end() && !m["PortraitType"].empty()) {
      portraitType = make_shared<long>(boost::any_cast<long>(m["PortraitType"]));
    }
    if (m.find("PositionX") != m.end() && !m["PositionX"].empty()) {
      positionX = make_shared<string>(boost::any_cast<string>(m["PositionX"]));
    }
    if (m.find("PositionY") != m.end() && !m["PositionY"].empty()) {
      positionY = make_shared<string>(boost::any_cast<string>(m["PositionY"]));
    }
    if (m.find("VideoResourceId") != m.end() && !m["VideoResourceId"].empty()) {
      videoResourceId = make_shared<string>(boost::any_cast<string>(m["VideoResourceId"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList() = default;
};
class DescribeStudioLayoutsResponseBodyStudioLayouts : public Darabonba::Model {
public:
  shared_ptr<DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig> bgImageConfig{};
  shared_ptr<DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig> commonConfig{};
  shared_ptr<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList>> layerOrderConfigList{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> layoutName{};
  shared_ptr<string> layoutType{};
  shared_ptr<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList>> mediaInputConfigList{};
  shared_ptr<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList>> screenInputConfigList{};

  DescribeStudioLayoutsResponseBodyStudioLayouts() {}

  explicit DescribeStudioLayoutsResponseBodyStudioLayouts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgImageConfig) {
      res["BgImageConfig"] = bgImageConfig ? boost::any(bgImageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (commonConfig) {
      res["CommonConfig"] = commonConfig ? boost::any(commonConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (layerOrderConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*layerOrderConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LayerOrderConfigList"] = boost::any(temp1);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (layoutName) {
      res["LayoutName"] = boost::any(*layoutName);
    }
    if (layoutType) {
      res["LayoutType"] = boost::any(*layoutType);
    }
    if (mediaInputConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInputConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInputConfigList"] = boost::any(temp1);
    }
    if (screenInputConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*screenInputConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScreenInputConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgImageConfig") != m.end() && !m["BgImageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BgImageConfig"].type()) {
        DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BgImageConfig"]));
        bgImageConfig = make_shared<DescribeStudioLayoutsResponseBodyStudioLayoutsBgImageConfig>(model1);
      }
    }
    if (m.find("CommonConfig") != m.end() && !m["CommonConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonConfig"].type()) {
        DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonConfig"]));
        commonConfig = make_shared<DescribeStudioLayoutsResponseBodyStudioLayoutsCommonConfig>(model1);
      }
    }
    if (m.find("LayerOrderConfigList") != m.end() && !m["LayerOrderConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["LayerOrderConfigList"].type()) {
        vector<DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LayerOrderConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        layerOrderConfigList = make_shared<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsLayerOrderConfigList>>(expect1);
      }
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("LayoutName") != m.end() && !m["LayoutName"].empty()) {
      layoutName = make_shared<string>(boost::any_cast<string>(m["LayoutName"]));
    }
    if (m.find("LayoutType") != m.end() && !m["LayoutType"].empty()) {
      layoutType = make_shared<string>(boost::any_cast<string>(m["LayoutType"]));
    }
    if (m.find("MediaInputConfigList") != m.end() && !m["MediaInputConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInputConfigList"].type()) {
        vector<DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInputConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInputConfigList = make_shared<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsMediaInputConfigList>>(expect1);
      }
    }
    if (m.find("ScreenInputConfigList") != m.end() && !m["ScreenInputConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ScreenInputConfigList"].type()) {
        vector<DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScreenInputConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        screenInputConfigList = make_shared<vector<DescribeStudioLayoutsResponseBodyStudioLayoutsScreenInputConfigList>>(expect1);
      }
    }
  }


  virtual ~DescribeStudioLayoutsResponseBodyStudioLayouts() = default;
};
class DescribeStudioLayoutsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeStudioLayoutsResponseBodyStudioLayouts>> studioLayouts{};
  shared_ptr<long> total{};

  DescribeStudioLayoutsResponseBody() {}

  explicit DescribeStudioLayoutsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (studioLayouts) {
      vector<boost::any> temp1;
      for(auto item1:*studioLayouts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StudioLayouts"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StudioLayouts") != m.end() && !m["StudioLayouts"].empty()) {
      if (typeid(vector<boost::any>) == m["StudioLayouts"].type()) {
        vector<DescribeStudioLayoutsResponseBodyStudioLayouts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StudioLayouts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStudioLayoutsResponseBodyStudioLayouts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        studioLayouts = make_shared<vector<DescribeStudioLayoutsResponseBodyStudioLayouts>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeStudioLayoutsResponseBody() = default;
};
class DescribeStudioLayoutsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStudioLayoutsResponseBody> body{};

  DescribeStudioLayoutsResponse() {}

  explicit DescribeStudioLayoutsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStudioLayoutsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStudioLayoutsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStudioLayoutsResponse() = default;
};
class DescribeToutiaoLivePlayRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> stream{};

  DescribeToutiaoLivePlayRequest() {}

  explicit DescribeToutiaoLivePlayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~DescribeToutiaoLivePlayRequest() = default;
};
class DescribeToutiaoLivePlayResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<double> bandwidth{};
  shared_ptr<string> cdnName{};
  shared_ptr<string> domain{};
  shared_ptr<long> playNum{};
  shared_ptr<string> streamName{};
  shared_ptr<long> timestamp{};

  DescribeToutiaoLivePlayResponseBodyContent() {}

  explicit DescribeToutiaoLivePlayResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (cdnName) {
      res["CdnName"] = boost::any(*cdnName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (playNum) {
      res["PlayNum"] = boost::any(*playNum);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<double>(boost::any_cast<double>(m["Bandwidth"]));
    }
    if (m.find("CdnName") != m.end() && !m["CdnName"].empty()) {
      cdnName = make_shared<string>(boost::any_cast<string>(m["CdnName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("PlayNum") != m.end() && !m["PlayNum"].empty()) {
      playNum = make_shared<long>(boost::any_cast<long>(m["PlayNum"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeToutiaoLivePlayResponseBodyContent() = default;
};
class DescribeToutiaoLivePlayResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeToutiaoLivePlayResponseBodyContent>> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};

  DescribeToutiaoLivePlayResponseBody() {}

  explicit DescribeToutiaoLivePlayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeToutiaoLivePlayResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeToutiaoLivePlayResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeToutiaoLivePlayResponseBodyContent>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeToutiaoLivePlayResponseBody() = default;
};
class DescribeToutiaoLivePlayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeToutiaoLivePlayResponseBody> body{};

  DescribeToutiaoLivePlayResponse() {}

  explicit DescribeToutiaoLivePlayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeToutiaoLivePlayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeToutiaoLivePlayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeToutiaoLivePlayResponse() = default;
};
class DescribeToutiaoLivePublishRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> stream{};

  DescribeToutiaoLivePublishRequest() {}

  explicit DescribeToutiaoLivePublishRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~DescribeToutiaoLivePublishRequest() = default;
};
class DescribeToutiaoLivePublishResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<double> bitrate{};
  shared_ptr<double> bwDiff{};
  shared_ptr<string> cdnName{};
  shared_ptr<string> domain{};
  shared_ptr<double> flr{};
  shared_ptr<double> fps{};
  shared_ptr<string> streamName{};
  shared_ptr<long> timestamp{};

  DescribeToutiaoLivePublishResponseBodyContent() {}

  explicit DescribeToutiaoLivePublishResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bwDiff) {
      res["BwDiff"] = boost::any(*bwDiff);
    }
    if (cdnName) {
      res["CdnName"] = boost::any(*cdnName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (flr) {
      res["Flr"] = boost::any(*flr);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<double>(boost::any_cast<double>(m["Bitrate"]));
    }
    if (m.find("BwDiff") != m.end() && !m["BwDiff"].empty()) {
      bwDiff = make_shared<double>(boost::any_cast<double>(m["BwDiff"]));
    }
    if (m.find("CdnName") != m.end() && !m["CdnName"].empty()) {
      cdnName = make_shared<string>(boost::any_cast<string>(m["CdnName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Flr") != m.end() && !m["Flr"].empty()) {
      flr = make_shared<double>(boost::any_cast<double>(m["Flr"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<double>(boost::any_cast<double>(m["Fps"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeToutiaoLivePublishResponseBodyContent() = default;
};
class DescribeToutiaoLivePublishResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeToutiaoLivePublishResponseBodyContent>> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};

  DescribeToutiaoLivePublishResponseBody() {}

  explicit DescribeToutiaoLivePublishResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeToutiaoLivePublishResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeToutiaoLivePublishResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeToutiaoLivePublishResponseBodyContent>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeToutiaoLivePublishResponseBody() = default;
};
class DescribeToutiaoLivePublishResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeToutiaoLivePublishResponseBody> body{};

  DescribeToutiaoLivePublishResponse() {}

  explicit DescribeToutiaoLivePublishResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeToutiaoLivePublishResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeToutiaoLivePublishResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeToutiaoLivePublishResponse() = default;
};
class DescribeUidOnlineStreamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DescribeUidOnlineStreamsRequest() {}

  explicit DescribeUidOnlineStreamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeUidOnlineStreamsRequest() = default;
};
class DescribeUidOnlineStreamsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> streamName{};

  DescribeUidOnlineStreamsResponseBodyData() {}

  explicit DescribeUidOnlineStreamsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeUidOnlineStreamsResponseBodyData() = default;
};
class DescribeUidOnlineStreamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUidOnlineStreamsResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};

  DescribeUidOnlineStreamsResponseBody() {}

  explicit DescribeUidOnlineStreamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeUidOnlineStreamsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUidOnlineStreamsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeUidOnlineStreamsResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
  }


  virtual ~DescribeUidOnlineStreamsResponseBody() = default;
};
class DescribeUidOnlineStreamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUidOnlineStreamsResponseBody> body{};

  DescribeUidOnlineStreamsResponse() {}

  explicit DescribeUidOnlineStreamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUidOnlineStreamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUidOnlineStreamsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUidOnlineStreamsResponse() = default;
};
class DescribeUpBpsPeakDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSwitch{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeUpBpsPeakDataRequest() {}

  explicit DescribeUpBpsPeakDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSwitch) {
      res["DomainSwitch"] = boost::any(*domainSwitch);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSwitch") != m.end() && !m["DomainSwitch"].empty()) {
      domainSwitch = make_shared<string>(boost::any_cast<string>(m["DomainSwitch"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeUpBpsPeakDataRequest() = default;
};
class DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic : public Darabonba::Model {
public:
  shared_ptr<string> bandWidth{};
  shared_ptr<string> peakTime{};
  shared_ptr<string> queryTime{};
  shared_ptr<string> statName{};

  DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic() {}

  explicit DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (peakTime) {
      res["PeakTime"] = boost::any(*peakTime);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    if (statName) {
      res["StatName"] = boost::any(*statName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<string>(boost::any_cast<string>(m["BandWidth"]));
    }
    if (m.find("PeakTime") != m.end() && !m["PeakTime"].empty()) {
      peakTime = make_shared<string>(boost::any_cast<string>(m["PeakTime"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<string>(boost::any_cast<string>(m["QueryTime"]));
    }
    if (m.find("StatName") != m.end() && !m["StatName"].empty()) {
      statName = make_shared<string>(boost::any_cast<string>(m["StatName"]));
    }
  }


  virtual ~DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic() = default;
};
class DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic>> describeUpPeakTraffic{};

  DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics() {}

  explicit DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpPeakTraffic) {
      vector<boost::any> temp1;
      for(auto item1:*describeUpPeakTraffic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribeUpPeakTraffic"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpPeakTraffic") != m.end() && !m["DescribeUpPeakTraffic"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribeUpPeakTraffic"].type()) {
        vector<DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribeUpPeakTraffic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describeUpPeakTraffic = make_shared<vector<DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTrafficsDescribeUpPeakTraffic>>(expect1);
      }
    }
  }


  virtual ~DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics() = default;
};
class DescribeUpBpsPeakDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics> describeUpPeakTraffics{};
  shared_ptr<string> requestId{};

  DescribeUpBpsPeakDataResponseBody() {}

  explicit DescribeUpBpsPeakDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpPeakTraffics) {
      res["DescribeUpPeakTraffics"] = describeUpPeakTraffics ? boost::any(describeUpPeakTraffics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpPeakTraffics") != m.end() && !m["DescribeUpPeakTraffics"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescribeUpPeakTraffics"].type()) {
        DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescribeUpPeakTraffics"]));
        describeUpPeakTraffics = make_shared<DescribeUpBpsPeakDataResponseBodyDescribeUpPeakTraffics>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUpBpsPeakDataResponseBody() = default;
};
class DescribeUpBpsPeakDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUpBpsPeakDataResponseBody> body{};

  DescribeUpBpsPeakDataResponse() {}

  explicit DescribeUpBpsPeakDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUpBpsPeakDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUpBpsPeakDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUpBpsPeakDataResponse() = default;
};
class DescribeUpBpsPeakOfLineRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSwitch{};
  shared_ptr<string> endTime{};
  shared_ptr<string> line{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeUpBpsPeakOfLineRequest() {}

  explicit DescribeUpBpsPeakOfLineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSwitch) {
      res["DomainSwitch"] = boost::any(*domainSwitch);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSwitch") != m.end() && !m["DomainSwitch"].empty()) {
      domainSwitch = make_shared<string>(boost::any_cast<string>(m["DomainSwitch"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeUpBpsPeakOfLineRequest() = default;
};
class DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine : public Darabonba::Model {
public:
  shared_ptr<double> bandWidth{};
  shared_ptr<string> peakTime{};
  shared_ptr<string> queryTime{};
  shared_ptr<string> statName{};

  DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine() {}

  explicit DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (peakTime) {
      res["PeakTime"] = boost::any(*peakTime);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    if (statName) {
      res["StatName"] = boost::any(*statName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<double>(boost::any_cast<double>(m["BandWidth"]));
    }
    if (m.find("PeakTime") != m.end() && !m["PeakTime"].empty()) {
      peakTime = make_shared<string>(boost::any_cast<string>(m["PeakTime"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<string>(boost::any_cast<string>(m["QueryTime"]));
    }
    if (m.find("StatName") != m.end() && !m["StatName"].empty()) {
      statName = make_shared<string>(boost::any_cast<string>(m["StatName"]));
    }
  }


  virtual ~DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine() = default;
};
class DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine>> describeUpBpsPeakOfLine{};

  DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines() {}

  explicit DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpBpsPeakOfLine) {
      vector<boost::any> temp1;
      for(auto item1:*describeUpBpsPeakOfLine){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribeUpBpsPeakOfLine"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpBpsPeakOfLine") != m.end() && !m["DescribeUpBpsPeakOfLine"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribeUpBpsPeakOfLine"].type()) {
        vector<DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribeUpBpsPeakOfLine"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describeUpBpsPeakOfLine = make_shared<vector<DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLinesDescribeUpBpsPeakOfLine>>(expect1);
      }
    }
  }


  virtual ~DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines() = default;
};
class DescribeUpBpsPeakOfLineResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines> describeUpBpsPeakOfLines{};
  shared_ptr<string> requestId{};

  DescribeUpBpsPeakOfLineResponseBody() {}

  explicit DescribeUpBpsPeakOfLineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpBpsPeakOfLines) {
      res["DescribeUpBpsPeakOfLines"] = describeUpBpsPeakOfLines ? boost::any(describeUpBpsPeakOfLines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpBpsPeakOfLines") != m.end() && !m["DescribeUpBpsPeakOfLines"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescribeUpBpsPeakOfLines"].type()) {
        DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescribeUpBpsPeakOfLines"]));
        describeUpBpsPeakOfLines = make_shared<DescribeUpBpsPeakOfLineResponseBodyDescribeUpBpsPeakOfLines>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUpBpsPeakOfLineResponseBody() = default;
};
class DescribeUpBpsPeakOfLineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUpBpsPeakOfLineResponseBody> body{};

  DescribeUpBpsPeakOfLineResponse() {}

  explicit DescribeUpBpsPeakOfLineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUpBpsPeakOfLineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUpBpsPeakOfLineResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUpBpsPeakOfLineResponse() = default;
};
class DescribeUpPeakPublishStreamDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSwitch{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeUpPeakPublishStreamDataRequest() {}

  explicit DescribeUpPeakPublishStreamDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSwitch) {
      res["DomainSwitch"] = boost::any(*domainSwitch);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSwitch") != m.end() && !m["DomainSwitch"].empty()) {
      domainSwitch = make_shared<string>(boost::any_cast<string>(m["DomainSwitch"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeUpPeakPublishStreamDataRequest() = default;
};
class DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData : public Darabonba::Model {
public:
  shared_ptr<string> bandWidth{};
  shared_ptr<string> peakTime{};
  shared_ptr<long> publishStreamNum{};
  shared_ptr<string> queryTime{};
  shared_ptr<string> statName{};

  DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData() {}

  explicit DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (peakTime) {
      res["PeakTime"] = boost::any(*peakTime);
    }
    if (publishStreamNum) {
      res["PublishStreamNum"] = boost::any(*publishStreamNum);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    if (statName) {
      res["StatName"] = boost::any(*statName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<string>(boost::any_cast<string>(m["BandWidth"]));
    }
    if (m.find("PeakTime") != m.end() && !m["PeakTime"].empty()) {
      peakTime = make_shared<string>(boost::any_cast<string>(m["PeakTime"]));
    }
    if (m.find("PublishStreamNum") != m.end() && !m["PublishStreamNum"].empty()) {
      publishStreamNum = make_shared<long>(boost::any_cast<long>(m["PublishStreamNum"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<string>(boost::any_cast<string>(m["QueryTime"]));
    }
    if (m.find("StatName") != m.end() && !m["StatName"].empty()) {
      statName = make_shared<string>(boost::any_cast<string>(m["StatName"]));
    }
  }


  virtual ~DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData() = default;
};
class DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData>> describeUpPeakPublishStreamData{};

  DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas() {}

  explicit DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpPeakPublishStreamData) {
      vector<boost::any> temp1;
      for(auto item1:*describeUpPeakPublishStreamData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribeUpPeakPublishStreamData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpPeakPublishStreamData") != m.end() && !m["DescribeUpPeakPublishStreamData"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribeUpPeakPublishStreamData"].type()) {
        vector<DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribeUpPeakPublishStreamData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describeUpPeakPublishStreamData = make_shared<vector<DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatasDescribeUpPeakPublishStreamData>>(expect1);
      }
    }
  }


  virtual ~DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas() = default;
};
class DescribeUpPeakPublishStreamDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas> describeUpPeakPublishStreamDatas{};
  shared_ptr<string> requestId{};

  DescribeUpPeakPublishStreamDataResponseBody() {}

  explicit DescribeUpPeakPublishStreamDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeUpPeakPublishStreamDatas) {
      res["DescribeUpPeakPublishStreamDatas"] = describeUpPeakPublishStreamDatas ? boost::any(describeUpPeakPublishStreamDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeUpPeakPublishStreamDatas") != m.end() && !m["DescribeUpPeakPublishStreamDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescribeUpPeakPublishStreamDatas"].type()) {
        DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescribeUpPeakPublishStreamDatas"]));
        describeUpPeakPublishStreamDatas = make_shared<DescribeUpPeakPublishStreamDataResponseBodyDescribeUpPeakPublishStreamDatas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUpPeakPublishStreamDataResponseBody() = default;
};
class DescribeUpPeakPublishStreamDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUpPeakPublishStreamDataResponseBody> body{};

  DescribeUpPeakPublishStreamDataResponse() {}

  explicit DescribeUpPeakPublishStreamDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUpPeakPublishStreamDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUpPeakPublishStreamDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUpPeakPublishStreamDataResponse() = default;
};
class DisableLiveRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  DisableLiveRealtimeLogDeliveryRequest() {}

  explicit DisableLiveRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DisableLiveRealtimeLogDeliveryRequest() = default;
};
class DisableLiveRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableLiveRealtimeLogDeliveryResponseBody() {}

  explicit DisableLiveRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableLiveRealtimeLogDeliveryResponseBody() = default;
};
class DisableLiveRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableLiveRealtimeLogDeliveryResponseBody> body{};

  DisableLiveRealtimeLogDeliveryResponse() {}

  explicit DisableLiveRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableLiveRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableLiveRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DisableLiveRealtimeLogDeliveryResponse() = default;
};
class DynamicUpdateWaterMarkStreamRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stream{};
  shared_ptr<string> templateId{};

  DynamicUpdateWaterMarkStreamRuleRequest() {}

  explicit DynamicUpdateWaterMarkStreamRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DynamicUpdateWaterMarkStreamRuleRequest() = default;
};
class DynamicUpdateWaterMarkStreamRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DynamicUpdateWaterMarkStreamRuleResponseBody() {}

  explicit DynamicUpdateWaterMarkStreamRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DynamicUpdateWaterMarkStreamRuleResponseBody() = default;
};
class DynamicUpdateWaterMarkStreamRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DynamicUpdateWaterMarkStreamRuleResponseBody> body{};

  DynamicUpdateWaterMarkStreamRuleResponse() {}

  explicit DynamicUpdateWaterMarkStreamRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DynamicUpdateWaterMarkStreamRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DynamicUpdateWaterMarkStreamRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DynamicUpdateWaterMarkStreamRuleResponse() = default;
};
class EditPlaylistRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programConfig{};
  shared_ptr<string> programId{};
  shared_ptr<string> programItems{};
  shared_ptr<string> regionId{};

  EditPlaylistRequest() {}

  explicit EditPlaylistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programConfig) {
      res["ProgramConfig"] = boost::any(*programConfig);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programItems) {
      res["ProgramItems"] = boost::any(*programItems);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramConfig") != m.end() && !m["ProgramConfig"].empty()) {
      programConfig = make_shared<string>(boost::any_cast<string>(m["ProgramConfig"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramItems") != m.end() && !m["ProgramItems"].empty()) {
      programItems = make_shared<string>(boost::any_cast<string>(m["ProgramItems"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~EditPlaylistRequest() = default;
};
class EditPlaylistResponseBodyItemsFailedItems : public Darabonba::Model {
public:
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};

  EditPlaylistResponseBodyItemsFailedItems() {}

  explicit EditPlaylistResponseBodyItemsFailedItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
  }


  virtual ~EditPlaylistResponseBodyItemsFailedItems() = default;
};
class EditPlaylistResponseBodyItemsSuccessItems : public Darabonba::Model {
public:
  shared_ptr<string> itemId{};
  shared_ptr<string> itemName{};

  EditPlaylistResponseBodyItemsSuccessItems() {}

  explicit EditPlaylistResponseBodyItemsSuccessItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
  }


  virtual ~EditPlaylistResponseBodyItemsSuccessItems() = default;
};
class EditPlaylistResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<EditPlaylistResponseBodyItemsFailedItems>> failedItems{};
  shared_ptr<vector<EditPlaylistResponseBodyItemsSuccessItems>> successItems{};

  EditPlaylistResponseBodyItems() {}

  explicit EditPlaylistResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedItems) {
      vector<boost::any> temp1;
      for(auto item1:*failedItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedItems"] = boost::any(temp1);
    }
    if (successItems) {
      vector<boost::any> temp1;
      for(auto item1:*successItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuccessItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedItems") != m.end() && !m["FailedItems"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedItems"].type()) {
        vector<EditPlaylistResponseBodyItemsFailedItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EditPlaylistResponseBodyItemsFailedItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedItems = make_shared<vector<EditPlaylistResponseBodyItemsFailedItems>>(expect1);
      }
    }
    if (m.find("SuccessItems") != m.end() && !m["SuccessItems"].empty()) {
      if (typeid(vector<boost::any>) == m["SuccessItems"].type()) {
        vector<EditPlaylistResponseBodyItemsSuccessItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuccessItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EditPlaylistResponseBodyItemsSuccessItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        successItems = make_shared<vector<EditPlaylistResponseBodyItemsSuccessItems>>(expect1);
      }
    }
  }


  virtual ~EditPlaylistResponseBodyItems() = default;
};
class EditPlaylistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<EditPlaylistResponseBodyItems> items{};
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  EditPlaylistResponseBody() {}

  explicit EditPlaylistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        EditPlaylistResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<EditPlaylistResponseBodyItems>(model1);
      }
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EditPlaylistResponseBody() = default;
};
class EditPlaylistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EditPlaylistResponseBody> body{};

  EditPlaylistResponse() {}

  explicit EditPlaylistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EditPlaylistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EditPlaylistResponseBody>(model1);
      }
    }
  }


  virtual ~EditPlaylistResponse() = default;
};
class EditShowAndReplaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<double> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> showId{};
  shared_ptr<double> startTime{};
  shared_ptr<string> storageInfo{};
  shared_ptr<string> userData{};

  EditShowAndReplaceRequest() {}

  explicit EditShowAndReplaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (storageInfo) {
      res["StorageInfo"] = boost::any(*storageInfo);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<double>(boost::any_cast<double>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("StorageInfo") != m.end() && !m["StorageInfo"].empty()) {
      storageInfo = make_shared<string>(boost::any_cast<string>(m["StorageInfo"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~EditShowAndReplaceRequest() = default;
};
class EditShowAndReplaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobInfo{};
  shared_ptr<string> requestId{};

  EditShowAndReplaceResponseBody() {}

  explicit EditShowAndReplaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobInfo) {
      res["JobInfo"] = boost::any(*jobInfo);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobInfo") != m.end() && !m["JobInfo"].empty()) {
      jobInfo = make_shared<string>(boost::any_cast<string>(m["JobInfo"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EditShowAndReplaceResponseBody() = default;
};
class EditShowAndReplaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EditShowAndReplaceResponseBody> body{};

  EditShowAndReplaceResponse() {}

  explicit EditShowAndReplaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EditShowAndReplaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EditShowAndReplaceResponseBody>(model1);
      }
    }
  }


  virtual ~EditShowAndReplaceResponse() = default;
};
class EffectCasterUrgentRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sceneId{};

  EffectCasterUrgentRequest() {}

  explicit EffectCasterUrgentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~EffectCasterUrgentRequest() = default;
};
class EffectCasterUrgentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EffectCasterUrgentResponseBody() {}

  explicit EffectCasterUrgentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EffectCasterUrgentResponseBody() = default;
};
class EffectCasterUrgentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EffectCasterUrgentResponseBody> body{};

  EffectCasterUrgentResponse() {}

  explicit EffectCasterUrgentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EffectCasterUrgentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EffectCasterUrgentResponseBody>(model1);
      }
    }
  }


  virtual ~EffectCasterUrgentResponse() = default;
};
class EffectCasterVideoResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> sceneId{};

  EffectCasterVideoResourceRequest() {}

  explicit EffectCasterVideoResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~EffectCasterVideoResourceRequest() = default;
};
class EffectCasterVideoResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EffectCasterVideoResourceResponseBody() {}

  explicit EffectCasterVideoResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EffectCasterVideoResourceResponseBody() = default;
};
class EffectCasterVideoResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EffectCasterVideoResourceResponseBody> body{};

  EffectCasterVideoResourceResponse() {}

  explicit EffectCasterVideoResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EffectCasterVideoResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EffectCasterVideoResourceResponseBody>(model1);
      }
    }
  }


  virtual ~EffectCasterVideoResourceResponse() = default;
};
class EnableLiveRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  EnableLiveRealtimeLogDeliveryRequest() {}

  explicit EnableLiveRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~EnableLiveRealtimeLogDeliveryRequest() = default;
};
class EnableLiveRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableLiveRealtimeLogDeliveryResponseBody() {}

  explicit EnableLiveRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableLiveRealtimeLogDeliveryResponseBody() = default;
};
class EnableLiveRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableLiveRealtimeLogDeliveryResponseBody> body{};

  EnableLiveRealtimeLogDeliveryResponse() {}

  explicit EnableLiveRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableLiveRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableLiveRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~EnableLiveRealtimeLogDeliveryResponse() = default;
};
class ForbidLiveStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveStreamType{};
  shared_ptr<string> oneshot{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resumeTime{};
  shared_ptr<string> streamName{};

  ForbidLiveStreamRequest() {}

  explicit ForbidLiveStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveStreamType) {
      res["LiveStreamType"] = boost::any(*liveStreamType);
    }
    if (oneshot) {
      res["Oneshot"] = boost::any(*oneshot);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resumeTime) {
      res["ResumeTime"] = boost::any(*resumeTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveStreamType") != m.end() && !m["LiveStreamType"].empty()) {
      liveStreamType = make_shared<string>(boost::any_cast<string>(m["LiveStreamType"]));
    }
    if (m.find("Oneshot") != m.end() && !m["Oneshot"].empty()) {
      oneshot = make_shared<string>(boost::any_cast<string>(m["Oneshot"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResumeTime") != m.end() && !m["ResumeTime"].empty()) {
      resumeTime = make_shared<string>(boost::any_cast<string>(m["ResumeTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~ForbidLiveStreamRequest() = default;
};
class ForbidLiveStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ForbidLiveStreamResponseBody() {}

  explicit ForbidLiveStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ForbidLiveStreamResponseBody() = default;
};
class ForbidLiveStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ForbidLiveStreamResponseBody> body{};

  ForbidLiveStreamResponse() {}

  explicit ForbidLiveStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ForbidLiveStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ForbidLiveStreamResponseBody>(model1);
      }
    }
  }


  virtual ~ForbidLiveStreamResponse() = default;
};
class GetAllCustomTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  GetAllCustomTemplatesRequest() {}

  explicit GetAllCustomTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetAllCustomTemplatesRequest() = default;
};
class GetAllCustomTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> customTemplates{};
  shared_ptr<string> requestId{};

  GetAllCustomTemplatesResponseBody() {}

  explicit GetAllCustomTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplates) {
      res["CustomTemplates"] = boost::any(*customTemplates);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplates") != m.end() && !m["CustomTemplates"].empty()) {
      customTemplates = make_shared<string>(boost::any_cast<string>(m["CustomTemplates"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAllCustomTemplatesResponseBody() = default;
};
class GetAllCustomTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAllCustomTemplatesResponseBody> body{};

  GetAllCustomTemplatesResponse() {}

  explicit GetAllCustomTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAllCustomTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAllCustomTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~GetAllCustomTemplatesResponse() = default;
};
class GetCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> template_{};

  GetCustomTemplateRequest() {}

  explicit GetCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~GetCustomTemplateRequest() = default;
};
class GetCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> customTemplate{};
  shared_ptr<string> requestId{};
  shared_ptr<string> template_{};

  GetCustomTemplateResponseBody() {}

  explicit GetCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplate) {
      res["CustomTemplate"] = boost::any(*customTemplate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplate") != m.end() && !m["CustomTemplate"].empty()) {
      customTemplate = make_shared<string>(boost::any_cast<string>(m["CustomTemplate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~GetCustomTemplateResponseBody() = default;
};
class GetCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomTemplateResponseBody> body{};

  GetCustomTemplateResponse() {}

  explicit GetCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomTemplateResponse() = default;
};
class GetEdgeTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  GetEdgeTranscodeJobRequest() {}

  explicit GetEdgeTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetEdgeTranscodeJobRequest() = default;
};
class GetEdgeTranscodeJobResponseBodyJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> lastStartAt{};
  shared_ptr<string> lastStopAt{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> streamInput{};
  shared_ptr<string> streamOutput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> type{};

  GetEdgeTranscodeJobResponseBodyJob() {}

  explicit GetEdgeTranscodeJobResponseBodyJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (lastStartAt) {
      res["LastStartAt"] = boost::any(*lastStartAt);
    }
    if (lastStopAt) {
      res["LastStopAt"] = boost::any(*lastStopAt);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = boost::any(*streamInput);
    }
    if (streamOutput) {
      res["StreamOutput"] = boost::any(*streamOutput);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("LastStartAt") != m.end() && !m["LastStartAt"].empty()) {
      lastStartAt = make_shared<string>(boost::any_cast<string>(m["LastStartAt"]));
    }
    if (m.find("LastStopAt") != m.end() && !m["LastStopAt"].empty()) {
      lastStopAt = make_shared<string>(boost::any_cast<string>(m["LastStopAt"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInput = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("StreamOutput") != m.end() && !m["StreamOutput"].empty()) {
      streamOutput = make_shared<string>(boost::any_cast<string>(m["StreamOutput"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetEdgeTranscodeJobResponseBodyJob() = default;
};
class GetEdgeTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetEdgeTranscodeJobResponseBodyJob> job{};
  shared_ptr<string> requestId{};

  GetEdgeTranscodeJobResponseBody() {}

  explicit GetEdgeTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        GetEdgeTranscodeJobResponseBodyJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<GetEdgeTranscodeJobResponseBodyJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEdgeTranscodeJobResponseBody() = default;
};
class GetEdgeTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeTranscodeJobResponseBody> body{};

  GetEdgeTranscodeJobResponse() {}

  explicit GetEdgeTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeTranscodeJobResponse() = default;
};
class GetEdgeTranscodeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> templateId{};

  GetEdgeTranscodeTemplateRequest() {}

  explicit GetEdgeTranscodeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetEdgeTranscodeTemplateRequest() = default;
};
class GetEdgeTranscodeTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> codec{};
  shared_ptr<string> createTime{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> name{};
  shared_ptr<string> resolution{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  GetEdgeTranscodeTemplateResponseBodyTemplate() {}

  explicit GetEdgeTranscodeTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resolution) {
      res["Resolution"] = boost::any(*resolution);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Resolution") != m.end() && !m["Resolution"].empty()) {
      resolution = make_shared<string>(boost::any_cast<string>(m["Resolution"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetEdgeTranscodeTemplateResponseBodyTemplate() = default;
};
class GetEdgeTranscodeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetEdgeTranscodeTemplateResponseBodyTemplate> template_{};

  GetEdgeTranscodeTemplateResponseBody() {}

  explicit GetEdgeTranscodeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        GetEdgeTranscodeTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<GetEdgeTranscodeTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~GetEdgeTranscodeTemplateResponseBody() = default;
};
class GetEdgeTranscodeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEdgeTranscodeTemplateResponseBody> body{};

  GetEdgeTranscodeTemplateResponse() {}

  explicit GetEdgeTranscodeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEdgeTranscodeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEdgeTranscodeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetEdgeTranscodeTemplateResponse() = default;
};
class GetEditingJobInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> showId{};

  GetEditingJobInfoRequest() {}

  explicit GetEditingJobInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
  }


  virtual ~GetEditingJobInfoRequest() = default;
};
class GetEditingJobInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> editingTasksInfo{};
  shared_ptr<string> requestId{};

  GetEditingJobInfoResponseBody() {}

  explicit GetEditingJobInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (editingTasksInfo) {
      res["EditingTasksInfo"] = boost::any(*editingTasksInfo);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EditingTasksInfo") != m.end() && !m["EditingTasksInfo"].empty()) {
      editingTasksInfo = make_shared<string>(boost::any_cast<string>(m["EditingTasksInfo"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEditingJobInfoResponseBody() = default;
};
class GetEditingJobInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEditingJobInfoResponseBody> body{};

  GetEditingJobInfoResponse() {}

  explicit GetEditingJobInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEditingJobInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEditingJobInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetEditingJobInfoResponse() = default;
};
class GetMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  GetMessageAppRequest() {}

  explicit GetMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~GetMessageAppRequest() = default;
};
class GetMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> appConfig{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<map<string, string>> extension{};
  shared_ptr<long> status{};

  GetMessageAppResponseBodyResult() {}

  explicit GetMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["AppConfig"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      appConfig = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetMessageAppResponseBodyResult() = default;
};
class GetMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMessageAppResponseBodyResult> result{};

  GetMessageAppResponseBody() {}

  explicit GetMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetMessageAppResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetMessageAppResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetMessageAppResponseBody() = default;
};
class GetMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMessageAppResponseBody> body{};

  GetMessageAppResponse() {}

  explicit GetMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~GetMessageAppResponse() = default;
};
class GetMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};

  GetMessageGroupRequest() {}

  explicit GetMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~GetMessageGroupRequest() = default;
};
class GetMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<map<string, boost::any>> extension{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> isMuteAll{};
  shared_ptr<long> status{};

  GetMessageGroupResponseBodyResult() {}

  explicit GetMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isMuteAll) {
      res["IsMuteAll"] = boost::any(*isMuteAll);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Extension"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsMuteAll") != m.end() && !m["IsMuteAll"].empty()) {
      isMuteAll = make_shared<bool>(boost::any_cast<bool>(m["IsMuteAll"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetMessageGroupResponseBodyResult() = default;
};
class GetMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMessageGroupResponseBodyResult> result{};

  GetMessageGroupResponseBody() {}

  explicit GetMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetMessageGroupResponseBody() = default;
};
class GetMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMessageGroupResponseBody> body{};

  GetMessageGroupResponse() {}

  explicit GetMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetMessageGroupResponse() = default;
};
class GetMessageTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> userId{};

  GetMessageTokenRequest() {}

  explicit GetMessageTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetMessageTokenRequest() = default;
};
class GetMessageTokenResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<long> accessTokenExpiredTime{};
  shared_ptr<string> refreshToken{};

  GetMessageTokenResponseBodyResult() {}

  explicit GetMessageTokenResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (accessTokenExpiredTime) {
      res["AccessTokenExpiredTime"] = boost::any(*accessTokenExpiredTime);
    }
    if (refreshToken) {
      res["RefreshToken"] = boost::any(*refreshToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("AccessTokenExpiredTime") != m.end() && !m["AccessTokenExpiredTime"].empty()) {
      accessTokenExpiredTime = make_shared<long>(boost::any_cast<long>(m["AccessTokenExpiredTime"]));
    }
    if (m.find("RefreshToken") != m.end() && !m["RefreshToken"].empty()) {
      refreshToken = make_shared<string>(boost::any_cast<string>(m["RefreshToken"]));
    }
  }


  virtual ~GetMessageTokenResponseBodyResult() = default;
};
class GetMessageTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMessageTokenResponseBodyResult> result{};

  GetMessageTokenResponseBody() {}

  explicit GetMessageTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetMessageTokenResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetMessageTokenResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetMessageTokenResponseBody() = default;
};
class GetMessageTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMessageTokenResponseBody> body{};

  GetMessageTokenResponse() {}

  explicit GetMessageTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMessageTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMessageTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GetMessageTokenResponse() = default;
};
class GetTranscodeTaskStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> streamName{};
  shared_ptr<string> transcodingTemplate{};

  GetTranscodeTaskStatusRequest() {}

  explicit GetTranscodeTaskStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transcodingTemplate) {
      res["TranscodingTemplate"] = boost::any(*transcodingTemplate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TranscodingTemplate") != m.end() && !m["TranscodingTemplate"].empty()) {
      transcodingTemplate = make_shared<string>(boost::any_cast<string>(m["TranscodingTemplate"]));
    }
  }


  virtual ~GetTranscodeTaskStatusRequest() = default;
};
class GetTranscodeTaskStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  GetTranscodeTaskStatusResponseBody() {}

  explicit GetTranscodeTaskStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTranscodeTaskStatusResponseBody() = default;
};
class GetTranscodeTaskStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTranscodeTaskStatusResponseBody> body{};

  GetTranscodeTaskStatusResponse() {}

  explicit GetTranscodeTaskStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTranscodeTaskStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTranscodeTaskStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetTranscodeTaskStatusResponse() = default;
};
class HotLiveRtcStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> audioMsid{};
  shared_ptr<string> connectionTimeout{};
  shared_ptr<string> domainName{};
  shared_ptr<string> mediaTimeout{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionCode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};
  shared_ptr<string> videoMsid{};

  HotLiveRtcStreamRequest() {}

  explicit HotLiveRtcStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (audioMsid) {
      res["AudioMsid"] = boost::any(*audioMsid);
    }
    if (connectionTimeout) {
      res["ConnectionTimeout"] = boost::any(*connectionTimeout);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (mediaTimeout) {
      res["MediaTimeout"] = boost::any(*mediaTimeout);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionCode) {
      res["RegionCode"] = boost::any(*regionCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (videoMsid) {
      res["VideoMsid"] = boost::any(*videoMsid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AudioMsid") != m.end() && !m["AudioMsid"].empty()) {
      audioMsid = make_shared<string>(boost::any_cast<string>(m["AudioMsid"]));
    }
    if (m.find("ConnectionTimeout") != m.end() && !m["ConnectionTimeout"].empty()) {
      connectionTimeout = make_shared<string>(boost::any_cast<string>(m["ConnectionTimeout"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MediaTimeout") != m.end() && !m["MediaTimeout"].empty()) {
      mediaTimeout = make_shared<string>(boost::any_cast<string>(m["MediaTimeout"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionCode") != m.end() && !m["RegionCode"].empty()) {
      regionCode = make_shared<string>(boost::any_cast<string>(m["RegionCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("VideoMsid") != m.end() && !m["VideoMsid"].empty()) {
      videoMsid = make_shared<string>(boost::any_cast<string>(m["VideoMsid"]));
    }
  }


  virtual ~HotLiveRtcStreamRequest() = default;
};
class HotLiveRtcStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  HotLiveRtcStreamResponseBody() {}

  explicit HotLiveRtcStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~HotLiveRtcStreamResponseBody() = default;
};
class HotLiveRtcStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotLiveRtcStreamResponseBody> body{};

  HotLiveRtcStreamResponse() {}

  explicit HotLiveRtcStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotLiveRtcStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotLiveRtcStreamResponseBody>(model1);
      }
    }
  }


  virtual ~HotLiveRtcStreamResponse() = default;
};
class InitializeAutoShowListTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> callBackUrl{};
  shared_ptr<string> casterConfig{};
  shared_ptr<string> domainName{};
  shared_ptr<long> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceIds{};
  shared_ptr<long> startTime{};

  InitializeAutoShowListTaskRequest() {}

  explicit InitializeAutoShowListTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callBackUrl) {
      res["CallBackUrl"] = boost::any(*callBackUrl);
    }
    if (casterConfig) {
      res["CasterConfig"] = boost::any(*casterConfig);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallBackUrl") != m.end() && !m["CallBackUrl"].empty()) {
      callBackUrl = make_shared<string>(boost::any_cast<string>(m["CallBackUrl"]));
    }
    if (m.find("CasterConfig") != m.end() && !m["CasterConfig"].empty()) {
      casterConfig = make_shared<string>(boost::any_cast<string>(m["CasterConfig"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~InitializeAutoShowListTaskRequest() = default;
};
class InitializeAutoShowListTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> streamList{};

  InitializeAutoShowListTaskResponseBody() {}

  explicit InitializeAutoShowListTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamList) {
      res["StreamList"] = boost::any(*streamList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamList") != m.end() && !m["StreamList"].empty()) {
      streamList = make_shared<string>(boost::any_cast<string>(m["StreamList"]));
    }
  }


  virtual ~InitializeAutoShowListTaskResponseBody() = default;
};
class InitializeAutoShowListTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitializeAutoShowListTaskResponseBody> body{};

  InitializeAutoShowListTaskResponse() {}

  explicit InitializeAutoShowListTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitializeAutoShowListTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitializeAutoShowListTaskResponseBody>(model1);
      }
    }
  }


  virtual ~InitializeAutoShowListTaskResponse() = default;
};
class JoinMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> broadCastStatistics{};
  shared_ptr<long> broadCastType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> userId{};

  JoinMessageGroupRequest() {}

  explicit JoinMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastStatistics) {
      res["BroadCastStatistics"] = boost::any(*broadCastStatistics);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastStatistics") != m.end() && !m["BroadCastStatistics"].empty()) {
      broadCastStatistics = make_shared<bool>(boost::any_cast<bool>(m["BroadCastStatistics"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~JoinMessageGroupRequest() = default;
};
class JoinMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  JoinMessageGroupResponseBodyResult() {}

  explicit JoinMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~JoinMessageGroupResponseBodyResult() = default;
};
class JoinMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<JoinMessageGroupResponseBodyResult> result{};

  JoinMessageGroupResponseBody() {}

  explicit JoinMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        JoinMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<JoinMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~JoinMessageGroupResponseBody() = default;
};
class JoinMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinMessageGroupResponseBody> body{};

  JoinMessageGroupResponse() {}

  explicit JoinMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~JoinMessageGroupResponse() = default;
};
class KickLiveMessageGroupUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<string> kickoffUser{};

  KickLiveMessageGroupUserRequest() {}

  explicit KickLiveMessageGroupUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (kickoffUser) {
      res["KickoffUser"] = boost::any(*kickoffUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("KickoffUser") != m.end() && !m["KickoffUser"].empty()) {
      kickoffUser = make_shared<string>(boost::any_cast<string>(m["KickoffUser"]));
    }
  }


  virtual ~KickLiveMessageGroupUserRequest() = default;
};
class KickLiveMessageGroupUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  KickLiveMessageGroupUserResponseBody() {}

  explicit KickLiveMessageGroupUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~KickLiveMessageGroupUserResponseBody() = default;
};
class KickLiveMessageGroupUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<KickLiveMessageGroupUserResponseBody> body{};

  KickLiveMessageGroupUserResponse() {}

  explicit KickLiveMessageGroupUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        KickLiveMessageGroupUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<KickLiveMessageGroupUserResponseBody>(model1);
      }
    }
  }


  virtual ~KickLiveMessageGroupUserResponse() = default;
};
class LeaveMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> broadCastStatistics{};
  shared_ptr<long> broadCastType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> userId{};

  LeaveMessageGroupRequest() {}

  explicit LeaveMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastStatistics) {
      res["BroadCastStatistics"] = boost::any(*broadCastStatistics);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastStatistics") != m.end() && !m["BroadCastStatistics"].empty()) {
      broadCastStatistics = make_shared<bool>(boost::any_cast<bool>(m["BroadCastStatistics"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~LeaveMessageGroupRequest() = default;
};
class LeaveMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  LeaveMessageGroupResponseBodyResult() {}

  explicit LeaveMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~LeaveMessageGroupResponseBodyResult() = default;
};
class LeaveMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<LeaveMessageGroupResponseBodyResult> result{};

  LeaveMessageGroupResponseBody() {}

  explicit LeaveMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        LeaveMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<LeaveMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~LeaveMessageGroupResponseBody() = default;
};
class LeaveMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LeaveMessageGroupResponseBody> body{};

  LeaveMessageGroupResponse() {}

  explicit LeaveMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LeaveMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LeaveMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~LeaveMessageGroupResponse() = default;
};
class ListEdgeTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> keyword{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  ListEdgeTranscodeJobRequest() {}

  explicit ListEdgeTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListEdgeTranscodeJobRequest() = default;
};
class ListEdgeTranscodeJobResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> lastStartAt{};
  shared_ptr<string> lastStopAt{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> streamInput{};
  shared_ptr<string> streamOutput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> type{};

  ListEdgeTranscodeJobResponseBodyJobListJob() {}

  explicit ListEdgeTranscodeJobResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (lastStartAt) {
      res["LastStartAt"] = boost::any(*lastStartAt);
    }
    if (lastStopAt) {
      res["LastStopAt"] = boost::any(*lastStopAt);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = boost::any(*streamInput);
    }
    if (streamOutput) {
      res["StreamOutput"] = boost::any(*streamOutput);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("LastStartAt") != m.end() && !m["LastStartAt"].empty()) {
      lastStartAt = make_shared<string>(boost::any_cast<string>(m["LastStartAt"]));
    }
    if (m.find("LastStopAt") != m.end() && !m["LastStopAt"].empty()) {
      lastStopAt = make_shared<string>(boost::any_cast<string>(m["LastStopAt"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInput = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("StreamOutput") != m.end() && !m["StreamOutput"].empty()) {
      streamOutput = make_shared<string>(boost::any_cast<string>(m["StreamOutput"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListEdgeTranscodeJobResponseBodyJobListJob() = default;
};
class ListEdgeTranscodeJobResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEdgeTranscodeJobResponseBodyJobListJob>> job{};

  ListEdgeTranscodeJobResponseBodyJobList() {}

  explicit ListEdgeTranscodeJobResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<ListEdgeTranscodeJobResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEdgeTranscodeJobResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<ListEdgeTranscodeJobResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~ListEdgeTranscodeJobResponseBodyJobList() = default;
};
class ListEdgeTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListEdgeTranscodeJobResponseBodyJobList> jobList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListEdgeTranscodeJobResponseBody() {}

  explicit ListEdgeTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        ListEdgeTranscodeJobResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<ListEdgeTranscodeJobResponseBodyJobList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEdgeTranscodeJobResponseBody() = default;
};
class ListEdgeTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEdgeTranscodeJobResponseBody> body{};

  ListEdgeTranscodeJobResponse() {}

  explicit ListEdgeTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEdgeTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEdgeTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListEdgeTranscodeJobResponse() = default;
};
class ListEdgeTranscodeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> keyword{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> type{};
  shared_ptr<string> videoCodec{};

  ListEdgeTranscodeTemplateRequest() {}

  explicit ListEdgeTranscodeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
  }


  virtual ~ListEdgeTranscodeTemplateRequest() = default;
};
class ListEdgeTranscodeTemplateResponseBodyTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> codec{};
  shared_ptr<string> createTime{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> name{};
  shared_ptr<string> resolution{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  ListEdgeTranscodeTemplateResponseBodyTemplateListTemplate() {}

  explicit ListEdgeTranscodeTemplateResponseBodyTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resolution) {
      res["Resolution"] = boost::any(*resolution);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Resolution") != m.end() && !m["Resolution"].empty()) {
      resolution = make_shared<string>(boost::any_cast<string>(m["Resolution"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListEdgeTranscodeTemplateResponseBodyTemplateListTemplate() = default;
};
class ListEdgeTranscodeTemplateResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEdgeTranscodeTemplateResponseBodyTemplateListTemplate>> template_{};

  ListEdgeTranscodeTemplateResponseBodyTemplateList() {}

  explicit ListEdgeTranscodeTemplateResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<ListEdgeTranscodeTemplateResponseBodyTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEdgeTranscodeTemplateResponseBodyTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<ListEdgeTranscodeTemplateResponseBodyTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~ListEdgeTranscodeTemplateResponseBodyTemplateList() = default;
};
class ListEdgeTranscodeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListEdgeTranscodeTemplateResponseBodyTemplateList> templateList{};
  shared_ptr<long> totalCount{};

  ListEdgeTranscodeTemplateResponseBody() {}

  explicit ListEdgeTranscodeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        ListEdgeTranscodeTemplateResponseBodyTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<ListEdgeTranscodeTemplateResponseBodyTemplateList>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEdgeTranscodeTemplateResponseBody() = default;
};
class ListEdgeTranscodeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEdgeTranscodeTemplateResponseBody> body{};

  ListEdgeTranscodeTemplateResponse() {}

  explicit ListEdgeTranscodeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEdgeTranscodeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEdgeTranscodeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ListEdgeTranscodeTemplateResponse() = default;
};
class ListEventSubRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListEventSubRequest() {}

  explicit ListEventSubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListEventSubRequest() = default;
};
class ListEventSubResponseBodySubscribers : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> channelId{};
  shared_ptr<string> createTime{};
  shared_ptr<vector<string>> events{};
  shared_ptr<string> modifyTime{};
  shared_ptr<long> roles{};
  shared_ptr<string> subId{};
  shared_ptr<vector<string>> users{};

  ListEventSubResponseBodySubscribers() {}

  explicit ListEventSubResponseBodySubscribers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (events) {
      res["Events"] = boost::any(*events);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (roles) {
      res["Roles"] = boost::any(*roles);
    }
    if (subId) {
      res["SubId"] = boost::any(*subId);
    }
    if (users) {
      res["Users"] = boost::any(*users);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Events") != m.end() && !m["Events"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Events"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Events"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      events = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      roles = make_shared<long>(boost::any_cast<long>(m["Roles"]));
    }
    if (m.find("SubId") != m.end() && !m["SubId"].empty()) {
      subId = make_shared<string>(boost::any_cast<string>(m["SubId"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Users"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      users = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListEventSubResponseBodySubscribers() = default;
};
class ListEventSubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListEventSubResponseBodySubscribers>> subscribers{};

  ListEventSubResponseBody() {}

  explicit ListEventSubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subscribers) {
      vector<boost::any> temp1;
      for(auto item1:*subscribers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subscribers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Subscribers") != m.end() && !m["Subscribers"].empty()) {
      if (typeid(vector<boost::any>) == m["Subscribers"].type()) {
        vector<ListEventSubResponseBodySubscribers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subscribers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventSubResponseBodySubscribers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subscribers = make_shared<vector<ListEventSubResponseBodySubscribers>>(expect1);
      }
    }
  }


  virtual ~ListEventSubResponseBody() = default;
};
class ListEventSubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEventSubResponseBody> body{};

  ListEventSubResponse() {}

  explicit ListEventSubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEventSubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEventSubResponseBody>(model1);
      }
    }
  }


  virtual ~ListEventSubResponse() = default;
};
class ListEventSubEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<string> subscribeId{};

  ListEventSubEventRequest() {}

  explicit ListEventSubEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (subscribeId) {
      res["SubscribeId"] = boost::any(*subscribeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("SubscribeId") != m.end() && !m["SubscribeId"].empty()) {
      subscribeId = make_shared<string>(boost::any_cast<string>(m["SubscribeId"]));
    }
  }


  virtual ~ListEventSubEventRequest() = default;
};
class ListEventSubEventResponseBodyLogs : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> code{};
  shared_ptr<long> cost{};
  shared_ptr<string> data{};
  shared_ptr<string> messageId{};
  shared_ptr<string> subId{};
  shared_ptr<string> time{};
  shared_ptr<string> url{};

  ListEventSubEventResponseBodyLogs() {}

  explicit ListEventSubEventResponseBodyLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (subId) {
      res["SubId"] = boost::any(*subId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("SubId") != m.end() && !m["SubId"].empty()) {
      subId = make_shared<string>(boost::any_cast<string>(m["SubId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListEventSubEventResponseBodyLogs() = default;
};
class ListEventSubEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<ListEventSubEventResponseBodyLogs>> logs{};
  shared_ptr<string> requestId{};

  ListEventSubEventResponseBody() {}

  explicit ListEventSubEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<ListEventSubEventResponseBodyLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventSubEventResponseBodyLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<ListEventSubEventResponseBodyLogs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEventSubEventResponseBody() = default;
};
class ListEventSubEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEventSubEventResponseBody> body{};

  ListEventSubEventResponse() {}

  explicit ListEventSubEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEventSubEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEventSubEventResponseBody>(model1);
      }
    }
  }


  virtual ~ListEventSubEventResponse() = default;
};
class ListLiveDelayConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  ListLiveDelayConfigRequest() {}

  explicit ListLiveDelayConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListLiveDelayConfigRequest() = default;
};
class ListLiveDelayConfigResponseBodyDelayConfigListDelayConfig : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> delayTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> stream{};
  shared_ptr<string> taskTriggerMode{};

  ListLiveDelayConfigResponseBodyDelayConfigListDelayConfig() {}

  explicit ListLiveDelayConfigResponseBodyDelayConfigListDelayConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (delayTime) {
      res["DelayTime"] = boost::any(*delayTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (taskTriggerMode) {
      res["TaskTriggerMode"] = boost::any(*taskTriggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("DelayTime") != m.end() && !m["DelayTime"].empty()) {
      delayTime = make_shared<string>(boost::any_cast<string>(m["DelayTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TaskTriggerMode") != m.end() && !m["TaskTriggerMode"].empty()) {
      taskTriggerMode = make_shared<string>(boost::any_cast<string>(m["TaskTriggerMode"]));
    }
  }


  virtual ~ListLiveDelayConfigResponseBodyDelayConfigListDelayConfig() = default;
};
class ListLiveDelayConfigResponseBodyDelayConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveDelayConfigResponseBodyDelayConfigListDelayConfig>> delayConfig{};

  ListLiveDelayConfigResponseBodyDelayConfigList() {}

  explicit ListLiveDelayConfigResponseBodyDelayConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delayConfig) {
      vector<boost::any> temp1;
      for(auto item1:*delayConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DelayConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DelayConfig") != m.end() && !m["DelayConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["DelayConfig"].type()) {
        vector<ListLiveDelayConfigResponseBodyDelayConfigListDelayConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DelayConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveDelayConfigResponseBodyDelayConfigListDelayConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        delayConfig = make_shared<vector<ListLiveDelayConfigResponseBodyDelayConfigListDelayConfig>>(expect1);
      }
    }
  }


  virtual ~ListLiveDelayConfigResponseBodyDelayConfigList() = default;
};
class ListLiveDelayConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListLiveDelayConfigResponseBodyDelayConfigList> delayConfigList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListLiveDelayConfigResponseBody() {}

  explicit ListLiveDelayConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delayConfigList) {
      res["DelayConfigList"] = delayConfigList ? boost::any(delayConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DelayConfigList") != m.end() && !m["DelayConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DelayConfigList"].type()) {
        ListLiveDelayConfigResponseBodyDelayConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DelayConfigList"]));
        delayConfigList = make_shared<ListLiveDelayConfigResponseBodyDelayConfigList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListLiveDelayConfigResponseBody() = default;
};
class ListLiveDelayConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveDelayConfigResponseBody> body{};

  ListLiveDelayConfigResponse() {}

  explicit ListLiveDelayConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveDelayConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveDelayConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveDelayConfigResponse() = default;
};
class ListLiveMessageAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataCenter{};
  shared_ptr<long> nextPageToken{};
  shared_ptr<long> sortType{};

  ListLiveMessageAppsRequest() {}

  explicit ListLiveMessageAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<long>(boost::any_cast<long>(m["NextPageToken"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
  }


  virtual ~ListLiveMessageAppsRequest() = default;
};
class ListLiveMessageAppsResponseBodyAppList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appName{};
  shared_ptr<string> appSign{};
  shared_ptr<long> createTime{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> disable{};
  shared_ptr<long> modifyTime{};
  shared_ptr<long> msgLifeCycle{};

  ListLiveMessageAppsResponseBodyAppList() {}

  explicit ListLiveMessageAppsResponseBodyAppList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appSign) {
      res["AppSign"] = boost::any(*appSign);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (disable) {
      res["Disable"] = boost::any(*disable);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (msgLifeCycle) {
      res["MsgLifeCycle"] = boost::any(*msgLifeCycle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppSign") != m.end() && !m["AppSign"].empty()) {
      appSign = make_shared<string>(boost::any_cast<string>(m["AppSign"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("Disable") != m.end() && !m["Disable"].empty()) {
      disable = make_shared<string>(boost::any_cast<string>(m["Disable"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("MsgLifeCycle") != m.end() && !m["MsgLifeCycle"].empty()) {
      msgLifeCycle = make_shared<long>(boost::any_cast<long>(m["MsgLifeCycle"]));
    }
  }


  virtual ~ListLiveMessageAppsResponseBodyAppList() = default;
};
class ListLiveMessageAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveMessageAppsResponseBodyAppList>> appList{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextPageToken{};
  shared_ptr<string> requestId{};

  ListLiveMessageAppsResponseBody() {}

  explicit ListLiveMessageAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appList) {
      vector<boost::any> temp1;
      for(auto item1:*appList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppList"] = boost::any(temp1);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppList") != m.end() && !m["AppList"].empty()) {
      if (typeid(vector<boost::any>) == m["AppList"].type()) {
        vector<ListLiveMessageAppsResponseBodyAppList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveMessageAppsResponseBodyAppList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appList = make_shared<vector<ListLiveMessageAppsResponseBodyAppList>>(expect1);
      }
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<long>(boost::any_cast<long>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListLiveMessageAppsResponseBody() = default;
};
class ListLiveMessageAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveMessageAppsResponseBody> body{};

  ListLiveMessageAppsResponse() {}

  explicit ListLiveMessageAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveMessageAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveMessageAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveMessageAppsResponse() = default;
};
class ListLiveMessageGroupByPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<long> groupStatus{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};

  ListLiveMessageGroupByPageRequest() {}

  explicit ListLiveMessageGroupByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupStatus) {
      res["GroupStatus"] = boost::any(*groupStatus);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupStatus") != m.end() && !m["GroupStatus"].empty()) {
      groupStatus = make_shared<long>(boost::any_cast<long>(m["GroupStatus"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
  }


  virtual ~ListLiveMessageGroupByPageRequest() = default;
};
class ListLiveMessageGroupByPageResponseBodyGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> adminList{};
  shared_ptr<long> createtime{};
  shared_ptr<string> creatorId{};
  shared_ptr<bool> delete_{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupInfo{};
  shared_ptr<string> groupName{};

  ListLiveMessageGroupByPageResponseBodyGroupList() {}

  explicit ListLiveMessageGroupByPageResponseBodyGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminList) {
      res["AdminList"] = boost::any(*adminList);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupInfo) {
      res["GroupInfo"] = boost::any(*groupInfo);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdminList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      adminList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      groupInfo = make_shared<string>(boost::any_cast<string>(m["GroupInfo"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~ListLiveMessageGroupByPageResponseBodyGroupList() = default;
};
class ListLiveMessageGroupByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveMessageGroupByPageResponseBodyGroupList>> groupList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListLiveMessageGroupByPageResponseBody() {}

  explicit ListLiveMessageGroupByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupList) {
      vector<boost::any> temp1;
      for(auto item1:*groupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupList") != m.end() && !m["GroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupList"].type()) {
        vector<ListLiveMessageGroupByPageResponseBodyGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveMessageGroupByPageResponseBodyGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupList = make_shared<vector<ListLiveMessageGroupByPageResponseBodyGroupList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveMessageGroupByPageResponseBody() = default;
};
class ListLiveMessageGroupByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveMessageGroupByPageResponseBody> body{};

  ListLiveMessageGroupByPageResponse() {}

  explicit ListLiveMessageGroupByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveMessageGroupByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveMessageGroupByPageResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveMessageGroupByPageResponse() = default;
};
class ListLiveMessageGroupMessagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> beginTime{};
  shared_ptr<string> dataCenter{};
  shared_ptr<long> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<long> msgType{};
  shared_ptr<long> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};

  ListLiveMessageGroupMessagesRequest() {}

  explicit ListLiveMessageGroupMessagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (msgType) {
      res["MsgType"] = boost::any(*msgType);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MsgType") != m.end() && !m["MsgType"].empty()) {
      msgType = make_shared<long>(boost::any_cast<long>(m["MsgType"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<long>(boost::any_cast<long>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
  }


  virtual ~ListLiveMessageGroupMessagesRequest() = default;
};
class ListLiveMessageGroupMessagesResponseBodyMessageListSender : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userInfo{};

  ListLiveMessageGroupMessagesResponseBodyMessageListSender() {}

  explicit ListLiveMessageGroupMessagesResponseBodyMessageListSender(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userInfo) {
      res["UserInfo"] = boost::any(*userInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      userInfo = make_shared<string>(boost::any_cast<string>(m["UserInfo"]));
    }
  }


  virtual ~ListLiveMessageGroupMessagesResponseBodyMessageListSender() = default;
};
class ListLiveMessageGroupMessagesResponseBodyMessageList : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> msgTid{};
  shared_ptr<long> msgType{};
  shared_ptr<ListLiveMessageGroupMessagesResponseBodyMessageListSender> sender{};
  shared_ptr<long> seqNumber{};
  shared_ptr<long> timestamp{};
  shared_ptr<long> totalMessages{};

  ListLiveMessageGroupMessagesResponseBodyMessageList() {}

  explicit ListLiveMessageGroupMessagesResponseBodyMessageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (msgTid) {
      res["MsgTid"] = boost::any(*msgTid);
    }
    if (msgType) {
      res["MsgType"] = boost::any(*msgType);
    }
    if (sender) {
      res["Sender"] = sender ? boost::any(sender->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seqNumber) {
      res["SeqNumber"] = boost::any(*seqNumber);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (totalMessages) {
      res["TotalMessages"] = boost::any(*totalMessages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("MsgTid") != m.end() && !m["MsgTid"].empty()) {
      msgTid = make_shared<string>(boost::any_cast<string>(m["MsgTid"]));
    }
    if (m.find("MsgType") != m.end() && !m["MsgType"].empty()) {
      msgType = make_shared<long>(boost::any_cast<long>(m["MsgType"]));
    }
    if (m.find("Sender") != m.end() && !m["Sender"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sender"].type()) {
        ListLiveMessageGroupMessagesResponseBodyMessageListSender model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sender"]));
        sender = make_shared<ListLiveMessageGroupMessagesResponseBodyMessageListSender>(model1);
      }
    }
    if (m.find("SeqNumber") != m.end() && !m["SeqNumber"].empty()) {
      seqNumber = make_shared<long>(boost::any_cast<long>(m["SeqNumber"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TotalMessages") != m.end() && !m["TotalMessages"].empty()) {
      totalMessages = make_shared<long>(boost::any_cast<long>(m["TotalMessages"]));
    }
  }


  virtual ~ListLiveMessageGroupMessagesResponseBodyMessageList() = default;
};
class ListLiveMessageGroupMessagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<bool> hasmore{};
  shared_ptr<vector<ListLiveMessageGroupMessagesResponseBodyMessageList>> messageList{};
  shared_ptr<long> nextPageToken{};
  shared_ptr<string> requestId{};

  ListLiveMessageGroupMessagesResponseBody() {}

  explicit ListLiveMessageGroupMessagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hasmore) {
      res["Hasmore"] = boost::any(*hasmore);
    }
    if (messageList) {
      vector<boost::any> temp1;
      for(auto item1:*messageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MessageList"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Hasmore") != m.end() && !m["Hasmore"].empty()) {
      hasmore = make_shared<bool>(boost::any_cast<bool>(m["Hasmore"]));
    }
    if (m.find("MessageList") != m.end() && !m["MessageList"].empty()) {
      if (typeid(vector<boost::any>) == m["MessageList"].type()) {
        vector<ListLiveMessageGroupMessagesResponseBodyMessageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MessageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveMessageGroupMessagesResponseBodyMessageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messageList = make_shared<vector<ListLiveMessageGroupMessagesResponseBodyMessageList>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<long>(boost::any_cast<long>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListLiveMessageGroupMessagesResponseBody() = default;
};
class ListLiveMessageGroupMessagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveMessageGroupMessagesResponseBody> body{};

  ListLiveMessageGroupMessagesResponse() {}

  explicit ListLiveMessageGroupMessagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveMessageGroupMessagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveMessageGroupMessagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveMessageGroupMessagesResponse() = default;
};
class ListLiveMessageGroupUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<long> nextPageToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};

  ListLiveMessageGroupUsersRequest() {}

  explicit ListLiveMessageGroupUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<long>(boost::any_cast<long>(m["NextPageToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
  }


  virtual ~ListLiveMessageGroupUsersRequest() = default;
};
class ListLiveMessageGroupUsersResponseBodyUserList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userInfo{};

  ListLiveMessageGroupUsersResponseBodyUserList() {}

  explicit ListLiveMessageGroupUsersResponseBodyUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userInfo) {
      res["UserInfo"] = boost::any(*userInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      userInfo = make_shared<string>(boost::any_cast<string>(m["UserInfo"]));
    }
  }


  virtual ~ListLiveMessageGroupUsersResponseBodyUserList() = default;
};
class ListLiveMessageGroupUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<bool> hasmore{};
  shared_ptr<long> nextPageToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListLiveMessageGroupUsersResponseBodyUserList>> userList{};

  ListLiveMessageGroupUsersResponseBody() {}

  explicit ListLiveMessageGroupUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hasmore) {
      res["Hasmore"] = boost::any(*hasmore);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Hasmore") != m.end() && !m["Hasmore"].empty()) {
      hasmore = make_shared<bool>(boost::any_cast<bool>(m["Hasmore"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<long>(boost::any_cast<long>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<ListLiveMessageGroupUsersResponseBodyUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveMessageGroupUsersResponseBodyUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<ListLiveMessageGroupUsersResponseBodyUserList>>(expect1);
      }
    }
  }


  virtual ~ListLiveMessageGroupUsersResponseBody() = default;
};
class ListLiveMessageGroupUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveMessageGroupUsersResponseBody> body{};

  ListLiveMessageGroupUsersResponse() {}

  explicit ListLiveMessageGroupUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveMessageGroupUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveMessageGroupUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveMessageGroupUsersResponse() = default;
};
class ListLiveMessageGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<long> groupStatus{};
  shared_ptr<long> nextPageToken{};
  shared_ptr<long> sortType{};

  ListLiveMessageGroupsRequest() {}

  explicit ListLiveMessageGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupStatus) {
      res["GroupStatus"] = boost::any(*groupStatus);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupStatus") != m.end() && !m["GroupStatus"].empty()) {
      groupStatus = make_shared<long>(boost::any_cast<long>(m["GroupStatus"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<long>(boost::any_cast<long>(m["NextPageToken"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
  }


  virtual ~ListLiveMessageGroupsRequest() = default;
};
class ListLiveMessageGroupsResponseBodyGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> adminList{};
  shared_ptr<long> createtime{};
  shared_ptr<string> creatorId{};
  shared_ptr<bool> delete_{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupInfo{};
  shared_ptr<string> groupName{};

  ListLiveMessageGroupsResponseBodyGroupList() {}

  explicit ListLiveMessageGroupsResponseBodyGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminList) {
      res["AdminList"] = boost::any(*adminList);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupInfo) {
      res["GroupInfo"] = boost::any(*groupInfo);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdminList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      adminList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      groupInfo = make_shared<string>(boost::any_cast<string>(m["GroupInfo"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~ListLiveMessageGroupsResponseBodyGroupList() = default;
};
class ListLiveMessageGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveMessageGroupsResponseBodyGroupList>> groupList{};
  shared_ptr<bool> hasmore{};
  shared_ptr<string> nextpageToken{};
  shared_ptr<string> requestId{};

  ListLiveMessageGroupsResponseBody() {}

  explicit ListLiveMessageGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupList) {
      vector<boost::any> temp1;
      for(auto item1:*groupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupList"] = boost::any(temp1);
    }
    if (hasmore) {
      res["Hasmore"] = boost::any(*hasmore);
    }
    if (nextpageToken) {
      res["NextpageToken"] = boost::any(*nextpageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupList") != m.end() && !m["GroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupList"].type()) {
        vector<ListLiveMessageGroupsResponseBodyGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveMessageGroupsResponseBodyGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupList = make_shared<vector<ListLiveMessageGroupsResponseBodyGroupList>>(expect1);
      }
    }
    if (m.find("Hasmore") != m.end() && !m["Hasmore"].empty()) {
      hasmore = make_shared<bool>(boost::any_cast<bool>(m["Hasmore"]));
    }
    if (m.find("NextpageToken") != m.end() && !m["NextpageToken"].empty()) {
      nextpageToken = make_shared<string>(boost::any_cast<string>(m["NextpageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListLiveMessageGroupsResponseBody() = default;
};
class ListLiveMessageGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveMessageGroupsResponseBody> body{};

  ListLiveMessageGroupsResponse() {}

  explicit ListLiveMessageGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveMessageGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveMessageGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveMessageGroupsResponse() = default;
};
class ListLiveRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveOpenapiReserve{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  ListLiveRealtimeLogDeliveryRequest() {}

  explicit ListLiveRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveOpenapiReserve) {
      res["LiveOpenapiReserve"] = boost::any(*liveOpenapiReserve);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveOpenapiReserve") != m.end() && !m["LiveOpenapiReserve"].empty()) {
      liveOpenapiReserve = make_shared<string>(boost::any_cast<string>(m["LiveOpenapiReserve"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryRequest() = default;
};
class ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo : public Darabonba::Model {
public:
  shared_ptr<long> dmId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};

  ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo() {}

  explicit ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dmId) {
      res["DmId"] = boost::any(*dmId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DmId") != m.end() && !m["DmId"].empty()) {
      dmId = make_shared<long>(boost::any_cast<long>(m["DmId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo() = default;
};
class ListLiveRealtimeLogDeliveryResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo>> realtimeLogDeliveryInfo{};

  ListLiveRealtimeLogDeliveryResponseBodyContent() {}

  explicit ListLiveRealtimeLogDeliveryResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realtimeLogDeliveryInfo) {
      vector<boost::any> temp1;
      for(auto item1:*realtimeLogDeliveryInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealtimeLogDeliveryInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealtimeLogDeliveryInfo") != m.end() && !m["RealtimeLogDeliveryInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["RealtimeLogDeliveryInfo"].type()) {
        vector<ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealtimeLogDeliveryInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realtimeLogDeliveryInfo = make_shared<vector<ListLiveRealtimeLogDeliveryResponseBodyContentRealtimeLogDeliveryInfo>>(expect1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryResponseBodyContent() = default;
};
class ListLiveRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListLiveRealtimeLogDeliveryResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  ListLiveRealtimeLogDeliveryResponseBody() {}

  explicit ListLiveRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        ListLiveRealtimeLogDeliveryResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<ListLiveRealtimeLogDeliveryResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryResponseBody() = default;
};
class ListLiveRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRealtimeLogDeliveryResponseBody> body{};

  ListLiveRealtimeLogDeliveryResponse() {}

  explicit ListLiveRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryResponse() = default;
};
class ListLiveRealtimeLogDeliveryDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};

  ListLiveRealtimeLogDeliveryDomainsRequest() {}

  explicit ListLiveRealtimeLogDeliveryDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryDomainsRequest() = default;
};
class ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> status{};

  ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains() {}

  explicit ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains() = default;
};
class ListLiveRealtimeLogDeliveryDomainsResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains>> domains{};

  ListLiveRealtimeLogDeliveryDomainsResponseBodyContent() {}

  explicit ListLiveRealtimeLogDeliveryDomainsResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<ListLiveRealtimeLogDeliveryDomainsResponseBodyContentDomains>>(expect1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryDomainsResponseBodyContent() = default;
};
class ListLiveRealtimeLogDeliveryDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListLiveRealtimeLogDeliveryDomainsResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  ListLiveRealtimeLogDeliveryDomainsResponseBody() {}

  explicit ListLiveRealtimeLogDeliveryDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        ListLiveRealtimeLogDeliveryDomainsResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<ListLiveRealtimeLogDeliveryDomainsResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryDomainsResponseBody() = default;
};
class ListLiveRealtimeLogDeliveryDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRealtimeLogDeliveryDomainsResponseBody> body{};

  ListLiveRealtimeLogDeliveryDomainsResponse() {}

  explicit ListLiveRealtimeLogDeliveryDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRealtimeLogDeliveryDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRealtimeLogDeliveryDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryDomainsResponse() = default;
};
class ListLiveRealtimeLogDeliveryInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveOpenapiReserve{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  ListLiveRealtimeLogDeliveryInfosRequest() {}

  explicit ListLiveRealtimeLogDeliveryInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveOpenapiReserve) {
      res["LiveOpenapiReserve"] = boost::any(*liveOpenapiReserve);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveOpenapiReserve") != m.end() && !m["LiveOpenapiReserve"].empty()) {
      liveOpenapiReserve = make_shared<string>(boost::any_cast<string>(m["LiveOpenapiReserve"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryInfosRequest() = default;
};
class ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos() {}

  explicit ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos() = default;
};
class ListLiveRealtimeLogDeliveryInfosResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos>> realtimeLogDeliveryInfos{};

  ListLiveRealtimeLogDeliveryInfosResponseBodyContent() {}

  explicit ListLiveRealtimeLogDeliveryInfosResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realtimeLogDeliveryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*realtimeLogDeliveryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealtimeLogDeliveryInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealtimeLogDeliveryInfos") != m.end() && !m["RealtimeLogDeliveryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["RealtimeLogDeliveryInfos"].type()) {
        vector<ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealtimeLogDeliveryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realtimeLogDeliveryInfos = make_shared<vector<ListLiveRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos>>(expect1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryInfosResponseBodyContent() = default;
};
class ListLiveRealtimeLogDeliveryInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListLiveRealtimeLogDeliveryInfosResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  ListLiveRealtimeLogDeliveryInfosResponseBody() {}

  explicit ListLiveRealtimeLogDeliveryInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        ListLiveRealtimeLogDeliveryInfosResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<ListLiveRealtimeLogDeliveryInfosResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryInfosResponseBody() = default;
};
class ListLiveRealtimeLogDeliveryInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRealtimeLogDeliveryInfosResponseBody> body{};

  ListLiveRealtimeLogDeliveryInfosResponse() {}

  explicit ListLiveRealtimeLogDeliveryInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRealtimeLogDeliveryInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRealtimeLogDeliveryInfosResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRealtimeLogDeliveryInfosResponse() = default;
};
class ListMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};
  shared_ptr<long> type{};

  ListMessageRequest() {}

  explicit ListMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ListMessageRequest() = default;
};
class ListMessageResponseBodyResultMessageList : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> groupId{};
  shared_ptr<string> messageId{};
  shared_ptr<string> senderId{};
  shared_ptr<long> type{};

  ListMessageResponseBodyResultMessageList() {}

  explicit ListMessageResponseBodyResultMessageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (senderId) {
      res["SenderId"] = boost::any(*senderId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("SenderId") != m.end() && !m["SenderId"].empty()) {
      senderId = make_shared<string>(boost::any_cast<string>(m["SenderId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ListMessageResponseBodyResultMessageList() = default;
};
class ListMessageResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<ListMessageResponseBodyResultMessageList>> messageList{};

  ListMessageResponseBodyResult() {}

  explicit ListMessageResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (messageList) {
      vector<boost::any> temp1;
      for(auto item1:*messageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MessageList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("MessageList") != m.end() && !m["MessageList"].empty()) {
      if (typeid(vector<boost::any>) == m["MessageList"].type()) {
        vector<ListMessageResponseBodyResultMessageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MessageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageResponseBodyResultMessageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messageList = make_shared<vector<ListMessageResponseBodyResultMessageList>>(expect1);
      }
    }
  }


  virtual ~ListMessageResponseBodyResult() = default;
};
class ListMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMessageResponseBodyResult> result{};

  ListMessageResponseBody() {}

  explicit ListMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListMessageResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListMessageResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListMessageResponseBody() = default;
};
class ListMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMessageResponseBody> body{};

  ListMessageResponse() {}

  explicit ListMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageResponse() = default;
};
class ListMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};

  ListMessageAppRequest() {}

  explicit ListMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
  }


  virtual ~ListMessageAppRequest() = default;
};
class ListMessageAppResponseBodyResultAppList : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> appConfig{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<map<string, string>> extension{};
  shared_ptr<long> status{};

  ListMessageAppResponseBodyResultAppList() {}

  explicit ListMessageAppResponseBodyResultAppList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["AppConfig"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      appConfig = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListMessageAppResponseBodyResultAppList() = default;
};
class ListMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListMessageAppResponseBodyResultAppList>> appList{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> total{};

  ListMessageAppResponseBodyResult() {}

  explicit ListMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appList) {
      vector<boost::any> temp1;
      for(auto item1:*appList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppList"] = boost::any(temp1);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppList") != m.end() && !m["AppList"].empty()) {
      if (typeid(vector<boost::any>) == m["AppList"].type()) {
        vector<ListMessageAppResponseBodyResultAppList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageAppResponseBodyResultAppList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appList = make_shared<vector<ListMessageAppResponseBodyResultAppList>>(expect1);
      }
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListMessageAppResponseBodyResult() = default;
};
class ListMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMessageAppResponseBodyResult> result{};

  ListMessageAppResponseBody() {}

  explicit ListMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListMessageAppResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListMessageAppResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListMessageAppResponseBody() = default;
};
class ListMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMessageAppResponseBody> body{};

  ListMessageAppResponse() {}

  explicit ListMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageAppResponse() = default;
};
class ListMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};
  shared_ptr<string> userId{};

  ListMessageGroupRequest() {}

  explicit ListMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListMessageGroupRequest() = default;
};
class ListMessageGroupResponseBodyResultGroupList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<map<string, string>> extension{};
  shared_ptr<string> groupId{};
  shared_ptr<long> status{};

  ListMessageGroupResponseBodyResultGroupList() {}

  explicit ListMessageGroupResponseBodyResultGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListMessageGroupResponseBodyResultGroupList() = default;
};
class ListMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListMessageGroupResponseBodyResultGroupList>> groupList{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> total{};

  ListMessageGroupResponseBodyResult() {}

  explicit ListMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupList) {
      vector<boost::any> temp1;
      for(auto item1:*groupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupList"] = boost::any(temp1);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupList") != m.end() && !m["GroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupList"].type()) {
        vector<ListMessageGroupResponseBodyResultGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageGroupResponseBodyResultGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupList = make_shared<vector<ListMessageGroupResponseBodyResultGroupList>>(expect1);
      }
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListMessageGroupResponseBodyResult() = default;
};
class ListMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMessageGroupResponseBodyResult> result{};

  ListMessageGroupResponseBody() {}

  explicit ListMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListMessageGroupResponseBody() = default;
};
class ListMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMessageGroupResponseBody> body{};

  ListMessageGroupResponse() {}

  explicit ListMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageGroupResponse() = default;
};
class ListMessageGroupUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};

  ListMessageGroupUserRequest() {}

  explicit ListMessageGroupUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
  }


  virtual ~ListMessageGroupUserRequest() = default;
};
class ListMessageGroupUserResponseBodyResultUserList : public Darabonba::Model {
public:
  shared_ptr<long> joinTime{};
  shared_ptr<string> userId{};

  ListMessageGroupUserResponseBodyResultUserList() {}

  explicit ListMessageGroupUserResponseBodyResultUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinTime) {
      res["JoinTime"] = boost::any(*joinTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinTime") != m.end() && !m["JoinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["JoinTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListMessageGroupUserResponseBodyResultUserList() = default;
};
class ListMessageGroupUserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<long> total{};
  shared_ptr<vector<ListMessageGroupUserResponseBodyResultUserList>> userList{};

  ListMessageGroupUserResponseBodyResult() {}

  explicit ListMessageGroupUserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<ListMessageGroupUserResponseBodyResultUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageGroupUserResponseBodyResultUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<ListMessageGroupUserResponseBodyResultUserList>>(expect1);
      }
    }
  }


  virtual ~ListMessageGroupUserResponseBodyResult() = default;
};
class ListMessageGroupUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMessageGroupUserResponseBodyResult> result{};

  ListMessageGroupUserResponseBody() {}

  explicit ListMessageGroupUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListMessageGroupUserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListMessageGroupUserResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListMessageGroupUserResponseBody() = default;
};
class ListMessageGroupUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMessageGroupUserResponseBody> body{};

  ListMessageGroupUserResponse() {}

  explicit ListMessageGroupUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageGroupUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageGroupUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageGroupUserResponse() = default;
};
class ListMessageGroupUserByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<string>> userIdList{};

  ListMessageGroupUserByIdRequest() {}

  explicit ListMessageGroupUserByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListMessageGroupUserByIdRequest() = default;
};
class ListMessageGroupUserByIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> userIdListShrink{};

  ListMessageGroupUserByIdShrinkRequest() {}

  explicit ListMessageGroupUserByIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (userIdListShrink) {
      res["UserIdList"] = boost::any(*userIdListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      userIdListShrink = make_shared<string>(boost::any_cast<string>(m["UserIdList"]));
    }
  }


  virtual ~ListMessageGroupUserByIdShrinkRequest() = default;
};
class ListMessageGroupUserByIdResponseBodyResultUserList : public Darabonba::Model {
public:
  shared_ptr<bool> isMute{};
  shared_ptr<vector<string>> muteBy{};
  shared_ptr<string> userAvatar{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};
  shared_ptr<string> userNick{};

  ListMessageGroupUserByIdResponseBodyResultUserList() {}

  explicit ListMessageGroupUserByIdResponseBodyResultUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isMute) {
      res["IsMute"] = boost::any(*isMute);
    }
    if (muteBy) {
      res["MuteBy"] = boost::any(*muteBy);
    }
    if (userAvatar) {
      res["UserAvatar"] = boost::any(*userAvatar);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userNick) {
      res["UserNick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsMute") != m.end() && !m["IsMute"].empty()) {
      isMute = make_shared<bool>(boost::any_cast<bool>(m["IsMute"]));
    }
    if (m.find("MuteBy") != m.end() && !m["MuteBy"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MuteBy"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MuteBy"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      muteBy = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserAvatar") != m.end() && !m["UserAvatar"].empty()) {
      userAvatar = make_shared<string>(boost::any_cast<string>(m["UserAvatar"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserNick") != m.end() && !m["UserNick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["UserNick"]));
    }
  }


  virtual ~ListMessageGroupUserByIdResponseBodyResultUserList() = default;
};
class ListMessageGroupUserByIdResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<long> total{};
  shared_ptr<vector<ListMessageGroupUserByIdResponseBodyResultUserList>> userList{};

  ListMessageGroupUserByIdResponseBodyResult() {}

  explicit ListMessageGroupUserByIdResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<ListMessageGroupUserByIdResponseBodyResultUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageGroupUserByIdResponseBodyResultUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<ListMessageGroupUserByIdResponseBodyResultUserList>>(expect1);
      }
    }
  }


  virtual ~ListMessageGroupUserByIdResponseBodyResult() = default;
};
class ListMessageGroupUserByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMessageGroupUserByIdResponseBodyResult> result{};

  ListMessageGroupUserByIdResponseBody() {}

  explicit ListMessageGroupUserByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListMessageGroupUserByIdResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListMessageGroupUserByIdResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListMessageGroupUserByIdResponseBody() = default;
};
class ListMessageGroupUserByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMessageGroupUserByIdResponseBody> body{};

  ListMessageGroupUserByIdResponse() {}

  explicit ListMessageGroupUserByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageGroupUserByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageGroupUserByIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageGroupUserByIdResponse() = default;
};
class ListMuteGroupUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  ListMuteGroupUserRequest() {}

  explicit ListMuteGroupUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListMuteGroupUserRequest() = default;
};
class ListMuteGroupUserResponseBodyResultUserList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};

  ListMuteGroupUserResponseBodyResultUserList() {}

  explicit ListMuteGroupUserResponseBodyResultUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListMuteGroupUserResponseBodyResultUserList() = default;
};
class ListMuteGroupUserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<long> total{};
  shared_ptr<vector<ListMuteGroupUserResponseBodyResultUserList>> userList{};

  ListMuteGroupUserResponseBodyResult() {}

  explicit ListMuteGroupUserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<ListMuteGroupUserResponseBodyResultUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMuteGroupUserResponseBodyResultUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<ListMuteGroupUserResponseBodyResultUserList>>(expect1);
      }
    }
  }


  virtual ~ListMuteGroupUserResponseBodyResult() = default;
};
class ListMuteGroupUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMuteGroupUserResponseBodyResult> result{};

  ListMuteGroupUserResponseBody() {}

  explicit ListMuteGroupUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListMuteGroupUserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListMuteGroupUserResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListMuteGroupUserResponseBody() = default;
};
class ListMuteGroupUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMuteGroupUserResponseBody> body{};

  ListMuteGroupUserResponse() {}

  explicit ListMuteGroupUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMuteGroupUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMuteGroupUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListMuteGroupUserResponse() = default;
};
class ListPlaylistRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> programId{};
  shared_ptr<string> regionId{};

  ListPlaylistRequest() {}

  explicit ListPlaylistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListPlaylistRequest() = default;
};
class ListPlaylistResponseBodyProgramList : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> programId{};
  shared_ptr<string> programName{};
  shared_ptr<long> repeatNumber{};
  shared_ptr<long> status{};

  ListPlaylistResponseBodyProgramList() {}

  explicit ListPlaylistResponseBodyProgramList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (repeatNumber) {
      res["RepeatNumber"] = boost::any(*repeatNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("RepeatNumber") != m.end() && !m["RepeatNumber"].empty()) {
      repeatNumber = make_shared<long>(boost::any_cast<long>(m["RepeatNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListPlaylistResponseBodyProgramList() = default;
};
class ListPlaylistResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPlaylistResponseBodyProgramList>> programList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListPlaylistResponseBody() {}

  explicit ListPlaylistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programList) {
      vector<boost::any> temp1;
      for(auto item1:*programList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProgramList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramList") != m.end() && !m["ProgramList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProgramList"].type()) {
        vector<ListPlaylistResponseBodyProgramList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProgramList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPlaylistResponseBodyProgramList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programList = make_shared<vector<ListPlaylistResponseBodyProgramList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListPlaylistResponseBody() = default;
};
class ListPlaylistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPlaylistResponseBody> body{};

  ListPlaylistResponse() {}

  explicit ListPlaylistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPlaylistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPlaylistResponseBody>(model1);
      }
    }
  }


  virtual ~ListPlaylistResponse() = default;
};
class ListPlaylistItemsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};
  shared_ptr<string> programItemIds{};
  shared_ptr<string> regionId{};

  ListPlaylistItemsRequest() {}

  explicit ListPlaylistItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programItemIds) {
      res["ProgramItemIds"] = boost::any(*programItemIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramItemIds") != m.end() && !m["ProgramItemIds"].empty()) {
      programItemIds = make_shared<string>(boost::any_cast<string>(m["ProgramItemIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListPlaylistItemsRequest() = default;
};
class ListPlaylistItemsResponseBodyProgramItems : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<string> programId{};
  shared_ptr<string> programItemId{};
  shared_ptr<string> programItemName{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceValue{};

  ListPlaylistItemsResponseBodyProgramItems() {}

  explicit ListPlaylistItemsResponseBodyProgramItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (programItemId) {
      res["ProgramItemId"] = boost::any(*programItemId);
    }
    if (programItemName) {
      res["ProgramItemName"] = boost::any(*programItemName);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceValue) {
      res["ResourceValue"] = boost::any(*resourceValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("ProgramItemId") != m.end() && !m["ProgramItemId"].empty()) {
      programItemId = make_shared<string>(boost::any_cast<string>(m["ProgramItemId"]));
    }
    if (m.find("ProgramItemName") != m.end() && !m["ProgramItemName"].empty()) {
      programItemName = make_shared<string>(boost::any_cast<string>(m["ProgramItemName"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceValue") != m.end() && !m["ResourceValue"].empty()) {
      resourceValue = make_shared<string>(boost::any_cast<string>(m["ResourceValue"]));
    }
  }


  virtual ~ListPlaylistItemsResponseBodyProgramItems() = default;
};
class ListPlaylistItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPlaylistItemsResponseBodyProgramItems>> programItems{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListPlaylistItemsResponseBody() {}

  explicit ListPlaylistItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programItems) {
      vector<boost::any> temp1;
      for(auto item1:*programItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProgramItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramItems") != m.end() && !m["ProgramItems"].empty()) {
      if (typeid(vector<boost::any>) == m["ProgramItems"].type()) {
        vector<ListPlaylistItemsResponseBodyProgramItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProgramItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPlaylistItemsResponseBodyProgramItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programItems = make_shared<vector<ListPlaylistItemsResponseBodyProgramItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListPlaylistItemsResponseBody() = default;
};
class ListPlaylistItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPlaylistItemsResponseBody> body{};

  ListPlaylistItemsResponse() {}

  explicit ListPlaylistItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPlaylistItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPlaylistItemsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPlaylistItemsResponse() = default;
};
class ListRtcMPUEventSubRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> subId{};

  ListRtcMPUEventSubRecordRequest() {}

  explicit ListRtcMPUEventSubRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (subId) {
      res["SubId"] = boost::any(*subId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SubId") != m.end() && !m["SubId"].empty()) {
      subId = make_shared<string>(boost::any_cast<string>(m["SubId"]));
    }
  }


  virtual ~ListRtcMPUEventSubRecordRequest() = default;
};
class ListRtcMPUEventSubRecordResponseBodyLogs : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<long> cost{};
  shared_ptr<string> data{};
  shared_ptr<string> HTTPCode{};
  shared_ptr<string> msgId{};
  shared_ptr<string> subId{};
  shared_ptr<string> time{};

  ListRtcMPUEventSubRecordResponseBodyLogs() {}

  explicit ListRtcMPUEventSubRecordResponseBodyLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (HTTPCode) {
      res["HTTPCode"] = boost::any(*HTTPCode);
    }
    if (msgId) {
      res["MsgId"] = boost::any(*msgId);
    }
    if (subId) {
      res["SubId"] = boost::any(*subId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HTTPCode") != m.end() && !m["HTTPCode"].empty()) {
      HTTPCode = make_shared<string>(boost::any_cast<string>(m["HTTPCode"]));
    }
    if (m.find("MsgId") != m.end() && !m["MsgId"].empty()) {
      msgId = make_shared<string>(boost::any_cast<string>(m["MsgId"]));
    }
    if (m.find("SubId") != m.end() && !m["SubId"].empty()) {
      subId = make_shared<string>(boost::any_cast<string>(m["SubId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~ListRtcMPUEventSubRecordResponseBodyLogs() = default;
};
class ListRtcMPUEventSubRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<ListRtcMPUEventSubRecordResponseBodyLogs>> logs{};
  shared_ptr<string> requestId{};

  ListRtcMPUEventSubRecordResponseBody() {}

  explicit ListRtcMPUEventSubRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<ListRtcMPUEventSubRecordResponseBodyLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRtcMPUEventSubRecordResponseBodyLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<ListRtcMPUEventSubRecordResponseBodyLogs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRtcMPUEventSubRecordResponseBody() = default;
};
class ListRtcMPUEventSubRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRtcMPUEventSubRecordResponseBody> body{};

  ListRtcMPUEventSubRecordResponse() {}

  explicit ListRtcMPUEventSubRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRtcMPUEventSubRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRtcMPUEventSubRecordResponseBody>(model1);
      }
    }
  }


  virtual ~ListRtcMPUEventSubRecordResponse() = default;
};
class ListRtcMPUTaskDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> taskId{};

  ListRtcMPUTaskDetailRequest() {}

  explicit ListRtcMPUTaskDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailRequest() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksMultiStreamURL : public Darabonba::Model {
public:
  shared_ptr<bool> isAliCdn{};
  shared_ptr<string> URL{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksMultiStreamURL() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksMultiStreamURL(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isAliCdn) {
      res["IsAliCdn"] = boost::any(*isAliCdn);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsAliCdn") != m.end() && !m["IsAliCdn"].empty()) {
      isAliCdn = make_shared<bool>(boost::any_cast<bool>(m["IsAliCdn"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksMultiStreamURL() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsLayoutVolume : public Darabonba::Model {
public:
  shared_ptr<string> followIdr{};
  shared_ptr<string> interval{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsLayoutVolume() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsLayoutVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (followIdr) {
      res["FollowIdr"] = boost::any(*followIdr);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FollowIdr") != m.end() && !m["FollowIdr"].empty()) {
      followIdr = make_shared<string>(boost::any_cast<string>(m["FollowIdr"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsLayoutVolume() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsPassThrough : public Darabonba::Model {
public:
  shared_ptr<string> followIdr{};
  shared_ptr<string> interval{};
  shared_ptr<string> payloadContent{};
  shared_ptr<string> payloadContentKey{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsPassThrough() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsPassThrough(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (followIdr) {
      res["FollowIdr"] = boost::any(*followIdr);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (payloadContent) {
      res["PayloadContent"] = boost::any(*payloadContent);
    }
    if (payloadContentKey) {
      res["PayloadContentKey"] = boost::any(*payloadContentKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FollowIdr") != m.end() && !m["FollowIdr"].empty()) {
      followIdr = make_shared<string>(boost::any_cast<string>(m["FollowIdr"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("PayloadContent") != m.end() && !m["PayloadContent"].empty()) {
      payloadContent = make_shared<string>(boost::any_cast<string>(m["PayloadContent"]));
    }
    if (m.find("PayloadContentKey") != m.end() && !m["PayloadContentKey"].empty()) {
      payloadContentKey = make_shared<string>(boost::any_cast<string>(m["PayloadContentKey"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsPassThrough() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParams : public Darabonba::Model {
public:
  shared_ptr<ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsLayoutVolume> layoutVolume{};
  shared_ptr<ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsPassThrough> passThrough{};
  shared_ptr<string> payloadType{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParams() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layoutVolume) {
      res["LayoutVolume"] = layoutVolume ? boost::any(layoutVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passThrough) {
      res["PassThrough"] = passThrough ? boost::any(passThrough->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payloadType) {
      res["PayloadType"] = boost::any(*payloadType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LayoutVolume") != m.end() && !m["LayoutVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["LayoutVolume"].type()) {
        ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsLayoutVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LayoutVolume"]));
        layoutVolume = make_shared<ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsLayoutVolume>(model1);
      }
    }
    if (m.find("PassThrough") != m.end() && !m["PassThrough"].empty()) {
      if (typeid(map<string, boost::any>) == m["PassThrough"].type()) {
        ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsPassThrough model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PassThrough"]));
        passThrough = make_shared<ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParamsPassThrough>(model1);
      }
    }
    if (m.find("PayloadType") != m.end() && !m["PayloadType"].empty()) {
      payloadType = make_shared<string>(boost::any_cast<string>(m["PayloadType"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParams() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksSingleSubParams : public Darabonba::Model {
public:
  shared_ptr<string> sourceType{};
  shared_ptr<string> streamType{};
  shared_ptr<string> userId{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksSingleSubParams() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksSingleSubParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksSingleSubParams() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsBackground : public Darabonba::Model {
public:
  shared_ptr<string> renderMode{};
  shared_ptr<string> URL{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsBackground() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsBackground(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderMode) {
      res["RenderMode"] = boost::any(*renderMode);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderMode") != m.end() && !m["RenderMode"].empty()) {
      renderMode = make_shared<string>(boost::any_cast<string>(m["RenderMode"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsBackground() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsEncodeParams : public Darabonba::Model {
public:
  shared_ptr<string> audioBitrate{};
  shared_ptr<string> audioChannels{};
  shared_ptr<string> audioOnly{};
  shared_ptr<string> audioSampleRate{};
  shared_ptr<string> enhancedParam{};
  shared_ptr<string> videoBitrate{};
  shared_ptr<string> videoCodec{};
  shared_ptr<string> videoFramerate{};
  shared_ptr<string> videoGop{};
  shared_ptr<string> videoHeight{};
  shared_ptr<string> videoWidth{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsEncodeParams() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsEncodeParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannels) {
      res["AudioChannels"] = boost::any(*audioChannels);
    }
    if (audioOnly) {
      res["AudioOnly"] = boost::any(*audioOnly);
    }
    if (audioSampleRate) {
      res["AudioSampleRate"] = boost::any(*audioSampleRate);
    }
    if (enhancedParam) {
      res["EnhancedParam"] = boost::any(*enhancedParam);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    if (videoFramerate) {
      res["VideoFramerate"] = boost::any(*videoFramerate);
    }
    if (videoGop) {
      res["VideoGop"] = boost::any(*videoGop);
    }
    if (videoHeight) {
      res["VideoHeight"] = boost::any(*videoHeight);
    }
    if (videoWidth) {
      res["VideoWidth"] = boost::any(*videoWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<string>(boost::any_cast<string>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannels") != m.end() && !m["AudioChannels"].empty()) {
      audioChannels = make_shared<string>(boost::any_cast<string>(m["AudioChannels"]));
    }
    if (m.find("AudioOnly") != m.end() && !m["AudioOnly"].empty()) {
      audioOnly = make_shared<string>(boost::any_cast<string>(m["AudioOnly"]));
    }
    if (m.find("AudioSampleRate") != m.end() && !m["AudioSampleRate"].empty()) {
      audioSampleRate = make_shared<string>(boost::any_cast<string>(m["AudioSampleRate"]));
    }
    if (m.find("EnhancedParam") != m.end() && !m["EnhancedParam"].empty()) {
      enhancedParam = make_shared<string>(boost::any_cast<string>(m["EnhancedParam"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<string>(boost::any_cast<string>(m["VideoBitrate"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
    if (m.find("VideoFramerate") != m.end() && !m["VideoFramerate"].empty()) {
      videoFramerate = make_shared<string>(boost::any_cast<string>(m["VideoFramerate"]));
    }
    if (m.find("VideoGop") != m.end() && !m["VideoGop"].empty()) {
      videoGop = make_shared<string>(boost::any_cast<string>(m["VideoGop"]));
    }
    if (m.find("VideoHeight") != m.end() && !m["VideoHeight"].empty()) {
      videoHeight = make_shared<string>(boost::any_cast<string>(m["VideoHeight"]));
    }
    if (m.find("VideoWidth") != m.end() && !m["VideoWidth"].empty()) {
      videoWidth = make_shared<string>(boost::any_cast<string>(m["VideoWidth"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsEncodeParams() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanesUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> userId{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanesUserInfo() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanesUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanesUserInfo() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanes : public Darabonba::Model {
public:
  shared_ptr<string> backgroundImageUrl{};
  shared_ptr<string> height{};
  shared_ptr<string> renderMode{};
  shared_ptr<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanesUserInfo> userInfo{};
  shared_ptr<string> width{};
  shared_ptr<string> x{};
  shared_ptr<string> y{};
  shared_ptr<string> ZOrder{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanes() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundImageUrl) {
      res["BackgroundImageUrl"] = boost::any(*backgroundImageUrl);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (renderMode) {
      res["RenderMode"] = boost::any(*renderMode);
    }
    if (userInfo) {
      res["UserInfo"] = userInfo ? boost::any(userInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    if (ZOrder) {
      res["ZOrder"] = boost::any(*ZOrder);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundImageUrl") != m.end() && !m["BackgroundImageUrl"].empty()) {
      backgroundImageUrl = make_shared<string>(boost::any_cast<string>(m["BackgroundImageUrl"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("RenderMode") != m.end() && !m["RenderMode"].empty()) {
      renderMode = make_shared<string>(boost::any_cast<string>(m["RenderMode"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserInfo"].type()) {
        ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanesUserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserInfo"]));
        userInfo = make_shared<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanesUserInfo>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<string>(boost::any_cast<string>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<string>(boost::any_cast<string>(m["Y"]));
    }
    if (m.find("ZOrder") != m.end() && !m["ZOrder"].empty()) {
      ZOrder = make_shared<string>(boost::any_cast<string>(m["ZOrder"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanes() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayout : public Darabonba::Model {
public:
  shared_ptr<vector<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanes>> userPanes{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayout() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userPanes) {
      vector<boost::any> temp1;
      for(auto item1:*userPanes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserPanes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserPanes") != m.end() && !m["UserPanes"].empty()) {
      if (typeid(vector<boost::any>) == m["UserPanes"].type()) {
        vector<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserPanes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userPanes = make_shared<vector<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayoutUserPanes>>(expect1);
      }
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayout() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsUserInfos : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> streamType{};
  shared_ptr<string> userId{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsUserInfos() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsUserInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsUserInfos() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParams : public Darabonba::Model {
public:
  shared_ptr<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsBackground> background{};
  shared_ptr<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsEncodeParams> encodeParams{};
  shared_ptr<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayout> layout{};
  shared_ptr<vector<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsUserInfos>> userInfos{};

  ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParams() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (background) {
      res["Background"] = background ? boost::any(background->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encodeParams) {
      res["EncodeParams"] = encodeParams ? boost::any(encodeParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (layout) {
      res["Layout"] = layout ? boost::any(layout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userInfos) {
      vector<boost::any> temp1;
      for(auto item1:*userInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Background") != m.end() && !m["Background"].empty()) {
      if (typeid(map<string, boost::any>) == m["Background"].type()) {
        ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsBackground model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Background"]));
        background = make_shared<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsBackground>(model1);
      }
    }
    if (m.find("EncodeParams") != m.end() && !m["EncodeParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["EncodeParams"].type()) {
        ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsEncodeParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EncodeParams"]));
        encodeParams = make_shared<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsEncodeParams>(model1);
      }
    }
    if (m.find("Layout") != m.end() && !m["Layout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Layout"].type()) {
        ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Layout"]));
        layout = make_shared<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsLayout>(model1);
      }
    }
    if (m.find("UserInfos") != m.end() && !m["UserInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["UserInfos"].type()) {
        vector<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsUserInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsUserInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userInfos = make_shared<vector<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParamsUserInfos>>(expect1);
      }
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParams() = default;
};
class ListRtcMPUTaskDetailResponseBodyMPUTasks : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> maxIdleTime{};
  shared_ptr<string> mixMode{};
  shared_ptr<vector<ListRtcMPUTaskDetailResponseBodyMPUTasksMultiStreamURL>> multiStreamURL{};
  shared_ptr<string> region{};
  shared_ptr<ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParams> seiParams{};
  shared_ptr<ListRtcMPUTaskDetailResponseBodyMPUTasksSingleSubParams> singleSubParams{};
  shared_ptr<string> streamURL{};
  shared_ptr<string> taskId{};
  shared_ptr<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParams> transcodeParams{};

  ListRtcMPUTaskDetailResponseBodyMPUTasks() {}

  explicit ListRtcMPUTaskDetailResponseBodyMPUTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (maxIdleTime) {
      res["MaxIdleTime"] = boost::any(*maxIdleTime);
    }
    if (mixMode) {
      res["MixMode"] = boost::any(*mixMode);
    }
    if (multiStreamURL) {
      vector<boost::any> temp1;
      for(auto item1:*multiStreamURL){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultiStreamURL"] = boost::any(temp1);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (seiParams) {
      res["SeiParams"] = seiParams ? boost::any(seiParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (singleSubParams) {
      res["SingleSubParams"] = singleSubParams ? boost::any(singleSubParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamURL) {
      res["StreamURL"] = boost::any(*streamURL);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (transcodeParams) {
      res["TranscodeParams"] = transcodeParams ? boost::any(transcodeParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("MaxIdleTime") != m.end() && !m["MaxIdleTime"].empty()) {
      maxIdleTime = make_shared<string>(boost::any_cast<string>(m["MaxIdleTime"]));
    }
    if (m.find("MixMode") != m.end() && !m["MixMode"].empty()) {
      mixMode = make_shared<string>(boost::any_cast<string>(m["MixMode"]));
    }
    if (m.find("MultiStreamURL") != m.end() && !m["MultiStreamURL"].empty()) {
      if (typeid(vector<boost::any>) == m["MultiStreamURL"].type()) {
        vector<ListRtcMPUTaskDetailResponseBodyMPUTasksMultiStreamURL> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultiStreamURL"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRtcMPUTaskDetailResponseBodyMPUTasksMultiStreamURL model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multiStreamURL = make_shared<vector<ListRtcMPUTaskDetailResponseBodyMPUTasksMultiStreamURL>>(expect1);
      }
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SeiParams") != m.end() && !m["SeiParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["SeiParams"].type()) {
        ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SeiParams"]));
        seiParams = make_shared<ListRtcMPUTaskDetailResponseBodyMPUTasksSeiParams>(model1);
      }
    }
    if (m.find("SingleSubParams") != m.end() && !m["SingleSubParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["SingleSubParams"].type()) {
        ListRtcMPUTaskDetailResponseBodyMPUTasksSingleSubParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SingleSubParams"]));
        singleSubParams = make_shared<ListRtcMPUTaskDetailResponseBodyMPUTasksSingleSubParams>(model1);
      }
    }
    if (m.find("StreamURL") != m.end() && !m["StreamURL"].empty()) {
      streamURL = make_shared<string>(boost::any_cast<string>(m["StreamURL"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TranscodeParams") != m.end() && !m["TranscodeParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeParams"].type()) {
        ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeParams"]));
        transcodeParams = make_shared<ListRtcMPUTaskDetailResponseBodyMPUTasksTranscodeParams>(model1);
      }
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBodyMPUTasks() = default;
};
class ListRtcMPUTaskDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListRtcMPUTaskDetailResponseBodyMPUTasks>> MPUTasks{};
  shared_ptr<string> requestId{};

  ListRtcMPUTaskDetailResponseBody() {}

  explicit ListRtcMPUTaskDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (MPUTasks) {
      vector<boost::any> temp1;
      for(auto item1:*MPUTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MPUTasks"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MPUTasks") != m.end() && !m["MPUTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["MPUTasks"].type()) {
        vector<ListRtcMPUTaskDetailResponseBodyMPUTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MPUTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRtcMPUTaskDetailResponseBodyMPUTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        MPUTasks = make_shared<vector<ListRtcMPUTaskDetailResponseBodyMPUTasks>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRtcMPUTaskDetailResponseBody() = default;
};
class ListRtcMPUTaskDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRtcMPUTaskDetailResponseBody> body{};

  ListRtcMPUTaskDetailResponse() {}

  explicit ListRtcMPUTaskDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRtcMPUTaskDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRtcMPUTaskDetailResponseBody>(model1);
      }
    }
  }


  virtual ~ListRtcMPUTaskDetailResponse() = default;
};
class LiveUpstreamQosDataRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cdnDomains{};
  shared_ptr<vector<string>> cdnIsps{};
  shared_ptr<vector<string>> cdnProvinces{};
  shared_ptr<string> endTime{};
  shared_ptr<vector<string>> kwaiSidcs{};
  shared_ptr<vector<long>> kwaiTsc{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<vector<string>> upstreamDomains{};

  LiveUpstreamQosDataRequest() {}

  explicit LiveUpstreamQosDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnDomains) {
      res["CdnDomains"] = boost::any(*cdnDomains);
    }
    if (cdnIsps) {
      res["CdnIsps"] = boost::any(*cdnIsps);
    }
    if (cdnProvinces) {
      res["CdnProvinces"] = boost::any(*cdnProvinces);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (kwaiSidcs) {
      res["KwaiSidcs"] = boost::any(*kwaiSidcs);
    }
    if (kwaiTsc) {
      res["KwaiTsc"] = boost::any(*kwaiTsc);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (upstreamDomains) {
      res["UpstreamDomains"] = boost::any(*upstreamDomains);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnDomains") != m.end() && !m["CdnDomains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CdnDomains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CdnDomains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cdnDomains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CdnIsps") != m.end() && !m["CdnIsps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CdnIsps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CdnIsps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cdnIsps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CdnProvinces") != m.end() && !m["CdnProvinces"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CdnProvinces"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CdnProvinces"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cdnProvinces = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("KwaiSidcs") != m.end() && !m["KwaiSidcs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["KwaiSidcs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["KwaiSidcs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      kwaiSidcs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("KwaiTsc") != m.end() && !m["KwaiTsc"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["KwaiTsc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["KwaiTsc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      kwaiTsc = make_shared<vector<long>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UpstreamDomains") != m.end() && !m["UpstreamDomains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UpstreamDomains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UpstreamDomains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      upstreamDomains = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~LiveUpstreamQosDataRequest() = default;
};
class LiveUpstreamQosDataShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdnDomainsShrink{};
  shared_ptr<string> cdnIspsShrink{};
  shared_ptr<string> cdnProvincesShrink{};
  shared_ptr<string> endTime{};
  shared_ptr<string> kwaiSidcsShrink{};
  shared_ptr<string> kwaiTscShrink{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> upstreamDomainsShrink{};

  LiveUpstreamQosDataShrinkRequest() {}

  explicit LiveUpstreamQosDataShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnDomainsShrink) {
      res["CdnDomains"] = boost::any(*cdnDomainsShrink);
    }
    if (cdnIspsShrink) {
      res["CdnIsps"] = boost::any(*cdnIspsShrink);
    }
    if (cdnProvincesShrink) {
      res["CdnProvinces"] = boost::any(*cdnProvincesShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (kwaiSidcsShrink) {
      res["KwaiSidcs"] = boost::any(*kwaiSidcsShrink);
    }
    if (kwaiTscShrink) {
      res["KwaiTsc"] = boost::any(*kwaiTscShrink);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (upstreamDomainsShrink) {
      res["UpstreamDomains"] = boost::any(*upstreamDomainsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnDomains") != m.end() && !m["CdnDomains"].empty()) {
      cdnDomainsShrink = make_shared<string>(boost::any_cast<string>(m["CdnDomains"]));
    }
    if (m.find("CdnIsps") != m.end() && !m["CdnIsps"].empty()) {
      cdnIspsShrink = make_shared<string>(boost::any_cast<string>(m["CdnIsps"]));
    }
    if (m.find("CdnProvinces") != m.end() && !m["CdnProvinces"].empty()) {
      cdnProvincesShrink = make_shared<string>(boost::any_cast<string>(m["CdnProvinces"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("KwaiSidcs") != m.end() && !m["KwaiSidcs"].empty()) {
      kwaiSidcsShrink = make_shared<string>(boost::any_cast<string>(m["KwaiSidcs"]));
    }
    if (m.find("KwaiTsc") != m.end() && !m["KwaiTsc"].empty()) {
      kwaiTscShrink = make_shared<string>(boost::any_cast<string>(m["KwaiTsc"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UpstreamDomains") != m.end() && !m["UpstreamDomains"].empty()) {
      upstreamDomainsShrink = make_shared<string>(boost::any_cast<string>(m["UpstreamDomains"]));
    }
  }


  virtual ~LiveUpstreamQosDataShrinkRequest() = default;
};
class LiveUpstreamQosDataResponseBodyDataDetailData : public Darabonba::Model {
public:
  shared_ptr<long> connectDur{};
  shared_ptr<long> connectFailedCount{};
  shared_ptr<long> count{};
  shared_ptr<long> firstDataDur{};
  shared_ptr<long> firstDataFailedCount{};
  shared_ptr<long> firstFrameDur{};
  shared_ptr<long> firstFrameSuccessCount{};
  shared_ptr<long> statusCode2Xx{};
  shared_ptr<long> statusCode3Xx{};
  shared_ptr<long> statusCode4Xx{};
  shared_ptr<long> statusCode5Xx{};
  shared_ptr<string> timestamp{};

  LiveUpstreamQosDataResponseBodyDataDetailData() {}

  explicit LiveUpstreamQosDataResponseBodyDataDetailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectDur) {
      res["ConnectDur"] = boost::any(*connectDur);
    }
    if (connectFailedCount) {
      res["ConnectFailedCount"] = boost::any(*connectFailedCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (firstDataDur) {
      res["FirstDataDur"] = boost::any(*firstDataDur);
    }
    if (firstDataFailedCount) {
      res["FirstDataFailedCount"] = boost::any(*firstDataFailedCount);
    }
    if (firstFrameDur) {
      res["FirstFrameDur"] = boost::any(*firstFrameDur);
    }
    if (firstFrameSuccessCount) {
      res["FirstFrameSuccessCount"] = boost::any(*firstFrameSuccessCount);
    }
    if (statusCode2Xx) {
      res["StatusCode2Xx"] = boost::any(*statusCode2Xx);
    }
    if (statusCode3Xx) {
      res["StatusCode3Xx"] = boost::any(*statusCode3Xx);
    }
    if (statusCode4Xx) {
      res["StatusCode4Xx"] = boost::any(*statusCode4Xx);
    }
    if (statusCode5Xx) {
      res["StatusCode5Xx"] = boost::any(*statusCode5Xx);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectDur") != m.end() && !m["ConnectDur"].empty()) {
      connectDur = make_shared<long>(boost::any_cast<long>(m["ConnectDur"]));
    }
    if (m.find("ConnectFailedCount") != m.end() && !m["ConnectFailedCount"].empty()) {
      connectFailedCount = make_shared<long>(boost::any_cast<long>(m["ConnectFailedCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("FirstDataDur") != m.end() && !m["FirstDataDur"].empty()) {
      firstDataDur = make_shared<long>(boost::any_cast<long>(m["FirstDataDur"]));
    }
    if (m.find("FirstDataFailedCount") != m.end() && !m["FirstDataFailedCount"].empty()) {
      firstDataFailedCount = make_shared<long>(boost::any_cast<long>(m["FirstDataFailedCount"]));
    }
    if (m.find("FirstFrameDur") != m.end() && !m["FirstFrameDur"].empty()) {
      firstFrameDur = make_shared<long>(boost::any_cast<long>(m["FirstFrameDur"]));
    }
    if (m.find("FirstFrameSuccessCount") != m.end() && !m["FirstFrameSuccessCount"].empty()) {
      firstFrameSuccessCount = make_shared<long>(boost::any_cast<long>(m["FirstFrameSuccessCount"]));
    }
    if (m.find("StatusCode2Xx") != m.end() && !m["StatusCode2Xx"].empty()) {
      statusCode2Xx = make_shared<long>(boost::any_cast<long>(m["StatusCode2Xx"]));
    }
    if (m.find("StatusCode3Xx") != m.end() && !m["StatusCode3Xx"].empty()) {
      statusCode3Xx = make_shared<long>(boost::any_cast<long>(m["StatusCode3Xx"]));
    }
    if (m.find("StatusCode4Xx") != m.end() && !m["StatusCode4Xx"].empty()) {
      statusCode4Xx = make_shared<long>(boost::any_cast<long>(m["StatusCode4Xx"]));
    }
    if (m.find("StatusCode5Xx") != m.end() && !m["StatusCode5Xx"].empty()) {
      statusCode5Xx = make_shared<long>(boost::any_cast<long>(m["StatusCode5Xx"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~LiveUpstreamQosDataResponseBodyDataDetailData() = default;
};
class LiveUpstreamQosDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> cdnDomain{};
  shared_ptr<string> cdnIsp{};
  shared_ptr<string> cdnOcid{};
  shared_ptr<string> cdnProvince{};
  shared_ptr<vector<LiveUpstreamQosDataResponseBodyDataDetailData>> detailData{};
  shared_ptr<string> kwaiSidc{};
  shared_ptr<long> kwaiTsc{};
  shared_ptr<string> upstreamDomain{};

  LiveUpstreamQosDataResponseBodyData() {}

  explicit LiveUpstreamQosDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnDomain) {
      res["CdnDomain"] = boost::any(*cdnDomain);
    }
    if (cdnIsp) {
      res["CdnIsp"] = boost::any(*cdnIsp);
    }
    if (cdnOcid) {
      res["CdnOcid"] = boost::any(*cdnOcid);
    }
    if (cdnProvince) {
      res["CdnProvince"] = boost::any(*cdnProvince);
    }
    if (detailData) {
      vector<boost::any> temp1;
      for(auto item1:*detailData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DetailData"] = boost::any(temp1);
    }
    if (kwaiSidc) {
      res["KwaiSidc"] = boost::any(*kwaiSidc);
    }
    if (kwaiTsc) {
      res["KwaiTsc"] = boost::any(*kwaiTsc);
    }
    if (upstreamDomain) {
      res["UpstreamDomain"] = boost::any(*upstreamDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnDomain") != m.end() && !m["CdnDomain"].empty()) {
      cdnDomain = make_shared<string>(boost::any_cast<string>(m["CdnDomain"]));
    }
    if (m.find("CdnIsp") != m.end() && !m["CdnIsp"].empty()) {
      cdnIsp = make_shared<string>(boost::any_cast<string>(m["CdnIsp"]));
    }
    if (m.find("CdnOcid") != m.end() && !m["CdnOcid"].empty()) {
      cdnOcid = make_shared<string>(boost::any_cast<string>(m["CdnOcid"]));
    }
    if (m.find("CdnProvince") != m.end() && !m["CdnProvince"].empty()) {
      cdnProvince = make_shared<string>(boost::any_cast<string>(m["CdnProvince"]));
    }
    if (m.find("DetailData") != m.end() && !m["DetailData"].empty()) {
      if (typeid(vector<boost::any>) == m["DetailData"].type()) {
        vector<LiveUpstreamQosDataResponseBodyDataDetailData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DetailData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LiveUpstreamQosDataResponseBodyDataDetailData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detailData = make_shared<vector<LiveUpstreamQosDataResponseBodyDataDetailData>>(expect1);
      }
    }
    if (m.find("KwaiSidc") != m.end() && !m["KwaiSidc"].empty()) {
      kwaiSidc = make_shared<string>(boost::any_cast<string>(m["KwaiSidc"]));
    }
    if (m.find("KwaiTsc") != m.end() && !m["KwaiTsc"].empty()) {
      kwaiTsc = make_shared<long>(boost::any_cast<long>(m["KwaiTsc"]));
    }
    if (m.find("UpstreamDomain") != m.end() && !m["UpstreamDomain"].empty()) {
      upstreamDomain = make_shared<string>(boost::any_cast<string>(m["UpstreamDomain"]));
    }
  }


  virtual ~LiveUpstreamQosDataResponseBodyData() = default;
};
class LiveUpstreamQosDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<LiveUpstreamQosDataResponseBodyData>> data{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  LiveUpstreamQosDataResponseBody() {}

  explicit LiveUpstreamQosDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<LiveUpstreamQosDataResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LiveUpstreamQosDataResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<LiveUpstreamQosDataResponseBodyData>>(expect1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~LiveUpstreamQosDataResponseBody() = default;
};
class LiveUpstreamQosDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LiveUpstreamQosDataResponseBody> body{};

  LiveUpstreamQosDataResponse() {}

  explicit LiveUpstreamQosDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LiveUpstreamQosDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LiveUpstreamQosDataResponseBody>(model1);
      }
    }
  }


  virtual ~LiveUpstreamQosDataResponse() = default;
};
class MiguLivePullToPushStartRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> miguData{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  MiguLivePullToPushStartRequest() {}

  explicit MiguLivePullToPushStartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (miguData) {
      res["MiguData"] = boost::any(*miguData);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MiguData") != m.end() && !m["MiguData"].empty()) {
      miguData = make_shared<string>(boost::any_cast<string>(m["MiguData"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~MiguLivePullToPushStartRequest() = default;
};
class MiguLivePullToPushStartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> timestamp{};

  MiguLivePullToPushStartResponseBody() {}

  explicit MiguLivePullToPushStartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["timestamp"]));
    }
  }


  virtual ~MiguLivePullToPushStartResponseBody() = default;
};
class MiguLivePullToPushStartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MiguLivePullToPushStartResponseBody> body{};

  MiguLivePullToPushStartResponse() {}

  explicit MiguLivePullToPushStartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MiguLivePullToPushStartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MiguLivePullToPushStartResponseBody>(model1);
      }
    }
  }


  virtual ~MiguLivePullToPushStartResponse() = default;
};
class MiguLivePullToPushStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> miguData{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  MiguLivePullToPushStatusRequest() {}

  explicit MiguLivePullToPushStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (miguData) {
      res["MiguData"] = boost::any(*miguData);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MiguData") != m.end() && !m["MiguData"].empty()) {
      miguData = make_shared<string>(boost::any_cast<string>(m["MiguData"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~MiguLivePullToPushStatusRequest() = default;
};
class MiguLivePullToPushStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> status{};

  MiguLivePullToPushStatusResponseBodyData() {}

  explicit MiguLivePullToPushStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~MiguLivePullToPushStatusResponseBodyData() = default;
};
class MiguLivePullToPushStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<MiguLivePullToPushStatusResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> timestamp{};

  MiguLivePullToPushStatusResponseBody() {}

  explicit MiguLivePullToPushStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        MiguLivePullToPushStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<MiguLivePullToPushStatusResponseBodyData>(model1);
      }
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["timestamp"]));
    }
  }


  virtual ~MiguLivePullToPushStatusResponseBody() = default;
};
class MiguLivePullToPushStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MiguLivePullToPushStatusResponseBody> body{};

  MiguLivePullToPushStatusResponse() {}

  explicit MiguLivePullToPushStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MiguLivePullToPushStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MiguLivePullToPushStatusResponseBody>(model1);
      }
    }
  }


  virtual ~MiguLivePullToPushStatusResponse() = default;
};
class ModifyCasterComponentRequest : public Darabonba::Model {
public:
  shared_ptr<string> captionLayerContent{};
  shared_ptr<string> casterId{};
  shared_ptr<string> componentId{};
  shared_ptr<string> componentLayer{};
  shared_ptr<string> componentName{};
  shared_ptr<string> componentType{};
  shared_ptr<string> effect{};
  shared_ptr<string> imageLayerContent{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> textLayerContent{};

  ModifyCasterComponentRequest() {}

  explicit ModifyCasterComponentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (captionLayerContent) {
      res["CaptionLayerContent"] = boost::any(*captionLayerContent);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (componentLayer) {
      res["ComponentLayer"] = boost::any(*componentLayer);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (componentType) {
      res["ComponentType"] = boost::any(*componentType);
    }
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (imageLayerContent) {
      res["ImageLayerContent"] = boost::any(*imageLayerContent);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (textLayerContent) {
      res["TextLayerContent"] = boost::any(*textLayerContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaptionLayerContent") != m.end() && !m["CaptionLayerContent"].empty()) {
      captionLayerContent = make_shared<string>(boost::any_cast<string>(m["CaptionLayerContent"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("ComponentLayer") != m.end() && !m["ComponentLayer"].empty()) {
      componentLayer = make_shared<string>(boost::any_cast<string>(m["ComponentLayer"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("ComponentType") != m.end() && !m["ComponentType"].empty()) {
      componentType = make_shared<string>(boost::any_cast<string>(m["ComponentType"]));
    }
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("ImageLayerContent") != m.end() && !m["ImageLayerContent"].empty()) {
      imageLayerContent = make_shared<string>(boost::any_cast<string>(m["ImageLayerContent"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TextLayerContent") != m.end() && !m["TextLayerContent"].empty()) {
      textLayerContent = make_shared<string>(boost::any_cast<string>(m["TextLayerContent"]));
    }
  }


  virtual ~ModifyCasterComponentRequest() = default;
};
class ModifyCasterComponentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> componentId{};
  shared_ptr<string> requestId{};

  ModifyCasterComponentResponseBody() {}

  explicit ModifyCasterComponentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      componentId = make_shared<string>(boost::any_cast<string>(m["ComponentId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCasterComponentResponseBody() = default;
};
class ModifyCasterComponentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCasterComponentResponseBody> body{};

  ModifyCasterComponentResponse() {}

  explicit ModifyCasterComponentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCasterComponentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCasterComponentResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCasterComponentResponse() = default;
};
class ModifyCasterEpisodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> episodeName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> switchType{};

  ModifyCasterEpisodeRequest() {}

  explicit ModifyCasterEpisodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (episodeName) {
      res["EpisodeName"] = boost::any(*episodeName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (switchType) {
      res["SwitchType"] = boost::any(*switchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("EpisodeName") != m.end() && !m["EpisodeName"].empty()) {
      episodeName = make_shared<string>(boost::any_cast<string>(m["EpisodeName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SwitchType") != m.end() && !m["SwitchType"].empty()) {
      switchType = make_shared<string>(boost::any_cast<string>(m["SwitchType"]));
    }
  }


  virtual ~ModifyCasterEpisodeRequest() = default;
};
class ModifyCasterEpisodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> requestId{};

  ModifyCasterEpisodeResponseBody() {}

  explicit ModifyCasterEpisodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCasterEpisodeResponseBody() = default;
};
class ModifyCasterEpisodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCasterEpisodeResponseBody> body{};

  ModifyCasterEpisodeResponse() {}

  explicit ModifyCasterEpisodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCasterEpisodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCasterEpisodeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCasterEpisodeResponse() = default;
};
class ModifyCasterLayoutRequestAudioLayer : public Darabonba::Model {
public:
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  ModifyCasterLayoutRequestAudioLayer() {}

  explicit ModifyCasterLayoutRequestAudioLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~ModifyCasterLayoutRequestAudioLayer() = default;
};
class ModifyCasterLayoutRequestVideoLayer : public Darabonba::Model {
public:
  shared_ptr<string> fillMode{};
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<double> heightNormalized{};
  shared_ptr<vector<double>> positionNormalized{};
  shared_ptr<string> positionRefer{};
  shared_ptr<double> widthNormalized{};

  ModifyCasterLayoutRequestVideoLayer() {}

  explicit ModifyCasterLayoutRequestVideoLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fillMode) {
      res["FillMode"] = boost::any(*fillMode);
    }
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionNormalized) {
      res["PositionNormalized"] = boost::any(*positionNormalized);
    }
    if (positionRefer) {
      res["PositionRefer"] = boost::any(*positionRefer);
    }
    if (widthNormalized) {
      res["WidthNormalized"] = boost::any(*widthNormalized);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FillMode") != m.end() && !m["FillMode"].empty()) {
      fillMode = make_shared<string>(boost::any_cast<string>(m["FillMode"]));
    }
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["PositionNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PositionNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      positionNormalized = make_shared<vector<double>>(toVec1);
    }
    if (m.find("PositionRefer") != m.end() && !m["PositionRefer"].empty()) {
      positionRefer = make_shared<string>(boost::any_cast<string>(m["PositionRefer"]));
    }
    if (m.find("WidthNormalized") != m.end() && !m["WidthNormalized"].empty()) {
      widthNormalized = make_shared<double>(boost::any_cast<double>(m["WidthNormalized"]));
    }
  }


  virtual ~ModifyCasterLayoutRequestVideoLayer() = default;
};
class ModifyCasterLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyCasterLayoutRequestAudioLayer>> audioLayer{};
  shared_ptr<vector<string>> blendList{};
  shared_ptr<string> casterId{};
  shared_ptr<string> layoutId{};
  shared_ptr<vector<string>> mixList{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ModifyCasterLayoutRequestVideoLayer>> videoLayer{};

  ModifyCasterLayoutRequest() {}

  explicit ModifyCasterLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayer) {
      vector<boost::any> temp1;
      for(auto item1:*audioLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioLayer"] = boost::any(temp1);
    }
    if (blendList) {
      res["BlendList"] = boost::any(*blendList);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (mixList) {
      res["MixList"] = boost::any(*mixList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (videoLayer) {
      vector<boost::any> temp1;
      for(auto item1:*videoLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoLayer"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayer") != m.end() && !m["AudioLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioLayer"].type()) {
        vector<ModifyCasterLayoutRequestAudioLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCasterLayoutRequestAudioLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioLayer = make_shared<vector<ModifyCasterLayoutRequestAudioLayer>>(expect1);
      }
    }
    if (m.find("BlendList") != m.end() && !m["BlendList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BlendList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BlendList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      blendList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("MixList") != m.end() && !m["MixList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MixList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MixList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mixList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VideoLayer") != m.end() && !m["VideoLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoLayer"].type()) {
        vector<ModifyCasterLayoutRequestVideoLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCasterLayoutRequestVideoLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoLayer = make_shared<vector<ModifyCasterLayoutRequestVideoLayer>>(expect1);
      }
    }
  }


  virtual ~ModifyCasterLayoutRequest() = default;
};
class ModifyCasterLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> layoutId{};
  shared_ptr<string> requestId{};

  ModifyCasterLayoutResponseBody() {}

  explicit ModifyCasterLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCasterLayoutResponseBody() = default;
};
class ModifyCasterLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCasterLayoutResponseBody> body{};

  ModifyCasterLayoutResponse() {}

  explicit ModifyCasterLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCasterLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCasterLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCasterLayoutResponse() = default;
};
class ModifyCasterProgramRequestEpisode : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> episodeId{};
  shared_ptr<string> episodeName{};
  shared_ptr<string> episodeType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> switchType{};

  ModifyCasterProgramRequestEpisode() {}

  explicit ModifyCasterProgramRequestEpisode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (episodeId) {
      res["EpisodeId"] = boost::any(*episodeId);
    }
    if (episodeName) {
      res["EpisodeName"] = boost::any(*episodeName);
    }
    if (episodeType) {
      res["EpisodeType"] = boost::any(*episodeType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (switchType) {
      res["SwitchType"] = boost::any(*switchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EpisodeId") != m.end() && !m["EpisodeId"].empty()) {
      episodeId = make_shared<string>(boost::any_cast<string>(m["EpisodeId"]));
    }
    if (m.find("EpisodeName") != m.end() && !m["EpisodeName"].empty()) {
      episodeName = make_shared<string>(boost::any_cast<string>(m["EpisodeName"]));
    }
    if (m.find("EpisodeType") != m.end() && !m["EpisodeType"].empty()) {
      episodeType = make_shared<string>(boost::any_cast<string>(m["EpisodeType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SwitchType") != m.end() && !m["SwitchType"].empty()) {
      switchType = make_shared<string>(boost::any_cast<string>(m["SwitchType"]));
    }
  }


  virtual ~ModifyCasterProgramRequestEpisode() = default;
};
class ModifyCasterProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<ModifyCasterProgramRequestEpisode>> episode{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  ModifyCasterProgramRequest() {}

  explicit ModifyCasterProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (episode) {
      vector<boost::any> temp1;
      for(auto item1:*episode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Episode"] = boost::any(temp1);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("Episode") != m.end() && !m["Episode"].empty()) {
      if (typeid(vector<boost::any>) == m["Episode"].type()) {
        vector<ModifyCasterProgramRequestEpisode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Episode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCasterProgramRequestEpisode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        episode = make_shared<vector<ModifyCasterProgramRequestEpisode>>(expect1);
      }
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyCasterProgramRequest() = default;
};
class ModifyCasterProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  ModifyCasterProgramResponseBody() {}

  explicit ModifyCasterProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCasterProgramResponseBody() = default;
};
class ModifyCasterProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCasterProgramResponseBody> body{};

  ModifyCasterProgramResponse() {}

  explicit ModifyCasterProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCasterProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCasterProgramResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCasterProgramResponse() = default;
};
class ModifyCasterVideoResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginOffset{};
  shared_ptr<string> casterId{};
  shared_ptr<long> endOffset{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> liveStreamUrl{};
  shared_ptr<string> materialId{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> ptsCallbackInterval{};
  shared_ptr<string> regionId{};
  shared_ptr<long> repeatNum{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> vodUrl{};

  ModifyCasterVideoResourceRequest() {}

  explicit ModifyCasterVideoResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginOffset) {
      res["BeginOffset"] = boost::any(*beginOffset);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (endOffset) {
      res["EndOffset"] = boost::any(*endOffset);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (liveStreamUrl) {
      res["LiveStreamUrl"] = boost::any(*liveStreamUrl);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ptsCallbackInterval) {
      res["PtsCallbackInterval"] = boost::any(*ptsCallbackInterval);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeatNum) {
      res["RepeatNum"] = boost::any(*repeatNum);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (vodUrl) {
      res["VodUrl"] = boost::any(*vodUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginOffset") != m.end() && !m["BeginOffset"].empty()) {
      beginOffset = make_shared<long>(boost::any_cast<long>(m["BeginOffset"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("EndOffset") != m.end() && !m["EndOffset"].empty()) {
      endOffset = make_shared<long>(boost::any_cast<long>(m["EndOffset"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("LiveStreamUrl") != m.end() && !m["LiveStreamUrl"].empty()) {
      liveStreamUrl = make_shared<string>(boost::any_cast<string>(m["LiveStreamUrl"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PtsCallbackInterval") != m.end() && !m["PtsCallbackInterval"].empty()) {
      ptsCallbackInterval = make_shared<long>(boost::any_cast<long>(m["PtsCallbackInterval"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepeatNum") != m.end() && !m["RepeatNum"].empty()) {
      repeatNum = make_shared<long>(boost::any_cast<long>(m["RepeatNum"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("VodUrl") != m.end() && !m["VodUrl"].empty()) {
      vodUrl = make_shared<string>(boost::any_cast<string>(m["VodUrl"]));
    }
  }


  virtual ~ModifyCasterVideoResourceRequest() = default;
};
class ModifyCasterVideoResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceId{};

  ModifyCasterVideoResourceResponseBody() {}

  explicit ModifyCasterVideoResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ModifyCasterVideoResourceResponseBody() = default;
};
class ModifyCasterVideoResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCasterVideoResourceResponseBody> body{};

  ModifyCasterVideoResourceResponse() {}

  explicit ModifyCasterVideoResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCasterVideoResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCasterVideoResourceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCasterVideoResourceResponse() = default;
};
class ModifyLiveAIStudioRequestMattingLayout : public Darabonba::Model {
public:
  shared_ptr<double> heightNormalized{};
  shared_ptr<double> positionX{};
  shared_ptr<double> positionY{};

  ModifyLiveAIStudioRequestMattingLayout() {}

  explicit ModifyLiveAIStudioRequestMattingLayout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionX) {
      res["PositionX"] = boost::any(*positionX);
    }
    if (positionY) {
      res["PositionY"] = boost::any(*positionY);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionX") != m.end() && !m["PositionX"].empty()) {
      positionX = make_shared<double>(boost::any_cast<double>(m["PositionX"]));
    }
    if (m.find("PositionY") != m.end() && !m["PositionY"].empty()) {
      positionY = make_shared<double>(boost::any_cast<double>(m["PositionY"]));
    }
  }


  virtual ~ModifyLiveAIStudioRequestMattingLayout() = default;
};
class ModifyLiveAIStudioRequestMediaLayout : public Darabonba::Model {
public:
  shared_ptr<double> heightNormalized{};
  shared_ptr<double> positionX{};
  shared_ptr<double> positionY{};

  ModifyLiveAIStudioRequestMediaLayout() {}

  explicit ModifyLiveAIStudioRequestMediaLayout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (heightNormalized) {
      res["HeightNormalized"] = boost::any(*heightNormalized);
    }
    if (positionX) {
      res["PositionX"] = boost::any(*positionX);
    }
    if (positionY) {
      res["PositionY"] = boost::any(*positionY);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeightNormalized") != m.end() && !m["HeightNormalized"].empty()) {
      heightNormalized = make_shared<double>(boost::any_cast<double>(m["HeightNormalized"]));
    }
    if (m.find("PositionX") != m.end() && !m["PositionX"].empty()) {
      positionX = make_shared<double>(boost::any_cast<double>(m["PositionX"]));
    }
    if (m.find("PositionY") != m.end() && !m["PositionY"].empty()) {
      positionY = make_shared<double>(boost::any_cast<double>(m["PositionY"]));
    }
  }


  virtual ~ModifyLiveAIStudioRequestMediaLayout() = default;
};
class ModifyLiveAIStudioRequest : public Darabonba::Model {
public:
  shared_ptr<string> backgroundResourceId{};
  shared_ptr<string> backgroundResourceUrl{};
  shared_ptr<string> backgroundType{};
  shared_ptr<string> description{};
  shared_ptr<long> height{};
  shared_ptr<ModifyLiveAIStudioRequestMattingLayout> mattingLayout{};
  shared_ptr<string> mattingType{};
  shared_ptr<ModifyLiveAIStudioRequestMediaLayout> mediaLayout{};
  shared_ptr<string> mediaResourceId{};
  shared_ptr<string> mediaResourceUrl{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> studioName{};
  shared_ptr<long> width{};

  ModifyLiveAIStudioRequest() {}

  explicit ModifyLiveAIStudioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundResourceId) {
      res["BackgroundResourceId"] = boost::any(*backgroundResourceId);
    }
    if (backgroundResourceUrl) {
      res["BackgroundResourceUrl"] = boost::any(*backgroundResourceUrl);
    }
    if (backgroundType) {
      res["BackgroundType"] = boost::any(*backgroundType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mattingLayout) {
      res["MattingLayout"] = mattingLayout ? boost::any(mattingLayout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mattingType) {
      res["MattingType"] = boost::any(*mattingType);
    }
    if (mediaLayout) {
      res["MediaLayout"] = mediaLayout ? boost::any(mediaLayout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaResourceId) {
      res["MediaResourceId"] = boost::any(*mediaResourceId);
    }
    if (mediaResourceUrl) {
      res["MediaResourceUrl"] = boost::any(*mediaResourceUrl);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (studioName) {
      res["StudioName"] = boost::any(*studioName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundResourceId") != m.end() && !m["BackgroundResourceId"].empty()) {
      backgroundResourceId = make_shared<string>(boost::any_cast<string>(m["BackgroundResourceId"]));
    }
    if (m.find("BackgroundResourceUrl") != m.end() && !m["BackgroundResourceUrl"].empty()) {
      backgroundResourceUrl = make_shared<string>(boost::any_cast<string>(m["BackgroundResourceUrl"]));
    }
    if (m.find("BackgroundType") != m.end() && !m["BackgroundType"].empty()) {
      backgroundType = make_shared<string>(boost::any_cast<string>(m["BackgroundType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("MattingLayout") != m.end() && !m["MattingLayout"].empty()) {
      if (typeid(map<string, boost::any>) == m["MattingLayout"].type()) {
        ModifyLiveAIStudioRequestMattingLayout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MattingLayout"]));
        mattingLayout = make_shared<ModifyLiveAIStudioRequestMattingLayout>(model1);
      }
    }
    if (m.find("MattingType") != m.end() && !m["MattingType"].empty()) {
      mattingType = make_shared<string>(boost::any_cast<string>(m["MattingType"]));
    }
    if (m.find("MediaLayout") != m.end() && !m["MediaLayout"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaLayout"].type()) {
        ModifyLiveAIStudioRequestMediaLayout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaLayout"]));
        mediaLayout = make_shared<ModifyLiveAIStudioRequestMediaLayout>(model1);
      }
    }
    if (m.find("MediaResourceId") != m.end() && !m["MediaResourceId"].empty()) {
      mediaResourceId = make_shared<string>(boost::any_cast<string>(m["MediaResourceId"]));
    }
    if (m.find("MediaResourceUrl") != m.end() && !m["MediaResourceUrl"].empty()) {
      mediaResourceUrl = make_shared<string>(boost::any_cast<string>(m["MediaResourceUrl"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StudioName") != m.end() && !m["StudioName"].empty()) {
      studioName = make_shared<string>(boost::any_cast<string>(m["StudioName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~ModifyLiveAIStudioRequest() = default;
};
class ModifyLiveAIStudioShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> backgroundResourceId{};
  shared_ptr<string> backgroundResourceUrl{};
  shared_ptr<string> backgroundType{};
  shared_ptr<string> description{};
  shared_ptr<long> height{};
  shared_ptr<string> mattingLayoutShrink{};
  shared_ptr<string> mattingType{};
  shared_ptr<string> mediaLayoutShrink{};
  shared_ptr<string> mediaResourceId{};
  shared_ptr<string> mediaResourceUrl{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> studioName{};
  shared_ptr<long> width{};

  ModifyLiveAIStudioShrinkRequest() {}

  explicit ModifyLiveAIStudioShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundResourceId) {
      res["BackgroundResourceId"] = boost::any(*backgroundResourceId);
    }
    if (backgroundResourceUrl) {
      res["BackgroundResourceUrl"] = boost::any(*backgroundResourceUrl);
    }
    if (backgroundType) {
      res["BackgroundType"] = boost::any(*backgroundType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mattingLayoutShrink) {
      res["MattingLayout"] = boost::any(*mattingLayoutShrink);
    }
    if (mattingType) {
      res["MattingType"] = boost::any(*mattingType);
    }
    if (mediaLayoutShrink) {
      res["MediaLayout"] = boost::any(*mediaLayoutShrink);
    }
    if (mediaResourceId) {
      res["MediaResourceId"] = boost::any(*mediaResourceId);
    }
    if (mediaResourceUrl) {
      res["MediaResourceUrl"] = boost::any(*mediaResourceUrl);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (studioName) {
      res["StudioName"] = boost::any(*studioName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundResourceId") != m.end() && !m["BackgroundResourceId"].empty()) {
      backgroundResourceId = make_shared<string>(boost::any_cast<string>(m["BackgroundResourceId"]));
    }
    if (m.find("BackgroundResourceUrl") != m.end() && !m["BackgroundResourceUrl"].empty()) {
      backgroundResourceUrl = make_shared<string>(boost::any_cast<string>(m["BackgroundResourceUrl"]));
    }
    if (m.find("BackgroundType") != m.end() && !m["BackgroundType"].empty()) {
      backgroundType = make_shared<string>(boost::any_cast<string>(m["BackgroundType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("MattingLayout") != m.end() && !m["MattingLayout"].empty()) {
      mattingLayoutShrink = make_shared<string>(boost::any_cast<string>(m["MattingLayout"]));
    }
    if (m.find("MattingType") != m.end() && !m["MattingType"].empty()) {
      mattingType = make_shared<string>(boost::any_cast<string>(m["MattingType"]));
    }
    if (m.find("MediaLayout") != m.end() && !m["MediaLayout"].empty()) {
      mediaLayoutShrink = make_shared<string>(boost::any_cast<string>(m["MediaLayout"]));
    }
    if (m.find("MediaResourceId") != m.end() && !m["MediaResourceId"].empty()) {
      mediaResourceId = make_shared<string>(boost::any_cast<string>(m["MediaResourceId"]));
    }
    if (m.find("MediaResourceUrl") != m.end() && !m["MediaResourceUrl"].empty()) {
      mediaResourceUrl = make_shared<string>(boost::any_cast<string>(m["MediaResourceUrl"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StudioName") != m.end() && !m["StudioName"].empty()) {
      studioName = make_shared<string>(boost::any_cast<string>(m["StudioName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~ModifyLiveAIStudioShrinkRequest() = default;
};
class ModifyLiveAIStudioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLiveAIStudioResponseBody() {}

  explicit ModifyLiveAIStudioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLiveAIStudioResponseBody() = default;
};
class ModifyLiveAIStudioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLiveAIStudioResponseBody> body{};

  ModifyLiveAIStudioResponse() {}

  explicit ModifyLiveAIStudioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLiveAIStudioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLiveAIStudioResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLiveAIStudioResponse() = default;
};
class ModifyLiveDomainSchdmByPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> property{};
  shared_ptr<string> regionId{};

  ModifyLiveDomainSchdmByPropertyRequest() {}

  explicit ModifyLiveDomainSchdmByPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyLiveDomainSchdmByPropertyRequest() = default;
};
class ModifyLiveDomainSchdmByPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLiveDomainSchdmByPropertyResponseBody() {}

  explicit ModifyLiveDomainSchdmByPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLiveDomainSchdmByPropertyResponseBody() = default;
};
class ModifyLiveDomainSchdmByPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLiveDomainSchdmByPropertyResponseBody> body{};

  ModifyLiveDomainSchdmByPropertyResponse() {}

  explicit ModifyLiveDomainSchdmByPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLiveDomainSchdmByPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLiveDomainSchdmByPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLiveDomainSchdmByPropertyResponse() = default;
};
class ModifyLiveMessageAppAuditRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> auditType{};
  shared_ptr<string> auditUrl{};
  shared_ptr<string> dataCenter{};

  ModifyLiveMessageAppAuditRequest() {}

  explicit ModifyLiveMessageAppAuditRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (auditType) {
      res["AuditType"] = boost::any(*auditType);
    }
    if (auditUrl) {
      res["AuditUrl"] = boost::any(*auditUrl);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AuditType") != m.end() && !m["AuditType"].empty()) {
      auditType = make_shared<long>(boost::any_cast<long>(m["AuditType"]));
    }
    if (m.find("AuditUrl") != m.end() && !m["AuditUrl"].empty()) {
      auditUrl = make_shared<string>(boost::any_cast<string>(m["AuditUrl"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
  }


  virtual ~ModifyLiveMessageAppAuditRequest() = default;
};
class ModifyLiveMessageAppAuditResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appSign{};
  shared_ptr<bool> auditNeedAuthentication{};
  shared_ptr<long> auditType{};
  shared_ptr<string> auditUrl{};
  shared_ptr<string> requestId{};

  ModifyLiveMessageAppAuditResponseBody() {}

  explicit ModifyLiveMessageAppAuditResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appSign) {
      res["AppSign"] = boost::any(*appSign);
    }
    if (auditNeedAuthentication) {
      res["AuditNeedAuthentication"] = boost::any(*auditNeedAuthentication);
    }
    if (auditType) {
      res["AuditType"] = boost::any(*auditType);
    }
    if (auditUrl) {
      res["AuditUrl"] = boost::any(*auditUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppSign") != m.end() && !m["AppSign"].empty()) {
      appSign = make_shared<string>(boost::any_cast<string>(m["AppSign"]));
    }
    if (m.find("AuditNeedAuthentication") != m.end() && !m["AuditNeedAuthentication"].empty()) {
      auditNeedAuthentication = make_shared<bool>(boost::any_cast<bool>(m["AuditNeedAuthentication"]));
    }
    if (m.find("AuditType") != m.end() && !m["AuditType"].empty()) {
      auditType = make_shared<long>(boost::any_cast<long>(m["AuditType"]));
    }
    if (m.find("AuditUrl") != m.end() && !m["AuditUrl"].empty()) {
      auditUrl = make_shared<string>(boost::any_cast<string>(m["AuditUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLiveMessageAppAuditResponseBody() = default;
};
class ModifyLiveMessageAppAuditResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLiveMessageAppAuditResponseBody> body{};

  ModifyLiveMessageAppAuditResponse() {}

  explicit ModifyLiveMessageAppAuditResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLiveMessageAppAuditResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLiveMessageAppAuditResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLiveMessageAppAuditResponse() = default;
};
class ModifyLiveMessageAppCallbackRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> eventCallbackUrl{};

  ModifyLiveMessageAppCallbackRequest() {}

  explicit ModifyLiveMessageAppCallbackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (eventCallbackUrl) {
      res["EventCallbackUrl"] = boost::any(*eventCallbackUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("EventCallbackUrl") != m.end() && !m["EventCallbackUrl"].empty()) {
      eventCallbackUrl = make_shared<string>(boost::any_cast<string>(m["EventCallbackUrl"]));
    }
  }


  virtual ~ModifyLiveMessageAppCallbackRequest() = default;
};
class ModifyLiveMessageAppCallbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appSign{};
  shared_ptr<bool> eventCallbackNeedAuthentication{};
  shared_ptr<string> eventCallbackUrl{};
  shared_ptr<string> requestId{};

  ModifyLiveMessageAppCallbackResponseBody() {}

  explicit ModifyLiveMessageAppCallbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appSign) {
      res["AppSign"] = boost::any(*appSign);
    }
    if (eventCallbackNeedAuthentication) {
      res["EventCallbackNeedAuthentication"] = boost::any(*eventCallbackNeedAuthentication);
    }
    if (eventCallbackUrl) {
      res["EventCallbackUrl"] = boost::any(*eventCallbackUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppSign") != m.end() && !m["AppSign"].empty()) {
      appSign = make_shared<string>(boost::any_cast<string>(m["AppSign"]));
    }
    if (m.find("EventCallbackNeedAuthentication") != m.end() && !m["EventCallbackNeedAuthentication"].empty()) {
      eventCallbackNeedAuthentication = make_shared<bool>(boost::any_cast<bool>(m["EventCallbackNeedAuthentication"]));
    }
    if (m.find("EventCallbackUrl") != m.end() && !m["EventCallbackUrl"].empty()) {
      eventCallbackUrl = make_shared<string>(boost::any_cast<string>(m["EventCallbackUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLiveMessageAppCallbackResponseBody() = default;
};
class ModifyLiveMessageAppCallbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLiveMessageAppCallbackResponseBody> body{};

  ModifyLiveMessageAppCallbackResponse() {}

  explicit ModifyLiveMessageAppCallbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLiveMessageAppCallbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLiveMessageAppCallbackResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLiveMessageAppCallbackResponse() = default;
};
class ModifyLiveMessageAppDisableRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<bool> disable{};

  ModifyLiveMessageAppDisableRequest() {}

  explicit ModifyLiveMessageAppDisableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (disable) {
      res["Disable"] = boost::any(*disable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("Disable") != m.end() && !m["Disable"].empty()) {
      disable = make_shared<bool>(boost::any_cast<bool>(m["Disable"]));
    }
  }


  virtual ~ModifyLiveMessageAppDisableRequest() = default;
};
class ModifyLiveMessageAppDisableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appSign{};
  shared_ptr<bool> disable{};
  shared_ptr<string> requestId{};

  ModifyLiveMessageAppDisableResponseBody() {}

  explicit ModifyLiveMessageAppDisableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appSign) {
      res["AppSign"] = boost::any(*appSign);
    }
    if (disable) {
      res["Disable"] = boost::any(*disable);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppSign") != m.end() && !m["AppSign"].empty()) {
      appSign = make_shared<string>(boost::any_cast<string>(m["AppSign"]));
    }
    if (m.find("Disable") != m.end() && !m["Disable"].empty()) {
      disable = make_shared<bool>(boost::any_cast<bool>(m["Disable"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLiveMessageAppDisableResponseBody() = default;
};
class ModifyLiveMessageAppDisableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLiveMessageAppDisableResponseBody> body{};

  ModifyLiveMessageAppDisableResponse() {}

  explicit ModifyLiveMessageAppDisableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLiveMessageAppDisableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLiveMessageAppDisableResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLiveMessageAppDisableResponse() = default;
};
class ModifyLiveMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> adminList{};
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupInfo{};
  shared_ptr<bool> modifyAdmin{};
  shared_ptr<bool> modifyInfo{};

  ModifyLiveMessageGroupRequest() {}

  explicit ModifyLiveMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminList) {
      res["AdminList"] = boost::any(*adminList);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupInfo) {
      res["GroupInfo"] = boost::any(*groupInfo);
    }
    if (modifyAdmin) {
      res["ModifyAdmin"] = boost::any(*modifyAdmin);
    }
    if (modifyInfo) {
      res["ModifyInfo"] = boost::any(*modifyInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdminList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      adminList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      groupInfo = make_shared<string>(boost::any_cast<string>(m["GroupInfo"]));
    }
    if (m.find("ModifyAdmin") != m.end() && !m["ModifyAdmin"].empty()) {
      modifyAdmin = make_shared<bool>(boost::any_cast<bool>(m["ModifyAdmin"]));
    }
    if (m.find("ModifyInfo") != m.end() && !m["ModifyInfo"].empty()) {
      modifyInfo = make_shared<bool>(boost::any_cast<bool>(m["ModifyInfo"]));
    }
  }


  virtual ~ModifyLiveMessageGroupRequest() = default;
};
class ModifyLiveMessageGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> adminListShrink{};
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupInfo{};
  shared_ptr<bool> modifyAdmin{};
  shared_ptr<bool> modifyInfo{};

  ModifyLiveMessageGroupShrinkRequest() {}

  explicit ModifyLiveMessageGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminListShrink) {
      res["AdminList"] = boost::any(*adminListShrink);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupInfo) {
      res["GroupInfo"] = boost::any(*groupInfo);
    }
    if (modifyAdmin) {
      res["ModifyAdmin"] = boost::any(*modifyAdmin);
    }
    if (modifyInfo) {
      res["ModifyInfo"] = boost::any(*modifyInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      adminListShrink = make_shared<string>(boost::any_cast<string>(m["AdminList"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupInfo") != m.end() && !m["GroupInfo"].empty()) {
      groupInfo = make_shared<string>(boost::any_cast<string>(m["GroupInfo"]));
    }
    if (m.find("ModifyAdmin") != m.end() && !m["ModifyAdmin"].empty()) {
      modifyAdmin = make_shared<bool>(boost::any_cast<bool>(m["ModifyAdmin"]));
    }
    if (m.find("ModifyInfo") != m.end() && !m["ModifyInfo"].empty()) {
      modifyInfo = make_shared<bool>(boost::any_cast<bool>(m["ModifyInfo"]));
    }
  }


  virtual ~ModifyLiveMessageGroupShrinkRequest() = default;
};
class ModifyLiveMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLiveMessageGroupResponseBody() {}

  explicit ModifyLiveMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLiveMessageGroupResponseBody() = default;
};
class ModifyLiveMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLiveMessageGroupResponseBody> body{};

  ModifyLiveMessageGroupResponse() {}

  explicit ModifyLiveMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLiveMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLiveMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLiveMessageGroupResponse() = default;
};
class ModifyLiveMessageGroupBandRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> bannedAll{};
  shared_ptr<vector<string>> bannnedUsers{};
  shared_ptr<string> dataCenter{};
  shared_ptr<vector<string>> exceptUsers{};
  shared_ptr<string> groupId{};

  ModifyLiveMessageGroupBandRequest() {}

  explicit ModifyLiveMessageGroupBandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (bannedAll) {
      res["BannedAll"] = boost::any(*bannedAll);
    }
    if (bannnedUsers) {
      res["BannnedUsers"] = boost::any(*bannnedUsers);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (exceptUsers) {
      res["ExceptUsers"] = boost::any(*exceptUsers);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BannedAll") != m.end() && !m["BannedAll"].empty()) {
      bannedAll = make_shared<bool>(boost::any_cast<bool>(m["BannedAll"]));
    }
    if (m.find("BannnedUsers") != m.end() && !m["BannnedUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BannnedUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BannnedUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bannnedUsers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("ExceptUsers") != m.end() && !m["ExceptUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExceptUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExceptUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      exceptUsers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~ModifyLiveMessageGroupBandRequest() = default;
};
class ModifyLiveMessageGroupBandShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> bannedAll{};
  shared_ptr<string> bannnedUsersShrink{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> exceptUsersShrink{};
  shared_ptr<string> groupId{};

  ModifyLiveMessageGroupBandShrinkRequest() {}

  explicit ModifyLiveMessageGroupBandShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (bannedAll) {
      res["BannedAll"] = boost::any(*bannedAll);
    }
    if (bannnedUsersShrink) {
      res["BannnedUsers"] = boost::any(*bannnedUsersShrink);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (exceptUsersShrink) {
      res["ExceptUsers"] = boost::any(*exceptUsersShrink);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BannedAll") != m.end() && !m["BannedAll"].empty()) {
      bannedAll = make_shared<bool>(boost::any_cast<bool>(m["BannedAll"]));
    }
    if (m.find("BannnedUsers") != m.end() && !m["BannnedUsers"].empty()) {
      bannnedUsersShrink = make_shared<string>(boost::any_cast<string>(m["BannnedUsers"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("ExceptUsers") != m.end() && !m["ExceptUsers"].empty()) {
      exceptUsersShrink = make_shared<string>(boost::any_cast<string>(m["ExceptUsers"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~ModifyLiveMessageGroupBandShrinkRequest() = default;
};
class ModifyLiveMessageGroupBandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLiveMessageGroupBandResponseBody() {}

  explicit ModifyLiveMessageGroupBandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLiveMessageGroupBandResponseBody() = default;
};
class ModifyLiveMessageGroupBandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLiveMessageGroupBandResponseBody> body{};

  ModifyLiveMessageGroupBandResponse() {}

  explicit ModifyLiveMessageGroupBandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLiveMessageGroupBandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLiveMessageGroupBandResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLiveMessageGroupBandResponse() = default;
};
class ModifyLiveMessageUserInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> userId{};
  shared_ptr<string> userMetaInfo{};

  ModifyLiveMessageUserInfoRequest() {}

  explicit ModifyLiveMessageUserInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userMetaInfo) {
      res["UserMetaInfo"] = boost::any(*userMetaInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserMetaInfo") != m.end() && !m["UserMetaInfo"].empty()) {
      userMetaInfo = make_shared<string>(boost::any_cast<string>(m["UserMetaInfo"]));
    }
  }


  virtual ~ModifyLiveMessageUserInfoRequest() = default;
};
class ModifyLiveMessageUserInfoResponseBodyFailList : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> groupId{};
  shared_ptr<string> reason{};
  shared_ptr<bool> success{};

  ModifyLiveMessageUserInfoResponseBodyFailList() {}

  explicit ModifyLiveMessageUserInfoResponseBodyFailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyLiveMessageUserInfoResponseBodyFailList() = default;
};
class ModifyLiveMessageUserInfoResponseBodySuccessList : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<bool> success{};

  ModifyLiveMessageUserInfoResponseBodySuccessList() {}

  explicit ModifyLiveMessageUserInfoResponseBodySuccessList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyLiveMessageUserInfoResponseBodySuccessList() = default;
};
class ModifyLiveMessageUserInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyLiveMessageUserInfoResponseBodyFailList>> failList{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ModifyLiveMessageUserInfoResponseBodySuccessList>> successList{};

  ModifyLiveMessageUserInfoResponseBody() {}

  explicit ModifyLiveMessageUserInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failList) {
      vector<boost::any> temp1;
      for(auto item1:*failList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successList) {
      vector<boost::any> temp1;
      for(auto item1:*successList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuccessList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailList") != m.end() && !m["FailList"].empty()) {
      if (typeid(vector<boost::any>) == m["FailList"].type()) {
        vector<ModifyLiveMessageUserInfoResponseBodyFailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyLiveMessageUserInfoResponseBodyFailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failList = make_shared<vector<ModifyLiveMessageUserInfoResponseBodyFailList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessList") != m.end() && !m["SuccessList"].empty()) {
      if (typeid(vector<boost::any>) == m["SuccessList"].type()) {
        vector<ModifyLiveMessageUserInfoResponseBodySuccessList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuccessList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyLiveMessageUserInfoResponseBodySuccessList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        successList = make_shared<vector<ModifyLiveMessageUserInfoResponseBodySuccessList>>(expect1);
      }
    }
  }


  virtual ~ModifyLiveMessageUserInfoResponseBody() = default;
};
class ModifyLiveMessageUserInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLiveMessageUserInfoResponseBody> body{};

  ModifyLiveMessageUserInfoResponse() {}

  explicit ModifyLiveMessageUserInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLiveMessageUserInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLiveMessageUserInfoResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLiveMessageUserInfoResponse() = default;
};
class ModifyLiveRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> logstore{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};

  ModifyLiveRealtimeLogDeliveryRequest() {}

  explicit ModifyLiveRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyLiveRealtimeLogDeliveryRequest() = default;
};
class ModifyLiveRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLiveRealtimeLogDeliveryResponseBody() {}

  explicit ModifyLiveRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLiveRealtimeLogDeliveryResponseBody() = default;
};
class ModifyLiveRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLiveRealtimeLogDeliveryResponseBody> body{};

  ModifyLiveRealtimeLogDeliveryResponse() {}

  explicit ModifyLiveRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLiveRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLiveRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLiveRealtimeLogDeliveryResponse() = default;
};
class ModifyShowListRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> highPriorityShowId{};
  shared_ptr<string> highPriorityShowStartTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> repeatTimes{};
  shared_ptr<string> showId{};
  shared_ptr<long> spot{};

  ModifyShowListRequest() {}

  explicit ModifyShowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (highPriorityShowId) {
      res["HighPriorityShowId"] = boost::any(*highPriorityShowId);
    }
    if (highPriorityShowStartTime) {
      res["HighPriorityShowStartTime"] = boost::any(*highPriorityShowStartTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeatTimes) {
      res["RepeatTimes"] = boost::any(*repeatTimes);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (spot) {
      res["Spot"] = boost::any(*spot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("HighPriorityShowId") != m.end() && !m["HighPriorityShowId"].empty()) {
      highPriorityShowId = make_shared<string>(boost::any_cast<string>(m["HighPriorityShowId"]));
    }
    if (m.find("HighPriorityShowStartTime") != m.end() && !m["HighPriorityShowStartTime"].empty()) {
      highPriorityShowStartTime = make_shared<string>(boost::any_cast<string>(m["HighPriorityShowStartTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepeatTimes") != m.end() && !m["RepeatTimes"].empty()) {
      repeatTimes = make_shared<long>(boost::any_cast<long>(m["RepeatTimes"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("Spot") != m.end() && !m["Spot"].empty()) {
      spot = make_shared<long>(boost::any_cast<long>(m["Spot"]));
    }
  }


  virtual ~ModifyShowListRequest() = default;
};
class ModifyShowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyShowListResponseBody() {}

  explicit ModifyShowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyShowListResponseBody() = default;
};
class ModifyShowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyShowListResponseBody> body{};

  ModifyShowListResponse() {}

  explicit ModifyShowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyShowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyShowListResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyShowListResponse() = default;
};
class ModifyStudioLayoutRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgImageConfig{};
  shared_ptr<string> casterId{};
  shared_ptr<string> commonConfig{};
  shared_ptr<string> layerOrderConfigList{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> layoutName{};
  shared_ptr<string> mediaInputConfigList{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> screenInputConfigList{};

  ModifyStudioLayoutRequest() {}

  explicit ModifyStudioLayoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgImageConfig) {
      res["BgImageConfig"] = boost::any(*bgImageConfig);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (commonConfig) {
      res["CommonConfig"] = boost::any(*commonConfig);
    }
    if (layerOrderConfigList) {
      res["LayerOrderConfigList"] = boost::any(*layerOrderConfigList);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (layoutName) {
      res["LayoutName"] = boost::any(*layoutName);
    }
    if (mediaInputConfigList) {
      res["MediaInputConfigList"] = boost::any(*mediaInputConfigList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (screenInputConfigList) {
      res["ScreenInputConfigList"] = boost::any(*screenInputConfigList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgImageConfig") != m.end() && !m["BgImageConfig"].empty()) {
      bgImageConfig = make_shared<string>(boost::any_cast<string>(m["BgImageConfig"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CommonConfig") != m.end() && !m["CommonConfig"].empty()) {
      commonConfig = make_shared<string>(boost::any_cast<string>(m["CommonConfig"]));
    }
    if (m.find("LayerOrderConfigList") != m.end() && !m["LayerOrderConfigList"].empty()) {
      layerOrderConfigList = make_shared<string>(boost::any_cast<string>(m["LayerOrderConfigList"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("LayoutName") != m.end() && !m["LayoutName"].empty()) {
      layoutName = make_shared<string>(boost::any_cast<string>(m["LayoutName"]));
    }
    if (m.find("MediaInputConfigList") != m.end() && !m["MediaInputConfigList"].empty()) {
      mediaInputConfigList = make_shared<string>(boost::any_cast<string>(m["MediaInputConfigList"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScreenInputConfigList") != m.end() && !m["ScreenInputConfigList"].empty()) {
      screenInputConfigList = make_shared<string>(boost::any_cast<string>(m["ScreenInputConfigList"]));
    }
  }


  virtual ~ModifyStudioLayoutRequest() = default;
};
class ModifyStudioLayoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyStudioLayoutResponseBody() {}

  explicit ModifyStudioLayoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyStudioLayoutResponseBody() = default;
};
class ModifyStudioLayoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyStudioLayoutResponseBody> body{};

  ModifyStudioLayoutResponse() {}

  explicit ModifyStudioLayoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyStudioLayoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyStudioLayoutResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyStudioLayoutResponse() = default;
};
class MuteAllGroupUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> broadCastType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};

  MuteAllGroupUserRequest() {}

  explicit MuteAllGroupUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
  }


  virtual ~MuteAllGroupUserRequest() = default;
};
class MuteAllGroupUserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  MuteAllGroupUserResponseBodyResult() {}

  explicit MuteAllGroupUserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MuteAllGroupUserResponseBodyResult() = default;
};
class MuteAllGroupUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<MuteAllGroupUserResponseBodyResult> result{};

  MuteAllGroupUserResponseBody() {}

  explicit MuteAllGroupUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        MuteAllGroupUserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<MuteAllGroupUserResponseBodyResult>(model1);
      }
    }
  }


  virtual ~MuteAllGroupUserResponseBody() = default;
};
class MuteAllGroupUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MuteAllGroupUserResponseBody> body{};

  MuteAllGroupUserResponse() {}

  explicit MuteAllGroupUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MuteAllGroupUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MuteAllGroupUserResponseBody>(model1);
      }
    }
  }


  virtual ~MuteAllGroupUserResponse() = default;
};
class MuteGroupUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> broadCastType{};
  shared_ptr<string> groupId{};
  shared_ptr<long> muteTime{};
  shared_ptr<vector<string>> muteUserList{};
  shared_ptr<string> operatorUserId{};

  MuteGroupUserRequest() {}

  explicit MuteGroupUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (muteTime) {
      res["MuteTime"] = boost::any(*muteTime);
    }
    if (muteUserList) {
      res["MuteUserList"] = boost::any(*muteUserList);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MuteTime") != m.end() && !m["MuteTime"].empty()) {
      muteTime = make_shared<long>(boost::any_cast<long>(m["MuteTime"]));
    }
    if (m.find("MuteUserList") != m.end() && !m["MuteUserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MuteUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MuteUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      muteUserList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
  }


  virtual ~MuteGroupUserRequest() = default;
};
class MuteGroupUserShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> broadCastType{};
  shared_ptr<string> groupId{};
  shared_ptr<long> muteTime{};
  shared_ptr<string> muteUserListShrink{};
  shared_ptr<string> operatorUserId{};

  MuteGroupUserShrinkRequest() {}

  explicit MuteGroupUserShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (muteTime) {
      res["MuteTime"] = boost::any(*muteTime);
    }
    if (muteUserListShrink) {
      res["MuteUserList"] = boost::any(*muteUserListShrink);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MuteTime") != m.end() && !m["MuteTime"].empty()) {
      muteTime = make_shared<long>(boost::any_cast<long>(m["MuteTime"]));
    }
    if (m.find("MuteUserList") != m.end() && !m["MuteUserList"].empty()) {
      muteUserListShrink = make_shared<string>(boost::any_cast<string>(m["MuteUserList"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
  }


  virtual ~MuteGroupUserShrinkRequest() = default;
};
class MuteGroupUserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  MuteGroupUserResponseBodyResult() {}

  explicit MuteGroupUserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MuteGroupUserResponseBodyResult() = default;
};
class MuteGroupUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<MuteGroupUserResponseBodyResult> result{};

  MuteGroupUserResponseBody() {}

  explicit MuteGroupUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        MuteGroupUserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<MuteGroupUserResponseBodyResult>(model1);
      }
    }
  }


  virtual ~MuteGroupUserResponseBody() = default;
};
class MuteGroupUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MuteGroupUserResponseBody> body{};

  MuteGroupUserResponse() {}

  explicit MuteGroupUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MuteGroupUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MuteGroupUserResponseBody>(model1);
      }
    }
  }


  virtual ~MuteGroupUserResponse() = default;
};
class OpenLiveShiftRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> duration{};
  shared_ptr<bool> ignoreTranscode{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};
  shared_ptr<long> vision{};

  OpenLiveShiftRequest() {}

  explicit OpenLiveShiftRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (ignoreTranscode) {
      res["IgnoreTranscode"] = boost::any(*ignoreTranscode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (vision) {
      res["Vision"] = boost::any(*vision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("IgnoreTranscode") != m.end() && !m["IgnoreTranscode"].empty()) {
      ignoreTranscode = make_shared<bool>(boost::any_cast<bool>(m["IgnoreTranscode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Vision") != m.end() && !m["Vision"].empty()) {
      vision = make_shared<long>(boost::any_cast<long>(m["Vision"]));
    }
  }


  virtual ~OpenLiveShiftRequest() = default;
};
class OpenLiveShiftResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OpenLiveShiftResponseBody() {}

  explicit OpenLiveShiftResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenLiveShiftResponseBody() = default;
};
class OpenLiveShiftResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenLiveShiftResponseBody> body{};

  OpenLiveShiftResponse() {}

  explicit OpenLiveShiftResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenLiveShiftResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenLiveShiftResponseBody>(model1);
      }
    }
  }


  virtual ~OpenLiveShiftResponse() = default;
};
class PlayChoosenShowRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> showId{};

  PlayChoosenShowRequest() {}

  explicit PlayChoosenShowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
  }


  virtual ~PlayChoosenShowRequest() = default;
};
class PlayChoosenShowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> showId{};

  PlayChoosenShowResponseBody() {}

  explicit PlayChoosenShowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
  }


  virtual ~PlayChoosenShowResponseBody() = default;
};
class PlayChoosenShowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PlayChoosenShowResponseBody> body{};

  PlayChoosenShowResponse() {}

  explicit PlayChoosenShowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PlayChoosenShowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PlayChoosenShowResponseBody>(model1);
      }
    }
  }


  virtual ~PlayChoosenShowResponse() = default;
};
class PublishLiveStagingConfigToProductionRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  PublishLiveStagingConfigToProductionRequest() {}

  explicit PublishLiveStagingConfigToProductionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~PublishLiveStagingConfigToProductionRequest() = default;
};
class PublishLiveStagingConfigToProductionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PublishLiveStagingConfigToProductionResponseBody() {}

  explicit PublishLiveStagingConfigToProductionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishLiveStagingConfigToProductionResponseBody() = default;
};
class PublishLiveStagingConfigToProductionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishLiveStagingConfigToProductionResponseBody> body{};

  PublishLiveStagingConfigToProductionResponse() {}

  explicit PublishLiveStagingConfigToProductionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishLiveStagingConfigToProductionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishLiveStagingConfigToProductionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishLiveStagingConfigToProductionResponse() = default;
};
class QueryLiveDomainMultiStreamListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  QueryLiveDomainMultiStreamListRequest() {}

  explicit QueryLiveDomainMultiStreamListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~QueryLiveDomainMultiStreamListRequest() = default;
};
class QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsChangeLogs : public Darabonba::Model {
public:
  shared_ptr<string> changeReason{};
  shared_ptr<string> changeTime{};
  shared_ptr<string> masterUpstream{};
  shared_ptr<string> upstreamIp{};
  shared_ptr<string> upstreamSequence{};

  QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsChangeLogs() {}

  explicit QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsChangeLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeReason) {
      res["ChangeReason"] = boost::any(*changeReason);
    }
    if (changeTime) {
      res["ChangeTime"] = boost::any(*changeTime);
    }
    if (masterUpstream) {
      res["MasterUpstream"] = boost::any(*masterUpstream);
    }
    if (upstreamIp) {
      res["UpstreamIp"] = boost::any(*upstreamIp);
    }
    if (upstreamSequence) {
      res["UpstreamSequence"] = boost::any(*upstreamSequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeReason") != m.end() && !m["ChangeReason"].empty()) {
      changeReason = make_shared<string>(boost::any_cast<string>(m["ChangeReason"]));
    }
    if (m.find("ChangeTime") != m.end() && !m["ChangeTime"].empty()) {
      changeTime = make_shared<string>(boost::any_cast<string>(m["ChangeTime"]));
    }
    if (m.find("MasterUpstream") != m.end() && !m["MasterUpstream"].empty()) {
      masterUpstream = make_shared<string>(boost::any_cast<string>(m["MasterUpstream"]));
    }
    if (m.find("UpstreamIp") != m.end() && !m["UpstreamIp"].empty()) {
      upstreamIp = make_shared<string>(boost::any_cast<string>(m["UpstreamIp"]));
    }
    if (m.find("UpstreamSequence") != m.end() && !m["UpstreamSequence"].empty()) {
      upstreamSequence = make_shared<string>(boost::any_cast<string>(m["UpstreamSequence"]));
    }
  }


  virtual ~QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsChangeLogs() = default;
};
class QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsUpstreamList : public Darabonba::Model {
public:
  shared_ptr<bool> masterFlag{};
  shared_ptr<string> upstreamIp{};
  shared_ptr<string> upstreamSequence{};
  shared_ptr<string> upstreamTime{};

  QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsUpstreamList() {}

  explicit QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsUpstreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (masterFlag) {
      res["MasterFlag"] = boost::any(*masterFlag);
    }
    if (upstreamIp) {
      res["UpstreamIp"] = boost::any(*upstreamIp);
    }
    if (upstreamSequence) {
      res["UpstreamSequence"] = boost::any(*upstreamSequence);
    }
    if (upstreamTime) {
      res["UpstreamTime"] = boost::any(*upstreamTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MasterFlag") != m.end() && !m["MasterFlag"].empty()) {
      masterFlag = make_shared<bool>(boost::any_cast<bool>(m["MasterFlag"]));
    }
    if (m.find("UpstreamIp") != m.end() && !m["UpstreamIp"].empty()) {
      upstreamIp = make_shared<string>(boost::any_cast<string>(m["UpstreamIp"]));
    }
    if (m.find("UpstreamSequence") != m.end() && !m["UpstreamSequence"].empty()) {
      upstreamSequence = make_shared<string>(boost::any_cast<string>(m["UpstreamSequence"]));
    }
    if (m.find("UpstreamTime") != m.end() && !m["UpstreamTime"].empty()) {
      upstreamTime = make_shared<string>(boost::any_cast<string>(m["UpstreamTime"]));
    }
  }


  virtual ~QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsUpstreamList() = default;
};
class QueryLiveDomainMultiStreamListResponseBodyOnlineStreams : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<vector<QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsChangeLogs>> changeLogs{};
  shared_ptr<string> domain{};
  shared_ptr<string> optimalMode{};
  shared_ptr<string> streamName{};
  shared_ptr<vector<QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsUpstreamList>> upstreamList{};

  QueryLiveDomainMultiStreamListResponseBodyOnlineStreams() {}

  explicit QueryLiveDomainMultiStreamListResponseBodyOnlineStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (changeLogs) {
      vector<boost::any> temp1;
      for(auto item1:*changeLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChangeLogs"] = boost::any(temp1);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (optimalMode) {
      res["OptimalMode"] = boost::any(*optimalMode);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (upstreamList) {
      vector<boost::any> temp1;
      for(auto item1:*upstreamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpstreamList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ChangeLogs") != m.end() && !m["ChangeLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["ChangeLogs"].type()) {
        vector<QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsChangeLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChangeLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsChangeLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeLogs = make_shared<vector<QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsChangeLogs>>(expect1);
      }
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OptimalMode") != m.end() && !m["OptimalMode"].empty()) {
      optimalMode = make_shared<string>(boost::any_cast<string>(m["OptimalMode"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("UpstreamList") != m.end() && !m["UpstreamList"].empty()) {
      if (typeid(vector<boost::any>) == m["UpstreamList"].type()) {
        vector<QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsUpstreamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpstreamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsUpstreamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upstreamList = make_shared<vector<QueryLiveDomainMultiStreamListResponseBodyOnlineStreamsUpstreamList>>(expect1);
      }
    }
  }


  virtual ~QueryLiveDomainMultiStreamListResponseBodyOnlineStreams() = default;
};
class QueryLiveDomainMultiStreamListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryLiveDomainMultiStreamListResponseBodyOnlineStreams>> onlineStreams{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryLiveDomainMultiStreamListResponseBody() {}

  explicit QueryLiveDomainMultiStreamListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onlineStreams) {
      vector<boost::any> temp1;
      for(auto item1:*onlineStreams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OnlineStreams"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnlineStreams") != m.end() && !m["OnlineStreams"].empty()) {
      if (typeid(vector<boost::any>) == m["OnlineStreams"].type()) {
        vector<QueryLiveDomainMultiStreamListResponseBodyOnlineStreams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OnlineStreams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLiveDomainMultiStreamListResponseBodyOnlineStreams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        onlineStreams = make_shared<vector<QueryLiveDomainMultiStreamListResponseBodyOnlineStreams>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryLiveDomainMultiStreamListResponseBody() = default;
};
class QueryLiveDomainMultiStreamListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLiveDomainMultiStreamListResponseBody> body{};

  QueryLiveDomainMultiStreamListResponse() {}

  explicit QueryLiveDomainMultiStreamListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLiveDomainMultiStreamListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLiveDomainMultiStreamListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLiveDomainMultiStreamListResponse() = default;
};
class QueryMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> sortType{};

  QueryMessageAppRequest() {}

  explicit QueryMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<long>(boost::any_cast<long>(m["SortType"]));
    }
  }


  virtual ~QueryMessageAppRequest() = default;
};
class QueryMessageAppResponseBodyResultAppList : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> appConfig{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<map<string, string>> extension{};
  shared_ptr<long> status{};

  QueryMessageAppResponseBodyResultAppList() {}

  explicit QueryMessageAppResponseBodyResultAppList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["AppConfig"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      appConfig = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~QueryMessageAppResponseBodyResultAppList() = default;
};
class QueryMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMessageAppResponseBodyResultAppList>> appList{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> totalCount{};

  QueryMessageAppResponseBodyResult() {}

  explicit QueryMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appList) {
      vector<boost::any> temp1;
      for(auto item1:*appList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppList"] = boost::any(temp1);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppList") != m.end() && !m["AppList"].empty()) {
      if (typeid(vector<boost::any>) == m["AppList"].type()) {
        vector<QueryMessageAppResponseBodyResultAppList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMessageAppResponseBodyResultAppList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appList = make_shared<vector<QueryMessageAppResponseBodyResultAppList>>(expect1);
      }
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryMessageAppResponseBodyResult() = default;
};
class QueryMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryMessageAppResponseBodyResult>> result{};

  QueryMessageAppResponseBody() {}

  explicit QueryMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryMessageAppResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMessageAppResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMessageAppResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~QueryMessageAppResponseBody() = default;
};
class QueryMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMessageAppResponseBody> body{};

  QueryMessageAppResponse() {}

  explicit QueryMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMessageAppResponse() = default;
};
class QueryRtcAsrTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  QueryRtcAsrTasksRequest() {}

  explicit QueryRtcAsrTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~QueryRtcAsrTasksRequest() = default;
};
class QueryRtcAsrTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};
  shared_ptr<map<string, boost::any>> tasks{};

  QueryRtcAsrTasksResponseBody() {}

  explicit QueryRtcAsrTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    if (tasks) {
      res["Tasks"] = boost::any(*tasks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tasks"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tasks = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~QueryRtcAsrTasksResponseBody() = default;
};
class QueryRtcAsrTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryRtcAsrTasksResponseBody> body{};

  QueryRtcAsrTasksResponse() {}

  explicit QueryRtcAsrTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryRtcAsrTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryRtcAsrTasksResponseBody>(model1);
      }
    }
  }


  virtual ~QueryRtcAsrTasksResponse() = default;
};
class QuerySnapshotCallbackAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  QuerySnapshotCallbackAuthRequest() {}

  explicit QuerySnapshotCallbackAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~QuerySnapshotCallbackAuthRequest() = default;
};
class QuerySnapshotCallbackAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> callbackAuthKey{};
  shared_ptr<string> callbackReqAuth{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  QuerySnapshotCallbackAuthResponseBody() {}

  explicit QuerySnapshotCallbackAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackAuthKey) {
      res["CallbackAuthKey"] = boost::any(*callbackAuthKey);
    }
    if (callbackReqAuth) {
      res["CallbackReqAuth"] = boost::any(*callbackReqAuth);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackAuthKey") != m.end() && !m["CallbackAuthKey"].empty()) {
      callbackAuthKey = make_shared<string>(boost::any_cast<string>(m["CallbackAuthKey"]));
    }
    if (m.find("CallbackReqAuth") != m.end() && !m["CallbackReqAuth"].empty()) {
      callbackReqAuth = make_shared<string>(boost::any_cast<string>(m["CallbackReqAuth"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySnapshotCallbackAuthResponseBody() = default;
};
class QuerySnapshotCallbackAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySnapshotCallbackAuthResponseBody> body{};

  QuerySnapshotCallbackAuthResponse() {}

  explicit QuerySnapshotCallbackAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySnapshotCallbackAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySnapshotCallbackAuthResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySnapshotCallbackAuthResponse() = default;
};
class RealTimeRecordCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> command{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  RealTimeRecordCommandRequest() {}

  explicit RealTimeRecordCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~RealTimeRecordCommandRequest() = default;
};
class RealTimeRecordCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RealTimeRecordCommandResponseBody() {}

  explicit RealTimeRecordCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RealTimeRecordCommandResponseBody() = default;
};
class RealTimeRecordCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RealTimeRecordCommandResponseBody> body{};

  RealTimeRecordCommandResponse() {}

  explicit RealTimeRecordCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RealTimeRecordCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RealTimeRecordCommandResponseBody>(model1);
      }
    }
  }


  virtual ~RealTimeRecordCommandResponse() = default;
};
class RecoverLiveMessageDeletedGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};

  RecoverLiveMessageDeletedGroupRequest() {}

  explicit RecoverLiveMessageDeletedGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~RecoverLiveMessageDeletedGroupRequest() = default;
};
class RecoverLiveMessageDeletedGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};

  RecoverLiveMessageDeletedGroupResponseBody() {}

  explicit RecoverLiveMessageDeletedGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RecoverLiveMessageDeletedGroupResponseBody() = default;
};
class RecoverLiveMessageDeletedGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecoverLiveMessageDeletedGroupResponseBody> body{};

  RecoverLiveMessageDeletedGroupResponse() {}

  explicit RecoverLiveMessageDeletedGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecoverLiveMessageDeletedGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecoverLiveMessageDeletedGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RecoverLiveMessageDeletedGroupResponse() = default;
};
class RemoveLiveMessageGroupBandRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<string>> unbannedUsers{};

  RemoveLiveMessageGroupBandRequest() {}

  explicit RemoveLiveMessageGroupBandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (unbannedUsers) {
      res["UnbannedUsers"] = boost::any(*unbannedUsers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UnbannedUsers") != m.end() && !m["UnbannedUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UnbannedUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UnbannedUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      unbannedUsers = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveLiveMessageGroupBandRequest() = default;
};
class RemoveLiveMessageGroupBandShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<string> unbannedUsersShrink{};

  RemoveLiveMessageGroupBandShrinkRequest() {}

  explicit RemoveLiveMessageGroupBandShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (unbannedUsersShrink) {
      res["UnbannedUsers"] = boost::any(*unbannedUsersShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("UnbannedUsers") != m.end() && !m["UnbannedUsers"].empty()) {
      unbannedUsersShrink = make_shared<string>(boost::any_cast<string>(m["UnbannedUsers"]));
    }
  }


  virtual ~RemoveLiveMessageGroupBandShrinkRequest() = default;
};
class RemoveLiveMessageGroupBandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveLiveMessageGroupBandResponseBody() {}

  explicit RemoveLiveMessageGroupBandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveLiveMessageGroupBandResponseBody() = default;
};
class RemoveLiveMessageGroupBandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveLiveMessageGroupBandResponseBody> body{};

  RemoveLiveMessageGroupBandResponse() {}

  explicit RemoveLiveMessageGroupBandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveLiveMessageGroupBandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveLiveMessageGroupBandResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveLiveMessageGroupBandResponse() = default;
};
class RemoveShowFromShowListRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> showId{};
  shared_ptr<bool> isBatchMode{};
  shared_ptr<vector<string>> showIdList{};

  RemoveShowFromShowListRequest() {}

  explicit RemoveShowFromShowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (isBatchMode) {
      res["isBatchMode"] = boost::any(*isBatchMode);
    }
    if (showIdList) {
      res["showIdList"] = boost::any(*showIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("isBatchMode") != m.end() && !m["isBatchMode"].empty()) {
      isBatchMode = make_shared<bool>(boost::any_cast<bool>(m["isBatchMode"]));
    }
    if (m.find("showIdList") != m.end() && !m["showIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["showIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["showIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      showIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveShowFromShowListRequest() = default;
};
class RemoveShowFromShowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> showId{};
  shared_ptr<string> failedList{};
  shared_ptr<string> successfulShowIds{};

  RemoveShowFromShowListResponseBody() {}

  explicit RemoveShowFromShowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (showId) {
      res["ShowId"] = boost::any(*showId);
    }
    if (failedList) {
      res["failedList"] = boost::any(*failedList);
    }
    if (successfulShowIds) {
      res["successfulShowIds"] = boost::any(*successfulShowIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShowId") != m.end() && !m["ShowId"].empty()) {
      showId = make_shared<string>(boost::any_cast<string>(m["ShowId"]));
    }
    if (m.find("failedList") != m.end() && !m["failedList"].empty()) {
      failedList = make_shared<string>(boost::any_cast<string>(m["failedList"]));
    }
    if (m.find("successfulShowIds") != m.end() && !m["successfulShowIds"].empty()) {
      successfulShowIds = make_shared<string>(boost::any_cast<string>(m["successfulShowIds"]));
    }
  }


  virtual ~RemoveShowFromShowListResponseBody() = default;
};
class RemoveShowFromShowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveShowFromShowListResponseBody> body{};

  RemoveShowFromShowListResponse() {}

  explicit RemoveShowFromShowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveShowFromShowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveShowFromShowListResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveShowFromShowListResponse() = default;
};
class RemoveTerminalsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<vector<string>> terminalIds{};

  RemoveTerminalsRequest() {}

  explicit RemoveTerminalsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (terminalIds) {
      res["TerminalIds"] = boost::any(*terminalIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("TerminalIds") != m.end() && !m["TerminalIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TerminalIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TerminalIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      terminalIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveTerminalsRequest() = default;
};
class RemoveTerminalsResponseBodyTerminals : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};

  RemoveTerminalsResponseBodyTerminals() {}

  explicit RemoveTerminalsResponseBodyTerminals(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~RemoveTerminalsResponseBodyTerminals() = default;
};
class RemoveTerminalsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<RemoveTerminalsResponseBodyTerminals>> terminals{};

  RemoveTerminalsResponseBody() {}

  explicit RemoveTerminalsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (terminals) {
      vector<boost::any> temp1;
      for(auto item1:*terminals){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Terminals"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Terminals") != m.end() && !m["Terminals"].empty()) {
      if (typeid(vector<boost::any>) == m["Terminals"].type()) {
        vector<RemoveTerminalsResponseBodyTerminals> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Terminals"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveTerminalsResponseBodyTerminals model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        terminals = make_shared<vector<RemoveTerminalsResponseBodyTerminals>>(expect1);
      }
    }
  }


  virtual ~RemoveTerminalsResponseBody() = default;
};
class RemoveTerminalsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveTerminalsResponseBody> body{};

  RemoveTerminalsResponse() {}

  explicit RemoveTerminalsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveTerminalsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveTerminalsResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveTerminalsResponse() = default;
};
class RestartCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  RestartCasterRequest() {}

  explicit RestartCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RestartCasterRequest() = default;
};
class RestartCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RestartCasterResponseBody() {}

  explicit RestartCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestartCasterResponseBody() = default;
};
class RestartCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartCasterResponseBody> body{};

  RestartCasterResponse() {}

  explicit RestartCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartCasterResponseBody>(model1);
      }
    }
  }


  virtual ~RestartCasterResponse() = default;
};
class RestartLivePullToPushRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  RestartLivePullToPushRequest() {}

  explicit RestartLivePullToPushRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~RestartLivePullToPushRequest() = default;
};
class RestartLivePullToPushResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  RestartLivePullToPushResponseBody() {}

  explicit RestartLivePullToPushResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~RestartLivePullToPushResponseBody() = default;
};
class RestartLivePullToPushResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartLivePullToPushResponseBody> body{};

  RestartLivePullToPushResponse() {}

  explicit RestartLivePullToPushResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartLivePullToPushResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartLivePullToPushResponseBody>(model1);
      }
    }
  }


  virtual ~RestartLivePullToPushResponse() = default;
};
class RestartTranscodeTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> streamName{};
  shared_ptr<string> transcodingTemplate{};

  RestartTranscodeTaskRequest() {}

  explicit RestartTranscodeTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transcodingTemplate) {
      res["TranscodingTemplate"] = boost::any(*transcodingTemplate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TranscodingTemplate") != m.end() && !m["TranscodingTemplate"].empty()) {
      transcodingTemplate = make_shared<string>(boost::any_cast<string>(m["TranscodingTemplate"]));
    }
  }


  virtual ~RestartTranscodeTaskRequest() = default;
};
class RestartTranscodeTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RestartTranscodeTaskResponseBody() {}

  explicit RestartTranscodeTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestartTranscodeTaskResponseBody() = default;
};
class RestartTranscodeTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartTranscodeTaskResponseBody> body{};

  RestartTranscodeTaskResponse() {}

  explicit RestartTranscodeTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartTranscodeTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartTranscodeTaskResponseBody>(model1);
      }
    }
  }


  virtual ~RestartTranscodeTaskResponse() = default;
};
class ResumeLiveStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveStreamType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> streamName{};

  ResumeLiveStreamRequest() {}

  explicit ResumeLiveStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveStreamType) {
      res["LiveStreamType"] = boost::any(*liveStreamType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveStreamType") != m.end() && !m["LiveStreamType"].empty()) {
      liveStreamType = make_shared<string>(boost::any_cast<string>(m["LiveStreamType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~ResumeLiveStreamRequest() = default;
};
class ResumeLiveStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResumeLiveStreamResponseBody() {}

  explicit ResumeLiveStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumeLiveStreamResponseBody() = default;
};
class ResumeLiveStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeLiveStreamResponseBody> body{};

  ResumeLiveStreamResponse() {}

  explicit ResumeLiveStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeLiveStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeLiveStreamResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeLiveStreamResponse() = default;
};
class RollbackLiveStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  RollbackLiveStagingConfigRequest() {}

  explicit RollbackLiveStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RollbackLiveStagingConfigRequest() = default;
};
class RollbackLiveStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackLiveStagingConfigResponseBody() {}

  explicit RollbackLiveStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackLiveStagingConfigResponseBody() = default;
};
class RollbackLiveStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackLiveStagingConfigResponseBody> body{};

  RollbackLiveStagingConfigResponse() {}

  explicit RollbackLiveStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackLiveStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackLiveStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackLiveStagingConfigResponse() = default;
};
class SendLikeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> broadCastType{};
  shared_ptr<string> count{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};

  SendLikeRequest() {}

  explicit SendLikeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (broadCastType) {
      res["BroadCastType"] = boost::any(*broadCastType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BroadCastType") != m.end() && !m["BroadCastType"].empty()) {
      broadCastType = make_shared<long>(boost::any_cast<long>(m["BroadCastType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
  }


  virtual ~SendLikeRequest() = default;
};
class SendLikeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> likeCount{};

  SendLikeResponseBodyResult() {}

  explicit SendLikeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (likeCount) {
      res["LikeCount"] = boost::any(*likeCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LikeCount") != m.end() && !m["LikeCount"].empty()) {
      likeCount = make_shared<long>(boost::any_cast<long>(m["LikeCount"]));
    }
  }


  virtual ~SendLikeResponseBodyResult() = default;
};
class SendLikeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SendLikeResponseBodyResult> result{};

  SendLikeResponseBody() {}

  explicit SendLikeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SendLikeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SendLikeResponseBodyResult>(model1);
      }
    }
  }


  virtual ~SendLikeResponseBody() = default;
};
class SendLikeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendLikeResponseBody> body{};

  SendLikeResponse() {}

  explicit SendLikeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendLikeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendLikeResponseBody>(model1);
      }
    }
  }


  virtual ~SendLikeResponse() = default;
};
class SendLiveMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> body{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};
  shared_ptr<string> msgTid{};
  shared_ptr<long> msgType{};
  shared_ptr<bool> noCache{};
  shared_ptr<bool> noStorage{};
  shared_ptr<string> senderId{};
  shared_ptr<string> senderMetaInfo{};
  shared_ptr<long> staticsIncrease{};
  shared_ptr<long> weight{};

  SendLiveMessageGroupRequest() {}

  explicit SendLiveMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (msgTid) {
      res["MsgTid"] = boost::any(*msgTid);
    }
    if (msgType) {
      res["MsgType"] = boost::any(*msgType);
    }
    if (noCache) {
      res["NoCache"] = boost::any(*noCache);
    }
    if (noStorage) {
      res["NoStorage"] = boost::any(*noStorage);
    }
    if (senderId) {
      res["SenderId"] = boost::any(*senderId);
    }
    if (senderMetaInfo) {
      res["SenderMetaInfo"] = boost::any(*senderMetaInfo);
    }
    if (staticsIncrease) {
      res["StaticsIncrease"] = boost::any(*staticsIncrease);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MsgTid") != m.end() && !m["MsgTid"].empty()) {
      msgTid = make_shared<string>(boost::any_cast<string>(m["MsgTid"]));
    }
    if (m.find("MsgType") != m.end() && !m["MsgType"].empty()) {
      msgType = make_shared<long>(boost::any_cast<long>(m["MsgType"]));
    }
    if (m.find("NoCache") != m.end() && !m["NoCache"].empty()) {
      noCache = make_shared<bool>(boost::any_cast<bool>(m["NoCache"]));
    }
    if (m.find("NoStorage") != m.end() && !m["NoStorage"].empty()) {
      noStorage = make_shared<bool>(boost::any_cast<bool>(m["NoStorage"]));
    }
    if (m.find("SenderId") != m.end() && !m["SenderId"].empty()) {
      senderId = make_shared<string>(boost::any_cast<string>(m["SenderId"]));
    }
    if (m.find("SenderMetaInfo") != m.end() && !m["SenderMetaInfo"].empty()) {
      senderMetaInfo = make_shared<string>(boost::any_cast<string>(m["SenderMetaInfo"]));
    }
    if (m.find("StaticsIncrease") != m.end() && !m["StaticsIncrease"].empty()) {
      staticsIncrease = make_shared<long>(boost::any_cast<long>(m["StaticsIncrease"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~SendLiveMessageGroupRequest() = default;
};
class SendLiveMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> msgTid{};
  shared_ptr<string> requestId{};

  SendLiveMessageGroupResponseBody() {}

  explicit SendLiveMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (msgTid) {
      res["MsgTid"] = boost::any(*msgTid);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MsgTid") != m.end() && !m["MsgTid"].empty()) {
      msgTid = make_shared<string>(boost::any_cast<string>(m["MsgTid"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendLiveMessageGroupResponseBody() = default;
};
class SendLiveMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendLiveMessageGroupResponseBody> body{};

  SendLiveMessageGroupResponse() {}

  explicit SendLiveMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendLiveMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendLiveMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SendLiveMessageGroupResponse() = default;
};
class SendLiveMessageUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> body{};
  shared_ptr<string> dataCenter{};
  shared_ptr<bool> highReliability{};
  shared_ptr<string> msgTid{};
  shared_ptr<long> msgType{};
  shared_ptr<string> receiverId{};
  shared_ptr<string> senderId{};
  shared_ptr<string> senderInfo{};
  shared_ptr<bool> storage{};

  SendLiveMessageUserRequest() {}

  explicit SendLiveMessageUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (highReliability) {
      res["HighReliability"] = boost::any(*highReliability);
    }
    if (msgTid) {
      res["MsgTid"] = boost::any(*msgTid);
    }
    if (msgType) {
      res["MsgType"] = boost::any(*msgType);
    }
    if (receiverId) {
      res["ReceiverId"] = boost::any(*receiverId);
    }
    if (senderId) {
      res["SenderId"] = boost::any(*senderId);
    }
    if (senderInfo) {
      res["SenderInfo"] = boost::any(*senderInfo);
    }
    if (storage) {
      res["Storage"] = boost::any(*storage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("HighReliability") != m.end() && !m["HighReliability"].empty()) {
      highReliability = make_shared<bool>(boost::any_cast<bool>(m["HighReliability"]));
    }
    if (m.find("MsgTid") != m.end() && !m["MsgTid"].empty()) {
      msgTid = make_shared<string>(boost::any_cast<string>(m["MsgTid"]));
    }
    if (m.find("MsgType") != m.end() && !m["MsgType"].empty()) {
      msgType = make_shared<long>(boost::any_cast<long>(m["MsgType"]));
    }
    if (m.find("ReceiverId") != m.end() && !m["ReceiverId"].empty()) {
      receiverId = make_shared<string>(boost::any_cast<string>(m["ReceiverId"]));
    }
    if (m.find("SenderId") != m.end() && !m["SenderId"].empty()) {
      senderId = make_shared<string>(boost::any_cast<string>(m["SenderId"]));
    }
    if (m.find("SenderInfo") != m.end() && !m["SenderInfo"].empty()) {
      senderInfo = make_shared<string>(boost::any_cast<string>(m["SenderInfo"]));
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      storage = make_shared<bool>(boost::any_cast<bool>(m["Storage"]));
    }
  }


  virtual ~SendLiveMessageUserRequest() = default;
};
class SendLiveMessageUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> msgTid{};
  shared_ptr<string> requestId{};

  SendLiveMessageUserResponseBody() {}

  explicit SendLiveMessageUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (msgTid) {
      res["MsgTid"] = boost::any(*msgTid);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MsgTid") != m.end() && !m["MsgTid"].empty()) {
      msgTid = make_shared<string>(boost::any_cast<string>(m["MsgTid"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendLiveMessageUserResponseBody() = default;
};
class SendLiveMessageUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendLiveMessageUserResponseBody> body{};

  SendLiveMessageUserResponse() {}

  explicit SendLiveMessageUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendLiveMessageUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendLiveMessageUserResponseBody>(model1);
      }
    }
  }


  virtual ~SendLiveMessageUserResponse() = default;
};
class SendMessageToGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> data{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};
  shared_ptr<bool> skipAudit{};
  shared_ptr<long> type{};

  SendMessageToGroupRequest() {}

  explicit SendMessageToGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    if (skipAudit) {
      res["SkipAudit"] = boost::any(*skipAudit);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
    if (m.find("SkipAudit") != m.end() && !m["SkipAudit"].empty()) {
      skipAudit = make_shared<bool>(boost::any_cast<bool>(m["SkipAudit"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SendMessageToGroupRequest() = default;
};
class SendMessageToGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};

  SendMessageToGroupResponseBodyResult() {}

  explicit SendMessageToGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SendMessageToGroupResponseBodyResult() = default;
};
class SendMessageToGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SendMessageToGroupResponseBodyResult> result{};

  SendMessageToGroupResponseBody() {}

  explicit SendMessageToGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SendMessageToGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SendMessageToGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~SendMessageToGroupResponseBody() = default;
};
class SendMessageToGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendMessageToGroupResponseBody> body{};

  SendMessageToGroupResponse() {}

  explicit SendMessageToGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendMessageToGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendMessageToGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SendMessageToGroupResponse() = default;
};
class SendMessageToGroupUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> data{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};
  shared_ptr<vector<string>> receiverIdList{};
  shared_ptr<bool> skipAudit{};
  shared_ptr<long> type{};

  SendMessageToGroupUsersRequest() {}

  explicit SendMessageToGroupUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    if (receiverIdList) {
      res["ReceiverIdList"] = boost::any(*receiverIdList);
    }
    if (skipAudit) {
      res["SkipAudit"] = boost::any(*skipAudit);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
    if (m.find("ReceiverIdList") != m.end() && !m["ReceiverIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReceiverIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReceiverIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkipAudit") != m.end() && !m["SkipAudit"].empty()) {
      skipAudit = make_shared<bool>(boost::any_cast<bool>(m["SkipAudit"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SendMessageToGroupUsersRequest() = default;
};
class SendMessageToGroupUsersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> data{};
  shared_ptr<string> groupId{};
  shared_ptr<string> operatorUserId{};
  shared_ptr<string> receiverIdListShrink{};
  shared_ptr<bool> skipAudit{};
  shared_ptr<long> type{};

  SendMessageToGroupUsersShrinkRequest() {}

  explicit SendMessageToGroupUsersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    if (receiverIdListShrink) {
      res["ReceiverIdList"] = boost::any(*receiverIdListShrink);
    }
    if (skipAudit) {
      res["SkipAudit"] = boost::any(*skipAudit);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
    if (m.find("ReceiverIdList") != m.end() && !m["ReceiverIdList"].empty()) {
      receiverIdListShrink = make_shared<string>(boost::any_cast<string>(m["ReceiverIdList"]));
    }
    if (m.find("SkipAudit") != m.end() && !m["SkipAudit"].empty()) {
      skipAudit = make_shared<bool>(boost::any_cast<bool>(m["SkipAudit"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SendMessageToGroupUsersShrinkRequest() = default;
};
class SendMessageToGroupUsersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> messageId{};

  SendMessageToGroupUsersResponseBodyResult() {}

  explicit SendMessageToGroupUsersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SendMessageToGroupUsersResponseBodyResult() = default;
};
class SendMessageToGroupUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SendMessageToGroupUsersResponseBodyResult> result{};

  SendMessageToGroupUsersResponseBody() {}

  explicit SendMessageToGroupUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SendMessageToGroupUsersResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SendMessageToGroupUsersResponseBodyResult>(model1);
      }
    }
  }


  virtual ~SendMessageToGroupUsersResponseBody() = default;
};
class SendMessageToGroupUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendMessageToGroupUsersResponseBody> body{};

  SendMessageToGroupUsersResponse() {}

  explicit SendMessageToGroupUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendMessageToGroupUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendMessageToGroupUsersResponseBody>(model1);
      }
    }
  }


  virtual ~SendMessageToGroupUsersResponse() = default;
};
class SetCasterChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> faceBeauty{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> playStatus{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<long> seekOffset{};

  SetCasterChannelRequest() {}

  explicit SetCasterChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (faceBeauty) {
      res["FaceBeauty"] = boost::any(*faceBeauty);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (playStatus) {
      res["PlayStatus"] = boost::any(*playStatus);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (seekOffset) {
      res["SeekOffset"] = boost::any(*seekOffset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("FaceBeauty") != m.end() && !m["FaceBeauty"].empty()) {
      faceBeauty = make_shared<string>(boost::any_cast<string>(m["FaceBeauty"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PlayStatus") != m.end() && !m["PlayStatus"].empty()) {
      playStatus = make_shared<long>(boost::any_cast<long>(m["PlayStatus"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("SeekOffset") != m.end() && !m["SeekOffset"].empty()) {
      seekOffset = make_shared<long>(boost::any_cast<long>(m["SeekOffset"]));
    }
  }


  virtual ~SetCasterChannelRequest() = default;
};
class SetCasterChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetCasterChannelResponseBody() {}

  explicit SetCasterChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCasterChannelResponseBody() = default;
};
class SetCasterChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCasterChannelResponseBody> body{};

  SetCasterChannelResponse() {}

  explicit SetCasterChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCasterChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCasterChannelResponseBody>(model1);
      }
    }
  }


  virtual ~SetCasterChannelResponse() = default;
};
class SetCasterConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> autoSwitchUrgentConfig{};
  shared_ptr<bool> autoSwitchUrgentOn{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> casterId{};
  shared_ptr<string> casterName{};
  shared_ptr<long> channelEnable{};
  shared_ptr<double> delay{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> programEffect{};
  shared_ptr<string> programName{};
  shared_ptr<string> recordConfig{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sideOutputUrl{};
  shared_ptr<string> sideOutputUrlList{};
  shared_ptr<string> syncGroupsConfig{};
  shared_ptr<string> transcodeConfig{};
  shared_ptr<string> urgentImageId{};
  shared_ptr<string> urgentImageUrl{};
  shared_ptr<string> urgentLiveStreamUrl{};
  shared_ptr<string> urgentMaterialId{};

  SetCasterConfigRequest() {}

  explicit SetCasterConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoSwitchUrgentConfig) {
      res["AutoSwitchUrgentConfig"] = boost::any(*autoSwitchUrgentConfig);
    }
    if (autoSwitchUrgentOn) {
      res["AutoSwitchUrgentOn"] = boost::any(*autoSwitchUrgentOn);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (casterName) {
      res["CasterName"] = boost::any(*casterName);
    }
    if (channelEnable) {
      res["ChannelEnable"] = boost::any(*channelEnable);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programEffect) {
      res["ProgramEffect"] = boost::any(*programEffect);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (recordConfig) {
      res["RecordConfig"] = boost::any(*recordConfig);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sideOutputUrl) {
      res["SideOutputUrl"] = boost::any(*sideOutputUrl);
    }
    if (sideOutputUrlList) {
      res["SideOutputUrlList"] = boost::any(*sideOutputUrlList);
    }
    if (syncGroupsConfig) {
      res["SyncGroupsConfig"] = boost::any(*syncGroupsConfig);
    }
    if (transcodeConfig) {
      res["TranscodeConfig"] = boost::any(*transcodeConfig);
    }
    if (urgentImageId) {
      res["UrgentImageId"] = boost::any(*urgentImageId);
    }
    if (urgentImageUrl) {
      res["UrgentImageUrl"] = boost::any(*urgentImageUrl);
    }
    if (urgentLiveStreamUrl) {
      res["UrgentLiveStreamUrl"] = boost::any(*urgentLiveStreamUrl);
    }
    if (urgentMaterialId) {
      res["UrgentMaterialId"] = boost::any(*urgentMaterialId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoSwitchUrgentConfig") != m.end() && !m["AutoSwitchUrgentConfig"].empty()) {
      autoSwitchUrgentConfig = make_shared<string>(boost::any_cast<string>(m["AutoSwitchUrgentConfig"]));
    }
    if (m.find("AutoSwitchUrgentOn") != m.end() && !m["AutoSwitchUrgentOn"].empty()) {
      autoSwitchUrgentOn = make_shared<bool>(boost::any_cast<bool>(m["AutoSwitchUrgentOn"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("CasterName") != m.end() && !m["CasterName"].empty()) {
      casterName = make_shared<string>(boost::any_cast<string>(m["CasterName"]));
    }
    if (m.find("ChannelEnable") != m.end() && !m["ChannelEnable"].empty()) {
      channelEnable = make_shared<long>(boost::any_cast<long>(m["ChannelEnable"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<double>(boost::any_cast<double>(m["Delay"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramEffect") != m.end() && !m["ProgramEffect"].empty()) {
      programEffect = make_shared<long>(boost::any_cast<long>(m["ProgramEffect"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("RecordConfig") != m.end() && !m["RecordConfig"].empty()) {
      recordConfig = make_shared<string>(boost::any_cast<string>(m["RecordConfig"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SideOutputUrl") != m.end() && !m["SideOutputUrl"].empty()) {
      sideOutputUrl = make_shared<string>(boost::any_cast<string>(m["SideOutputUrl"]));
    }
    if (m.find("SideOutputUrlList") != m.end() && !m["SideOutputUrlList"].empty()) {
      sideOutputUrlList = make_shared<string>(boost::any_cast<string>(m["SideOutputUrlList"]));
    }
    if (m.find("SyncGroupsConfig") != m.end() && !m["SyncGroupsConfig"].empty()) {
      syncGroupsConfig = make_shared<string>(boost::any_cast<string>(m["SyncGroupsConfig"]));
    }
    if (m.find("TranscodeConfig") != m.end() && !m["TranscodeConfig"].empty()) {
      transcodeConfig = make_shared<string>(boost::any_cast<string>(m["TranscodeConfig"]));
    }
    if (m.find("UrgentImageId") != m.end() && !m["UrgentImageId"].empty()) {
      urgentImageId = make_shared<string>(boost::any_cast<string>(m["UrgentImageId"]));
    }
    if (m.find("UrgentImageUrl") != m.end() && !m["UrgentImageUrl"].empty()) {
      urgentImageUrl = make_shared<string>(boost::any_cast<string>(m["UrgentImageUrl"]));
    }
    if (m.find("UrgentLiveStreamUrl") != m.end() && !m["UrgentLiveStreamUrl"].empty()) {
      urgentLiveStreamUrl = make_shared<string>(boost::any_cast<string>(m["UrgentLiveStreamUrl"]));
    }
    if (m.find("UrgentMaterialId") != m.end() && !m["UrgentMaterialId"].empty()) {
      urgentMaterialId = make_shared<string>(boost::any_cast<string>(m["UrgentMaterialId"]));
    }
  }


  virtual ~SetCasterConfigRequest() = default;
};
class SetCasterConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> requestId{};

  SetCasterConfigResponseBody() {}

  explicit SetCasterConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCasterConfigResponseBody() = default;
};
class SetCasterConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCasterConfigResponseBody> body{};

  SetCasterConfigResponse() {}

  explicit SetCasterConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCasterConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCasterConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetCasterConfigResponse() = default;
};
class SetCasterSceneConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sceneId{};

  SetCasterSceneConfigRequest() {}

  explicit SetCasterSceneConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~SetCasterSceneConfigRequest() = default;
};
class SetCasterSceneConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetCasterSceneConfigResponseBody() {}

  explicit SetCasterSceneConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCasterSceneConfigResponseBody() = default;
};
class SetCasterSceneConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCasterSceneConfigResponseBody> body{};

  SetCasterSceneConfigResponse() {}

  explicit SetCasterSceneConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCasterSceneConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCasterSceneConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetCasterSceneConfigResponse() = default;
};
class SetLiveDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> forceSet{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> SSLPri{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> securityToken{};

  SetLiveDomainCertificateRequest() {}

  explicit SetLiveDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (forceSet) {
      res["ForceSet"] = boost::any(*forceSet);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (SSLPri) {
      res["SSLPri"] = boost::any(*SSLPri);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ForceSet") != m.end() && !m["ForceSet"].empty()) {
      forceSet = make_shared<string>(boost::any_cast<string>(m["ForceSet"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SSLPri") != m.end() && !m["SSLPri"].empty()) {
      SSLPri = make_shared<string>(boost::any_cast<string>(m["SSLPri"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetLiveDomainCertificateRequest() = default;
};
class SetLiveDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveDomainCertificateResponseBody() {}

  explicit SetLiveDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveDomainCertificateResponseBody() = default;
};
class SetLiveDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveDomainCertificateResponseBody> body{};

  SetLiveDomainCertificateResponse() {}

  explicit SetLiveDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveDomainCertificateResponse() = default;
};
class SetLiveDomainMultiStreamConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> switch_{};

  SetLiveDomainMultiStreamConfigRequest() {}

  explicit SetLiveDomainMultiStreamConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (switch_) {
      res["Switch"] = boost::any(*switch_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Switch") != m.end() && !m["Switch"].empty()) {
      switch_ = make_shared<string>(boost::any_cast<string>(m["Switch"]));
    }
  }


  virtual ~SetLiveDomainMultiStreamConfigRequest() = default;
};
class SetLiveDomainMultiStreamConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveDomainMultiStreamConfigResponseBody() {}

  explicit SetLiveDomainMultiStreamConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveDomainMultiStreamConfigResponseBody() = default;
};
class SetLiveDomainMultiStreamConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveDomainMultiStreamConfigResponseBody> body{};

  SetLiveDomainMultiStreamConfigResponse() {}

  explicit SetLiveDomainMultiStreamConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveDomainMultiStreamConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveDomainMultiStreamConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveDomainMultiStreamConfigResponse() = default;
};
class SetLiveDomainMultiStreamMasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};
  shared_ptr<string> upstreamSequence{};

  SetLiveDomainMultiStreamMasterRequest() {}

  explicit SetLiveDomainMultiStreamMasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (upstreamSequence) {
      res["UpstreamSequence"] = boost::any(*upstreamSequence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("UpstreamSequence") != m.end() && !m["UpstreamSequence"].empty()) {
      upstreamSequence = make_shared<string>(boost::any_cast<string>(m["UpstreamSequence"]));
    }
  }


  virtual ~SetLiveDomainMultiStreamMasterRequest() = default;
};
class SetLiveDomainMultiStreamMasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveDomainMultiStreamMasterResponseBody() {}

  explicit SetLiveDomainMultiStreamMasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveDomainMultiStreamMasterResponseBody() = default;
};
class SetLiveDomainMultiStreamMasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveDomainMultiStreamMasterResponseBody> body{};

  SetLiveDomainMultiStreamMasterResponse() {}

  explicit SetLiveDomainMultiStreamMasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveDomainMultiStreamMasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveDomainMultiStreamMasterResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveDomainMultiStreamMasterResponse() = default;
};
class SetLiveDomainMultiStreamOptimalModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domain{};
  shared_ptr<string> optimalMode{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  SetLiveDomainMultiStreamOptimalModeRequest() {}

  explicit SetLiveDomainMultiStreamOptimalModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (optimalMode) {
      res["OptimalMode"] = boost::any(*optimalMode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OptimalMode") != m.end() && !m["OptimalMode"].empty()) {
      optimalMode = make_shared<string>(boost::any_cast<string>(m["OptimalMode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~SetLiveDomainMultiStreamOptimalModeRequest() = default;
};
class SetLiveDomainMultiStreamOptimalModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveDomainMultiStreamOptimalModeResponseBody() {}

  explicit SetLiveDomainMultiStreamOptimalModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveDomainMultiStreamOptimalModeResponseBody() = default;
};
class SetLiveDomainMultiStreamOptimalModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveDomainMultiStreamOptimalModeResponseBody> body{};

  SetLiveDomainMultiStreamOptimalModeResponse() {}

  explicit SetLiveDomainMultiStreamOptimalModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveDomainMultiStreamOptimalModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveDomainMultiStreamOptimalModeResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveDomainMultiStreamOptimalModeResponse() = default;
};
class SetLiveDomainStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functions{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  SetLiveDomainStagingConfigRequest() {}

  explicit SetLiveDomainStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetLiveDomainStagingConfigRequest() = default;
};
class SetLiveDomainStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveDomainStagingConfigResponseBody() {}

  explicit SetLiveDomainStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveDomainStagingConfigResponseBody() = default;
};
class SetLiveDomainStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveDomainStagingConfigResponseBody> body{};

  SetLiveDomainStagingConfigResponse() {}

  explicit SetLiveDomainStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveDomainStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveDomainStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveDomainStagingConfigResponse() = default;
};
class SetLiveEdgeTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> httpDns{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};
  shared_ptr<string> targetDomainList{};
  shared_ptr<string> transferArgs{};

  SetLiveEdgeTransferRequest() {}

  explicit SetLiveEdgeTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (httpDns) {
      res["HttpDns"] = boost::any(*httpDns);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (targetDomainList) {
      res["TargetDomainList"] = boost::any(*targetDomainList);
    }
    if (transferArgs) {
      res["TransferArgs"] = boost::any(*transferArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("HttpDns") != m.end() && !m["HttpDns"].empty()) {
      httpDns = make_shared<string>(boost::any_cast<string>(m["HttpDns"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TargetDomainList") != m.end() && !m["TargetDomainList"].empty()) {
      targetDomainList = make_shared<string>(boost::any_cast<string>(m["TargetDomainList"]));
    }
    if (m.find("TransferArgs") != m.end() && !m["TransferArgs"].empty()) {
      transferArgs = make_shared<string>(boost::any_cast<string>(m["TransferArgs"]));
    }
  }


  virtual ~SetLiveEdgeTransferRequest() = default;
};
class SetLiveEdgeTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveEdgeTransferResponseBody() {}

  explicit SetLiveEdgeTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveEdgeTransferResponseBody() = default;
};
class SetLiveEdgeTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveEdgeTransferResponseBody> body{};

  SetLiveEdgeTransferResponse() {}

  explicit SetLiveEdgeTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveEdgeTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveEdgeTransferResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveEdgeTransferResponse() = default;
};
class SetLiveLazyPullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pullAppName{};
  shared_ptr<string> pullDomainName{};
  shared_ptr<string> pullProtocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> transcodeLazy{};

  SetLiveLazyPullStreamInfoConfigRequest() {}

  explicit SetLiveLazyPullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pullAppName) {
      res["PullAppName"] = boost::any(*pullAppName);
    }
    if (pullDomainName) {
      res["PullDomainName"] = boost::any(*pullDomainName);
    }
    if (pullProtocol) {
      res["PullProtocol"] = boost::any(*pullProtocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (transcodeLazy) {
      res["TranscodeLazy"] = boost::any(*transcodeLazy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PullAppName") != m.end() && !m["PullAppName"].empty()) {
      pullAppName = make_shared<string>(boost::any_cast<string>(m["PullAppName"]));
    }
    if (m.find("PullDomainName") != m.end() && !m["PullDomainName"].empty()) {
      pullDomainName = make_shared<string>(boost::any_cast<string>(m["PullDomainName"]));
    }
    if (m.find("PullProtocol") != m.end() && !m["PullProtocol"].empty()) {
      pullProtocol = make_shared<string>(boost::any_cast<string>(m["PullProtocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TranscodeLazy") != m.end() && !m["TranscodeLazy"].empty()) {
      transcodeLazy = make_shared<string>(boost::any_cast<string>(m["TranscodeLazy"]));
    }
  }


  virtual ~SetLiveLazyPullStreamInfoConfigRequest() = default;
};
class SetLiveLazyPullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveLazyPullStreamInfoConfigResponseBody() {}

  explicit SetLiveLazyPullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveLazyPullStreamInfoConfigResponseBody() = default;
};
class SetLiveLazyPullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveLazyPullStreamInfoConfigResponseBody> body{};

  SetLiveLazyPullStreamInfoConfigResponse() {}

  explicit SetLiveLazyPullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveLazyPullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveLazyPullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveLazyPullStreamInfoConfigResponse() = default;
};
class SetLiveMpuTaskSeiRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> customSei{};
  shared_ptr<string> taskId{};

  SetLiveMpuTaskSeiRequest() {}

  explicit SetLiveMpuTaskSeiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (customSei) {
      res["CustomSei"] = boost::any(*customSei);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CustomSei") != m.end() && !m["CustomSei"].empty()) {
      customSei = make_shared<string>(boost::any_cast<string>(m["CustomSei"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SetLiveMpuTaskSeiRequest() = default;
};
class SetLiveMpuTaskSeiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveMpuTaskSeiResponseBody() {}

  explicit SetLiveMpuTaskSeiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveMpuTaskSeiResponseBody() = default;
};
class SetLiveMpuTaskSeiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveMpuTaskSeiResponseBody> body{};

  SetLiveMpuTaskSeiResponse() {}

  explicit SetLiveMpuTaskSeiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveMpuTaskSeiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveMpuTaskSeiResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveMpuTaskSeiResponse() = default;
};
class SetLiveStreamBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> blockType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> locationList{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> releaseTime{};
  shared_ptr<string> streamName{};

  SetLiveStreamBlockRequest() {}

  explicit SetLiveStreamBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (locationList) {
      res["LocationList"] = boost::any(*locationList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<string>(boost::any_cast<string>(m["BlockType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LocationList") != m.end() && !m["LocationList"].empty()) {
      locationList = make_shared<string>(boost::any_cast<string>(m["LocationList"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<string>(boost::any_cast<string>(m["ReleaseTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~SetLiveStreamBlockRequest() = default;
};
class SetLiveStreamBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  SetLiveStreamBlockResponseBody() {}

  explicit SetLiveStreamBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SetLiveStreamBlockResponseBody() = default;
};
class SetLiveStreamBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveStreamBlockResponseBody> body{};

  SetLiveStreamBlockResponse() {}

  explicit SetLiveStreamBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveStreamBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveStreamBlockResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveStreamBlockResponse() = default;
};
class SetLiveStreamDelayConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> flvDelay{};
  shared_ptr<string> flvLevel{};
  shared_ptr<long> hlsDelay{};
  shared_ptr<string> hlsLevel{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> rtmpDelay{};
  shared_ptr<string> rtmpLevel{};

  SetLiveStreamDelayConfigRequest() {}

  explicit SetLiveStreamDelayConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (flvDelay) {
      res["FlvDelay"] = boost::any(*flvDelay);
    }
    if (flvLevel) {
      res["FlvLevel"] = boost::any(*flvLevel);
    }
    if (hlsDelay) {
      res["HlsDelay"] = boost::any(*hlsDelay);
    }
    if (hlsLevel) {
      res["HlsLevel"] = boost::any(*hlsLevel);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rtmpDelay) {
      res["RtmpDelay"] = boost::any(*rtmpDelay);
    }
    if (rtmpLevel) {
      res["RtmpLevel"] = boost::any(*rtmpLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FlvDelay") != m.end() && !m["FlvDelay"].empty()) {
      flvDelay = make_shared<long>(boost::any_cast<long>(m["FlvDelay"]));
    }
    if (m.find("FlvLevel") != m.end() && !m["FlvLevel"].empty()) {
      flvLevel = make_shared<string>(boost::any_cast<string>(m["FlvLevel"]));
    }
    if (m.find("HlsDelay") != m.end() && !m["HlsDelay"].empty()) {
      hlsDelay = make_shared<long>(boost::any_cast<long>(m["HlsDelay"]));
    }
    if (m.find("HlsLevel") != m.end() && !m["HlsLevel"].empty()) {
      hlsLevel = make_shared<string>(boost::any_cast<string>(m["HlsLevel"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RtmpDelay") != m.end() && !m["RtmpDelay"].empty()) {
      rtmpDelay = make_shared<long>(boost::any_cast<long>(m["RtmpDelay"]));
    }
    if (m.find("RtmpLevel") != m.end() && !m["RtmpLevel"].empty()) {
      rtmpLevel = make_shared<string>(boost::any_cast<string>(m["RtmpLevel"]));
    }
  }


  virtual ~SetLiveStreamDelayConfigRequest() = default;
};
class SetLiveStreamDelayConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveStreamDelayConfigResponseBody() {}

  explicit SetLiveStreamDelayConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveStreamDelayConfigResponseBody() = default;
};
class SetLiveStreamDelayConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveStreamDelayConfigResponseBody> body{};

  SetLiveStreamDelayConfigResponse() {}

  explicit SetLiveStreamDelayConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveStreamDelayConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveStreamDelayConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveStreamDelayConfigResponse() = default;
};
class SetLiveStreamPreloadTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> playUrl{};
  shared_ptr<string> preloadedEndTime{};
  shared_ptr<string> preloadedStartTime{};
  shared_ptr<string> regionId{};

  SetLiveStreamPreloadTasksRequest() {}

  explicit SetLiveStreamPreloadTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (playUrl) {
      res["PlayUrl"] = boost::any(*playUrl);
    }
    if (preloadedEndTime) {
      res["PreloadedEndTime"] = boost::any(*preloadedEndTime);
    }
    if (preloadedStartTime) {
      res["PreloadedStartTime"] = boost::any(*preloadedStartTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PlayUrl") != m.end() && !m["PlayUrl"].empty()) {
      playUrl = make_shared<string>(boost::any_cast<string>(m["PlayUrl"]));
    }
    if (m.find("PreloadedEndTime") != m.end() && !m["PreloadedEndTime"].empty()) {
      preloadedEndTime = make_shared<string>(boost::any_cast<string>(m["PreloadedEndTime"]));
    }
    if (m.find("PreloadedStartTime") != m.end() && !m["PreloadedStartTime"].empty()) {
      preloadedStartTime = make_shared<string>(boost::any_cast<string>(m["PreloadedStartTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetLiveStreamPreloadTasksRequest() = default;
};
class SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessagesPreloadTasksMessage : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> playUrl{};
  shared_ptr<string> taskId{};

  SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessagesPreloadTasksMessage() {}

  explicit SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessagesPreloadTasksMessage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (playUrl) {
      res["PlayUrl"] = boost::any(*playUrl);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PlayUrl") != m.end() && !m["PlayUrl"].empty()) {
      playUrl = make_shared<string>(boost::any_cast<string>(m["PlayUrl"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessagesPreloadTasksMessage() = default;
};
class SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessages : public Darabonba::Model {
public:
  shared_ptr<vector<SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessagesPreloadTasksMessage>> preloadTasksMessage{};

  SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessages() {}

  explicit SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTasksMessage) {
      vector<boost::any> temp1;
      for(auto item1:*preloadTasksMessage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PreloadTasksMessage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTasksMessage") != m.end() && !m["PreloadTasksMessage"].empty()) {
      if (typeid(vector<boost::any>) == m["PreloadTasksMessage"].type()) {
        vector<SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessagesPreloadTasksMessage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PreloadTasksMessage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessagesPreloadTasksMessage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preloadTasksMessage = make_shared<vector<SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessagesPreloadTasksMessage>>(expect1);
      }
    }
  }


  virtual ~SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessages() = default;
};
class SetLiveStreamPreloadTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> failedURL{};
  shared_ptr<SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessages> preloadTasksMessages{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<long> successURL{};
  shared_ptr<long> totalURL{};

  SetLiveStreamPreloadTasksResponseBody() {}

  explicit SetLiveStreamPreloadTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedURL) {
      res["FailedURL"] = boost::any(*failedURL);
    }
    if (preloadTasksMessages) {
      res["PreloadTasksMessages"] = preloadTasksMessages ? boost::any(preloadTasksMessages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (successURL) {
      res["SuccessURL"] = boost::any(*successURL);
    }
    if (totalURL) {
      res["TotalURL"] = boost::any(*totalURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedURL") != m.end() && !m["FailedURL"].empty()) {
      failedURL = make_shared<long>(boost::any_cast<long>(m["FailedURL"]));
    }
    if (m.find("PreloadTasksMessages") != m.end() && !m["PreloadTasksMessages"].empty()) {
      if (typeid(map<string, boost::any>) == m["PreloadTasksMessages"].type()) {
        SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PreloadTasksMessages"]));
        preloadTasksMessages = make_shared<SetLiveStreamPreloadTasksResponseBodyPreloadTasksMessages>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SuccessURL") != m.end() && !m["SuccessURL"].empty()) {
      successURL = make_shared<long>(boost::any_cast<long>(m["SuccessURL"]));
    }
    if (m.find("TotalURL") != m.end() && !m["TotalURL"].empty()) {
      totalURL = make_shared<long>(boost::any_cast<long>(m["TotalURL"]));
    }
  }


  virtual ~SetLiveStreamPreloadTasksResponseBody() = default;
};
class SetLiveStreamPreloadTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveStreamPreloadTasksResponseBody> body{};

  SetLiveStreamPreloadTasksResponse() {}

  explicit SetLiveStreamPreloadTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveStreamPreloadTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveStreamPreloadTasksResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveStreamPreloadTasksResponse() = default;
};
class SetLiveStreamsNotifyUrlConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> exceptionNotifyUrl{};
  shared_ptr<string> notifyAuthKey{};
  shared_ptr<string> notifyReqAuth{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> switchNotifyUrl{};

  SetLiveStreamsNotifyUrlConfigRequest() {}

  explicit SetLiveStreamsNotifyUrlConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (exceptionNotifyUrl) {
      res["ExceptionNotifyUrl"] = boost::any(*exceptionNotifyUrl);
    }
    if (notifyAuthKey) {
      res["NotifyAuthKey"] = boost::any(*notifyAuthKey);
    }
    if (notifyReqAuth) {
      res["NotifyReqAuth"] = boost::any(*notifyReqAuth);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (switchNotifyUrl) {
      res["SwitchNotifyUrl"] = boost::any(*switchNotifyUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ExceptionNotifyUrl") != m.end() && !m["ExceptionNotifyUrl"].empty()) {
      exceptionNotifyUrl = make_shared<string>(boost::any_cast<string>(m["ExceptionNotifyUrl"]));
    }
    if (m.find("NotifyAuthKey") != m.end() && !m["NotifyAuthKey"].empty()) {
      notifyAuthKey = make_shared<string>(boost::any_cast<string>(m["NotifyAuthKey"]));
    }
    if (m.find("NotifyReqAuth") != m.end() && !m["NotifyReqAuth"].empty()) {
      notifyReqAuth = make_shared<string>(boost::any_cast<string>(m["NotifyReqAuth"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SwitchNotifyUrl") != m.end() && !m["SwitchNotifyUrl"].empty()) {
      switchNotifyUrl = make_shared<string>(boost::any_cast<string>(m["SwitchNotifyUrl"]));
    }
  }


  virtual ~SetLiveStreamsNotifyUrlConfigRequest() = default;
};
class SetLiveStreamsNotifyUrlConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetLiveStreamsNotifyUrlConfigResponseBody() {}

  explicit SetLiveStreamsNotifyUrlConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetLiveStreamsNotifyUrlConfigResponseBody() = default;
};
class SetLiveStreamsNotifyUrlConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetLiveStreamsNotifyUrlConfigResponseBody> body{};

  SetLiveStreamsNotifyUrlConfigResponse() {}

  explicit SetLiveStreamsNotifyUrlConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetLiveStreamsNotifyUrlConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetLiveStreamsNotifyUrlConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetLiveStreamsNotifyUrlConfigResponse() = default;
};
class SetShowListBackgroundRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> materialId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> resourceUrl{};

  SetShowListBackgroundRequest() {}

  explicit SetShowListBackgroundRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceUrl) {
      res["ResourceUrl"] = boost::any(*resourceUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceUrl") != m.end() && !m["ResourceUrl"].empty()) {
      resourceUrl = make_shared<string>(boost::any_cast<string>(m["ResourceUrl"]));
    }
  }


  virtual ~SetShowListBackgroundRequest() = default;
};
class SetShowListBackgroundResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetShowListBackgroundResponseBody() {}

  explicit SetShowListBackgroundResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetShowListBackgroundResponseBody() = default;
};
class SetShowListBackgroundResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetShowListBackgroundResponseBody> body{};

  SetShowListBackgroundResponse() {}

  explicit SetShowListBackgroundResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetShowListBackgroundResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetShowListBackgroundResponseBody>(model1);
      }
    }
  }


  virtual ~SetShowListBackgroundResponse() = default;
};
class SetSnapshotCallbackAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackAuthKey{};
  shared_ptr<string> callbackReqAuth{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  SetSnapshotCallbackAuthRequest() {}

  explicit SetSnapshotCallbackAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackAuthKey) {
      res["CallbackAuthKey"] = boost::any(*callbackAuthKey);
    }
    if (callbackReqAuth) {
      res["CallbackReqAuth"] = boost::any(*callbackReqAuth);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackAuthKey") != m.end() && !m["CallbackAuthKey"].empty()) {
      callbackAuthKey = make_shared<string>(boost::any_cast<string>(m["CallbackAuthKey"]));
    }
    if (m.find("CallbackReqAuth") != m.end() && !m["CallbackReqAuth"].empty()) {
      callbackReqAuth = make_shared<string>(boost::any_cast<string>(m["CallbackReqAuth"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetSnapshotCallbackAuthRequest() = default;
};
class SetSnapshotCallbackAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetSnapshotCallbackAuthResponseBody() {}

  explicit SetSnapshotCallbackAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetSnapshotCallbackAuthResponseBody() = default;
};
class SetSnapshotCallbackAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetSnapshotCallbackAuthResponseBody> body{};

  SetSnapshotCallbackAuthResponse() {}

  explicit SetSnapshotCallbackAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetSnapshotCallbackAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetSnapshotCallbackAuthResponseBody>(model1);
      }
    }
  }


  virtual ~SetSnapshotCallbackAuthResponse() = default;
};
class StartCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  StartCasterRequest() {}

  explicit StartCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StartCasterRequest() = default;
};
class StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo : public Darabonba::Model {
public:
  shared_ptr<string> outputStreamUrl{};
  shared_ptr<string> transcodeConfig{};
  shared_ptr<string> videoFormat{};

  StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo() {}

  explicit StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputStreamUrl) {
      res["OutputStreamUrl"] = boost::any(*outputStreamUrl);
    }
    if (transcodeConfig) {
      res["TranscodeConfig"] = boost::any(*transcodeConfig);
    }
    if (videoFormat) {
      res["VideoFormat"] = boost::any(*videoFormat);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputStreamUrl") != m.end() && !m["OutputStreamUrl"].empty()) {
      outputStreamUrl = make_shared<string>(boost::any_cast<string>(m["OutputStreamUrl"]));
    }
    if (m.find("TranscodeConfig") != m.end() && !m["TranscodeConfig"].empty()) {
      transcodeConfig = make_shared<string>(boost::any_cast<string>(m["TranscodeConfig"]));
    }
    if (m.find("VideoFormat") != m.end() && !m["VideoFormat"].empty()) {
      videoFormat = make_shared<string>(boost::any_cast<string>(m["VideoFormat"]));
    }
  }


  virtual ~StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo() = default;
};
class StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos : public Darabonba::Model {
public:
  shared_ptr<vector<StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo>> streamInfo{};

  StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos() {}

  explicit StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamInfo) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamInfo") != m.end() && !m["StreamInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfo"].type()) {
        vector<StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfo = make_shared<vector<StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfosStreamInfo>>(expect1);
      }
    }
  }


  virtual ~StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos() = default;
};
class StartCasterResponseBodyPgmSceneInfosSceneInfo : public Darabonba::Model {
public:
  shared_ptr<string> sceneId{};
  shared_ptr<StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos> streamInfos{};
  shared_ptr<string> streamUrl{};

  StartCasterResponseBodyPgmSceneInfosSceneInfo() {}

  explicit StartCasterResponseBodyPgmSceneInfosSceneInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    if (streamInfos) {
      res["StreamInfos"] = streamInfos ? boost::any(streamInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInfos"].type()) {
        StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInfos"]));
        streamInfos = make_shared<StartCasterResponseBodyPgmSceneInfosSceneInfoStreamInfos>(model1);
      }
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~StartCasterResponseBodyPgmSceneInfosSceneInfo() = default;
};
class StartCasterResponseBodyPgmSceneInfos : public Darabonba::Model {
public:
  shared_ptr<vector<StartCasterResponseBodyPgmSceneInfosSceneInfo>> sceneInfo{};

  StartCasterResponseBodyPgmSceneInfos() {}

  explicit StartCasterResponseBodyPgmSceneInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sceneInfo) {
      vector<boost::any> temp1;
      for(auto item1:*sceneInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SceneInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SceneInfo") != m.end() && !m["SceneInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SceneInfo"].type()) {
        vector<StartCasterResponseBodyPgmSceneInfosSceneInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SceneInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartCasterResponseBodyPgmSceneInfosSceneInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sceneInfo = make_shared<vector<StartCasterResponseBodyPgmSceneInfosSceneInfo>>(expect1);
      }
    }
  }


  virtual ~StartCasterResponseBodyPgmSceneInfos() = default;
};
class StartCasterResponseBodyPvwSceneInfosSceneInfo : public Darabonba::Model {
public:
  shared_ptr<string> sceneId{};
  shared_ptr<string> streamUrl{};

  StartCasterResponseBodyPvwSceneInfosSceneInfo() {}

  explicit StartCasterResponseBodyPvwSceneInfosSceneInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~StartCasterResponseBodyPvwSceneInfosSceneInfo() = default;
};
class StartCasterResponseBodyPvwSceneInfos : public Darabonba::Model {
public:
  shared_ptr<vector<StartCasterResponseBodyPvwSceneInfosSceneInfo>> sceneInfo{};

  StartCasterResponseBodyPvwSceneInfos() {}

  explicit StartCasterResponseBodyPvwSceneInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sceneInfo) {
      vector<boost::any> temp1;
      for(auto item1:*sceneInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SceneInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SceneInfo") != m.end() && !m["SceneInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SceneInfo"].type()) {
        vector<StartCasterResponseBodyPvwSceneInfosSceneInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SceneInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartCasterResponseBodyPvwSceneInfosSceneInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sceneInfo = make_shared<vector<StartCasterResponseBodyPvwSceneInfosSceneInfo>>(expect1);
      }
    }
  }


  virtual ~StartCasterResponseBodyPvwSceneInfos() = default;
};
class StartCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<StartCasterResponseBodyPgmSceneInfos> pgmSceneInfos{};
  shared_ptr<StartCasterResponseBodyPvwSceneInfos> pvwSceneInfos{};
  shared_ptr<string> requestId{};

  StartCasterResponseBody() {}

  explicit StartCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pgmSceneInfos) {
      res["PgmSceneInfos"] = pgmSceneInfos ? boost::any(pgmSceneInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pvwSceneInfos) {
      res["PvwSceneInfos"] = pvwSceneInfos ? boost::any(pvwSceneInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PgmSceneInfos") != m.end() && !m["PgmSceneInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PgmSceneInfos"].type()) {
        StartCasterResponseBodyPgmSceneInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PgmSceneInfos"]));
        pgmSceneInfos = make_shared<StartCasterResponseBodyPgmSceneInfos>(model1);
      }
    }
    if (m.find("PvwSceneInfos") != m.end() && !m["PvwSceneInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PvwSceneInfos"].type()) {
        StartCasterResponseBodyPvwSceneInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PvwSceneInfos"]));
        pvwSceneInfos = make_shared<StartCasterResponseBodyPvwSceneInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartCasterResponseBody() = default;
};
class StartCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartCasterResponseBody> body{};

  StartCasterResponse() {}

  explicit StartCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartCasterResponseBody>(model1);
      }
    }
  }


  virtual ~StartCasterResponse() = default;
};
class StartCasterSceneRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sceneId{};

  StartCasterSceneRequest() {}

  explicit StartCasterSceneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~StartCasterSceneRequest() = default;
};
class StartCasterSceneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> streamUrl{};

  StartCasterSceneResponseBody() {}

  explicit StartCasterSceneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
  }


  virtual ~StartCasterSceneResponseBody() = default;
};
class StartCasterSceneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartCasterSceneResponseBody> body{};

  StartCasterSceneResponse() {}

  explicit StartCasterSceneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartCasterSceneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartCasterSceneResponseBody>(model1);
      }
    }
  }


  virtual ~StartCasterSceneResponse() = default;
};
class StartEdgeTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  StartEdgeTranscodeJobRequest() {}

  explicit StartEdgeTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StartEdgeTranscodeJobRequest() = default;
};
class StartEdgeTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  StartEdgeTranscodeJobResponseBody() {}

  explicit StartEdgeTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartEdgeTranscodeJobResponseBody() = default;
};
class StartEdgeTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartEdgeTranscodeJobResponseBody> body{};

  StartEdgeTranscodeJobResponse() {}

  explicit StartEdgeTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartEdgeTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartEdgeTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~StartEdgeTranscodeJobResponse() = default;
};
class StartLiveDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  StartLiveDomainRequest() {}

  explicit StartLiveDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~StartLiveDomainRequest() = default;
};
class StartLiveDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartLiveDomainResponseBody() {}

  explicit StartLiveDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartLiveDomainResponseBody() = default;
};
class StartLiveDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartLiveDomainResponseBody> body{};

  StartLiveDomainResponse() {}

  explicit StartLiveDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartLiveDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartLiveDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StartLiveDomainResponse() = default;
};
class StartLiveMPUTaskRequestMultiStreamURL : public Darabonba::Model {
public:
  shared_ptr<bool> isAliCdn{};
  shared_ptr<string> URL{};

  StartLiveMPUTaskRequestMultiStreamURL() {}

  explicit StartLiveMPUTaskRequestMultiStreamURL(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isAliCdn) {
      res["IsAliCdn"] = boost::any(*isAliCdn);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsAliCdn") != m.end() && !m["IsAliCdn"].empty()) {
      isAliCdn = make_shared<bool>(boost::any_cast<bool>(m["IsAliCdn"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~StartLiveMPUTaskRequestMultiStreamURL() = default;
};
class StartLiveMPUTaskRequestSeiParamsLayoutVolume : public Darabonba::Model {
public:
  shared_ptr<string> followIdr{};
  shared_ptr<string> interval{};

  StartLiveMPUTaskRequestSeiParamsLayoutVolume() {}

  explicit StartLiveMPUTaskRequestSeiParamsLayoutVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (followIdr) {
      res["FollowIdr"] = boost::any(*followIdr);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FollowIdr") != m.end() && !m["FollowIdr"].empty()) {
      followIdr = make_shared<string>(boost::any_cast<string>(m["FollowIdr"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
  }


  virtual ~StartLiveMPUTaskRequestSeiParamsLayoutVolume() = default;
};
class StartLiveMPUTaskRequestSeiParamsPassThrough : public Darabonba::Model {
public:
  shared_ptr<string> followIdr{};
  shared_ptr<string> interval{};
  shared_ptr<string> payloadContent{};
  shared_ptr<string> payloadContentKey{};

  StartLiveMPUTaskRequestSeiParamsPassThrough() {}

  explicit StartLiveMPUTaskRequestSeiParamsPassThrough(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (followIdr) {
      res["FollowIdr"] = boost::any(*followIdr);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (payloadContent) {
      res["PayloadContent"] = boost::any(*payloadContent);
    }
    if (payloadContentKey) {
      res["PayloadContentKey"] = boost::any(*payloadContentKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FollowIdr") != m.end() && !m["FollowIdr"].empty()) {
      followIdr = make_shared<string>(boost::any_cast<string>(m["FollowIdr"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("PayloadContent") != m.end() && !m["PayloadContent"].empty()) {
      payloadContent = make_shared<string>(boost::any_cast<string>(m["PayloadContent"]));
    }
    if (m.find("PayloadContentKey") != m.end() && !m["PayloadContentKey"].empty()) {
      payloadContentKey = make_shared<string>(boost::any_cast<string>(m["PayloadContentKey"]));
    }
  }


  virtual ~StartLiveMPUTaskRequestSeiParamsPassThrough() = default;
};
class StartLiveMPUTaskRequestSeiParams : public Darabonba::Model {
public:
  shared_ptr<StartLiveMPUTaskRequestSeiParamsLayoutVolume> layoutVolume{};
  shared_ptr<StartLiveMPUTaskRequestSeiParamsPassThrough> passThrough{};
  shared_ptr<string> payloadType{};

  StartLiveMPUTaskRequestSeiParams() {}

  explicit StartLiveMPUTaskRequestSeiParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layoutVolume) {
      res["LayoutVolume"] = layoutVolume ? boost::any(layoutVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passThrough) {
      res["PassThrough"] = passThrough ? boost::any(passThrough->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payloadType) {
      res["PayloadType"] = boost::any(*payloadType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LayoutVolume") != m.end() && !m["LayoutVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["LayoutVolume"].type()) {
        StartLiveMPUTaskRequestSeiParamsLayoutVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LayoutVolume"]));
        layoutVolume = make_shared<StartLiveMPUTaskRequestSeiParamsLayoutVolume>(model1);
      }
    }
    if (m.find("PassThrough") != m.end() && !m["PassThrough"].empty()) {
      if (typeid(map<string, boost::any>) == m["PassThrough"].type()) {
        StartLiveMPUTaskRequestSeiParamsPassThrough model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PassThrough"]));
        passThrough = make_shared<StartLiveMPUTaskRequestSeiParamsPassThrough>(model1);
      }
    }
    if (m.find("PayloadType") != m.end() && !m["PayloadType"].empty()) {
      payloadType = make_shared<string>(boost::any_cast<string>(m["PayloadType"]));
    }
  }


  virtual ~StartLiveMPUTaskRequestSeiParams() = default;
};
class StartLiveMPUTaskRequestSingleSubParams : public Darabonba::Model {
public:
  shared_ptr<string> sourceType{};
  shared_ptr<string> streamType{};
  shared_ptr<string> userId{};

  StartLiveMPUTaskRequestSingleSubParams() {}

  explicit StartLiveMPUTaskRequestSingleSubParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartLiveMPUTaskRequestSingleSubParams() = default;
};
class StartLiveMPUTaskRequestTranscodeParamsBackground : public Darabonba::Model {
public:
  shared_ptr<string> renderMode{};
  shared_ptr<string> URL{};

  StartLiveMPUTaskRequestTranscodeParamsBackground() {}

  explicit StartLiveMPUTaskRequestTranscodeParamsBackground(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderMode) {
      res["RenderMode"] = boost::any(*renderMode);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderMode") != m.end() && !m["RenderMode"].empty()) {
      renderMode = make_shared<string>(boost::any_cast<string>(m["RenderMode"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~StartLiveMPUTaskRequestTranscodeParamsBackground() = default;
};
class StartLiveMPUTaskRequestTranscodeParamsEncodeParams : public Darabonba::Model {
public:
  shared_ptr<string> audioBitrate{};
  shared_ptr<string> audioChannels{};
  shared_ptr<string> audioOnly{};
  shared_ptr<string> audioSampleRate{};
  shared_ptr<string> enhancedParam{};
  shared_ptr<string> videoBitrate{};
  shared_ptr<string> videoCodec{};
  shared_ptr<string> videoFramerate{};
  shared_ptr<string> videoGop{};
  shared_ptr<string> videoHeight{};
  shared_ptr<string> videoWidth{};

  StartLiveMPUTaskRequestTranscodeParamsEncodeParams() {}

  explicit StartLiveMPUTaskRequestTranscodeParamsEncodeParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannels) {
      res["AudioChannels"] = boost::any(*audioChannels);
    }
    if (audioOnly) {
      res["AudioOnly"] = boost::any(*audioOnly);
    }
    if (audioSampleRate) {
      res["AudioSampleRate"] = boost::any(*audioSampleRate);
    }
    if (enhancedParam) {
      res["EnhancedParam"] = boost::any(*enhancedParam);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    if (videoFramerate) {
      res["VideoFramerate"] = boost::any(*videoFramerate);
    }
    if (videoGop) {
      res["VideoGop"] = boost::any(*videoGop);
    }
    if (videoHeight) {
      res["VideoHeight"] = boost::any(*videoHeight);
    }
    if (videoWidth) {
      res["VideoWidth"] = boost::any(*videoWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<string>(boost::any_cast<string>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannels") != m.end() && !m["AudioChannels"].empty()) {
      audioChannels = make_shared<string>(boost::any_cast<string>(m["AudioChannels"]));
    }
    if (m.find("AudioOnly") != m.end() && !m["AudioOnly"].empty()) {
      audioOnly = make_shared<string>(boost::any_cast<string>(m["AudioOnly"]));
    }
    if (m.find("AudioSampleRate") != m.end() && !m["AudioSampleRate"].empty()) {
      audioSampleRate = make_shared<string>(boost::any_cast<string>(m["AudioSampleRate"]));
    }
    if (m.find("EnhancedParam") != m.end() && !m["EnhancedParam"].empty()) {
      enhancedParam = make_shared<string>(boost::any_cast<string>(m["EnhancedParam"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<string>(boost::any_cast<string>(m["VideoBitrate"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
    if (m.find("VideoFramerate") != m.end() && !m["VideoFramerate"].empty()) {
      videoFramerate = make_shared<string>(boost::any_cast<string>(m["VideoFramerate"]));
    }
    if (m.find("VideoGop") != m.end() && !m["VideoGop"].empty()) {
      videoGop = make_shared<string>(boost::any_cast<string>(m["VideoGop"]));
    }
    if (m.find("VideoHeight") != m.end() && !m["VideoHeight"].empty()) {
      videoHeight = make_shared<string>(boost::any_cast<string>(m["VideoHeight"]));
    }
    if (m.find("VideoWidth") != m.end() && !m["VideoWidth"].empty()) {
      videoWidth = make_shared<string>(boost::any_cast<string>(m["VideoWidth"]));
    }
  }


  virtual ~StartLiveMPUTaskRequestTranscodeParamsEncodeParams() = default;
};
class StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> userId{};

  StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo() {}

  explicit StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo() = default;
};
class StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanes : public Darabonba::Model {
public:
  shared_ptr<string> backgroundImageUrl{};
  shared_ptr<string> height{};
  shared_ptr<string> renderMode{};
  shared_ptr<StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo> userInfo{};
  shared_ptr<string> width{};
  shared_ptr<string> x{};
  shared_ptr<string> y{};
  shared_ptr<string> ZOrder{};

  StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanes() {}

  explicit StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundImageUrl) {
      res["BackgroundImageUrl"] = boost::any(*backgroundImageUrl);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (renderMode) {
      res["RenderMode"] = boost::any(*renderMode);
    }
    if (userInfo) {
      res["UserInfo"] = userInfo ? boost::any(userInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    if (ZOrder) {
      res["ZOrder"] = boost::any(*ZOrder);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundImageUrl") != m.end() && !m["BackgroundImageUrl"].empty()) {
      backgroundImageUrl = make_shared<string>(boost::any_cast<string>(m["BackgroundImageUrl"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("RenderMode") != m.end() && !m["RenderMode"].empty()) {
      renderMode = make_shared<string>(boost::any_cast<string>(m["RenderMode"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserInfo"].type()) {
        StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserInfo"]));
        userInfo = make_shared<StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<string>(boost::any_cast<string>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<string>(boost::any_cast<string>(m["Y"]));
    }
    if (m.find("ZOrder") != m.end() && !m["ZOrder"].empty()) {
      ZOrder = make_shared<string>(boost::any_cast<string>(m["ZOrder"]));
    }
  }


  virtual ~StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanes() = default;
};
class StartLiveMPUTaskRequestTranscodeParamsLayout : public Darabonba::Model {
public:
  shared_ptr<vector<StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanes>> userPanes{};

  StartLiveMPUTaskRequestTranscodeParamsLayout() {}

  explicit StartLiveMPUTaskRequestTranscodeParamsLayout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userPanes) {
      vector<boost::any> temp1;
      for(auto item1:*userPanes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserPanes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserPanes") != m.end() && !m["UserPanes"].empty()) {
      if (typeid(vector<boost::any>) == m["UserPanes"].type()) {
        vector<StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserPanes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userPanes = make_shared<vector<StartLiveMPUTaskRequestTranscodeParamsLayoutUserPanes>>(expect1);
      }
    }
  }


  virtual ~StartLiveMPUTaskRequestTranscodeParamsLayout() = default;
};
class StartLiveMPUTaskRequestTranscodeParamsUserInfos : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> streamType{};
  shared_ptr<string> userId{};

  StartLiveMPUTaskRequestTranscodeParamsUserInfos() {}

  explicit StartLiveMPUTaskRequestTranscodeParamsUserInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartLiveMPUTaskRequestTranscodeParamsUserInfos() = default;
};
class StartLiveMPUTaskRequestTranscodeParams : public Darabonba::Model {
public:
  shared_ptr<StartLiveMPUTaskRequestTranscodeParamsBackground> background{};
  shared_ptr<StartLiveMPUTaskRequestTranscodeParamsEncodeParams> encodeParams{};
  shared_ptr<StartLiveMPUTaskRequestTranscodeParamsLayout> layout{};
  shared_ptr<vector<StartLiveMPUTaskRequestTranscodeParamsUserInfos>> userInfos{};

  StartLiveMPUTaskRequestTranscodeParams() {}

  explicit StartLiveMPUTaskRequestTranscodeParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (background) {
      res["Background"] = background ? boost::any(background->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encodeParams) {
      res["EncodeParams"] = encodeParams ? boost::any(encodeParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (layout) {
      res["Layout"] = layout ? boost::any(layout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userInfos) {
      vector<boost::any> temp1;
      for(auto item1:*userInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Background") != m.end() && !m["Background"].empty()) {
      if (typeid(map<string, boost::any>) == m["Background"].type()) {
        StartLiveMPUTaskRequestTranscodeParamsBackground model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Background"]));
        background = make_shared<StartLiveMPUTaskRequestTranscodeParamsBackground>(model1);
      }
    }
    if (m.find("EncodeParams") != m.end() && !m["EncodeParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["EncodeParams"].type()) {
        StartLiveMPUTaskRequestTranscodeParamsEncodeParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EncodeParams"]));
        encodeParams = make_shared<StartLiveMPUTaskRequestTranscodeParamsEncodeParams>(model1);
      }
    }
    if (m.find("Layout") != m.end() && !m["Layout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Layout"].type()) {
        StartLiveMPUTaskRequestTranscodeParamsLayout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Layout"]));
        layout = make_shared<StartLiveMPUTaskRequestTranscodeParamsLayout>(model1);
      }
    }
    if (m.find("UserInfos") != m.end() && !m["UserInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["UserInfos"].type()) {
        vector<StartLiveMPUTaskRequestTranscodeParamsUserInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartLiveMPUTaskRequestTranscodeParamsUserInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userInfos = make_shared<vector<StartLiveMPUTaskRequestTranscodeParamsUserInfos>>(expect1);
      }
    }
  }


  virtual ~StartLiveMPUTaskRequestTranscodeParams() = default;
};
class StartLiveMPUTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> maxIdleTime{};
  shared_ptr<string> mixMode{};
  shared_ptr<vector<StartLiveMPUTaskRequestMultiStreamURL>> multiStreamURL{};
  shared_ptr<string> region{};
  shared_ptr<StartLiveMPUTaskRequestSeiParams> seiParams{};
  shared_ptr<StartLiveMPUTaskRequestSingleSubParams> singleSubParams{};
  shared_ptr<string> streamURL{};
  shared_ptr<string> taskId{};
  shared_ptr<StartLiveMPUTaskRequestTranscodeParams> transcodeParams{};

  StartLiveMPUTaskRequest() {}

  explicit StartLiveMPUTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (maxIdleTime) {
      res["MaxIdleTime"] = boost::any(*maxIdleTime);
    }
    if (mixMode) {
      res["MixMode"] = boost::any(*mixMode);
    }
    if (multiStreamURL) {
      vector<boost::any> temp1;
      for(auto item1:*multiStreamURL){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultiStreamURL"] = boost::any(temp1);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (seiParams) {
      res["SeiParams"] = seiParams ? boost::any(seiParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (singleSubParams) {
      res["SingleSubParams"] = singleSubParams ? boost::any(singleSubParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamURL) {
      res["StreamURL"] = boost::any(*streamURL);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (transcodeParams) {
      res["TranscodeParams"] = transcodeParams ? boost::any(transcodeParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("MaxIdleTime") != m.end() && !m["MaxIdleTime"].empty()) {
      maxIdleTime = make_shared<string>(boost::any_cast<string>(m["MaxIdleTime"]));
    }
    if (m.find("MixMode") != m.end() && !m["MixMode"].empty()) {
      mixMode = make_shared<string>(boost::any_cast<string>(m["MixMode"]));
    }
    if (m.find("MultiStreamURL") != m.end() && !m["MultiStreamURL"].empty()) {
      if (typeid(vector<boost::any>) == m["MultiStreamURL"].type()) {
        vector<StartLiveMPUTaskRequestMultiStreamURL> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultiStreamURL"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartLiveMPUTaskRequestMultiStreamURL model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multiStreamURL = make_shared<vector<StartLiveMPUTaskRequestMultiStreamURL>>(expect1);
      }
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SeiParams") != m.end() && !m["SeiParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["SeiParams"].type()) {
        StartLiveMPUTaskRequestSeiParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SeiParams"]));
        seiParams = make_shared<StartLiveMPUTaskRequestSeiParams>(model1);
      }
    }
    if (m.find("SingleSubParams") != m.end() && !m["SingleSubParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["SingleSubParams"].type()) {
        StartLiveMPUTaskRequestSingleSubParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SingleSubParams"]));
        singleSubParams = make_shared<StartLiveMPUTaskRequestSingleSubParams>(model1);
      }
    }
    if (m.find("StreamURL") != m.end() && !m["StreamURL"].empty()) {
      streamURL = make_shared<string>(boost::any_cast<string>(m["StreamURL"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TranscodeParams") != m.end() && !m["TranscodeParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeParams"].type()) {
        StartLiveMPUTaskRequestTranscodeParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeParams"]));
        transcodeParams = make_shared<StartLiveMPUTaskRequestTranscodeParams>(model1);
      }
    }
  }


  virtual ~StartLiveMPUTaskRequest() = default;
};
class StartLiveMPUTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> maxIdleTime{};
  shared_ptr<string> mixMode{};
  shared_ptr<string> multiStreamURLShrink{};
  shared_ptr<string> region{};
  shared_ptr<string> seiParamsShrink{};
  shared_ptr<string> singleSubParamsShrink{};
  shared_ptr<string> streamURL{};
  shared_ptr<string> taskId{};
  shared_ptr<string> transcodeParamsShrink{};

  StartLiveMPUTaskShrinkRequest() {}

  explicit StartLiveMPUTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (maxIdleTime) {
      res["MaxIdleTime"] = boost::any(*maxIdleTime);
    }
    if (mixMode) {
      res["MixMode"] = boost::any(*mixMode);
    }
    if (multiStreamURLShrink) {
      res["MultiStreamURL"] = boost::any(*multiStreamURLShrink);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (seiParamsShrink) {
      res["SeiParams"] = boost::any(*seiParamsShrink);
    }
    if (singleSubParamsShrink) {
      res["SingleSubParams"] = boost::any(*singleSubParamsShrink);
    }
    if (streamURL) {
      res["StreamURL"] = boost::any(*streamURL);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (transcodeParamsShrink) {
      res["TranscodeParams"] = boost::any(*transcodeParamsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("MaxIdleTime") != m.end() && !m["MaxIdleTime"].empty()) {
      maxIdleTime = make_shared<string>(boost::any_cast<string>(m["MaxIdleTime"]));
    }
    if (m.find("MixMode") != m.end() && !m["MixMode"].empty()) {
      mixMode = make_shared<string>(boost::any_cast<string>(m["MixMode"]));
    }
    if (m.find("MultiStreamURL") != m.end() && !m["MultiStreamURL"].empty()) {
      multiStreamURLShrink = make_shared<string>(boost::any_cast<string>(m["MultiStreamURL"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SeiParams") != m.end() && !m["SeiParams"].empty()) {
      seiParamsShrink = make_shared<string>(boost::any_cast<string>(m["SeiParams"]));
    }
    if (m.find("SingleSubParams") != m.end() && !m["SingleSubParams"].empty()) {
      singleSubParamsShrink = make_shared<string>(boost::any_cast<string>(m["SingleSubParams"]));
    }
    if (m.find("StreamURL") != m.end() && !m["StreamURL"].empty()) {
      streamURL = make_shared<string>(boost::any_cast<string>(m["StreamURL"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TranscodeParams") != m.end() && !m["TranscodeParams"].empty()) {
      transcodeParamsShrink = make_shared<string>(boost::any_cast<string>(m["TranscodeParams"]));
    }
  }


  virtual ~StartLiveMPUTaskShrinkRequest() = default;
};
class StartLiveMPUTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartLiveMPUTaskResponseBody() {}

  explicit StartLiveMPUTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartLiveMPUTaskResponseBody() = default;
};
class StartLiveMPUTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartLiveMPUTaskResponseBody> body{};

  StartLiveMPUTaskResponse() {}

  explicit StartLiveMPUTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartLiveMPUTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartLiveMPUTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StartLiveMPUTaskResponse() = default;
};
class StartLiveStreamMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> monitorId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  StartLiveStreamMonitorRequest() {}

  explicit StartLiveStreamMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StartLiveStreamMonitorRequest() = default;
};
class StartLiveStreamMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartLiveStreamMonitorResponseBody() {}

  explicit StartLiveStreamMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartLiveStreamMonitorResponseBody() = default;
};
class StartLiveStreamMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartLiveStreamMonitorResponseBody> body{};

  StartLiveStreamMonitorResponse() {}

  explicit StartLiveStreamMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartLiveStreamMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartLiveStreamMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~StartLiveStreamMonitorResponse() = default;
};
class StartPlaylistRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resumeMode{};
  shared_ptr<string> startItemId{};

  StartPlaylistRequest() {}

  explicit StartPlaylistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resumeMode) {
      res["ResumeMode"] = boost::any(*resumeMode);
    }
    if (startItemId) {
      res["StartItemId"] = boost::any(*startItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResumeMode") != m.end() && !m["ResumeMode"].empty()) {
      resumeMode = make_shared<string>(boost::any_cast<string>(m["ResumeMode"]));
    }
    if (m.find("StartItemId") != m.end() && !m["StartItemId"].empty()) {
      startItemId = make_shared<string>(boost::any_cast<string>(m["StartItemId"]));
    }
  }


  virtual ~StartPlaylistRequest() = default;
};
class StartPlaylistResponseBodyStreamInfoStreamsStream : public Darabonba::Model {
public:
  shared_ptr<string> pullFlvUrl{};
  shared_ptr<string> pullM3U8Url{};
  shared_ptr<string> pullRtmpUrl{};
  shared_ptr<string> quality{};

  StartPlaylistResponseBodyStreamInfoStreamsStream() {}

  explicit StartPlaylistResponseBodyStreamInfoStreamsStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pullFlvUrl) {
      res["PullFlvUrl"] = boost::any(*pullFlvUrl);
    }
    if (pullM3U8Url) {
      res["PullM3U8Url"] = boost::any(*pullM3U8Url);
    }
    if (pullRtmpUrl) {
      res["PullRtmpUrl"] = boost::any(*pullRtmpUrl);
    }
    if (quality) {
      res["Quality"] = boost::any(*quality);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PullFlvUrl") != m.end() && !m["PullFlvUrl"].empty()) {
      pullFlvUrl = make_shared<string>(boost::any_cast<string>(m["PullFlvUrl"]));
    }
    if (m.find("PullM3U8Url") != m.end() && !m["PullM3U8Url"].empty()) {
      pullM3U8Url = make_shared<string>(boost::any_cast<string>(m["PullM3U8Url"]));
    }
    if (m.find("PullRtmpUrl") != m.end() && !m["PullRtmpUrl"].empty()) {
      pullRtmpUrl = make_shared<string>(boost::any_cast<string>(m["PullRtmpUrl"]));
    }
    if (m.find("Quality") != m.end() && !m["Quality"].empty()) {
      quality = make_shared<string>(boost::any_cast<string>(m["Quality"]));
    }
  }


  virtual ~StartPlaylistResponseBodyStreamInfoStreamsStream() = default;
};
class StartPlaylistResponseBodyStreamInfoStreams : public Darabonba::Model {
public:
  shared_ptr<vector<StartPlaylistResponseBodyStreamInfoStreamsStream>> stream{};

  StartPlaylistResponseBodyStreamInfoStreams() {}

  explicit StartPlaylistResponseBodyStreamInfoStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stream) {
      vector<boost::any> temp1;
      for(auto item1:*stream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Stream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      if (typeid(vector<boost::any>) == m["Stream"].type()) {
        vector<StartPlaylistResponseBodyStreamInfoStreamsStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Stream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartPlaylistResponseBodyStreamInfoStreamsStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stream = make_shared<vector<StartPlaylistResponseBodyStreamInfoStreamsStream>>(expect1);
      }
    }
  }


  virtual ~StartPlaylistResponseBodyStreamInfoStreams() = default;
};
class StartPlaylistResponseBodyStreamInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> streamName{};
  shared_ptr<StartPlaylistResponseBodyStreamInfoStreams> streams{};

  StartPlaylistResponseBodyStreamInfo() {}

  explicit StartPlaylistResponseBodyStreamInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        StartPlaylistResponseBodyStreamInfoStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<StartPlaylistResponseBodyStreamInfoStreams>(model1);
      }
    }
  }


  virtual ~StartPlaylistResponseBodyStreamInfo() = default;
};
class StartPlaylistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};
  shared_ptr<StartPlaylistResponseBodyStreamInfo> streamInfo{};

  StartPlaylistResponseBody() {}

  explicit StartPlaylistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streamInfo) {
      res["StreamInfo"] = streamInfo ? boost::any(streamInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StreamInfo") != m.end() && !m["StreamInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInfo"].type()) {
        StartPlaylistResponseBodyStreamInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInfo"]));
        streamInfo = make_shared<StartPlaylistResponseBodyStreamInfo>(model1);
      }
    }
  }


  virtual ~StartPlaylistResponseBody() = default;
};
class StartPlaylistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartPlaylistResponseBody> body{};

  StartPlaylistResponse() {}

  explicit StartPlaylistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartPlaylistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartPlaylistResponseBody>(model1);
      }
    }
  }


  virtual ~StartPlaylistResponse() = default;
};
class StartRtcCloudRecordingRequestMixLayoutParamsMixBackground : public Darabonba::Model {
public:
  shared_ptr<long> renderMode{};
  shared_ptr<string> url{};

  StartRtcCloudRecordingRequestMixLayoutParamsMixBackground() {}

  explicit StartRtcCloudRecordingRequestMixLayoutParamsMixBackground(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderMode) {
      res["RenderMode"] = boost::any(*renderMode);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderMode") != m.end() && !m["RenderMode"].empty()) {
      renderMode = make_shared<long>(boost::any_cast<long>(m["RenderMode"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~StartRtcCloudRecordingRequestMixLayoutParamsMixBackground() = default;
};
class StartRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground : public Darabonba::Model {
public:
  shared_ptr<long> renderMode{};
  shared_ptr<string> url{};

  StartRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground() {}

  explicit StartRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderMode) {
      res["RenderMode"] = boost::any(*renderMode);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderMode") != m.end() && !m["RenderMode"].empty()) {
      renderMode = make_shared<long>(boost::any_cast<long>(m["RenderMode"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~StartRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground() = default;
};
class StartRtcCloudRecordingRequestMixLayoutParamsUserPanes : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<long> sourceType{};
  shared_ptr<StartRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground> subBackground{};
  shared_ptr<string> userId{};
  shared_ptr<string> width{};
  shared_ptr<string> x{};
  shared_ptr<string> y{};
  shared_ptr<long> ZOrder{};

  StartRtcCloudRecordingRequestMixLayoutParamsUserPanes() {}

  explicit StartRtcCloudRecordingRequestMixLayoutParamsUserPanes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (subBackground) {
      res["SubBackground"] = subBackground ? boost::any(subBackground->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    if (ZOrder) {
      res["ZOrder"] = boost::any(*ZOrder);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<long>(boost::any_cast<long>(m["SourceType"]));
    }
    if (m.find("SubBackground") != m.end() && !m["SubBackground"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubBackground"].type()) {
        StartRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubBackground"]));
        subBackground = make_shared<StartRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<string>(boost::any_cast<string>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<string>(boost::any_cast<string>(m["Y"]));
    }
    if (m.find("ZOrder") != m.end() && !m["ZOrder"].empty()) {
      ZOrder = make_shared<long>(boost::any_cast<long>(m["ZOrder"]));
    }
  }


  virtual ~StartRtcCloudRecordingRequestMixLayoutParamsUserPanes() = default;
};
class StartRtcCloudRecordingRequestMixLayoutParams : public Darabonba::Model {
public:
  shared_ptr<StartRtcCloudRecordingRequestMixLayoutParamsMixBackground> mixBackground{};
  shared_ptr<vector<StartRtcCloudRecordingRequestMixLayoutParamsUserPanes>> userPanes{};

  StartRtcCloudRecordingRequestMixLayoutParams() {}

  explicit StartRtcCloudRecordingRequestMixLayoutParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixBackground) {
      res["MixBackground"] = mixBackground ? boost::any(mixBackground->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userPanes) {
      vector<boost::any> temp1;
      for(auto item1:*userPanes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserPanes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixBackground") != m.end() && !m["MixBackground"].empty()) {
      if (typeid(map<string, boost::any>) == m["MixBackground"].type()) {
        StartRtcCloudRecordingRequestMixLayoutParamsMixBackground model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MixBackground"]));
        mixBackground = make_shared<StartRtcCloudRecordingRequestMixLayoutParamsMixBackground>(model1);
      }
    }
    if (m.find("UserPanes") != m.end() && !m["UserPanes"].empty()) {
      if (typeid(vector<boost::any>) == m["UserPanes"].type()) {
        vector<StartRtcCloudRecordingRequestMixLayoutParamsUserPanes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserPanes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartRtcCloudRecordingRequestMixLayoutParamsUserPanes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userPanes = make_shared<vector<StartRtcCloudRecordingRequestMixLayoutParamsUserPanes>>(expect1);
      }
    }
  }


  virtual ~StartRtcCloudRecordingRequestMixLayoutParams() = default;
};
class StartRtcCloudRecordingRequestMixTranscodeParams : public Darabonba::Model {
public:
  shared_ptr<long> audioBitrate{};
  shared_ptr<long> audioChannels{};
  shared_ptr<long> audioSampleRate{};
  shared_ptr<long> frameFillType{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<string> videoCodec{};
  shared_ptr<long> videoFramerate{};
  shared_ptr<long> videoGop{};
  shared_ptr<long> videoHeight{};
  shared_ptr<long> videoWidth{};

  StartRtcCloudRecordingRequestMixTranscodeParams() {}

  explicit StartRtcCloudRecordingRequestMixTranscodeParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannels) {
      res["AudioChannels"] = boost::any(*audioChannels);
    }
    if (audioSampleRate) {
      res["AudioSampleRate"] = boost::any(*audioSampleRate);
    }
    if (frameFillType) {
      res["FrameFillType"] = boost::any(*frameFillType);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    if (videoFramerate) {
      res["VideoFramerate"] = boost::any(*videoFramerate);
    }
    if (videoGop) {
      res["VideoGop"] = boost::any(*videoGop);
    }
    if (videoHeight) {
      res["VideoHeight"] = boost::any(*videoHeight);
    }
    if (videoWidth) {
      res["VideoWidth"] = boost::any(*videoWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<long>(boost::any_cast<long>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannels") != m.end() && !m["AudioChannels"].empty()) {
      audioChannels = make_shared<long>(boost::any_cast<long>(m["AudioChannels"]));
    }
    if (m.find("AudioSampleRate") != m.end() && !m["AudioSampleRate"].empty()) {
      audioSampleRate = make_shared<long>(boost::any_cast<long>(m["AudioSampleRate"]));
    }
    if (m.find("FrameFillType") != m.end() && !m["FrameFillType"].empty()) {
      frameFillType = make_shared<long>(boost::any_cast<long>(m["FrameFillType"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
    if (m.find("VideoFramerate") != m.end() && !m["VideoFramerate"].empty()) {
      videoFramerate = make_shared<long>(boost::any_cast<long>(m["VideoFramerate"]));
    }
    if (m.find("VideoGop") != m.end() && !m["VideoGop"].empty()) {
      videoGop = make_shared<long>(boost::any_cast<long>(m["VideoGop"]));
    }
    if (m.find("VideoHeight") != m.end() && !m["VideoHeight"].empty()) {
      videoHeight = make_shared<long>(boost::any_cast<long>(m["VideoHeight"]));
    }
    if (m.find("VideoWidth") != m.end() && !m["VideoWidth"].empty()) {
      videoWidth = make_shared<long>(boost::any_cast<long>(m["VideoWidth"]));
    }
  }


  virtual ~StartRtcCloudRecordingRequestMixTranscodeParams() = default;
};
class StartRtcCloudRecordingRequestRecordParams : public Darabonba::Model {
public:
  shared_ptr<long> maxFileDuration{};
  shared_ptr<long> recordMode{};
  shared_ptr<long> streamType{};

  StartRtcCloudRecordingRequestRecordParams() {}

  explicit StartRtcCloudRecordingRequestRecordParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxFileDuration) {
      res["MaxFileDuration"] = boost::any(*maxFileDuration);
    }
    if (recordMode) {
      res["RecordMode"] = boost::any(*recordMode);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxFileDuration") != m.end() && !m["MaxFileDuration"].empty()) {
      maxFileDuration = make_shared<long>(boost::any_cast<long>(m["MaxFileDuration"]));
    }
    if (m.find("RecordMode") != m.end() && !m["RecordMode"].empty()) {
      recordMode = make_shared<long>(boost::any_cast<long>(m["RecordMode"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<long>(boost::any_cast<long>(m["StreamType"]));
    }
  }


  virtual ~StartRtcCloudRecordingRequestRecordParams() = default;
};
class StartRtcCloudRecordingRequestStorageParamsFileInfo : public Darabonba::Model {
public:
  shared_ptr<string> fileNamePattern{};
  shared_ptr<string> format{};
  shared_ptr<string> sliceNamePattern{};

  StartRtcCloudRecordingRequestStorageParamsFileInfo() {}

  explicit StartRtcCloudRecordingRequestStorageParamsFileInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileNamePattern) {
      res["FileNamePattern"] = boost::any(*fileNamePattern);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (sliceNamePattern) {
      res["SliceNamePattern"] = boost::any(*sliceNamePattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileNamePattern") != m.end() && !m["FileNamePattern"].empty()) {
      fileNamePattern = make_shared<string>(boost::any_cast<string>(m["FileNamePattern"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("SliceNamePattern") != m.end() && !m["SliceNamePattern"].empty()) {
      sliceNamePattern = make_shared<string>(boost::any_cast<string>(m["SliceNamePattern"]));
    }
  }


  virtual ~StartRtcCloudRecordingRequestStorageParamsFileInfo() = default;
};
class StartRtcCloudRecordingRequestStorageParamsOSSParams : public Darabonba::Model {
public:
  shared_ptr<string> OSSBucket{};
  shared_ptr<string> OSSEndpoint{};

  StartRtcCloudRecordingRequestStorageParamsOSSParams() {}

  explicit StartRtcCloudRecordingRequestStorageParamsOSSParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (OSSBucket) {
      res["OSSBucket"] = boost::any(*OSSBucket);
    }
    if (OSSEndpoint) {
      res["OSSEndpoint"] = boost::any(*OSSEndpoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OSSBucket") != m.end() && !m["OSSBucket"].empty()) {
      OSSBucket = make_shared<string>(boost::any_cast<string>(m["OSSBucket"]));
    }
    if (m.find("OSSEndpoint") != m.end() && !m["OSSEndpoint"].empty()) {
      OSSEndpoint = make_shared<string>(boost::any_cast<string>(m["OSSEndpoint"]));
    }
  }


  virtual ~StartRtcCloudRecordingRequestStorageParamsOSSParams() = default;
};
class StartRtcCloudRecordingRequestStorageParams : public Darabonba::Model {
public:
  shared_ptr<vector<StartRtcCloudRecordingRequestStorageParamsFileInfo>> fileInfo{};
  shared_ptr<StartRtcCloudRecordingRequestStorageParamsOSSParams> OSSParams{};
  shared_ptr<long> storageType{};

  StartRtcCloudRecordingRequestStorageParams() {}

  explicit StartRtcCloudRecordingRequestStorageParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfo) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfo"] = boost::any(temp1);
    }
    if (OSSParams) {
      res["OSSParams"] = OSSParams ? boost::any(OSSParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfo") != m.end() && !m["FileInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfo"].type()) {
        vector<StartRtcCloudRecordingRequestStorageParamsFileInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartRtcCloudRecordingRequestStorageParamsFileInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfo = make_shared<vector<StartRtcCloudRecordingRequestStorageParamsFileInfo>>(expect1);
      }
    }
    if (m.find("OSSParams") != m.end() && !m["OSSParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OSSParams"].type()) {
        StartRtcCloudRecordingRequestStorageParamsOSSParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OSSParams"]));
        OSSParams = make_shared<StartRtcCloudRecordingRequestStorageParamsOSSParams>(model1);
      }
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<long>(boost::any_cast<long>(m["StorageType"]));
    }
  }


  virtual ~StartRtcCloudRecordingRequestStorageParams() = default;
};
class StartRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList : public Darabonba::Model {
public:
  shared_ptr<long> sourceType{};
  shared_ptr<long> streamType{};
  shared_ptr<string> userId{};

  StartRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList() {}

  explicit StartRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<long>(boost::any_cast<long>(m["SourceType"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<long>(boost::any_cast<long>(m["StreamType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList() = default;
};
class StartRtcCloudRecordingRequestSubscribeParams : public Darabonba::Model {
public:
  shared_ptr<vector<StartRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList>> subscribeUserIdList{};

  StartRtcCloudRecordingRequestSubscribeParams() {}

  explicit StartRtcCloudRecordingRequestSubscribeParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subscribeUserIdList) {
      vector<boost::any> temp1;
      for(auto item1:*subscribeUserIdList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubscribeUserIdList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubscribeUserIdList") != m.end() && !m["SubscribeUserIdList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubscribeUserIdList"].type()) {
        vector<StartRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubscribeUserIdList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subscribeUserIdList = make_shared<vector<StartRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList>>(expect1);
      }
    }
  }


  virtual ~StartRtcCloudRecordingRequestSubscribeParams() = default;
};
class StartRtcCloudRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<StartRtcCloudRecordingRequestMixLayoutParams> mixLayoutParams{};
  shared_ptr<StartRtcCloudRecordingRequestMixTranscodeParams> mixTranscodeParams{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<StartRtcCloudRecordingRequestRecordParams> recordParams{};
  shared_ptr<StartRtcCloudRecordingRequestStorageParams> storageParams{};
  shared_ptr<StartRtcCloudRecordingRequestSubscribeParams> subscribeParams{};

  StartRtcCloudRecordingRequest() {}

  explicit StartRtcCloudRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (mixLayoutParams) {
      res["MixLayoutParams"] = mixLayoutParams ? boost::any(mixLayoutParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mixTranscodeParams) {
      res["MixTranscodeParams"] = mixTranscodeParams ? boost::any(mixTranscodeParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (recordParams) {
      res["RecordParams"] = recordParams ? boost::any(recordParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storageParams) {
      res["StorageParams"] = storageParams ? boost::any(storageParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscribeParams) {
      res["SubscribeParams"] = subscribeParams ? boost::any(subscribeParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("MixLayoutParams") != m.end() && !m["MixLayoutParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["MixLayoutParams"].type()) {
        StartRtcCloudRecordingRequestMixLayoutParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MixLayoutParams"]));
        mixLayoutParams = make_shared<StartRtcCloudRecordingRequestMixLayoutParams>(model1);
      }
    }
    if (m.find("MixTranscodeParams") != m.end() && !m["MixTranscodeParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["MixTranscodeParams"].type()) {
        StartRtcCloudRecordingRequestMixTranscodeParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MixTranscodeParams"]));
        mixTranscodeParams = make_shared<StartRtcCloudRecordingRequestMixTranscodeParams>(model1);
      }
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RecordParams") != m.end() && !m["RecordParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordParams"].type()) {
        StartRtcCloudRecordingRequestRecordParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordParams"]));
        recordParams = make_shared<StartRtcCloudRecordingRequestRecordParams>(model1);
      }
    }
    if (m.find("StorageParams") != m.end() && !m["StorageParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["StorageParams"].type()) {
        StartRtcCloudRecordingRequestStorageParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StorageParams"]));
        storageParams = make_shared<StartRtcCloudRecordingRequestStorageParams>(model1);
      }
    }
    if (m.find("SubscribeParams") != m.end() && !m["SubscribeParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscribeParams"].type()) {
        StartRtcCloudRecordingRequestSubscribeParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscribeParams"]));
        subscribeParams = make_shared<StartRtcCloudRecordingRequestSubscribeParams>(model1);
      }
    }
  }


  virtual ~StartRtcCloudRecordingRequest() = default;
};
class StartRtcCloudRecordingShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> mixLayoutParamsShrink{};
  shared_ptr<string> mixTranscodeParamsShrink{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> recordParamsShrink{};
  shared_ptr<string> storageParamsShrink{};
  shared_ptr<string> subscribeParamsShrink{};

  StartRtcCloudRecordingShrinkRequest() {}

  explicit StartRtcCloudRecordingShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (mixLayoutParamsShrink) {
      res["MixLayoutParams"] = boost::any(*mixLayoutParamsShrink);
    }
    if (mixTranscodeParamsShrink) {
      res["MixTranscodeParams"] = boost::any(*mixTranscodeParamsShrink);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (recordParamsShrink) {
      res["RecordParams"] = boost::any(*recordParamsShrink);
    }
    if (storageParamsShrink) {
      res["StorageParams"] = boost::any(*storageParamsShrink);
    }
    if (subscribeParamsShrink) {
      res["SubscribeParams"] = boost::any(*subscribeParamsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("MixLayoutParams") != m.end() && !m["MixLayoutParams"].empty()) {
      mixLayoutParamsShrink = make_shared<string>(boost::any_cast<string>(m["MixLayoutParams"]));
    }
    if (m.find("MixTranscodeParams") != m.end() && !m["MixTranscodeParams"].empty()) {
      mixTranscodeParamsShrink = make_shared<string>(boost::any_cast<string>(m["MixTranscodeParams"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RecordParams") != m.end() && !m["RecordParams"].empty()) {
      recordParamsShrink = make_shared<string>(boost::any_cast<string>(m["RecordParams"]));
    }
    if (m.find("StorageParams") != m.end() && !m["StorageParams"].empty()) {
      storageParamsShrink = make_shared<string>(boost::any_cast<string>(m["StorageParams"]));
    }
    if (m.find("SubscribeParams") != m.end() && !m["SubscribeParams"].empty()) {
      subscribeParamsShrink = make_shared<string>(boost::any_cast<string>(m["SubscribeParams"]));
    }
  }


  virtual ~StartRtcCloudRecordingShrinkRequest() = default;
};
class StartRtcCloudRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  StartRtcCloudRecordingResponseBody() {}

  explicit StartRtcCloudRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~StartRtcCloudRecordingResponseBody() = default;
};
class StartRtcCloudRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartRtcCloudRecordingResponseBody> body{};

  StartRtcCloudRecordingResponse() {}

  explicit StartRtcCloudRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartRtcCloudRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartRtcCloudRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~StartRtcCloudRecordingResponse() = default;
};
class StopCasterRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  StopCasterRequest() {}

  explicit StopCasterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StopCasterRequest() = default;
};
class StopCasterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopCasterResponseBody() {}

  explicit StopCasterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopCasterResponseBody() = default;
};
class StopCasterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopCasterResponseBody> body{};

  StopCasterResponse() {}

  explicit StopCasterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopCasterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopCasterResponseBody>(model1);
      }
    }
  }


  virtual ~StopCasterResponse() = default;
};
class StopCasterSceneRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sceneId{};

  StopCasterSceneRequest() {}

  explicit StopCasterSceneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~StopCasterSceneRequest() = default;
};
class StopCasterSceneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopCasterSceneResponseBody() {}

  explicit StopCasterSceneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopCasterSceneResponseBody() = default;
};
class StopCasterSceneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopCasterSceneResponseBody> body{};

  StopCasterSceneResponse() {}

  explicit StopCasterSceneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopCasterSceneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopCasterSceneResponseBody>(model1);
      }
    }
  }


  virtual ~StopCasterSceneResponse() = default;
};
class StopEdgeTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  StopEdgeTranscodeJobRequest() {}

  explicit StopEdgeTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StopEdgeTranscodeJobRequest() = default;
};
class StopEdgeTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  StopEdgeTranscodeJobResponseBody() {}

  explicit StopEdgeTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopEdgeTranscodeJobResponseBody() = default;
};
class StopEdgeTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopEdgeTranscodeJobResponseBody> body{};

  StopEdgeTranscodeJobResponse() {}

  explicit StopEdgeTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopEdgeTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopEdgeTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~StopEdgeTranscodeJobResponse() = default;
};
class StopLiveDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  StopLiveDomainRequest() {}

  explicit StopLiveDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~StopLiveDomainRequest() = default;
};
class StopLiveDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopLiveDomainResponseBody() {}

  explicit StopLiveDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopLiveDomainResponseBody() = default;
};
class StopLiveDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopLiveDomainResponseBody> body{};

  StopLiveDomainResponse() {}

  explicit StopLiveDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopLiveDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopLiveDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StopLiveDomainResponse() = default;
};
class StopLiveMPUTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> taskId{};

  StopLiveMPUTaskRequest() {}

  explicit StopLiveMPUTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~StopLiveMPUTaskRequest() = default;
};
class StopLiveMPUTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopLiveMPUTaskResponseBody() {}

  explicit StopLiveMPUTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopLiveMPUTaskResponseBody() = default;
};
class StopLiveMPUTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopLiveMPUTaskResponseBody> body{};

  StopLiveMPUTaskResponse() {}

  explicit StopLiveMPUTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopLiveMPUTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopLiveMPUTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StopLiveMPUTaskResponse() = default;
};
class StopLivePullToPushRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  StopLivePullToPushRequest() {}

  explicit StopLivePullToPushRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~StopLivePullToPushRequest() = default;
};
class StopLivePullToPushResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  StopLivePullToPushResponseBody() {}

  explicit StopLivePullToPushResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~StopLivePullToPushResponseBody() = default;
};
class StopLivePullToPushResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopLivePullToPushResponseBody> body{};

  StopLivePullToPushResponse() {}

  explicit StopLivePullToPushResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopLivePullToPushResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopLivePullToPushResponseBody>(model1);
      }
    }
  }


  virtual ~StopLivePullToPushResponse() = default;
};
class StopLiveStreamMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> monitorId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  StopLiveStreamMonitorRequest() {}

  explicit StopLiveStreamMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StopLiveStreamMonitorRequest() = default;
};
class StopLiveStreamMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopLiveStreamMonitorResponseBody() {}

  explicit StopLiveStreamMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopLiveStreamMonitorResponseBody() = default;
};
class StopLiveStreamMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopLiveStreamMonitorResponseBody> body{};

  StopLiveStreamMonitorResponse() {}

  explicit StopLiveStreamMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopLiveStreamMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopLiveStreamMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~StopLiveStreamMonitorResponse() = default;
};
class StopPlaylistRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> programId{};
  shared_ptr<string> regionId{};

  StopPlaylistRequest() {}

  explicit StopPlaylistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StopPlaylistRequest() = default;
};
class StopPlaylistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> programId{};
  shared_ptr<string> requestId{};

  StopPlaylistResponseBody() {}

  explicit StopPlaylistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (programId) {
      res["ProgramId"] = boost::any(*programId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProgramId") != m.end() && !m["ProgramId"].empty()) {
      programId = make_shared<string>(boost::any_cast<string>(m["ProgramId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopPlaylistResponseBody() = default;
};
class StopPlaylistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopPlaylistResponseBody> body{};

  StopPlaylistResponse() {}

  explicit StopPlaylistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopPlaylistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopPlaylistResponseBody>(model1);
      }
    }
  }


  virtual ~StopPlaylistResponse() = default;
};
class StopRtcAsrTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  StopRtcAsrTaskRequest() {}

  explicit StopRtcAsrTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~StopRtcAsrTaskRequest() = default;
};
class StopRtcAsrTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  StopRtcAsrTaskResponseBody() {}

  explicit StopRtcAsrTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~StopRtcAsrTaskResponseBody() = default;
};
class StopRtcAsrTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopRtcAsrTaskResponseBody> body{};

  StopRtcAsrTaskResponse() {}

  explicit StopRtcAsrTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopRtcAsrTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopRtcAsrTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StopRtcAsrTaskResponse() = default;
};
class StopRtcCloudRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  StopRtcCloudRecordingRequest() {}

  explicit StopRtcCloudRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~StopRtcCloudRecordingRequest() = default;
};
class StopRtcCloudRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  StopRtcCloudRecordingResponseBody() {}

  explicit StopRtcCloudRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~StopRtcCloudRecordingResponseBody() = default;
};
class StopRtcCloudRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopRtcCloudRecordingResponseBody> body{};

  StopRtcCloudRecordingResponse() {}

  explicit StopRtcCloudRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopRtcCloudRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopRtcCloudRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~StopRtcCloudRecordingResponse() = default;
};
class TagLiveResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagLiveResourcesRequestTag() {}

  explicit TagLiveResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagLiveResourcesRequestTag() = default;
};
class TagLiveResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagLiveResourcesRequestTag>> tag{};

  TagLiveResourcesRequest() {}

  explicit TagLiveResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagLiveResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagLiveResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagLiveResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagLiveResourcesRequest() = default;
};
class TagLiveResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagLiveResourcesResponseBody() {}

  explicit TagLiveResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagLiveResourcesResponseBody() = default;
};
class TagLiveResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagLiveResourcesResponseBody> body{};

  TagLiveResourcesResponse() {}

  explicit TagLiveResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagLiveResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagLiveResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagLiveResourcesResponse() = default;
};
class UnTagLiveResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UnTagLiveResourcesRequest() {}

  explicit UnTagLiveResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UnTagLiveResourcesRequest() = default;
};
class UnTagLiveResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnTagLiveResourcesResponseBody() {}

  explicit UnTagLiveResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnTagLiveResourcesResponseBody() = default;
};
class UnTagLiveResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnTagLiveResourcesResponseBody> body{};

  UnTagLiveResourcesResponse() {}

  explicit UnTagLiveResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnTagLiveResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnTagLiveResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UnTagLiveResourcesResponse() = default;
};
class UnbanLiveMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> groupId{};

  UnbanLiveMessageGroupRequest() {}

  explicit UnbanLiveMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~UnbanLiveMessageGroupRequest() = default;
};
class UnbanLiveMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbanLiveMessageGroupResponseBody() {}

  explicit UnbanLiveMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbanLiveMessageGroupResponseBody() = default;
};
class UnbanLiveMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbanLiveMessageGroupResponseBody> body{};

  UnbanLiveMessageGroupResponse() {}

  explicit UnbanLiveMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbanLiveMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbanLiveMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UnbanLiveMessageGroupResponse() = default;
};
class UpdateCasterResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  UpdateCasterResourceGroupRequest() {}

  explicit UpdateCasterResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateCasterResourceGroupRequest() = default;
};
class UpdateCasterResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCasterResourceGroupResponseBody() {}

  explicit UpdateCasterResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCasterResourceGroupResponseBody() = default;
};
class UpdateCasterResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCasterResourceGroupResponseBody> body{};

  UpdateCasterResourceGroupResponse() {}

  explicit UpdateCasterResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCasterResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCasterResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCasterResourceGroupResponse() = default;
};
class UpdateCasterSceneAudioRequestAudioLayer : public Darabonba::Model {
public:
  shared_ptr<string> filter{};
  shared_ptr<long> fixedDelayDuration{};
  shared_ptr<string> validChannel{};
  shared_ptr<double> volumeRate{};

  UpdateCasterSceneAudioRequestAudioLayer() {}

  explicit UpdateCasterSceneAudioRequestAudioLayer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (fixedDelayDuration) {
      res["FixedDelayDuration"] = boost::any(*fixedDelayDuration);
    }
    if (validChannel) {
      res["ValidChannel"] = boost::any(*validChannel);
    }
    if (volumeRate) {
      res["VolumeRate"] = boost::any(*volumeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("FixedDelayDuration") != m.end() && !m["FixedDelayDuration"].empty()) {
      fixedDelayDuration = make_shared<long>(boost::any_cast<long>(m["FixedDelayDuration"]));
    }
    if (m.find("ValidChannel") != m.end() && !m["ValidChannel"].empty()) {
      validChannel = make_shared<string>(boost::any_cast<string>(m["ValidChannel"]));
    }
    if (m.find("VolumeRate") != m.end() && !m["VolumeRate"].empty()) {
      volumeRate = make_shared<double>(boost::any_cast<double>(m["VolumeRate"]));
    }
  }


  virtual ~UpdateCasterSceneAudioRequestAudioLayer() = default;
};
class UpdateCasterSceneAudioRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateCasterSceneAudioRequestAudioLayer>> audioLayer{};
  shared_ptr<string> casterId{};
  shared_ptr<long> followEnable{};
  shared_ptr<vector<string>> mixList{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sceneId{};

  UpdateCasterSceneAudioRequest() {}

  explicit UpdateCasterSceneAudioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLayer) {
      vector<boost::any> temp1;
      for(auto item1:*audioLayer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioLayer"] = boost::any(temp1);
    }
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (followEnable) {
      res["FollowEnable"] = boost::any(*followEnable);
    }
    if (mixList) {
      res["MixList"] = boost::any(*mixList);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLayer") != m.end() && !m["AudioLayer"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioLayer"].type()) {
        vector<UpdateCasterSceneAudioRequestAudioLayer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioLayer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCasterSceneAudioRequestAudioLayer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioLayer = make_shared<vector<UpdateCasterSceneAudioRequestAudioLayer>>(expect1);
      }
    }
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("FollowEnable") != m.end() && !m["FollowEnable"].empty()) {
      followEnable = make_shared<long>(boost::any_cast<long>(m["FollowEnable"]));
    }
    if (m.find("MixList") != m.end() && !m["MixList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MixList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MixList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mixList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~UpdateCasterSceneAudioRequest() = default;
};
class UpdateCasterSceneAudioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCasterSceneAudioResponseBody() {}

  explicit UpdateCasterSceneAudioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCasterSceneAudioResponseBody() = default;
};
class UpdateCasterSceneAudioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCasterSceneAudioResponseBody> body{};

  UpdateCasterSceneAudioResponse() {}

  explicit UpdateCasterSceneAudioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCasterSceneAudioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCasterSceneAudioResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCasterSceneAudioResponse() = default;
};
class UpdateCasterSceneConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> casterId{};
  shared_ptr<vector<string>> componentId{};
  shared_ptr<string> layoutId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sceneId{};

  UpdateCasterSceneConfigRequest() {}

  explicit UpdateCasterSceneConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (casterId) {
      res["CasterId"] = boost::any(*casterId);
    }
    if (componentId) {
      res["ComponentId"] = boost::any(*componentId);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sceneId) {
      res["SceneId"] = boost::any(*sceneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CasterId") != m.end() && !m["CasterId"].empty()) {
      casterId = make_shared<string>(boost::any_cast<string>(m["CasterId"]));
    }
    if (m.find("ComponentId") != m.end() && !m["ComponentId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SceneId") != m.end() && !m["SceneId"].empty()) {
      sceneId = make_shared<string>(boost::any_cast<string>(m["SceneId"]));
    }
  }


  virtual ~UpdateCasterSceneConfigRequest() = default;
};
class UpdateCasterSceneConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCasterSceneConfigResponseBody() {}

  explicit UpdateCasterSceneConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCasterSceneConfigResponseBody() = default;
};
class UpdateCasterSceneConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCasterSceneConfigResponseBody> body{};

  UpdateCasterSceneConfigResponse() {}

  explicit UpdateCasterSceneConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCasterSceneConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCasterSceneConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCasterSceneConfigResponse() = default;
};
class UpdateCustomLiveStreamTranscodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<long> audioBitrate{};
  shared_ptr<long> audioChannelNum{};
  shared_ptr<string> audioCodec{};
  shared_ptr<string> audioProfile{};
  shared_ptr<long> audioRate{};
  shared_ptr<string> bitrateWithSource{};
  shared_ptr<string> domain{};
  shared_ptr<string> encryptParameters{};
  shared_ptr<string> extWithSource{};
  shared_ptr<long> FPS{};
  shared_ptr<string> fpsWithSource{};
  shared_ptr<string> gop{};
  shared_ptr<long> height{};
  shared_ptr<string> lazy{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> profile{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resWithSource{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<long> width{};

  UpdateCustomLiveStreamTranscodeRequest() {}

  explicit UpdateCustomLiveStreamTranscodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannelNum) {
      res["AudioChannelNum"] = boost::any(*audioChannelNum);
    }
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioProfile) {
      res["AudioProfile"] = boost::any(*audioProfile);
    }
    if (audioRate) {
      res["AudioRate"] = boost::any(*audioRate);
    }
    if (bitrateWithSource) {
      res["BitrateWithSource"] = boost::any(*bitrateWithSource);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (encryptParameters) {
      res["EncryptParameters"] = boost::any(*encryptParameters);
    }
    if (extWithSource) {
      res["ExtWithSource"] = boost::any(*extWithSource);
    }
    if (FPS) {
      res["FPS"] = boost::any(*FPS);
    }
    if (fpsWithSource) {
      res["FpsWithSource"] = boost::any(*fpsWithSource);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (lazy) {
      res["Lazy"] = boost::any(*lazy);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resWithSource) {
      res["ResWithSource"] = boost::any(*resWithSource);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<long>(boost::any_cast<long>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannelNum") != m.end() && !m["AudioChannelNum"].empty()) {
      audioChannelNum = make_shared<long>(boost::any_cast<long>(m["AudioChannelNum"]));
    }
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioProfile") != m.end() && !m["AudioProfile"].empty()) {
      audioProfile = make_shared<string>(boost::any_cast<string>(m["AudioProfile"]));
    }
    if (m.find("AudioRate") != m.end() && !m["AudioRate"].empty()) {
      audioRate = make_shared<long>(boost::any_cast<long>(m["AudioRate"]));
    }
    if (m.find("BitrateWithSource") != m.end() && !m["BitrateWithSource"].empty()) {
      bitrateWithSource = make_shared<string>(boost::any_cast<string>(m["BitrateWithSource"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EncryptParameters") != m.end() && !m["EncryptParameters"].empty()) {
      encryptParameters = make_shared<string>(boost::any_cast<string>(m["EncryptParameters"]));
    }
    if (m.find("ExtWithSource") != m.end() && !m["ExtWithSource"].empty()) {
      extWithSource = make_shared<string>(boost::any_cast<string>(m["ExtWithSource"]));
    }
    if (m.find("FPS") != m.end() && !m["FPS"].empty()) {
      FPS = make_shared<long>(boost::any_cast<long>(m["FPS"]));
    }
    if (m.find("FpsWithSource") != m.end() && !m["FpsWithSource"].empty()) {
      fpsWithSource = make_shared<string>(boost::any_cast<string>(m["FpsWithSource"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Lazy") != m.end() && !m["Lazy"].empty()) {
      lazy = make_shared<string>(boost::any_cast<string>(m["Lazy"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<long>(boost::any_cast<long>(m["Profile"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResWithSource") != m.end() && !m["ResWithSource"].empty()) {
      resWithSource = make_shared<string>(boost::any_cast<string>(m["ResWithSource"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~UpdateCustomLiveStreamTranscodeRequest() = default;
};
class UpdateCustomLiveStreamTranscodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCustomLiveStreamTranscodeResponseBody() {}

  explicit UpdateCustomLiveStreamTranscodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCustomLiveStreamTranscodeResponseBody() = default;
};
class UpdateCustomLiveStreamTranscodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCustomLiveStreamTranscodeResponseBody> body{};

  UpdateCustomLiveStreamTranscodeResponse() {}

  explicit UpdateCustomLiveStreamTranscodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomLiveStreamTranscodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomLiveStreamTranscodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomLiveStreamTranscodeResponse() = default;
};
class UpdateEdgeTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamInput{};
  shared_ptr<string> streamOutput{};
  shared_ptr<string> templateId{};

  UpdateEdgeTranscodeJobRequest() {}

  explicit UpdateEdgeTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamInput) {
      res["StreamInput"] = boost::any(*streamInput);
    }
    if (streamOutput) {
      res["StreamOutput"] = boost::any(*streamOutput);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInput = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("StreamOutput") != m.end() && !m["StreamOutput"].empty()) {
      streamOutput = make_shared<string>(boost::any_cast<string>(m["StreamOutput"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateEdgeTranscodeJobRequest() = default;
};
class UpdateEdgeTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  UpdateEdgeTranscodeJobResponseBody() {}

  explicit UpdateEdgeTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEdgeTranscodeJobResponseBody() = default;
};
class UpdateEdgeTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEdgeTranscodeJobResponseBody> body{};

  UpdateEdgeTranscodeJobResponse() {}

  explicit UpdateEdgeTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEdgeTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEdgeTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEdgeTranscodeJobResponse() = default;
};
class UpdateEventSubRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> channelId{};
  shared_ptr<vector<string>> events{};
  shared_ptr<string> subscribeId{};
  shared_ptr<vector<string>> users{};

  UpdateEventSubRequest() {}

  explicit UpdateEventSubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (events) {
      res["Events"] = boost::any(*events);
    }
    if (subscribeId) {
      res["SubscribeId"] = boost::any(*subscribeId);
    }
    if (users) {
      res["Users"] = boost::any(*users);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Events") != m.end() && !m["Events"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Events"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Events"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      events = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubscribeId") != m.end() && !m["SubscribeId"].empty()) {
      subscribeId = make_shared<string>(boost::any_cast<string>(m["SubscribeId"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Users"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      users = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateEventSubRequest() = default;
};
class UpdateEventSubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateEventSubResponseBody() {}

  explicit UpdateEventSubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEventSubResponseBody() = default;
};
class UpdateEventSubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEventSubResponseBody> body{};

  UpdateEventSubResponse() {}

  explicit UpdateEventSubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEventSubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEventSubResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEventSubResponse() = default;
};
class UpdateLiveAIProduceRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<bool> isLazy{};
  shared_ptr<string> liveTemplate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> rulesId{};
  shared_ptr<string> studioName{};
  shared_ptr<string> subtitleId{};
  shared_ptr<string> subtitleName{};
  shared_ptr<string> suffix{};

  UpdateLiveAIProduceRulesRequest() {}

  explicit UpdateLiveAIProduceRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (isLazy) {
      res["IsLazy"] = boost::any(*isLazy);
    }
    if (liveTemplate) {
      res["LiveTemplate"] = boost::any(*liveTemplate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rulesId) {
      res["RulesId"] = boost::any(*rulesId);
    }
    if (studioName) {
      res["StudioName"] = boost::any(*studioName);
    }
    if (subtitleId) {
      res["SubtitleId"] = boost::any(*subtitleId);
    }
    if (subtitleName) {
      res["SubtitleName"] = boost::any(*subtitleName);
    }
    if (suffix) {
      res["Suffix"] = boost::any(*suffix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("IsLazy") != m.end() && !m["IsLazy"].empty()) {
      isLazy = make_shared<bool>(boost::any_cast<bool>(m["IsLazy"]));
    }
    if (m.find("LiveTemplate") != m.end() && !m["LiveTemplate"].empty()) {
      liveTemplate = make_shared<string>(boost::any_cast<string>(m["LiveTemplate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RulesId") != m.end() && !m["RulesId"].empty()) {
      rulesId = make_shared<string>(boost::any_cast<string>(m["RulesId"]));
    }
    if (m.find("StudioName") != m.end() && !m["StudioName"].empty()) {
      studioName = make_shared<string>(boost::any_cast<string>(m["StudioName"]));
    }
    if (m.find("SubtitleId") != m.end() && !m["SubtitleId"].empty()) {
      subtitleId = make_shared<string>(boost::any_cast<string>(m["SubtitleId"]));
    }
    if (m.find("SubtitleName") != m.end() && !m["SubtitleName"].empty()) {
      subtitleName = make_shared<string>(boost::any_cast<string>(m["SubtitleName"]));
    }
    if (m.find("Suffix") != m.end() && !m["Suffix"].empty()) {
      suffix = make_shared<string>(boost::any_cast<string>(m["Suffix"]));
    }
  }


  virtual ~UpdateLiveAIProduceRulesRequest() = default;
};
class UpdateLiveAIProduceRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveAIProduceRulesResponseBody() {}

  explicit UpdateLiveAIProduceRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveAIProduceRulesResponseBody() = default;
};
class UpdateLiveAIProduceRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveAIProduceRulesResponseBody> body{};

  UpdateLiveAIProduceRulesResponse() {}

  explicit UpdateLiveAIProduceRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveAIProduceRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveAIProduceRulesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveAIProduceRulesResponse() = default;
};
class UpdateLiveAISubtitleRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<double> bgWidthNormalized{};
  shared_ptr<double> borderWidthNormalized{};
  shared_ptr<string> description{};
  shared_ptr<string> dstLanguage{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<double> fontSizeNormalized{};
  shared_ptr<string> height{};
  shared_ptr<long> maxLines{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<double>> positionNormalized{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> showSourceLan{};
  shared_ptr<string> srcLanguage{};
  shared_ptr<string> subtitleId{};
  shared_ptr<string> subtitleName{};
  shared_ptr<string> width{};
  shared_ptr<long> wordPerLine{};

  UpdateLiveAISubtitleRequest() {}

  explicit UpdateLiveAISubtitleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (bgWidthNormalized) {
      res["BgWidthNormalized"] = boost::any(*bgWidthNormalized);
    }
    if (borderWidthNormalized) {
      res["BorderWidthNormalized"] = boost::any(*borderWidthNormalized);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dstLanguage) {
      res["DstLanguage"] = boost::any(*dstLanguage);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSizeNormalized) {
      res["FontSizeNormalized"] = boost::any(*fontSizeNormalized);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxLines) {
      res["MaxLines"] = boost::any(*maxLines);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (positionNormalized) {
      res["PositionNormalized"] = boost::any(*positionNormalized);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showSourceLan) {
      res["ShowSourceLan"] = boost::any(*showSourceLan);
    }
    if (srcLanguage) {
      res["SrcLanguage"] = boost::any(*srcLanguage);
    }
    if (subtitleId) {
      res["SubtitleId"] = boost::any(*subtitleId);
    }
    if (subtitleName) {
      res["SubtitleName"] = boost::any(*subtitleName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (wordPerLine) {
      res["WordPerLine"] = boost::any(*wordPerLine);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("BgWidthNormalized") != m.end() && !m["BgWidthNormalized"].empty()) {
      bgWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BgWidthNormalized"]));
    }
    if (m.find("BorderWidthNormalized") != m.end() && !m["BorderWidthNormalized"].empty()) {
      borderWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BorderWidthNormalized"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DstLanguage") != m.end() && !m["DstLanguage"].empty()) {
      dstLanguage = make_shared<string>(boost::any_cast<string>(m["DstLanguage"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSizeNormalized") != m.end() && !m["FontSizeNormalized"].empty()) {
      fontSizeNormalized = make_shared<double>(boost::any_cast<double>(m["FontSizeNormalized"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxLines") != m.end() && !m["MaxLines"].empty()) {
      maxLines = make_shared<long>(boost::any_cast<long>(m["MaxLines"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["PositionNormalized"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PositionNormalized"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      positionNormalized = make_shared<vector<double>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowSourceLan") != m.end() && !m["ShowSourceLan"].empty()) {
      showSourceLan = make_shared<bool>(boost::any_cast<bool>(m["ShowSourceLan"]));
    }
    if (m.find("SrcLanguage") != m.end() && !m["SrcLanguage"].empty()) {
      srcLanguage = make_shared<string>(boost::any_cast<string>(m["SrcLanguage"]));
    }
    if (m.find("SubtitleId") != m.end() && !m["SubtitleId"].empty()) {
      subtitleId = make_shared<string>(boost::any_cast<string>(m["SubtitleId"]));
    }
    if (m.find("SubtitleName") != m.end() && !m["SubtitleName"].empty()) {
      subtitleName = make_shared<string>(boost::any_cast<string>(m["SubtitleName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("WordPerLine") != m.end() && !m["WordPerLine"].empty()) {
      wordPerLine = make_shared<long>(boost::any_cast<long>(m["WordPerLine"]));
    }
  }


  virtual ~UpdateLiveAISubtitleRequest() = default;
};
class UpdateLiveAISubtitleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<double> bgWidthNormalized{};
  shared_ptr<double> borderWidthNormalized{};
  shared_ptr<string> description{};
  shared_ptr<string> dstLanguage{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<double> fontSizeNormalized{};
  shared_ptr<string> height{};
  shared_ptr<long> maxLines{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> positionNormalizedShrink{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> showSourceLan{};
  shared_ptr<string> srcLanguage{};
  shared_ptr<string> subtitleId{};
  shared_ptr<string> subtitleName{};
  shared_ptr<string> width{};
  shared_ptr<long> wordPerLine{};

  UpdateLiveAISubtitleShrinkRequest() {}

  explicit UpdateLiveAISubtitleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (bgWidthNormalized) {
      res["BgWidthNormalized"] = boost::any(*bgWidthNormalized);
    }
    if (borderWidthNormalized) {
      res["BorderWidthNormalized"] = boost::any(*borderWidthNormalized);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dstLanguage) {
      res["DstLanguage"] = boost::any(*dstLanguage);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSizeNormalized) {
      res["FontSizeNormalized"] = boost::any(*fontSizeNormalized);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxLines) {
      res["MaxLines"] = boost::any(*maxLines);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (positionNormalizedShrink) {
      res["PositionNormalized"] = boost::any(*positionNormalizedShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showSourceLan) {
      res["ShowSourceLan"] = boost::any(*showSourceLan);
    }
    if (srcLanguage) {
      res["SrcLanguage"] = boost::any(*srcLanguage);
    }
    if (subtitleId) {
      res["SubtitleId"] = boost::any(*subtitleId);
    }
    if (subtitleName) {
      res["SubtitleName"] = boost::any(*subtitleName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (wordPerLine) {
      res["WordPerLine"] = boost::any(*wordPerLine);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("BgWidthNormalized") != m.end() && !m["BgWidthNormalized"].empty()) {
      bgWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BgWidthNormalized"]));
    }
    if (m.find("BorderWidthNormalized") != m.end() && !m["BorderWidthNormalized"].empty()) {
      borderWidthNormalized = make_shared<double>(boost::any_cast<double>(m["BorderWidthNormalized"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DstLanguage") != m.end() && !m["DstLanguage"].empty()) {
      dstLanguage = make_shared<string>(boost::any_cast<string>(m["DstLanguage"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSizeNormalized") != m.end() && !m["FontSizeNormalized"].empty()) {
      fontSizeNormalized = make_shared<double>(boost::any_cast<double>(m["FontSizeNormalized"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxLines") != m.end() && !m["MaxLines"].empty()) {
      maxLines = make_shared<long>(boost::any_cast<long>(m["MaxLines"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PositionNormalized") != m.end() && !m["PositionNormalized"].empty()) {
      positionNormalizedShrink = make_shared<string>(boost::any_cast<string>(m["PositionNormalized"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowSourceLan") != m.end() && !m["ShowSourceLan"].empty()) {
      showSourceLan = make_shared<bool>(boost::any_cast<bool>(m["ShowSourceLan"]));
    }
    if (m.find("SrcLanguage") != m.end() && !m["SrcLanguage"].empty()) {
      srcLanguage = make_shared<string>(boost::any_cast<string>(m["SrcLanguage"]));
    }
    if (m.find("SubtitleId") != m.end() && !m["SubtitleId"].empty()) {
      subtitleId = make_shared<string>(boost::any_cast<string>(m["SubtitleId"]));
    }
    if (m.find("SubtitleName") != m.end() && !m["SubtitleName"].empty()) {
      subtitleName = make_shared<string>(boost::any_cast<string>(m["SubtitleName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("WordPerLine") != m.end() && !m["WordPerLine"].empty()) {
      wordPerLine = make_shared<long>(boost::any_cast<long>(m["WordPerLine"]));
    }
  }


  virtual ~UpdateLiveAISubtitleShrinkRequest() = default;
};
class UpdateLiveAISubtitleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveAISubtitleResponseBody() {}

  explicit UpdateLiveAISubtitleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveAISubtitleResponseBody() = default;
};
class UpdateLiveAISubtitleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveAISubtitleResponseBody> body{};

  UpdateLiveAISubtitleResponse() {}

  explicit UpdateLiveAISubtitleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveAISubtitleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveAISubtitleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveAISubtitleResponse() = default;
};
class UpdateLiveAppRecordConfigRequestRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<long> sliceDuration{};

  UpdateLiveAppRecordConfigRequestRecordFormat() {}

  explicit UpdateLiveAppRecordConfigRequestRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
  }


  virtual ~UpdateLiveAppRecordConfigRequestRecordFormat() = default;
};
class UpdateLiveAppRecordConfigRequestTranscodeRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<long> sliceDuration{};

  UpdateLiveAppRecordConfigRequestTranscodeRecordFormat() {}

  explicit UpdateLiveAppRecordConfigRequestTranscodeRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
  }


  virtual ~UpdateLiveAppRecordConfigRequestTranscodeRecordFormat() = default;
};
class UpdateLiveAppRecordConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> delayTime{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> onDemand{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<UpdateLiveAppRecordConfigRequestRecordFormat>> recordFormat{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<vector<UpdateLiveAppRecordConfigRequestTranscodeRecordFormat>> transcodeRecordFormat{};
  shared_ptr<vector<string>> transcodeTemplates{};

  UpdateLiveAppRecordConfigRequest() {}

  explicit UpdateLiveAppRecordConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (delayTime) {
      res["DelayTime"] = boost::any(*delayTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (onDemand) {
      res["OnDemand"] = boost::any(*onDemand);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transcodeRecordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeRecordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeRecordFormat"] = boost::any(temp1);
    }
    if (transcodeTemplates) {
      res["TranscodeTemplates"] = boost::any(*transcodeTemplates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DelayTime") != m.end() && !m["DelayTime"].empty()) {
      delayTime = make_shared<long>(boost::any_cast<long>(m["DelayTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OnDemand") != m.end() && !m["OnDemand"].empty()) {
      onDemand = make_shared<long>(boost::any_cast<long>(m["OnDemand"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<UpdateLiveAppRecordConfigRequestRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateLiveAppRecordConfigRequestRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<UpdateLiveAppRecordConfigRequestRecordFormat>>(expect1);
      }
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TranscodeRecordFormat") != m.end() && !m["TranscodeRecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeRecordFormat"].type()) {
        vector<UpdateLiveAppRecordConfigRequestTranscodeRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeRecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateLiveAppRecordConfigRequestTranscodeRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeRecordFormat = make_shared<vector<UpdateLiveAppRecordConfigRequestTranscodeRecordFormat>>(expect1);
      }
    }
    if (m.find("TranscodeTemplates") != m.end() && !m["TranscodeTemplates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TranscodeTemplates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TranscodeTemplates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      transcodeTemplates = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateLiveAppRecordConfigRequest() = default;
};
class UpdateLiveAppRecordConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveAppRecordConfigResponseBody() {}

  explicit UpdateLiveAppRecordConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveAppRecordConfigResponseBody() = default;
};
class UpdateLiveAppRecordConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveAppRecordConfigResponseBody> body{};

  UpdateLiveAppRecordConfigResponse() {}

  explicit UpdateLiveAppRecordConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveAppRecordConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveAppRecordConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveAppRecordConfigResponse() = default;
};
class UpdateLiveAppSnapshotConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> callback{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> overwriteOssObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sequenceOssObject{};
  shared_ptr<long> timeInterval{};

  UpdateLiveAppSnapshotConfigRequest() {}

  explicit UpdateLiveAppSnapshotConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (overwriteOssObject) {
      res["OverwriteOssObject"] = boost::any(*overwriteOssObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sequenceOssObject) {
      res["SequenceOssObject"] = boost::any(*sequenceOssObject);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OverwriteOssObject") != m.end() && !m["OverwriteOssObject"].empty()) {
      overwriteOssObject = make_shared<string>(boost::any_cast<string>(m["OverwriteOssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SequenceOssObject") != m.end() && !m["SequenceOssObject"].empty()) {
      sequenceOssObject = make_shared<string>(boost::any_cast<string>(m["SequenceOssObject"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~UpdateLiveAppSnapshotConfigRequest() = default;
};
class UpdateLiveAppSnapshotConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveAppSnapshotConfigResponseBody() {}

  explicit UpdateLiveAppSnapshotConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveAppSnapshotConfigResponseBody() = default;
};
class UpdateLiveAppSnapshotConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveAppSnapshotConfigResponseBody> body{};

  UpdateLiveAppSnapshotConfigResponse() {}

  explicit UpdateLiveAppSnapshotConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveAppSnapshotConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveAppSnapshotConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveAppSnapshotConfigResponse() = default;
};
class UpdateLiveAudioAuditConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> bizType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};

  UpdateLiveAudioAuditConfigRequest() {}

  explicit UpdateLiveAudioAuditConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~UpdateLiveAudioAuditConfigRequest() = default;
};
class UpdateLiveAudioAuditConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveAudioAuditConfigResponseBody() {}

  explicit UpdateLiveAudioAuditConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveAudioAuditConfigResponseBody() = default;
};
class UpdateLiveAudioAuditConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveAudioAuditConfigResponseBody> body{};

  UpdateLiveAudioAuditConfigResponse() {}

  explicit UpdateLiveAudioAuditConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveAudioAuditConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveAudioAuditConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveAudioAuditConfigResponse() = default;
};
class UpdateLiveAudioAuditNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> callback{};
  shared_ptr<string> callbackTemplate{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  UpdateLiveAudioAuditNotifyConfigRequest() {}

  explicit UpdateLiveAudioAuditNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (callbackTemplate) {
      res["CallbackTemplate"] = boost::any(*callbackTemplate);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CallbackTemplate") != m.end() && !m["CallbackTemplate"].empty()) {
      callbackTemplate = make_shared<string>(boost::any_cast<string>(m["CallbackTemplate"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateLiveAudioAuditNotifyConfigRequest() = default;
};
class UpdateLiveAudioAuditNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveAudioAuditNotifyConfigResponseBody() {}

  explicit UpdateLiveAudioAuditNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveAudioAuditNotifyConfigResponseBody() = default;
};
class UpdateLiveAudioAuditNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveAudioAuditNotifyConfigResponseBody> body{};

  UpdateLiveAudioAuditNotifyConfigResponse() {}

  explicit UpdateLiveAudioAuditNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveAudioAuditNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveAudioAuditNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveAudioAuditNotifyConfigResponse() = default;
};
class UpdateLiveCenterTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dstUrl{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> transferArgs{};

  UpdateLiveCenterTransferRequest() {}

  explicit UpdateLiveCenterTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dstUrl) {
      res["DstUrl"] = boost::any(*dstUrl);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transferArgs) {
      res["TransferArgs"] = boost::any(*transferArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DstUrl") != m.end() && !m["DstUrl"].empty()) {
      dstUrl = make_shared<string>(boost::any_cast<string>(m["DstUrl"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TransferArgs") != m.end() && !m["TransferArgs"].empty()) {
      transferArgs = make_shared<string>(boost::any_cast<string>(m["TransferArgs"]));
    }
  }


  virtual ~UpdateLiveCenterTransferRequest() = default;
};
class UpdateLiveCenterTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveCenterTransferResponseBody() {}

  explicit UpdateLiveCenterTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveCenterTransferResponseBody() = default;
};
class UpdateLiveCenterTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveCenterTransferResponseBody> body{};

  UpdateLiveCenterTransferResponse() {}

  explicit UpdateLiveCenterTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveCenterTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveCenterTransferResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveCenterTransferResponse() = default;
};
class UpdateLiveDelayConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<long> delayTime{};
  shared_ptr<string> domain{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stream{};
  shared_ptr<string> taskTriggerMode{};

  UpdateLiveDelayConfigRequest() {}

  explicit UpdateLiveDelayConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (delayTime) {
      res["DelayTime"] = boost::any(*delayTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (taskTriggerMode) {
      res["TaskTriggerMode"] = boost::any(*taskTriggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("DelayTime") != m.end() && !m["DelayTime"].empty()) {
      delayTime = make_shared<long>(boost::any_cast<long>(m["DelayTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("TaskTriggerMode") != m.end() && !m["TaskTriggerMode"].empty()) {
      taskTriggerMode = make_shared<string>(boost::any_cast<string>(m["TaskTriggerMode"]));
    }
  }


  virtual ~UpdateLiveDelayConfigRequest() = default;
};
class UpdateLiveDelayConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveDelayConfigResponseBody() {}

  explicit UpdateLiveDelayConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveDelayConfigResponseBody() = default;
};
class UpdateLiveDelayConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveDelayConfigResponseBody> body{};

  UpdateLiveDelayConfigResponse() {}

  explicit UpdateLiveDelayConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveDelayConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveDelayConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveDelayConfigResponse() = default;
};
class UpdateLiveDetectNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  UpdateLiveDetectNotifyConfigRequest() {}

  explicit UpdateLiveDetectNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~UpdateLiveDetectNotifyConfigRequest() = default;
};
class UpdateLiveDetectNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveDetectNotifyConfigResponseBody() {}

  explicit UpdateLiveDetectNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveDetectNotifyConfigResponseBody() = default;
};
class UpdateLiveDetectNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveDetectNotifyConfigResponseBody> body{};

  UpdateLiveDetectNotifyConfigResponse() {}

  explicit UpdateLiveDetectNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveDetectNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveDetectNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveDetectNotifyConfigResponse() = default;
};
class UpdateLiveMPUTaskRequestMultiStreamURL : public Darabonba::Model {
public:
  shared_ptr<bool> isAliCdn{};
  shared_ptr<string> URL{};

  UpdateLiveMPUTaskRequestMultiStreamURL() {}

  explicit UpdateLiveMPUTaskRequestMultiStreamURL(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isAliCdn) {
      res["IsAliCdn"] = boost::any(*isAliCdn);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsAliCdn") != m.end() && !m["IsAliCdn"].empty()) {
      isAliCdn = make_shared<bool>(boost::any_cast<bool>(m["IsAliCdn"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~UpdateLiveMPUTaskRequestMultiStreamURL() = default;
};
class UpdateLiveMPUTaskRequestSeiParamsLayoutVolume : public Darabonba::Model {
public:
  shared_ptr<string> followIdr{};
  shared_ptr<string> interval{};

  UpdateLiveMPUTaskRequestSeiParamsLayoutVolume() {}

  explicit UpdateLiveMPUTaskRequestSeiParamsLayoutVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (followIdr) {
      res["FollowIdr"] = boost::any(*followIdr);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FollowIdr") != m.end() && !m["FollowIdr"].empty()) {
      followIdr = make_shared<string>(boost::any_cast<string>(m["FollowIdr"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
  }


  virtual ~UpdateLiveMPUTaskRequestSeiParamsLayoutVolume() = default;
};
class UpdateLiveMPUTaskRequestSeiParamsPassThrough : public Darabonba::Model {
public:
  shared_ptr<string> followIdr{};
  shared_ptr<string> interval{};
  shared_ptr<string> payloadContent{};
  shared_ptr<string> payloadContentKey{};

  UpdateLiveMPUTaskRequestSeiParamsPassThrough() {}

  explicit UpdateLiveMPUTaskRequestSeiParamsPassThrough(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (followIdr) {
      res["FollowIdr"] = boost::any(*followIdr);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (payloadContent) {
      res["PayloadContent"] = boost::any(*payloadContent);
    }
    if (payloadContentKey) {
      res["PayloadContentKey"] = boost::any(*payloadContentKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FollowIdr") != m.end() && !m["FollowIdr"].empty()) {
      followIdr = make_shared<string>(boost::any_cast<string>(m["FollowIdr"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("PayloadContent") != m.end() && !m["PayloadContent"].empty()) {
      payloadContent = make_shared<string>(boost::any_cast<string>(m["PayloadContent"]));
    }
    if (m.find("PayloadContentKey") != m.end() && !m["PayloadContentKey"].empty()) {
      payloadContentKey = make_shared<string>(boost::any_cast<string>(m["PayloadContentKey"]));
    }
  }


  virtual ~UpdateLiveMPUTaskRequestSeiParamsPassThrough() = default;
};
class UpdateLiveMPUTaskRequestSeiParams : public Darabonba::Model {
public:
  shared_ptr<UpdateLiveMPUTaskRequestSeiParamsLayoutVolume> layoutVolume{};
  shared_ptr<UpdateLiveMPUTaskRequestSeiParamsPassThrough> passThrough{};

  UpdateLiveMPUTaskRequestSeiParams() {}

  explicit UpdateLiveMPUTaskRequestSeiParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (layoutVolume) {
      res["LayoutVolume"] = layoutVolume ? boost::any(layoutVolume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passThrough) {
      res["PassThrough"] = passThrough ? boost::any(passThrough->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LayoutVolume") != m.end() && !m["LayoutVolume"].empty()) {
      if (typeid(map<string, boost::any>) == m["LayoutVolume"].type()) {
        UpdateLiveMPUTaskRequestSeiParamsLayoutVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LayoutVolume"]));
        layoutVolume = make_shared<UpdateLiveMPUTaskRequestSeiParamsLayoutVolume>(model1);
      }
    }
    if (m.find("PassThrough") != m.end() && !m["PassThrough"].empty()) {
      if (typeid(map<string, boost::any>) == m["PassThrough"].type()) {
        UpdateLiveMPUTaskRequestSeiParamsPassThrough model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PassThrough"]));
        passThrough = make_shared<UpdateLiveMPUTaskRequestSeiParamsPassThrough>(model1);
      }
    }
  }


  virtual ~UpdateLiveMPUTaskRequestSeiParams() = default;
};
class UpdateLiveMPUTaskRequestSingleSubParams : public Darabonba::Model {
public:
  shared_ptr<string> sourceType{};
  shared_ptr<string> streamType{};
  shared_ptr<string> userId{};

  UpdateLiveMPUTaskRequestSingleSubParams() {}

  explicit UpdateLiveMPUTaskRequestSingleSubParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdateLiveMPUTaskRequestSingleSubParams() = default;
};
class UpdateLiveMPUTaskRequestTranscodeParamsBackground : public Darabonba::Model {
public:
  shared_ptr<string> renderMode{};
  shared_ptr<string> URL{};

  UpdateLiveMPUTaskRequestTranscodeParamsBackground() {}

  explicit UpdateLiveMPUTaskRequestTranscodeParamsBackground(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderMode) {
      res["RenderMode"] = boost::any(*renderMode);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderMode") != m.end() && !m["RenderMode"].empty()) {
      renderMode = make_shared<string>(boost::any_cast<string>(m["RenderMode"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~UpdateLiveMPUTaskRequestTranscodeParamsBackground() = default;
};
class UpdateLiveMPUTaskRequestTranscodeParamsEncodeParams : public Darabonba::Model {
public:
  shared_ptr<string> audioBitrate{};
  shared_ptr<string> audioChannels{};
  shared_ptr<string> audioOnly{};
  shared_ptr<string> audioSampleRate{};
  shared_ptr<string> enhancedParam{};
  shared_ptr<string> videoBitrate{};
  shared_ptr<string> videoCodec{};
  shared_ptr<string> videoFramerate{};
  shared_ptr<string> videoGop{};
  shared_ptr<string> videoHeight{};
  shared_ptr<string> videoWidth{};

  UpdateLiveMPUTaskRequestTranscodeParamsEncodeParams() {}

  explicit UpdateLiveMPUTaskRequestTranscodeParamsEncodeParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannels) {
      res["AudioChannels"] = boost::any(*audioChannels);
    }
    if (audioOnly) {
      res["AudioOnly"] = boost::any(*audioOnly);
    }
    if (audioSampleRate) {
      res["AudioSampleRate"] = boost::any(*audioSampleRate);
    }
    if (enhancedParam) {
      res["EnhancedParam"] = boost::any(*enhancedParam);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    if (videoFramerate) {
      res["VideoFramerate"] = boost::any(*videoFramerate);
    }
    if (videoGop) {
      res["VideoGop"] = boost::any(*videoGop);
    }
    if (videoHeight) {
      res["VideoHeight"] = boost::any(*videoHeight);
    }
    if (videoWidth) {
      res["VideoWidth"] = boost::any(*videoWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<string>(boost::any_cast<string>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannels") != m.end() && !m["AudioChannels"].empty()) {
      audioChannels = make_shared<string>(boost::any_cast<string>(m["AudioChannels"]));
    }
    if (m.find("AudioOnly") != m.end() && !m["AudioOnly"].empty()) {
      audioOnly = make_shared<string>(boost::any_cast<string>(m["AudioOnly"]));
    }
    if (m.find("AudioSampleRate") != m.end() && !m["AudioSampleRate"].empty()) {
      audioSampleRate = make_shared<string>(boost::any_cast<string>(m["AudioSampleRate"]));
    }
    if (m.find("EnhancedParam") != m.end() && !m["EnhancedParam"].empty()) {
      enhancedParam = make_shared<string>(boost::any_cast<string>(m["EnhancedParam"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<string>(boost::any_cast<string>(m["VideoBitrate"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
    if (m.find("VideoFramerate") != m.end() && !m["VideoFramerate"].empty()) {
      videoFramerate = make_shared<string>(boost::any_cast<string>(m["VideoFramerate"]));
    }
    if (m.find("VideoGop") != m.end() && !m["VideoGop"].empty()) {
      videoGop = make_shared<string>(boost::any_cast<string>(m["VideoGop"]));
    }
    if (m.find("VideoHeight") != m.end() && !m["VideoHeight"].empty()) {
      videoHeight = make_shared<string>(boost::any_cast<string>(m["VideoHeight"]));
    }
    if (m.find("VideoWidth") != m.end() && !m["VideoWidth"].empty()) {
      videoWidth = make_shared<string>(boost::any_cast<string>(m["VideoWidth"]));
    }
  }


  virtual ~UpdateLiveMPUTaskRequestTranscodeParamsEncodeParams() = default;
};
class UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> userId{};

  UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo() {}

  explicit UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo() = default;
};
class UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanes : public Darabonba::Model {
public:
  shared_ptr<string> backgroundImageUrl{};
  shared_ptr<string> height{};
  shared_ptr<string> renderMode{};
  shared_ptr<UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo> userInfo{};
  shared_ptr<string> width{};
  shared_ptr<string> x{};
  shared_ptr<string> y{};
  shared_ptr<string> ZOrder{};

  UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanes() {}

  explicit UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundImageUrl) {
      res["BackgroundImageUrl"] = boost::any(*backgroundImageUrl);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (renderMode) {
      res["RenderMode"] = boost::any(*renderMode);
    }
    if (userInfo) {
      res["UserInfo"] = userInfo ? boost::any(userInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    if (ZOrder) {
      res["ZOrder"] = boost::any(*ZOrder);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundImageUrl") != m.end() && !m["BackgroundImageUrl"].empty()) {
      backgroundImageUrl = make_shared<string>(boost::any_cast<string>(m["BackgroundImageUrl"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("RenderMode") != m.end() && !m["RenderMode"].empty()) {
      renderMode = make_shared<string>(boost::any_cast<string>(m["RenderMode"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserInfo"].type()) {
        UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserInfo"]));
        userInfo = make_shared<UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanesUserInfo>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<string>(boost::any_cast<string>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<string>(boost::any_cast<string>(m["Y"]));
    }
    if (m.find("ZOrder") != m.end() && !m["ZOrder"].empty()) {
      ZOrder = make_shared<string>(boost::any_cast<string>(m["ZOrder"]));
    }
  }


  virtual ~UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanes() = default;
};
class UpdateLiveMPUTaskRequestTranscodeParamsLayout : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanes>> userPanes{};

  UpdateLiveMPUTaskRequestTranscodeParamsLayout() {}

  explicit UpdateLiveMPUTaskRequestTranscodeParamsLayout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userPanes) {
      vector<boost::any> temp1;
      for(auto item1:*userPanes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserPanes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserPanes") != m.end() && !m["UserPanes"].empty()) {
      if (typeid(vector<boost::any>) == m["UserPanes"].type()) {
        vector<UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserPanes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userPanes = make_shared<vector<UpdateLiveMPUTaskRequestTranscodeParamsLayoutUserPanes>>(expect1);
      }
    }
  }


  virtual ~UpdateLiveMPUTaskRequestTranscodeParamsLayout() = default;
};
class UpdateLiveMPUTaskRequestTranscodeParamsUserInfos : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> streamType{};
  shared_ptr<string> userId{};

  UpdateLiveMPUTaskRequestTranscodeParamsUserInfos() {}

  explicit UpdateLiveMPUTaskRequestTranscodeParamsUserInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdateLiveMPUTaskRequestTranscodeParamsUserInfos() = default;
};
class UpdateLiveMPUTaskRequestTranscodeParams : public Darabonba::Model {
public:
  shared_ptr<UpdateLiveMPUTaskRequestTranscodeParamsBackground> background{};
  shared_ptr<UpdateLiveMPUTaskRequestTranscodeParamsEncodeParams> encodeParams{};
  shared_ptr<UpdateLiveMPUTaskRequestTranscodeParamsLayout> layout{};
  shared_ptr<vector<UpdateLiveMPUTaskRequestTranscodeParamsUserInfos>> userInfos{};

  UpdateLiveMPUTaskRequestTranscodeParams() {}

  explicit UpdateLiveMPUTaskRequestTranscodeParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (background) {
      res["Background"] = background ? boost::any(background->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encodeParams) {
      res["EncodeParams"] = encodeParams ? boost::any(encodeParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (layout) {
      res["Layout"] = layout ? boost::any(layout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userInfos) {
      vector<boost::any> temp1;
      for(auto item1:*userInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Background") != m.end() && !m["Background"].empty()) {
      if (typeid(map<string, boost::any>) == m["Background"].type()) {
        UpdateLiveMPUTaskRequestTranscodeParamsBackground model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Background"]));
        background = make_shared<UpdateLiveMPUTaskRequestTranscodeParamsBackground>(model1);
      }
    }
    if (m.find("EncodeParams") != m.end() && !m["EncodeParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["EncodeParams"].type()) {
        UpdateLiveMPUTaskRequestTranscodeParamsEncodeParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EncodeParams"]));
        encodeParams = make_shared<UpdateLiveMPUTaskRequestTranscodeParamsEncodeParams>(model1);
      }
    }
    if (m.find("Layout") != m.end() && !m["Layout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Layout"].type()) {
        UpdateLiveMPUTaskRequestTranscodeParamsLayout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Layout"]));
        layout = make_shared<UpdateLiveMPUTaskRequestTranscodeParamsLayout>(model1);
      }
    }
    if (m.find("UserInfos") != m.end() && !m["UserInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["UserInfos"].type()) {
        vector<UpdateLiveMPUTaskRequestTranscodeParamsUserInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateLiveMPUTaskRequestTranscodeParamsUserInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userInfos = make_shared<vector<UpdateLiveMPUTaskRequestTranscodeParamsUserInfos>>(expect1);
      }
    }
  }


  virtual ~UpdateLiveMPUTaskRequestTranscodeParams() = default;
};
class UpdateLiveMPUTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> mixMode{};
  shared_ptr<vector<UpdateLiveMPUTaskRequestMultiStreamURL>> multiStreamURL{};
  shared_ptr<UpdateLiveMPUTaskRequestSeiParams> seiParams{};
  shared_ptr<UpdateLiveMPUTaskRequestSingleSubParams> singleSubParams{};
  shared_ptr<string> streamURL{};
  shared_ptr<string> taskId{};
  shared_ptr<UpdateLiveMPUTaskRequestTranscodeParams> transcodeParams{};

  UpdateLiveMPUTaskRequest() {}

  explicit UpdateLiveMPUTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (mixMode) {
      res["MixMode"] = boost::any(*mixMode);
    }
    if (multiStreamURL) {
      vector<boost::any> temp1;
      for(auto item1:*multiStreamURL){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultiStreamURL"] = boost::any(temp1);
    }
    if (seiParams) {
      res["SeiParams"] = seiParams ? boost::any(seiParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (singleSubParams) {
      res["SingleSubParams"] = singleSubParams ? boost::any(singleSubParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamURL) {
      res["StreamURL"] = boost::any(*streamURL);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (transcodeParams) {
      res["TranscodeParams"] = transcodeParams ? boost::any(transcodeParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("MixMode") != m.end() && !m["MixMode"].empty()) {
      mixMode = make_shared<string>(boost::any_cast<string>(m["MixMode"]));
    }
    if (m.find("MultiStreamURL") != m.end() && !m["MultiStreamURL"].empty()) {
      if (typeid(vector<boost::any>) == m["MultiStreamURL"].type()) {
        vector<UpdateLiveMPUTaskRequestMultiStreamURL> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultiStreamURL"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateLiveMPUTaskRequestMultiStreamURL model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multiStreamURL = make_shared<vector<UpdateLiveMPUTaskRequestMultiStreamURL>>(expect1);
      }
    }
    if (m.find("SeiParams") != m.end() && !m["SeiParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["SeiParams"].type()) {
        UpdateLiveMPUTaskRequestSeiParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SeiParams"]));
        seiParams = make_shared<UpdateLiveMPUTaskRequestSeiParams>(model1);
      }
    }
    if (m.find("SingleSubParams") != m.end() && !m["SingleSubParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["SingleSubParams"].type()) {
        UpdateLiveMPUTaskRequestSingleSubParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SingleSubParams"]));
        singleSubParams = make_shared<UpdateLiveMPUTaskRequestSingleSubParams>(model1);
      }
    }
    if (m.find("StreamURL") != m.end() && !m["StreamURL"].empty()) {
      streamURL = make_shared<string>(boost::any_cast<string>(m["StreamURL"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TranscodeParams") != m.end() && !m["TranscodeParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeParams"].type()) {
        UpdateLiveMPUTaskRequestTranscodeParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeParams"]));
        transcodeParams = make_shared<UpdateLiveMPUTaskRequestTranscodeParams>(model1);
      }
    }
  }


  virtual ~UpdateLiveMPUTaskRequest() = default;
};
class UpdateLiveMPUTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> mixMode{};
  shared_ptr<string> multiStreamURLShrink{};
  shared_ptr<string> seiParamsShrink{};
  shared_ptr<string> singleSubParamsShrink{};
  shared_ptr<string> streamURL{};
  shared_ptr<string> taskId{};
  shared_ptr<string> transcodeParamsShrink{};

  UpdateLiveMPUTaskShrinkRequest() {}

  explicit UpdateLiveMPUTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (mixMode) {
      res["MixMode"] = boost::any(*mixMode);
    }
    if (multiStreamURLShrink) {
      res["MultiStreamURL"] = boost::any(*multiStreamURLShrink);
    }
    if (seiParamsShrink) {
      res["SeiParams"] = boost::any(*seiParamsShrink);
    }
    if (singleSubParamsShrink) {
      res["SingleSubParams"] = boost::any(*singleSubParamsShrink);
    }
    if (streamURL) {
      res["StreamURL"] = boost::any(*streamURL);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (transcodeParamsShrink) {
      res["TranscodeParams"] = boost::any(*transcodeParamsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("MixMode") != m.end() && !m["MixMode"].empty()) {
      mixMode = make_shared<string>(boost::any_cast<string>(m["MixMode"]));
    }
    if (m.find("MultiStreamURL") != m.end() && !m["MultiStreamURL"].empty()) {
      multiStreamURLShrink = make_shared<string>(boost::any_cast<string>(m["MultiStreamURL"]));
    }
    if (m.find("SeiParams") != m.end() && !m["SeiParams"].empty()) {
      seiParamsShrink = make_shared<string>(boost::any_cast<string>(m["SeiParams"]));
    }
    if (m.find("SingleSubParams") != m.end() && !m["SingleSubParams"].empty()) {
      singleSubParamsShrink = make_shared<string>(boost::any_cast<string>(m["SingleSubParams"]));
    }
    if (m.find("StreamURL") != m.end() && !m["StreamURL"].empty()) {
      streamURL = make_shared<string>(boost::any_cast<string>(m["StreamURL"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TranscodeParams") != m.end() && !m["TranscodeParams"].empty()) {
      transcodeParamsShrink = make_shared<string>(boost::any_cast<string>(m["TranscodeParams"]));
    }
  }


  virtual ~UpdateLiveMPUTaskShrinkRequest() = default;
};
class UpdateLiveMPUTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveMPUTaskResponseBody() {}

  explicit UpdateLiveMPUTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveMPUTaskResponseBody() = default;
};
class UpdateLiveMPUTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveMPUTaskResponseBody> body{};

  UpdateLiveMPUTaskResponse() {}

  explicit UpdateLiveMPUTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveMPUTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveMPUTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveMPUTaskResponse() = default;
};
class UpdateLivePackageConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<bool> ignoreTranscode{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> partDuration{};
  shared_ptr<string> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<long> segmentDuration{};
  shared_ptr<long> segmentNum{};
  shared_ptr<string> streamName{};

  UpdateLivePackageConfigRequest() {}

  explicit UpdateLivePackageConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ignoreTranscode) {
      res["IgnoreTranscode"] = boost::any(*ignoreTranscode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (partDuration) {
      res["PartDuration"] = boost::any(*partDuration);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    if (segmentNum) {
      res["SegmentNum"] = boost::any(*segmentNum);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IgnoreTranscode") != m.end() && !m["IgnoreTranscode"].empty()) {
      ignoreTranscode = make_shared<bool>(boost::any_cast<bool>(m["IgnoreTranscode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PartDuration") != m.end() && !m["PartDuration"].empty()) {
      partDuration = make_shared<long>(boost::any_cast<long>(m["PartDuration"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
    if (m.find("SegmentNum") != m.end() && !m["SegmentNum"].empty()) {
      segmentNum = make_shared<long>(boost::any_cast<long>(m["SegmentNum"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~UpdateLivePackageConfigRequest() = default;
};
class UpdateLivePackageConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLivePackageConfigResponseBody() {}

  explicit UpdateLivePackageConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLivePackageConfigResponseBody() = default;
};
class UpdateLivePackageConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLivePackageConfigResponseBody> body{};

  UpdateLivePackageConfigResponse() {}

  explicit UpdateLivePackageConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLivePackageConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLivePackageConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLivePackageConfigResponse() = default;
};
class UpdateLivePullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  UpdateLivePullStreamInfoConfigRequest() {}

  explicit UpdateLivePullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~UpdateLivePullStreamInfoConfigRequest() = default;
};
class UpdateLivePullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLivePullStreamInfoConfigResponseBody() {}

  explicit UpdateLivePullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLivePullStreamInfoConfigResponseBody() = default;
};
class UpdateLivePullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLivePullStreamInfoConfigResponseBody> body{};

  UpdateLivePullStreamInfoConfigResponse() {}

  explicit UpdateLivePullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLivePullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLivePullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLivePullStreamInfoConfigResponse() = default;
};
class UpdateLivePullToPushRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> endTime{};
  shared_ptr<long> fileIndex{};
  shared_ptr<long> offset{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<long> repeatNumber{};
  shared_ptr<vector<string>> sourceUrls{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskId{};

  UpdateLivePullToPushRequest() {}

  explicit UpdateLivePullToPushRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileIndex) {
      res["FileIndex"] = boost::any(*fileIndex);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeatNumber) {
      res["RepeatNumber"] = boost::any(*repeatNumber);
    }
    if (sourceUrls) {
      res["SourceUrls"] = boost::any(*sourceUrls);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FileIndex") != m.end() && !m["FileIndex"].empty()) {
      fileIndex = make_shared<long>(boost::any_cast<long>(m["FileIndex"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepeatNumber") != m.end() && !m["RepeatNumber"].empty()) {
      repeatNumber = make_shared<long>(boost::any_cast<long>(m["RepeatNumber"]));
    }
    if (m.find("SourceUrls") != m.end() && !m["SourceUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpdateLivePullToPushRequest() = default;
};
class UpdateLivePullToPushShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> endTime{};
  shared_ptr<long> fileIndex{};
  shared_ptr<long> offset{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<long> repeatNumber{};
  shared_ptr<string> sourceUrlsShrink{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskId{};

  UpdateLivePullToPushShrinkRequest() {}

  explicit UpdateLivePullToPushShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileIndex) {
      res["FileIndex"] = boost::any(*fileIndex);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repeatNumber) {
      res["RepeatNumber"] = boost::any(*repeatNumber);
    }
    if (sourceUrlsShrink) {
      res["SourceUrls"] = boost::any(*sourceUrlsShrink);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FileIndex") != m.end() && !m["FileIndex"].empty()) {
      fileIndex = make_shared<long>(boost::any_cast<long>(m["FileIndex"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepeatNumber") != m.end() && !m["RepeatNumber"].empty()) {
      repeatNumber = make_shared<long>(boost::any_cast<long>(m["RepeatNumber"]));
    }
    if (m.find("SourceUrls") != m.end() && !m["SourceUrls"].empty()) {
      sourceUrlsShrink = make_shared<string>(boost::any_cast<string>(m["SourceUrls"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpdateLivePullToPushShrinkRequest() = default;
};
class UpdateLivePullToPushResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  UpdateLivePullToPushResponseBody() {}

  explicit UpdateLivePullToPushResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~UpdateLivePullToPushResponseBody() = default;
};
class UpdateLivePullToPushResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLivePullToPushResponseBody> body{};

  UpdateLivePullToPushResponse() {}

  explicit UpdateLivePullToPushResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLivePullToPushResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLivePullToPushResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLivePullToPushResponse() = default;
};
class UpdateLiveRecordNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<bool> needStatusNotify{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> onDemandUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  UpdateLiveRecordNotifyConfigRequest() {}

  explicit UpdateLiveRecordNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (needStatusNotify) {
      res["NeedStatusNotify"] = boost::any(*needStatusNotify);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (onDemandUrl) {
      res["OnDemandUrl"] = boost::any(*onDemandUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NeedStatusNotify") != m.end() && !m["NeedStatusNotify"].empty()) {
      needStatusNotify = make_shared<bool>(boost::any_cast<bool>(m["NeedStatusNotify"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OnDemandUrl") != m.end() && !m["OnDemandUrl"].empty()) {
      onDemandUrl = make_shared<string>(boost::any_cast<string>(m["OnDemandUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~UpdateLiveRecordNotifyConfigRequest() = default;
};
class UpdateLiveRecordNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveRecordNotifyConfigResponseBody() {}

  explicit UpdateLiveRecordNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveRecordNotifyConfigResponseBody() = default;
};
class UpdateLiveRecordNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveRecordNotifyConfigResponseBody> body{};

  UpdateLiveRecordNotifyConfigResponse() {}

  explicit UpdateLiveRecordNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveRecordNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveRecordNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveRecordNotifyConfigResponse() = default;
};
class UpdateLiveRecordVodConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> autoCompose{};
  shared_ptr<string> composeVodTranscodeGroupId{};
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> domainName{};
  shared_ptr<long> onDemand{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> streamName{};
  shared_ptr<string> vodTranscodeGroupId{};

  UpdateLiveRecordVodConfigRequest() {}

  explicit UpdateLiveRecordVodConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (autoCompose) {
      res["AutoCompose"] = boost::any(*autoCompose);
    }
    if (composeVodTranscodeGroupId) {
      res["ComposeVodTranscodeGroupId"] = boost::any(*composeVodTranscodeGroupId);
    }
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (onDemand) {
      res["OnDemand"] = boost::any(*onDemand);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (vodTranscodeGroupId) {
      res["VodTranscodeGroupId"] = boost::any(*vodTranscodeGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AutoCompose") != m.end() && !m["AutoCompose"].empty()) {
      autoCompose = make_shared<string>(boost::any_cast<string>(m["AutoCompose"]));
    }
    if (m.find("ComposeVodTranscodeGroupId") != m.end() && !m["ComposeVodTranscodeGroupId"].empty()) {
      composeVodTranscodeGroupId = make_shared<string>(boost::any_cast<string>(m["ComposeVodTranscodeGroupId"]));
    }
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OnDemand") != m.end() && !m["OnDemand"].empty()) {
      onDemand = make_shared<long>(boost::any_cast<long>(m["OnDemand"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("VodTranscodeGroupId") != m.end() && !m["VodTranscodeGroupId"].empty()) {
      vodTranscodeGroupId = make_shared<string>(boost::any_cast<string>(m["VodTranscodeGroupId"]));
    }
  }


  virtual ~UpdateLiveRecordVodConfigRequest() = default;
};
class UpdateLiveRecordVodConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveRecordVodConfigResponseBody() {}

  explicit UpdateLiveRecordVodConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveRecordVodConfigResponseBody() = default;
};
class UpdateLiveRecordVodConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveRecordVodConfigResponseBody> body{};

  UpdateLiveRecordVodConfigResponse() {}

  explicit UpdateLiveRecordVodConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveRecordVodConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveRecordVodConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveRecordVodConfigResponse() = default;
};
class UpdateLiveSnapshotDetectPornConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> interval{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<long> ownerId{};
  shared_ptr<vector<string>> scene{};
  shared_ptr<string> securityToken{};

  UpdateLiveSnapshotDetectPornConfigRequest() {}

  explicit UpdateLiveSnapshotDetectPornConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Scene"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Scene"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scene = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~UpdateLiveSnapshotDetectPornConfigRequest() = default;
};
class UpdateLiveSnapshotDetectPornConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveSnapshotDetectPornConfigResponseBody() {}

  explicit UpdateLiveSnapshotDetectPornConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveSnapshotDetectPornConfigResponseBody() = default;
};
class UpdateLiveSnapshotDetectPornConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveSnapshotDetectPornConfigResponseBody> body{};

  UpdateLiveSnapshotDetectPornConfigResponse() {}

  explicit UpdateLiveSnapshotDetectPornConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveSnapshotDetectPornConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveSnapshotDetectPornConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveSnapshotDetectPornConfigResponse() = default;
};
class UpdateLiveSnapshotNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyAuthKey{};
  shared_ptr<string> notifyReqAuth{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  UpdateLiveSnapshotNotifyConfigRequest() {}

  explicit UpdateLiveSnapshotNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyAuthKey) {
      res["NotifyAuthKey"] = boost::any(*notifyAuthKey);
    }
    if (notifyReqAuth) {
      res["NotifyReqAuth"] = boost::any(*notifyReqAuth);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyAuthKey") != m.end() && !m["NotifyAuthKey"].empty()) {
      notifyAuthKey = make_shared<string>(boost::any_cast<string>(m["NotifyAuthKey"]));
    }
    if (m.find("NotifyReqAuth") != m.end() && !m["NotifyReqAuth"].empty()) {
      notifyReqAuth = make_shared<string>(boost::any_cast<string>(m["NotifyReqAuth"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateLiveSnapshotNotifyConfigRequest() = default;
};
class UpdateLiveSnapshotNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveSnapshotNotifyConfigResponseBody() {}

  explicit UpdateLiveSnapshotNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveSnapshotNotifyConfigResponseBody() = default;
};
class UpdateLiveSnapshotNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveSnapshotNotifyConfigResponseBody> body{};

  UpdateLiveSnapshotNotifyConfigResponse() {}

  explicit UpdateLiveSnapshotNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveSnapshotNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveSnapshotNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveSnapshotNotifyConfigResponse() = default;
};
class UpdateLiveStreamMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> dingTalkWebHookUrl{};
  shared_ptr<string> domain{};
  shared_ptr<string> inputList{};
  shared_ptr<string> monitorConfig{};
  shared_ptr<string> monitorId{};
  shared_ptr<string> monitorName{};
  shared_ptr<string> outputTemplate{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stream{};

  UpdateLiveStreamMonitorRequest() {}

  explicit UpdateLiveStreamMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (dingTalkWebHookUrl) {
      res["DingTalkWebHookUrl"] = boost::any(*dingTalkWebHookUrl);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (inputList) {
      res["InputList"] = boost::any(*inputList);
    }
    if (monitorConfig) {
      res["MonitorConfig"] = boost::any(*monitorConfig);
    }
    if (monitorId) {
      res["MonitorId"] = boost::any(*monitorId);
    }
    if (monitorName) {
      res["MonitorName"] = boost::any(*monitorName);
    }
    if (outputTemplate) {
      res["OutputTemplate"] = boost::any(*outputTemplate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("DingTalkWebHookUrl") != m.end() && !m["DingTalkWebHookUrl"].empty()) {
      dingTalkWebHookUrl = make_shared<string>(boost::any_cast<string>(m["DingTalkWebHookUrl"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      inputList = make_shared<string>(boost::any_cast<string>(m["InputList"]));
    }
    if (m.find("MonitorConfig") != m.end() && !m["MonitorConfig"].empty()) {
      monitorConfig = make_shared<string>(boost::any_cast<string>(m["MonitorConfig"]));
    }
    if (m.find("MonitorId") != m.end() && !m["MonitorId"].empty()) {
      monitorId = make_shared<string>(boost::any_cast<string>(m["MonitorId"]));
    }
    if (m.find("MonitorName") != m.end() && !m["MonitorName"].empty()) {
      monitorName = make_shared<string>(boost::any_cast<string>(m["MonitorName"]));
    }
    if (m.find("OutputTemplate") != m.end() && !m["OutputTemplate"].empty()) {
      outputTemplate = make_shared<string>(boost::any_cast<string>(m["OutputTemplate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
  }


  virtual ~UpdateLiveStreamMonitorRequest() = default;
};
class UpdateLiveStreamMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveStreamMonitorResponseBody() {}

  explicit UpdateLiveStreamMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveStreamMonitorResponseBody() = default;
};
class UpdateLiveStreamMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveStreamMonitorResponseBody> body{};

  UpdateLiveStreamMonitorResponse() {}

  explicit UpdateLiveStreamMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveStreamMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveStreamMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveStreamMonitorResponse() = default;
};
class UpdateLiveStreamTranscodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> domain{};
  shared_ptr<string> encryptParameters{};
  shared_ptr<string> lazy{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> template_{};

  UpdateLiveStreamTranscodeRequest() {}

  explicit UpdateLiveStreamTranscodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (encryptParameters) {
      res["EncryptParameters"] = boost::any(*encryptParameters);
    }
    if (lazy) {
      res["Lazy"] = boost::any(*lazy);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EncryptParameters") != m.end() && !m["EncryptParameters"].empty()) {
      encryptParameters = make_shared<string>(boost::any_cast<string>(m["EncryptParameters"]));
    }
    if (m.find("Lazy") != m.end() && !m["Lazy"].empty()) {
      lazy = make_shared<string>(boost::any_cast<string>(m["Lazy"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~UpdateLiveStreamTranscodeRequest() = default;
};
class UpdateLiveStreamTranscodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveStreamTranscodeResponseBody() {}

  explicit UpdateLiveStreamTranscodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveStreamTranscodeResponseBody() = default;
};
class UpdateLiveStreamTranscodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveStreamTranscodeResponseBody> body{};

  UpdateLiveStreamTranscodeResponse() {}

  explicit UpdateLiveStreamTranscodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveStreamTranscodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveStreamTranscodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveStreamTranscodeResponse() = default;
};
class UpdateLiveStreamWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> height{};
  shared_ptr<string> name{};
  shared_ptr<string> offsetCorner{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pictureUrl{};
  shared_ptr<long> refHeight{};
  shared_ptr<long> refWidth{};
  shared_ptr<string> regionId{};
  shared_ptr<string> templateId{};
  shared_ptr<long> transparency{};
  shared_ptr<double> XOffset{};
  shared_ptr<double> YOffset{};

  UpdateLiveStreamWatermarkRequest() {}

  explicit UpdateLiveStreamWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (offsetCorner) {
      res["OffsetCorner"] = boost::any(*offsetCorner);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pictureUrl) {
      res["PictureUrl"] = boost::any(*pictureUrl);
    }
    if (refHeight) {
      res["RefHeight"] = boost::any(*refHeight);
    }
    if (refWidth) {
      res["RefWidth"] = boost::any(*refWidth);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transparency) {
      res["Transparency"] = boost::any(*transparency);
    }
    if (XOffset) {
      res["XOffset"] = boost::any(*XOffset);
    }
    if (YOffset) {
      res["YOffset"] = boost::any(*YOffset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OffsetCorner") != m.end() && !m["OffsetCorner"].empty()) {
      offsetCorner = make_shared<string>(boost::any_cast<string>(m["OffsetCorner"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PictureUrl") != m.end() && !m["PictureUrl"].empty()) {
      pictureUrl = make_shared<string>(boost::any_cast<string>(m["PictureUrl"]));
    }
    if (m.find("RefHeight") != m.end() && !m["RefHeight"].empty()) {
      refHeight = make_shared<long>(boost::any_cast<long>(m["RefHeight"]));
    }
    if (m.find("RefWidth") != m.end() && !m["RefWidth"].empty()) {
      refWidth = make_shared<long>(boost::any_cast<long>(m["RefWidth"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Transparency") != m.end() && !m["Transparency"].empty()) {
      transparency = make_shared<long>(boost::any_cast<long>(m["Transparency"]));
    }
    if (m.find("XOffset") != m.end() && !m["XOffset"].empty()) {
      XOffset = make_shared<double>(boost::any_cast<double>(m["XOffset"]));
    }
    if (m.find("YOffset") != m.end() && !m["YOffset"].empty()) {
      YOffset = make_shared<double>(boost::any_cast<double>(m["YOffset"]));
    }
  }


  virtual ~UpdateLiveStreamWatermarkRequest() = default;
};
class UpdateLiveStreamWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveStreamWatermarkResponseBody() {}

  explicit UpdateLiveStreamWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveStreamWatermarkResponseBody() = default;
};
class UpdateLiveStreamWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveStreamWatermarkResponseBody> body{};

  UpdateLiveStreamWatermarkResponse() {}

  explicit UpdateLiveStreamWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveStreamWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveStreamWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveStreamWatermarkResponse() = default;
};
class UpdateLiveStreamWatermarkRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> templateId{};

  UpdateLiveStreamWatermarkRuleRequest() {}

  explicit UpdateLiveStreamWatermarkRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateLiveStreamWatermarkRuleRequest() = default;
};
class UpdateLiveStreamWatermarkRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveStreamWatermarkRuleResponseBody() {}

  explicit UpdateLiveStreamWatermarkRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveStreamWatermarkRuleResponseBody() = default;
};
class UpdateLiveStreamWatermarkRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveStreamWatermarkRuleResponseBody> body{};

  UpdateLiveStreamWatermarkRuleResponse() {}

  explicit UpdateLiveStreamWatermarkRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveStreamWatermarkRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveStreamWatermarkRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveStreamWatermarkRuleResponse() = default;
};
class UpdateMessageAppRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> appConfig{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<map<string, string>> extension{};

  UpdateMessageAppRequest() {}

  explicit UpdateMessageAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["AppConfig"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      appConfig = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~UpdateMessageAppRequest() = default;
};
class UpdateMessageAppShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appConfigShrink{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> extensionShrink{};

  UpdateMessageAppShrinkRequest() {}

  explicit UpdateMessageAppShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfigShrink) {
      res["AppConfig"] = boost::any(*appConfigShrink);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (extensionShrink) {
      res["Extension"] = boost::any(*extensionShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      appConfigShrink = make_shared<string>(boost::any_cast<string>(m["AppConfig"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extensionShrink = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
  }


  virtual ~UpdateMessageAppShrinkRequest() = default;
};
class UpdateMessageAppResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  UpdateMessageAppResponseBodyResult() {}

  explicit UpdateMessageAppResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMessageAppResponseBodyResult() = default;
};
class UpdateMessageAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateMessageAppResponseBodyResult> result{};

  UpdateMessageAppResponseBody() {}

  explicit UpdateMessageAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateMessageAppResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateMessageAppResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateMessageAppResponseBody() = default;
};
class UpdateMessageAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMessageAppResponseBody> body{};

  UpdateMessageAppResponse() {}

  explicit UpdateMessageAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMessageAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMessageAppResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMessageAppResponse() = default;
};
class UpdateMessageGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<map<string, string>> extension{};
  shared_ptr<string> groupId{};

  UpdateMessageGroupRequest() {}

  explicit UpdateMessageGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extension"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extension = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~UpdateMessageGroupRequest() = default;
};
class UpdateMessageGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> extensionShrink{};
  shared_ptr<string> groupId{};

  UpdateMessageGroupShrinkRequest() {}

  explicit UpdateMessageGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (extensionShrink) {
      res["Extension"] = boost::any(*extensionShrink);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extensionShrink = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~UpdateMessageGroupShrinkRequest() = default;
};
class UpdateMessageGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> success{};

  UpdateMessageGroupResponseBodyResult() {}

  explicit UpdateMessageGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMessageGroupResponseBodyResult() = default;
};
class UpdateMessageGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateMessageGroupResponseBodyResult> result{};

  UpdateMessageGroupResponseBody() {}

  explicit UpdateMessageGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateMessageGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateMessageGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateMessageGroupResponseBody() = default;
};
class UpdateMessageGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMessageGroupResponseBody> body{};

  UpdateMessageGroupResponse() {}

  explicit UpdateMessageGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMessageGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMessageGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMessageGroupResponse() = default;
};
class UpdateMixStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> inputStreamList{};
  shared_ptr<string> layoutId{};
  shared_ptr<string> mixStreamId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};

  UpdateMixStreamRequest() {}

  explicit UpdateMixStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (inputStreamList) {
      res["InputStreamList"] = boost::any(*inputStreamList);
    }
    if (layoutId) {
      res["LayoutId"] = boost::any(*layoutId);
    }
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InputStreamList") != m.end() && !m["InputStreamList"].empty()) {
      inputStreamList = make_shared<string>(boost::any_cast<string>(m["InputStreamList"]));
    }
    if (m.find("LayoutId") != m.end() && !m["LayoutId"].empty()) {
      layoutId = make_shared<string>(boost::any_cast<string>(m["LayoutId"]));
    }
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateMixStreamRequest() = default;
};
class UpdateMixStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mixStreamId{};
  shared_ptr<string> requestId{};

  UpdateMixStreamResponseBody() {}

  explicit UpdateMixStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixStreamId) {
      res["MixStreamId"] = boost::any(*mixStreamId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixStreamId") != m.end() && !m["MixStreamId"].empty()) {
      mixStreamId = make_shared<string>(boost::any_cast<string>(m["MixStreamId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMixStreamResponseBody() = default;
};
class UpdateMixStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMixStreamResponseBody> body{};

  UpdateMixStreamResponse() {}

  explicit UpdateMixStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMixStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMixStreamResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMixStreamResponse() = default;
};
class UpdateRtcCloudRecordingRequestMixLayoutParamsMixBackground : public Darabonba::Model {
public:
  shared_ptr<long> renderMode{};
  shared_ptr<string> url{};

  UpdateRtcCloudRecordingRequestMixLayoutParamsMixBackground() {}

  explicit UpdateRtcCloudRecordingRequestMixLayoutParamsMixBackground(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderMode) {
      res["RenderMode"] = boost::any(*renderMode);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderMode") != m.end() && !m["RenderMode"].empty()) {
      renderMode = make_shared<long>(boost::any_cast<long>(m["RenderMode"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~UpdateRtcCloudRecordingRequestMixLayoutParamsMixBackground() = default;
};
class UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground : public Darabonba::Model {
public:
  shared_ptr<long> renderMode{};
  shared_ptr<string> url{};

  UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground() {}

  explicit UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderMode) {
      res["RenderMode"] = boost::any(*renderMode);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderMode") != m.end() && !m["RenderMode"].empty()) {
      renderMode = make_shared<long>(boost::any_cast<long>(m["RenderMode"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground() = default;
};
class UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanes : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<long> sourceType{};
  shared_ptr<UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground> subBackground{};
  shared_ptr<string> userId{};
  shared_ptr<string> width{};
  shared_ptr<string> x{};
  shared_ptr<string> y{};
  shared_ptr<long> ZOrder{};

  UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanes() {}

  explicit UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (subBackground) {
      res["SubBackground"] = subBackground ? boost::any(subBackground->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    if (ZOrder) {
      res["ZOrder"] = boost::any(*ZOrder);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<long>(boost::any_cast<long>(m["SourceType"]));
    }
    if (m.find("SubBackground") != m.end() && !m["SubBackground"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubBackground"].type()) {
        UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubBackground"]));
        subBackground = make_shared<UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanesSubBackground>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<string>(boost::any_cast<string>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<string>(boost::any_cast<string>(m["Y"]));
    }
    if (m.find("ZOrder") != m.end() && !m["ZOrder"].empty()) {
      ZOrder = make_shared<long>(boost::any_cast<long>(m["ZOrder"]));
    }
  }


  virtual ~UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanes() = default;
};
class UpdateRtcCloudRecordingRequestMixLayoutParams : public Darabonba::Model {
public:
  shared_ptr<UpdateRtcCloudRecordingRequestMixLayoutParamsMixBackground> mixBackground{};
  shared_ptr<vector<UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanes>> userPanes{};

  UpdateRtcCloudRecordingRequestMixLayoutParams() {}

  explicit UpdateRtcCloudRecordingRequestMixLayoutParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixBackground) {
      res["MixBackground"] = mixBackground ? boost::any(mixBackground->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userPanes) {
      vector<boost::any> temp1;
      for(auto item1:*userPanes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserPanes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixBackground") != m.end() && !m["MixBackground"].empty()) {
      if (typeid(map<string, boost::any>) == m["MixBackground"].type()) {
        UpdateRtcCloudRecordingRequestMixLayoutParamsMixBackground model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MixBackground"]));
        mixBackground = make_shared<UpdateRtcCloudRecordingRequestMixLayoutParamsMixBackground>(model1);
      }
    }
    if (m.find("UserPanes") != m.end() && !m["UserPanes"].empty()) {
      if (typeid(vector<boost::any>) == m["UserPanes"].type()) {
        vector<UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserPanes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userPanes = make_shared<vector<UpdateRtcCloudRecordingRequestMixLayoutParamsUserPanes>>(expect1);
      }
    }
  }


  virtual ~UpdateRtcCloudRecordingRequestMixLayoutParams() = default;
};
class UpdateRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList : public Darabonba::Model {
public:
  shared_ptr<long> sourceType{};
  shared_ptr<long> streamType{};
  shared_ptr<string> userId{};

  UpdateRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList() {}

  explicit UpdateRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<long>(boost::any_cast<long>(m["SourceType"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<long>(boost::any_cast<long>(m["StreamType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdateRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList() = default;
};
class UpdateRtcCloudRecordingRequestSubscribeParams : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList>> subscribeUserIdList{};

  UpdateRtcCloudRecordingRequestSubscribeParams() {}

  explicit UpdateRtcCloudRecordingRequestSubscribeParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subscribeUserIdList) {
      vector<boost::any> temp1;
      for(auto item1:*subscribeUserIdList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubscribeUserIdList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubscribeUserIdList") != m.end() && !m["SubscribeUserIdList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubscribeUserIdList"].type()) {
        vector<UpdateRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubscribeUserIdList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subscribeUserIdList = make_shared<vector<UpdateRtcCloudRecordingRequestSubscribeParamsSubscribeUserIdList>>(expect1);
      }
    }
  }


  virtual ~UpdateRtcCloudRecordingRequestSubscribeParams() = default;
};
class UpdateRtcCloudRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateRtcCloudRecordingRequestMixLayoutParams> mixLayoutParams{};
  shared_ptr<UpdateRtcCloudRecordingRequestSubscribeParams> subscribeParams{};
  shared_ptr<string> taskId{};

  UpdateRtcCloudRecordingRequest() {}

  explicit UpdateRtcCloudRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixLayoutParams) {
      res["MixLayoutParams"] = mixLayoutParams ? boost::any(mixLayoutParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscribeParams) {
      res["SubscribeParams"] = subscribeParams ? boost::any(subscribeParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixLayoutParams") != m.end() && !m["MixLayoutParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["MixLayoutParams"].type()) {
        UpdateRtcCloudRecordingRequestMixLayoutParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MixLayoutParams"]));
        mixLayoutParams = make_shared<UpdateRtcCloudRecordingRequestMixLayoutParams>(model1);
      }
    }
    if (m.find("SubscribeParams") != m.end() && !m["SubscribeParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscribeParams"].type()) {
        UpdateRtcCloudRecordingRequestSubscribeParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscribeParams"]));
        subscribeParams = make_shared<UpdateRtcCloudRecordingRequestSubscribeParams>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpdateRtcCloudRecordingRequest() = default;
};
class UpdateRtcCloudRecordingShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> mixLayoutParamsShrink{};
  shared_ptr<string> subscribeParamsShrink{};
  shared_ptr<string> taskId{};

  UpdateRtcCloudRecordingShrinkRequest() {}

  explicit UpdateRtcCloudRecordingShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixLayoutParamsShrink) {
      res["MixLayoutParams"] = boost::any(*mixLayoutParamsShrink);
    }
    if (subscribeParamsShrink) {
      res["SubscribeParams"] = boost::any(*subscribeParamsShrink);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MixLayoutParams") != m.end() && !m["MixLayoutParams"].empty()) {
      mixLayoutParamsShrink = make_shared<string>(boost::any_cast<string>(m["MixLayoutParams"]));
    }
    if (m.find("SubscribeParams") != m.end() && !m["SubscribeParams"].empty()) {
      subscribeParamsShrink = make_shared<string>(boost::any_cast<string>(m["SubscribeParams"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpdateRtcCloudRecordingShrinkRequest() = default;
};
class UpdateRtcCloudRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  UpdateRtcCloudRecordingResponseBody() {}

  explicit UpdateRtcCloudRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpdateRtcCloudRecordingResponseBody() = default;
};
class UpdateRtcCloudRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRtcCloudRecordingResponseBody> body{};

  UpdateRtcCloudRecordingResponse() {}

  explicit UpdateRtcCloudRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRtcCloudRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRtcCloudRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRtcCloudRecordingResponse() = default;
};
class UpdateRtcMPUEventSubRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> channelIds{};

  UpdateRtcMPUEventSubRequest() {}

  explicit UpdateRtcMPUEventSubRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (channelIds) {
      res["ChannelIds"] = boost::any(*channelIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("ChannelIds") != m.end() && !m["ChannelIds"].empty()) {
      channelIds = make_shared<string>(boost::any_cast<string>(m["ChannelIds"]));
    }
  }


  virtual ~UpdateRtcMPUEventSubRequest() = default;
};
class UpdateRtcMPUEventSubResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateRtcMPUEventSubResponseBody() {}

  explicit UpdateRtcMPUEventSubResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateRtcMPUEventSubResponseBody() = default;
};
class UpdateRtcMPUEventSubResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRtcMPUEventSubResponseBody> body{};

  UpdateRtcMPUEventSubResponse() {}

  explicit UpdateRtcMPUEventSubResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRtcMPUEventSubResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRtcMPUEventSubResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRtcMPUEventSubResponse() = default;
};
class UpdateRtsLiveStreamTranscodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<long> audioBitrate{};
  shared_ptr<long> audioChannelNum{};
  shared_ptr<string> audioCodec{};
  shared_ptr<string> audioProfile{};
  shared_ptr<long> audioRate{};
  shared_ptr<bool> deleteBframes{};
  shared_ptr<string> domain{};
  shared_ptr<long> FPS{};
  shared_ptr<string> gop{};
  shared_ptr<long> height{};
  shared_ptr<string> lazy{};
  shared_ptr<bool> opus{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> profile{};
  shared_ptr<string> regionId{};
  shared_ptr<string> template_{};
  shared_ptr<string> templateType{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<long> width{};

  UpdateRtsLiveStreamTranscodeRequest() {}

  explicit UpdateRtsLiveStreamTranscodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (audioBitrate) {
      res["AudioBitrate"] = boost::any(*audioBitrate);
    }
    if (audioChannelNum) {
      res["AudioChannelNum"] = boost::any(*audioChannelNum);
    }
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioProfile) {
      res["AudioProfile"] = boost::any(*audioProfile);
    }
    if (audioRate) {
      res["AudioRate"] = boost::any(*audioRate);
    }
    if (deleteBframes) {
      res["DeleteBframes"] = boost::any(*deleteBframes);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (FPS) {
      res["FPS"] = boost::any(*FPS);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (lazy) {
      res["Lazy"] = boost::any(*lazy);
    }
    if (opus) {
      res["Opus"] = boost::any(*opus);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("AudioBitrate") != m.end() && !m["AudioBitrate"].empty()) {
      audioBitrate = make_shared<long>(boost::any_cast<long>(m["AudioBitrate"]));
    }
    if (m.find("AudioChannelNum") != m.end() && !m["AudioChannelNum"].empty()) {
      audioChannelNum = make_shared<long>(boost::any_cast<long>(m["AudioChannelNum"]));
    }
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioProfile") != m.end() && !m["AudioProfile"].empty()) {
      audioProfile = make_shared<string>(boost::any_cast<string>(m["AudioProfile"]));
    }
    if (m.find("AudioRate") != m.end() && !m["AudioRate"].empty()) {
      audioRate = make_shared<long>(boost::any_cast<long>(m["AudioRate"]));
    }
    if (m.find("DeleteBframes") != m.end() && !m["DeleteBframes"].empty()) {
      deleteBframes = make_shared<bool>(boost::any_cast<bool>(m["DeleteBframes"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("FPS") != m.end() && !m["FPS"].empty()) {
      FPS = make_shared<long>(boost::any_cast<long>(m["FPS"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Lazy") != m.end() && !m["Lazy"].empty()) {
      lazy = make_shared<string>(boost::any_cast<string>(m["Lazy"]));
    }
    if (m.find("Opus") != m.end() && !m["Opus"].empty()) {
      opus = make_shared<bool>(boost::any_cast<bool>(m["Opus"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<long>(boost::any_cast<long>(m["Profile"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~UpdateRtsLiveStreamTranscodeRequest() = default;
};
class UpdateRtsLiveStreamTranscodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateRtsLiveStreamTranscodeResponseBody() {}

  explicit UpdateRtsLiveStreamTranscodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateRtsLiveStreamTranscodeResponseBody() = default;
};
class UpdateRtsLiveStreamTranscodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRtsLiveStreamTranscodeResponseBody> body{};

  UpdateRtsLiveStreamTranscodeResponse() {}

  explicit UpdateRtsLiveStreamTranscodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRtsLiveStreamTranscodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRtsLiveStreamTranscodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRtsLiveStreamTranscodeResponse() = default;
};
class VerifyLiveDomainOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> verifyType{};

  VerifyLiveDomainOwnerRequest() {}

  explicit VerifyLiveDomainOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (verifyType) {
      res["VerifyType"] = boost::any(*verifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VerifyType") != m.end() && !m["VerifyType"].empty()) {
      verifyType = make_shared<string>(boost::any_cast<string>(m["VerifyType"]));
    }
  }


  virtual ~VerifyLiveDomainOwnerRequest() = default;
};
class VerifyLiveDomainOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  VerifyLiveDomainOwnerResponseBody() {}

  explicit VerifyLiveDomainOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyLiveDomainOwnerResponseBody() = default;
};
class VerifyLiveDomainOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyLiveDomainOwnerResponseBody> body{};

  VerifyLiveDomainOwnerResponse() {}

  explicit VerifyLiveDomainOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyLiveDomainOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyLiveDomainOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyLiveDomainOwnerResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddCasterComponentResponse addCasterComponentWithOptions(shared_ptr<AddCasterComponentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterComponentResponse addCasterComponent(shared_ptr<AddCasterComponentRequest> request);
  AddCasterEpisodeResponse addCasterEpisodeWithOptions(shared_ptr<AddCasterEpisodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterEpisodeResponse addCasterEpisode(shared_ptr<AddCasterEpisodeRequest> request);
  AddCasterEpisodeGroupResponse addCasterEpisodeGroupWithOptions(shared_ptr<AddCasterEpisodeGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterEpisodeGroupResponse addCasterEpisodeGroup(shared_ptr<AddCasterEpisodeGroupRequest> request);
  AddCasterEpisodeGroupContentResponse addCasterEpisodeGroupContentWithOptions(shared_ptr<AddCasterEpisodeGroupContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterEpisodeGroupContentResponse addCasterEpisodeGroupContent(shared_ptr<AddCasterEpisodeGroupContentRequest> request);
  AddCasterLayoutResponse addCasterLayoutWithOptions(shared_ptr<AddCasterLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterLayoutResponse addCasterLayout(shared_ptr<AddCasterLayoutRequest> request);
  AddCasterProgramResponse addCasterProgramWithOptions(shared_ptr<AddCasterProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterProgramResponse addCasterProgram(shared_ptr<AddCasterProgramRequest> request);
  AddCasterVideoResourceResponse addCasterVideoResourceWithOptions(shared_ptr<AddCasterVideoResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasterVideoResourceResponse addCasterVideoResource(shared_ptr<AddCasterVideoResourceRequest> request);
  AddCustomLiveStreamTranscodeResponse addCustomLiveStreamTranscodeWithOptions(shared_ptr<AddCustomLiveStreamTranscodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCustomLiveStreamTranscodeResponse addCustomLiveStreamTranscode(shared_ptr<AddCustomLiveStreamTranscodeRequest> request);
  AddLiveAIProduceRulesResponse addLiveAIProduceRulesWithOptions(shared_ptr<AddLiveAIProduceRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveAIProduceRulesResponse addLiveAIProduceRules(shared_ptr<AddLiveAIProduceRulesRequest> request);
  AddLiveAISubtitleResponse addLiveAISubtitleWithOptions(shared_ptr<AddLiveAISubtitleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveAISubtitleResponse addLiveAISubtitle(shared_ptr<AddLiveAISubtitleRequest> request);
  AddLiveAppRecordConfigResponse addLiveAppRecordConfigWithOptions(shared_ptr<AddLiveAppRecordConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveAppRecordConfigResponse addLiveAppRecordConfig(shared_ptr<AddLiveAppRecordConfigRequest> request);
  AddLiveAppSnapshotConfigResponse addLiveAppSnapshotConfigWithOptions(shared_ptr<AddLiveAppSnapshotConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveAppSnapshotConfigResponse addLiveAppSnapshotConfig(shared_ptr<AddLiveAppSnapshotConfigRequest> request);
  AddLiveAudioAuditConfigResponse addLiveAudioAuditConfigWithOptions(shared_ptr<AddLiveAudioAuditConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveAudioAuditConfigResponse addLiveAudioAuditConfig(shared_ptr<AddLiveAudioAuditConfigRequest> request);
  AddLiveAudioAuditNotifyConfigResponse addLiveAudioAuditNotifyConfigWithOptions(shared_ptr<AddLiveAudioAuditNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveAudioAuditNotifyConfigResponse addLiveAudioAuditNotifyConfig(shared_ptr<AddLiveAudioAuditNotifyConfigRequest> request);
  AddLiveCenterTransferResponse addLiveCenterTransferWithOptions(shared_ptr<AddLiveCenterTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveCenterTransferResponse addLiveCenterTransfer(shared_ptr<AddLiveCenterTransferRequest> request);
  AddLiveDetectNotifyConfigResponse addLiveDetectNotifyConfigWithOptions(shared_ptr<AddLiveDetectNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveDetectNotifyConfigResponse addLiveDetectNotifyConfig(shared_ptr<AddLiveDetectNotifyConfigRequest> request);
  AddLiveDomainResponse addLiveDomainWithOptions(shared_ptr<AddLiveDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveDomainResponse addLiveDomain(shared_ptr<AddLiveDomainRequest> request);
  AddLiveDomainMappingResponse addLiveDomainMappingWithOptions(shared_ptr<AddLiveDomainMappingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveDomainMappingResponse addLiveDomainMapping(shared_ptr<AddLiveDomainMappingRequest> request);
  AddLiveDomainPlayMappingResponse addLiveDomainPlayMappingWithOptions(shared_ptr<AddLiveDomainPlayMappingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveDomainPlayMappingResponse addLiveDomainPlayMapping(shared_ptr<AddLiveDomainPlayMappingRequest> request);
  AddLiveMessageGroupBandResponse addLiveMessageGroupBandWithOptions(shared_ptr<AddLiveMessageGroupBandRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveMessageGroupBandResponse addLiveMessageGroupBand(shared_ptr<AddLiveMessageGroupBandRequest> request);
  AddLivePackageConfigResponse addLivePackageConfigWithOptions(shared_ptr<AddLivePackageConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLivePackageConfigResponse addLivePackageConfig(shared_ptr<AddLivePackageConfigRequest> request);
  AddLivePullStreamInfoConfigResponse addLivePullStreamInfoConfigWithOptions(shared_ptr<AddLivePullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLivePullStreamInfoConfigResponse addLivePullStreamInfoConfig(shared_ptr<AddLivePullStreamInfoConfigRequest> request);
  AddLiveRecordNotifyConfigResponse addLiveRecordNotifyConfigWithOptions(shared_ptr<AddLiveRecordNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveRecordNotifyConfigResponse addLiveRecordNotifyConfig(shared_ptr<AddLiveRecordNotifyConfigRequest> request);
  AddLiveRecordVodConfigResponse addLiveRecordVodConfigWithOptions(shared_ptr<AddLiveRecordVodConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveRecordVodConfigResponse addLiveRecordVodConfig(shared_ptr<AddLiveRecordVodConfigRequest> request);
  AddLiveSnapshotDetectPornConfigResponse addLiveSnapshotDetectPornConfigWithOptions(shared_ptr<AddLiveSnapshotDetectPornConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveSnapshotDetectPornConfigResponse addLiveSnapshotDetectPornConfig(shared_ptr<AddLiveSnapshotDetectPornConfigRequest> request);
  AddLiveSnapshotNotifyConfigResponse addLiveSnapshotNotifyConfigWithOptions(shared_ptr<AddLiveSnapshotNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveSnapshotNotifyConfigResponse addLiveSnapshotNotifyConfig(shared_ptr<AddLiveSnapshotNotifyConfigRequest> request);
  AddLiveStreamMergeResponse addLiveStreamMergeWithOptions(shared_ptr<AddLiveStreamMergeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveStreamMergeResponse addLiveStreamMerge(shared_ptr<AddLiveStreamMergeRequest> request);
  AddLiveStreamTranscodeResponse addLiveStreamTranscodeWithOptions(shared_ptr<AddLiveStreamTranscodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveStreamTranscodeResponse addLiveStreamTranscode(shared_ptr<AddLiveStreamTranscodeRequest> request);
  AddLiveStreamWatermarkResponse addLiveStreamWatermarkWithOptions(shared_ptr<AddLiveStreamWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveStreamWatermarkResponse addLiveStreamWatermark(shared_ptr<AddLiveStreamWatermarkRequest> request);
  AddLiveStreamWatermarkRuleResponse addLiveStreamWatermarkRuleWithOptions(shared_ptr<AddLiveStreamWatermarkRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLiveStreamWatermarkRuleResponse addLiveStreamWatermarkRule(shared_ptr<AddLiveStreamWatermarkRuleRequest> request);
  AddPlaylistItemsResponse addPlaylistItemsWithOptions(shared_ptr<AddPlaylistItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPlaylistItemsResponse addPlaylistItems(shared_ptr<AddPlaylistItemsRequest> request);
  AddRtsLiveStreamTranscodeResponse addRtsLiveStreamTranscodeWithOptions(shared_ptr<AddRtsLiveStreamTranscodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddRtsLiveStreamTranscodeResponse addRtsLiveStreamTranscode(shared_ptr<AddRtsLiveStreamTranscodeRequest> request);
  AddShowIntoShowListResponse addShowIntoShowListWithOptions(shared_ptr<AddShowIntoShowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddShowIntoShowListResponse addShowIntoShowList(shared_ptr<AddShowIntoShowListRequest> request);
  AddStudioLayoutResponse addStudioLayoutWithOptions(shared_ptr<AddStudioLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddStudioLayoutResponse addStudioLayout(shared_ptr<AddStudioLayoutRequest> request);
  AddTrancodeSEIResponse addTrancodeSEIWithOptions(shared_ptr<AddTrancodeSEIRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTrancodeSEIResponse addTrancodeSEI(shared_ptr<AddTrancodeSEIRequest> request);
  BanLiveMessageGroupResponse banLiveMessageGroupWithOptions(shared_ptr<BanLiveMessageGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BanLiveMessageGroupResponse banLiveMessageGroup(shared_ptr<BanLiveMessageGroupRequest> request);
  BatchDeleteLiveDomainConfigsResponse batchDeleteLiveDomainConfigsWithOptions(shared_ptr<BatchDeleteLiveDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteLiveDomainConfigsResponse batchDeleteLiveDomainConfigs(shared_ptr<BatchDeleteLiveDomainConfigsRequest> request);
  BatchGetOnlineUsersResponse batchGetOnlineUsersWithOptions(shared_ptr<BatchGetOnlineUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetOnlineUsersResponse batchGetOnlineUsers(shared_ptr<BatchGetOnlineUsersRequest> request);
  BatchSetLiveDomainConfigsResponse batchSetLiveDomainConfigsWithOptions(shared_ptr<BatchSetLiveDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetLiveDomainConfigsResponse batchSetLiveDomainConfigs(shared_ptr<BatchSetLiveDomainConfigsRequest> request);
  CancelMuteAllGroupUserResponse cancelMuteAllGroupUserWithOptions(shared_ptr<CancelMuteAllGroupUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelMuteAllGroupUserResponse cancelMuteAllGroupUser(shared_ptr<CancelMuteAllGroupUserRequest> request);
  CancelMuteGroupUserResponse cancelMuteGroupUserWithOptions(shared_ptr<CancelMuteGroupUserRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelMuteGroupUserResponse cancelMuteGroupUser(shared_ptr<CancelMuteGroupUserRequest> request);
  ChangeLiveDomainResourceGroupResponse changeLiveDomainResourceGroupWithOptions(shared_ptr<ChangeLiveDomainResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeLiveDomainResourceGroupResponse changeLiveDomainResourceGroup(shared_ptr<ChangeLiveDomainResourceGroupRequest> request);
  CheckLiveMessageUsersInGroupResponse checkLiveMessageUsersInGroupWithOptions(shared_ptr<CheckLiveMessageUsersInGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckLiveMessageUsersInGroupResponse checkLiveMessageUsersInGroup(shared_ptr<CheckLiveMessageUsersInGroupRequest> request);
  CheckLiveMessageUsersOnlineResponse checkLiveMessageUsersOnlineWithOptions(shared_ptr<CheckLiveMessageUsersOnlineRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckLiveMessageUsersOnlineResponse checkLiveMessageUsersOnline(shared_ptr<CheckLiveMessageUsersOnlineRequest> request);
  CloseLiveShiftResponse closeLiveShiftWithOptions(shared_ptr<CloseLiveShiftRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseLiveShiftResponse closeLiveShift(shared_ptr<CloseLiveShiftRequest> request);
  CopyCasterResponse copyCasterWithOptions(shared_ptr<CopyCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyCasterResponse copyCaster(shared_ptr<CopyCasterRequest> request);
  CopyCasterSceneConfigResponse copyCasterSceneConfigWithOptions(shared_ptr<CopyCasterSceneConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyCasterSceneConfigResponse copyCasterSceneConfig(shared_ptr<CopyCasterSceneConfigRequest> request);
  CreateCasterResponse createCasterWithOptions(shared_ptr<CreateCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCasterResponse createCaster(shared_ptr<CreateCasterRequest> request);
  CreateCustomTemplateResponse createCustomTemplateWithOptions(shared_ptr<CreateCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomTemplateResponse createCustomTemplate(shared_ptr<CreateCustomTemplateRequest> request);
  CreateEdgeTranscodeJobResponse createEdgeTranscodeJobWithOptions(shared_ptr<CreateEdgeTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEdgeTranscodeJobResponse createEdgeTranscodeJob(shared_ptr<CreateEdgeTranscodeJobRequest> request);
  CreateEventSubResponse createEventSubWithOptions(shared_ptr<CreateEventSubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEventSubResponse createEventSub(shared_ptr<CreateEventSubRequest> request);
  CreateLiveAIStudioResponse createLiveAIStudioWithOptions(shared_ptr<CreateLiveAIStudioRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveAIStudioResponse createLiveAIStudio(shared_ptr<CreateLiveAIStudioRequest> request);
  CreateLiveDelayConfigResponse createLiveDelayConfigWithOptions(shared_ptr<CreateLiveDelayConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveDelayConfigResponse createLiveDelayConfig(shared_ptr<CreateLiveDelayConfigRequest> request);
  CreateLiveMessageAppResponse createLiveMessageAppWithOptions(shared_ptr<CreateLiveMessageAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveMessageAppResponse createLiveMessageApp(shared_ptr<CreateLiveMessageAppRequest> request);
  CreateLiveMessageGroupResponse createLiveMessageGroupWithOptions(shared_ptr<CreateLiveMessageGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveMessageGroupResponse createLiveMessageGroup(shared_ptr<CreateLiveMessageGroupRequest> request);
  CreateLivePrivateLineResponse createLivePrivateLineWithOptions(shared_ptr<CreateLivePrivateLineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLivePrivateLineResponse createLivePrivateLine(shared_ptr<CreateLivePrivateLineRequest> request);
  CreateLivePullToPushResponse createLivePullToPushWithOptions(shared_ptr<CreateLivePullToPushRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLivePullToPushResponse createLivePullToPush(shared_ptr<CreateLivePullToPushRequest> request);
  CreateLiveRealTimeLogDeliveryResponse createLiveRealTimeLogDeliveryWithOptions(shared_ptr<CreateLiveRealTimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveRealTimeLogDeliveryResponse createLiveRealTimeLogDelivery(shared_ptr<CreateLiveRealTimeLogDeliveryRequest> request);
  CreateLiveStreamMonitorResponse createLiveStreamMonitorWithOptions(shared_ptr<CreateLiveStreamMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveStreamMonitorResponse createLiveStreamMonitor(shared_ptr<CreateLiveStreamMonitorRequest> request);
  CreateLiveStreamRecordIndexFilesResponse createLiveStreamRecordIndexFilesWithOptions(shared_ptr<CreateLiveStreamRecordIndexFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveStreamRecordIndexFilesResponse createLiveStreamRecordIndexFiles(shared_ptr<CreateLiveStreamRecordIndexFilesRequest> request);
  CreateMessageAppResponse createMessageAppWithOptions(shared_ptr<CreateMessageAppRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMessageAppResponse createMessageApp(shared_ptr<CreateMessageAppRequest> request);
  CreateMessageGroupResponse createMessageGroupWithOptions(shared_ptr<CreateMessageGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMessageGroupResponse createMessageGroup(shared_ptr<CreateMessageGroupRequest> request);
  CreateMixStreamResponse createMixStreamWithOptions(shared_ptr<CreateMixStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMixStreamResponse createMixStream(shared_ptr<CreateMixStreamRequest> request);
  CreateRTCWhipStreamAddressResponse createRTCWhipStreamAddressWithOptions(shared_ptr<CreateRTCWhipStreamAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRTCWhipStreamAddressResponse createRTCWhipStreamAddress(shared_ptr<CreateRTCWhipStreamAddressRequest> request);
  CreateRoomRealTimeStreamAddressResponse createRoomRealTimeStreamAddressWithOptions(shared_ptr<CreateRoomRealTimeStreamAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRoomRealTimeStreamAddressResponse createRoomRealTimeStreamAddress(shared_ptr<CreateRoomRealTimeStreamAddressRequest> request);
  CreateRtcAsrTaskResponse createRtcAsrTaskWithOptions(shared_ptr<CreateRtcAsrTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRtcAsrTaskResponse createRtcAsrTask(shared_ptr<CreateRtcAsrTaskRequest> request);
  CreateRtcMPUEventSubResponse createRtcMPUEventSubWithOptions(shared_ptr<CreateRtcMPUEventSubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRtcMPUEventSubResponse createRtcMPUEventSub(shared_ptr<CreateRtcMPUEventSubRequest> request);
  DeleteCasterResponse deleteCasterWithOptions(shared_ptr<DeleteCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterResponse deleteCaster(shared_ptr<DeleteCasterRequest> request);
  DeleteCasterComponentResponse deleteCasterComponentWithOptions(shared_ptr<DeleteCasterComponentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterComponentResponse deleteCasterComponent(shared_ptr<DeleteCasterComponentRequest> request);
  DeleteCasterEpisodeResponse deleteCasterEpisodeWithOptions(shared_ptr<DeleteCasterEpisodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterEpisodeResponse deleteCasterEpisode(shared_ptr<DeleteCasterEpisodeRequest> request);
  DeleteCasterEpisodeGroupResponse deleteCasterEpisodeGroupWithOptions(shared_ptr<DeleteCasterEpisodeGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterEpisodeGroupResponse deleteCasterEpisodeGroup(shared_ptr<DeleteCasterEpisodeGroupRequest> request);
  DeleteCasterLayoutResponse deleteCasterLayoutWithOptions(shared_ptr<DeleteCasterLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterLayoutResponse deleteCasterLayout(shared_ptr<DeleteCasterLayoutRequest> request);
  DeleteCasterProgramResponse deleteCasterProgramWithOptions(shared_ptr<DeleteCasterProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterProgramResponse deleteCasterProgram(shared_ptr<DeleteCasterProgramRequest> request);
  DeleteCasterSceneConfigResponse deleteCasterSceneConfigWithOptions(shared_ptr<DeleteCasterSceneConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterSceneConfigResponse deleteCasterSceneConfig(shared_ptr<DeleteCasterSceneConfigRequest> request);
  DeleteCasterVideoResourceResponse deleteCasterVideoResourceWithOptions(shared_ptr<DeleteCasterVideoResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCasterVideoResourceResponse deleteCasterVideoResource(shared_ptr<DeleteCasterVideoResourceRequest> request);
  DeleteChannelResponse deleteChannelWithOptions(shared_ptr<DeleteChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteChannelResponse deleteChannel(shared_ptr<DeleteChannelRequest> request);
  DeleteCustomTemplateResponse deleteCustomTemplateWithOptions(shared_ptr<DeleteCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomTemplateResponse deleteCustomTemplate(shared_ptr<DeleteCustomTemplateRequest> request);
  DeleteEdgeTranscodeJobResponse deleteEdgeTranscodeJobWithOptions(shared_ptr<DeleteEdgeTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEdgeTranscodeJobResponse deleteEdgeTranscodeJob(shared_ptr<DeleteEdgeTranscodeJobRequest> request);
  DeleteEventSubResponse deleteEventSubWithOptions(shared_ptr<DeleteEventSubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEventSubResponse deleteEventSub(shared_ptr<DeleteEventSubRequest> request);
  DeleteLiveAIProduceRulesResponse deleteLiveAIProduceRulesWithOptions(shared_ptr<DeleteLiveAIProduceRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveAIProduceRulesResponse deleteLiveAIProduceRules(shared_ptr<DeleteLiveAIProduceRulesRequest> request);
  DeleteLiveAIStudioResponse deleteLiveAIStudioWithOptions(shared_ptr<DeleteLiveAIStudioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveAIStudioResponse deleteLiveAIStudio(shared_ptr<DeleteLiveAIStudioRequest> request);
  DeleteLiveAISubtitleResponse deleteLiveAISubtitleWithOptions(shared_ptr<DeleteLiveAISubtitleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveAISubtitleResponse deleteLiveAISubtitle(shared_ptr<DeleteLiveAISubtitleRequest> request);
  DeleteLiveAppRecordConfigResponse deleteLiveAppRecordConfigWithOptions(shared_ptr<DeleteLiveAppRecordConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveAppRecordConfigResponse deleteLiveAppRecordConfig(shared_ptr<DeleteLiveAppRecordConfigRequest> request);
  DeleteLiveAppSnapshotConfigResponse deleteLiveAppSnapshotConfigWithOptions(shared_ptr<DeleteLiveAppSnapshotConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveAppSnapshotConfigResponse deleteLiveAppSnapshotConfig(shared_ptr<DeleteLiveAppSnapshotConfigRequest> request);
  DeleteLiveAudioAuditConfigResponse deleteLiveAudioAuditConfigWithOptions(shared_ptr<DeleteLiveAudioAuditConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveAudioAuditConfigResponse deleteLiveAudioAuditConfig(shared_ptr<DeleteLiveAudioAuditConfigRequest> request);
  DeleteLiveAudioAuditNotifyConfigResponse deleteLiveAudioAuditNotifyConfigWithOptions(shared_ptr<DeleteLiveAudioAuditNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveAudioAuditNotifyConfigResponse deleteLiveAudioAuditNotifyConfig(shared_ptr<DeleteLiveAudioAuditNotifyConfigRequest> request);
  DeleteLiveCenterTransferResponse deleteLiveCenterTransferWithOptions(shared_ptr<DeleteLiveCenterTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveCenterTransferResponse deleteLiveCenterTransfer(shared_ptr<DeleteLiveCenterTransferRequest> request);
  DeleteLiveDelayConfigResponse deleteLiveDelayConfigWithOptions(shared_ptr<DeleteLiveDelayConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveDelayConfigResponse deleteLiveDelayConfig(shared_ptr<DeleteLiveDelayConfigRequest> request);
  DeleteLiveDetectNotifyConfigResponse deleteLiveDetectNotifyConfigWithOptions(shared_ptr<DeleteLiveDetectNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveDetectNotifyConfigResponse deleteLiveDetectNotifyConfig(shared_ptr<DeleteLiveDetectNotifyConfigRequest> request);
  DeleteLiveDomainResponse deleteLiveDomainWithOptions(shared_ptr<DeleteLiveDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveDomainResponse deleteLiveDomain(shared_ptr<DeleteLiveDomainRequest> request);
  DeleteLiveDomainMappingResponse deleteLiveDomainMappingWithOptions(shared_ptr<DeleteLiveDomainMappingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveDomainMappingResponse deleteLiveDomainMapping(shared_ptr<DeleteLiveDomainMappingRequest> request);
  DeleteLiveDomainPlayMappingResponse deleteLiveDomainPlayMappingWithOptions(shared_ptr<DeleteLiveDomainPlayMappingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveDomainPlayMappingResponse deleteLiveDomainPlayMapping(shared_ptr<DeleteLiveDomainPlayMappingRequest> request);
  DeleteLiveEdgeTransferResponse deleteLiveEdgeTransferWithOptions(shared_ptr<DeleteLiveEdgeTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveEdgeTransferResponse deleteLiveEdgeTransfer(shared_ptr<DeleteLiveEdgeTransferRequest> request);
  DeleteLiveLazyPullStreamInfoConfigResponse deleteLiveLazyPullStreamInfoConfigWithOptions(shared_ptr<DeleteLiveLazyPullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveLazyPullStreamInfoConfigResponse deleteLiveLazyPullStreamInfoConfig(shared_ptr<DeleteLiveLazyPullStreamInfoConfigRequest> request);
  DeleteLiveMessageGroupResponse deleteLiveMessageGroupWithOptions(shared_ptr<DeleteLiveMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveMessageGroupResponse deleteLiveMessageGroup(shared_ptr<DeleteLiveMessageGroupRequest> request);
  DeleteLiveMessageGroupMessageResponse deleteLiveMessageGroupMessageWithOptions(shared_ptr<DeleteLiveMessageGroupMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveMessageGroupMessageResponse deleteLiveMessageGroupMessage(shared_ptr<DeleteLiveMessageGroupMessageRequest> request);
  DeleteLiveMessageUserMessageResponse deleteLiveMessageUserMessageWithOptions(shared_ptr<DeleteLiveMessageUserMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveMessageUserMessageResponse deleteLiveMessageUserMessage(shared_ptr<DeleteLiveMessageUserMessageRequest> request);
  DeleteLivePackageConfigResponse deleteLivePackageConfigWithOptions(shared_ptr<DeleteLivePackageConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLivePackageConfigResponse deleteLivePackageConfig(shared_ptr<DeleteLivePackageConfigRequest> request);
  DeleteLivePrivateLineResponse deleteLivePrivateLineWithOptions(shared_ptr<DeleteLivePrivateLineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLivePrivateLineResponse deleteLivePrivateLine(shared_ptr<DeleteLivePrivateLineRequest> request);
  DeleteLivePullStreamInfoConfigResponse deleteLivePullStreamInfoConfigWithOptions(shared_ptr<DeleteLivePullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLivePullStreamInfoConfigResponse deleteLivePullStreamInfoConfig(shared_ptr<DeleteLivePullStreamInfoConfigRequest> request);
  DeleteLivePullToPushResponse deleteLivePullToPushWithOptions(shared_ptr<DeleteLivePullToPushRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLivePullToPushResponse deleteLivePullToPush(shared_ptr<DeleteLivePullToPushRequest> request);
  DeleteLiveRealTimeLogLogstoreResponse deleteLiveRealTimeLogLogstoreWithOptions(shared_ptr<DeleteLiveRealTimeLogLogstoreRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRealTimeLogLogstoreResponse deleteLiveRealTimeLogLogstore(shared_ptr<DeleteLiveRealTimeLogLogstoreRequest> request);
  DeleteLiveRealtimeLogDeliveryResponse deleteLiveRealtimeLogDeliveryWithOptions(shared_ptr<DeleteLiveRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRealtimeLogDeliveryResponse deleteLiveRealtimeLogDelivery(shared_ptr<DeleteLiveRealtimeLogDeliveryRequest> request);
  DeleteLiveRecordNotifyConfigResponse deleteLiveRecordNotifyConfigWithOptions(shared_ptr<DeleteLiveRecordNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRecordNotifyConfigResponse deleteLiveRecordNotifyConfig(shared_ptr<DeleteLiveRecordNotifyConfigRequest> request);
  DeleteLiveRecordVodConfigResponse deleteLiveRecordVodConfigWithOptions(shared_ptr<DeleteLiveRecordVodConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRecordVodConfigResponse deleteLiveRecordVodConfig(shared_ptr<DeleteLiveRecordVodConfigRequest> request);
  DeleteLiveSnapshotDetectPornConfigResponse deleteLiveSnapshotDetectPornConfigWithOptions(shared_ptr<DeleteLiveSnapshotDetectPornConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveSnapshotDetectPornConfigResponse deleteLiveSnapshotDetectPornConfig(shared_ptr<DeleteLiveSnapshotDetectPornConfigRequest> request);
  DeleteLiveSnapshotNotifyConfigResponse deleteLiveSnapshotNotifyConfigWithOptions(shared_ptr<DeleteLiveSnapshotNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveSnapshotNotifyConfigResponse deleteLiveSnapshotNotifyConfig(shared_ptr<DeleteLiveSnapshotNotifyConfigRequest> request);
  DeleteLiveSpecificStagingConfigResponse deleteLiveSpecificStagingConfigWithOptions(shared_ptr<DeleteLiveSpecificStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveSpecificStagingConfigResponse deleteLiveSpecificStagingConfig(shared_ptr<DeleteLiveSpecificStagingConfigRequest> request);
  DeleteLiveStreamBlockResponse deleteLiveStreamBlockWithOptions(shared_ptr<DeleteLiveStreamBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamBlockResponse deleteLiveStreamBlock(shared_ptr<DeleteLiveStreamBlockRequest> request);
  DeleteLiveStreamMergeResponse deleteLiveStreamMergeWithOptions(shared_ptr<DeleteLiveStreamMergeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamMergeResponse deleteLiveStreamMerge(shared_ptr<DeleteLiveStreamMergeRequest> request);
  DeleteLiveStreamMonitorResponse deleteLiveStreamMonitorWithOptions(shared_ptr<DeleteLiveStreamMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamMonitorResponse deleteLiveStreamMonitor(shared_ptr<DeleteLiveStreamMonitorRequest> request);
  DeleteLiveStreamRecordIndexFilesResponse deleteLiveStreamRecordIndexFilesWithOptions(shared_ptr<DeleteLiveStreamRecordIndexFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamRecordIndexFilesResponse deleteLiveStreamRecordIndexFiles(shared_ptr<DeleteLiveStreamRecordIndexFilesRequest> request);
  DeleteLiveStreamTranscodeResponse deleteLiveStreamTranscodeWithOptions(shared_ptr<DeleteLiveStreamTranscodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamTranscodeResponse deleteLiveStreamTranscode(shared_ptr<DeleteLiveStreamTranscodeRequest> request);
  DeleteLiveStreamWatermarkResponse deleteLiveStreamWatermarkWithOptions(shared_ptr<DeleteLiveStreamWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamWatermarkResponse deleteLiveStreamWatermark(shared_ptr<DeleteLiveStreamWatermarkRequest> request);
  DeleteLiveStreamWatermarkRuleResponse deleteLiveStreamWatermarkRuleWithOptions(shared_ptr<DeleteLiveStreamWatermarkRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamWatermarkRuleResponse deleteLiveStreamWatermarkRule(shared_ptr<DeleteLiveStreamWatermarkRuleRequest> request);
  DeleteLiveStreamsNotifyUrlConfigResponse deleteLiveStreamsNotifyUrlConfigWithOptions(shared_ptr<DeleteLiveStreamsNotifyUrlConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveStreamsNotifyUrlConfigResponse deleteLiveStreamsNotifyUrlConfig(shared_ptr<DeleteLiveStreamsNotifyUrlConfigRequest> request);
  DeleteMessageAppResponse deleteMessageAppWithOptions(shared_ptr<DeleteMessageAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMessageAppResponse deleteMessageApp(shared_ptr<DeleteMessageAppRequest> request);
  DeleteMixStreamResponse deleteMixStreamWithOptions(shared_ptr<DeleteMixStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMixStreamResponse deleteMixStream(shared_ptr<DeleteMixStreamRequest> request);
  DeletePlaylistResponse deletePlaylistWithOptions(shared_ptr<DeletePlaylistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePlaylistResponse deletePlaylist(shared_ptr<DeletePlaylistRequest> request);
  DeletePlaylistItemsResponse deletePlaylistItemsWithOptions(shared_ptr<DeletePlaylistItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePlaylistItemsResponse deletePlaylistItems(shared_ptr<DeletePlaylistItemsRequest> request);
  DeleteRtcAsrTaskResponse deleteRtcAsrTaskWithOptions(shared_ptr<DeleteRtcAsrTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRtcAsrTaskResponse deleteRtcAsrTask(shared_ptr<DeleteRtcAsrTaskRequest> request);
  DeleteRtcMPUEventSubResponse deleteRtcMPUEventSubWithOptions(shared_ptr<DeleteRtcMPUEventSubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRtcMPUEventSubResponse deleteRtcMPUEventSub(shared_ptr<DeleteRtcMPUEventSubRequest> request);
  DeleteSnapshotCallbackAuthResponse deleteSnapshotCallbackAuthWithOptions(shared_ptr<DeleteSnapshotCallbackAuthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnapshotCallbackAuthResponse deleteSnapshotCallbackAuth(shared_ptr<DeleteSnapshotCallbackAuthRequest> request);
  DeleteSnapshotFilesResponse deleteSnapshotFilesWithOptions(shared_ptr<DeleteSnapshotFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnapshotFilesResponse deleteSnapshotFiles(shared_ptr<DeleteSnapshotFilesRequest> request);
  DeleteStudioLayoutResponse deleteStudioLayoutWithOptions(shared_ptr<DeleteStudioLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStudioLayoutResponse deleteStudioLayout(shared_ptr<DeleteStudioLayoutRequest> request);
  DescribeAutoShowListTasksResponse describeAutoShowListTasksWithOptions(shared_ptr<DescribeAutoShowListTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoShowListTasksResponse describeAutoShowListTasks(shared_ptr<DescribeAutoShowListTasksRequest> request);
  DescribeCasterChannelsResponse describeCasterChannelsWithOptions(shared_ptr<DescribeCasterChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterChannelsResponse describeCasterChannels(shared_ptr<DescribeCasterChannelsRequest> request);
  DescribeCasterComponentsResponse describeCasterComponentsWithOptions(shared_ptr<DescribeCasterComponentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterComponentsResponse describeCasterComponents(shared_ptr<DescribeCasterComponentsRequest> request);
  DescribeCasterConfigResponse describeCasterConfigWithOptions(shared_ptr<DescribeCasterConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterConfigResponse describeCasterConfig(shared_ptr<DescribeCasterConfigRequest> request);
  DescribeCasterLayoutsResponse describeCasterLayoutsWithOptions(shared_ptr<DescribeCasterLayoutsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterLayoutsResponse describeCasterLayouts(shared_ptr<DescribeCasterLayoutsRequest> request);
  DescribeCasterProgramResponse describeCasterProgramWithOptions(shared_ptr<DescribeCasterProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterProgramResponse describeCasterProgram(shared_ptr<DescribeCasterProgramRequest> request);
  DescribeCasterSceneAudioResponse describeCasterSceneAudioWithOptions(shared_ptr<DescribeCasterSceneAudioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterSceneAudioResponse describeCasterSceneAudio(shared_ptr<DescribeCasterSceneAudioRequest> request);
  DescribeCasterScenesResponse describeCasterScenesWithOptions(shared_ptr<DescribeCasterScenesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterScenesResponse describeCasterScenes(shared_ptr<DescribeCasterScenesRequest> request);
  DescribeCasterStreamUrlResponse describeCasterStreamUrlWithOptions(shared_ptr<DescribeCasterStreamUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterStreamUrlResponse describeCasterStreamUrl(shared_ptr<DescribeCasterStreamUrlRequest> request);
  DescribeCasterVideoResourcesResponse describeCasterVideoResourcesWithOptions(shared_ptr<DescribeCasterVideoResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCasterVideoResourcesResponse describeCasterVideoResources(shared_ptr<DescribeCasterVideoResourcesRequest> request);
  DescribeCastersResponse describeCastersWithOptions(shared_ptr<DescribeCastersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCastersResponse describeCasters(shared_ptr<DescribeCastersRequest> request);
  DescribeChannelParticipantsResponse describeChannelParticipantsWithOptions(shared_ptr<DescribeChannelParticipantsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeChannelParticipantsResponse describeChannelParticipants(shared_ptr<DescribeChannelParticipantsRequest> request);
  DescribeChannelUsersResponse describeChannelUsersWithOptions(shared_ptr<DescribeChannelUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeChannelUsersResponse describeChannelUsers(shared_ptr<DescribeChannelUsersRequest> request);
  DescribeDomainUsageDataResponse describeDomainUsageDataWithOptions(shared_ptr<DescribeDomainUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainUsageDataResponse describeDomainUsageData(shared_ptr<DescribeDomainUsageDataRequest> request);
  DescribeDomainWithIntegrityResponse describeDomainWithIntegrityWithOptions(shared_ptr<DescribeDomainWithIntegrityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainWithIntegrityResponse describeDomainWithIntegrity(shared_ptr<DescribeDomainWithIntegrityRequest> request);
  DescribeHlsLiveStreamRealTimeBpsDataResponse describeHlsLiveStreamRealTimeBpsDataWithOptions(shared_ptr<DescribeHlsLiveStreamRealTimeBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHlsLiveStreamRealTimeBpsDataResponse describeHlsLiveStreamRealTimeBpsData(shared_ptr<DescribeHlsLiveStreamRealTimeBpsDataRequest> request);
  DescribeLiveAIProduceRulesResponse describeLiveAIProduceRulesWithOptions(shared_ptr<DescribeLiveAIProduceRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveAIProduceRulesResponse describeLiveAIProduceRules(shared_ptr<DescribeLiveAIProduceRulesRequest> request);
  DescribeLiveAIStudioResponse describeLiveAIStudioWithOptions(shared_ptr<DescribeLiveAIStudioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveAIStudioResponse describeLiveAIStudio(shared_ptr<DescribeLiveAIStudioRequest> request);
  DescribeLiveAISubtitleResponse describeLiveAISubtitleWithOptions(shared_ptr<DescribeLiveAISubtitleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveAISubtitleResponse describeLiveAISubtitle(shared_ptr<DescribeLiveAISubtitleRequest> request);
  DescribeLiveAudioAuditConfigResponse describeLiveAudioAuditConfigWithOptions(shared_ptr<DescribeLiveAudioAuditConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveAudioAuditConfigResponse describeLiveAudioAuditConfig(shared_ptr<DescribeLiveAudioAuditConfigRequest> request);
  DescribeLiveAudioAuditNotifyConfigResponse describeLiveAudioAuditNotifyConfigWithOptions(shared_ptr<DescribeLiveAudioAuditNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveAudioAuditNotifyConfigResponse describeLiveAudioAuditNotifyConfig(shared_ptr<DescribeLiveAudioAuditNotifyConfigRequest> request);
  DescribeLiveCdnDiagnoseInfoResponse describeLiveCdnDiagnoseInfoWithOptions(shared_ptr<DescribeLiveCdnDiagnoseInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveCdnDiagnoseInfoResponse describeLiveCdnDiagnoseInfo(shared_ptr<DescribeLiveCdnDiagnoseInfoRequest> request);
  DescribeLiveCenterStreamRateDataResponse describeLiveCenterStreamRateDataWithOptions(shared_ptr<DescribeLiveCenterStreamRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveCenterStreamRateDataResponse describeLiveCenterStreamRateData(shared_ptr<DescribeLiveCenterStreamRateDataRequest> request);
  DescribeLiveCenterTransferResponse describeLiveCenterTransferWithOptions(shared_ptr<DescribeLiveCenterTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveCenterTransferResponse describeLiveCenterTransfer(shared_ptr<DescribeLiveCenterTransferRequest> request);
  DescribeLiveCertificateDetailResponse describeLiveCertificateDetailWithOptions(shared_ptr<DescribeLiveCertificateDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveCertificateDetailResponse describeLiveCertificateDetail(shared_ptr<DescribeLiveCertificateDetailRequest> request);
  DescribeLiveCertificateListResponse describeLiveCertificateListWithOptions(shared_ptr<DescribeLiveCertificateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveCertificateListResponse describeLiveCertificateList(shared_ptr<DescribeLiveCertificateListRequest> request);
  DescribeLiveDelayConfigResponse describeLiveDelayConfigWithOptions(shared_ptr<DescribeLiveDelayConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDelayConfigResponse describeLiveDelayConfig(shared_ptr<DescribeLiveDelayConfigRequest> request);
  DescribeLiveDelayedStreamingUsageResponse describeLiveDelayedStreamingUsageWithOptions(shared_ptr<DescribeLiveDelayedStreamingUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDelayedStreamingUsageResponse describeLiveDelayedStreamingUsage(shared_ptr<DescribeLiveDelayedStreamingUsageRequest> request);
  DescribeLiveDetectNotifyConfigResponse describeLiveDetectNotifyConfigWithOptions(shared_ptr<DescribeLiveDetectNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDetectNotifyConfigResponse describeLiveDetectNotifyConfig(shared_ptr<DescribeLiveDetectNotifyConfigRequest> request);
  DescribeLiveDetectPornDataResponse describeLiveDetectPornDataWithOptions(shared_ptr<DescribeLiveDetectPornDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDetectPornDataResponse describeLiveDetectPornData(shared_ptr<DescribeLiveDetectPornDataRequest> request);
  DescribeLiveDomainBpsDataResponse describeLiveDomainBpsDataWithOptions(shared_ptr<DescribeLiveDomainBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainBpsDataResponse describeLiveDomainBpsData(shared_ptr<DescribeLiveDomainBpsDataRequest> request);
  DescribeLiveDomainBpsDataByLayerResponse describeLiveDomainBpsDataByLayerWithOptions(shared_ptr<DescribeLiveDomainBpsDataByLayerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainBpsDataByLayerResponse describeLiveDomainBpsDataByLayer(shared_ptr<DescribeLiveDomainBpsDataByLayerRequest> request);
  DescribeLiveDomainByCertificateResponse describeLiveDomainByCertificateWithOptions(shared_ptr<DescribeLiveDomainByCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainByCertificateResponse describeLiveDomainByCertificate(shared_ptr<DescribeLiveDomainByCertificateRequest> request);
  DescribeLiveDomainCertificateInfoResponse describeLiveDomainCertificateInfoWithOptions(shared_ptr<DescribeLiveDomainCertificateInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainCertificateInfoResponse describeLiveDomainCertificateInfo(shared_ptr<DescribeLiveDomainCertificateInfoRequest> request);
  DescribeLiveDomainConfigsResponse describeLiveDomainConfigsWithOptions(shared_ptr<DescribeLiveDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainConfigsResponse describeLiveDomainConfigs(shared_ptr<DescribeLiveDomainConfigsRequest> request);
  DescribeLiveDomainDetailResponse describeLiveDomainDetailWithOptions(shared_ptr<DescribeLiveDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainDetailResponse describeLiveDomainDetail(shared_ptr<DescribeLiveDomainDetailRequest> request);
  DescribeLiveDomainEdgeLogResponse describeLiveDomainEdgeLogWithOptions(shared_ptr<DescribeLiveDomainEdgeLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainEdgeLogResponse describeLiveDomainEdgeLog(shared_ptr<DescribeLiveDomainEdgeLogRequest> request);
  DescribeLiveDomainFrameRateAndBitRateDataResponse describeLiveDomainFrameRateAndBitRateDataWithOptions(shared_ptr<DescribeLiveDomainFrameRateAndBitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainFrameRateAndBitRateDataResponse describeLiveDomainFrameRateAndBitRateData(shared_ptr<DescribeLiveDomainFrameRateAndBitRateDataRequest> request);
  DescribeLiveDomainLimitResponse describeLiveDomainLimitWithOptions(shared_ptr<DescribeLiveDomainLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainLimitResponse describeLiveDomainLimit(shared_ptr<DescribeLiveDomainLimitRequest> request);
  DescribeLiveDomainLogResponse describeLiveDomainLogWithOptions(shared_ptr<DescribeLiveDomainLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainLogResponse describeLiveDomainLog(shared_ptr<DescribeLiveDomainLogRequest> request);
  DescribeLiveDomainLogExTtlResponse describeLiveDomainLogExTtlWithOptions(shared_ptr<DescribeLiveDomainLogExTtlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainLogExTtlResponse describeLiveDomainLogExTtl(shared_ptr<DescribeLiveDomainLogExTtlRequest> request);
  DescribeLiveDomainMappingResponse describeLiveDomainMappingWithOptions(shared_ptr<DescribeLiveDomainMappingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainMappingResponse describeLiveDomainMapping(shared_ptr<DescribeLiveDomainMappingRequest> request);
  DescribeLiveDomainMonitoringUsageDataResponse describeLiveDomainMonitoringUsageDataWithOptions(shared_ptr<DescribeLiveDomainMonitoringUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainMonitoringUsageDataResponse describeLiveDomainMonitoringUsageData(shared_ptr<DescribeLiveDomainMonitoringUsageDataRequest> request);
  DescribeLiveDomainMultiStreamConfigResponse describeLiveDomainMultiStreamConfigWithOptions(shared_ptr<DescribeLiveDomainMultiStreamConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainMultiStreamConfigResponse describeLiveDomainMultiStreamConfig(shared_ptr<DescribeLiveDomainMultiStreamConfigRequest> request);
  DescribeLiveDomainOnlineUserNumResponse describeLiveDomainOnlineUserNumWithOptions(shared_ptr<DescribeLiveDomainOnlineUserNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainOnlineUserNumResponse describeLiveDomainOnlineUserNum(shared_ptr<DescribeLiveDomainOnlineUserNumRequest> request);
  DescribeLiveDomainPublishErrorCodeResponse describeLiveDomainPublishErrorCodeWithOptions(shared_ptr<DescribeLiveDomainPublishErrorCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainPublishErrorCodeResponse describeLiveDomainPublishErrorCode(shared_ptr<DescribeLiveDomainPublishErrorCodeRequest> request);
  DescribeLiveDomainPushBpsDataResponse describeLiveDomainPushBpsDataWithOptions(shared_ptr<DescribeLiveDomainPushBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainPushBpsDataResponse describeLiveDomainPushBpsData(shared_ptr<DescribeLiveDomainPushBpsDataRequest> request);
  DescribeLiveDomainPushTrafficDataResponse describeLiveDomainPushTrafficDataWithOptions(shared_ptr<DescribeLiveDomainPushTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainPushTrafficDataResponse describeLiveDomainPushTrafficData(shared_ptr<DescribeLiveDomainPushTrafficDataRequest> request);
  DescribeLiveDomainPvUvDataResponse describeLiveDomainPvUvDataWithOptions(shared_ptr<DescribeLiveDomainPvUvDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainPvUvDataResponse describeLiveDomainPvUvData(shared_ptr<DescribeLiveDomainPvUvDataRequest> request);
  DescribeLiveDomainRealTimeBpsDataResponse describeLiveDomainRealTimeBpsDataWithOptions(shared_ptr<DescribeLiveDomainRealTimeBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainRealTimeBpsDataResponse describeLiveDomainRealTimeBpsData(shared_ptr<DescribeLiveDomainRealTimeBpsDataRequest> request);
  DescribeLiveDomainRealTimeHttpCodeDataResponse describeLiveDomainRealTimeHttpCodeDataWithOptions(shared_ptr<DescribeLiveDomainRealTimeHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainRealTimeHttpCodeDataResponse describeLiveDomainRealTimeHttpCodeData(shared_ptr<DescribeLiveDomainRealTimeHttpCodeDataRequest> request);
  DescribeLiveDomainRealTimeTrafficDataResponse describeLiveDomainRealTimeTrafficDataWithOptions(shared_ptr<DescribeLiveDomainRealTimeTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainRealTimeTrafficDataResponse describeLiveDomainRealTimeTrafficData(shared_ptr<DescribeLiveDomainRealTimeTrafficDataRequest> request);
  DescribeLiveDomainRealtimeLogDeliveryResponse describeLiveDomainRealtimeLogDeliveryWithOptions(shared_ptr<DescribeLiveDomainRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainRealtimeLogDeliveryResponse describeLiveDomainRealtimeLogDelivery(shared_ptr<DescribeLiveDomainRealtimeLogDeliveryRequest> request);
  DescribeLiveDomainRecordUsageDataResponse describeLiveDomainRecordUsageDataWithOptions(shared_ptr<DescribeLiveDomainRecordUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainRecordUsageDataResponse describeLiveDomainRecordUsageData(shared_ptr<DescribeLiveDomainRecordUsageDataRequest> request);
  DescribeLiveDomainSnapshotDataResponse describeLiveDomainSnapshotDataWithOptions(shared_ptr<DescribeLiveDomainSnapshotDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainSnapshotDataResponse describeLiveDomainSnapshotData(shared_ptr<DescribeLiveDomainSnapshotDataRequest> request);
  DescribeLiveDomainStagingConfigResponse describeLiveDomainStagingConfigWithOptions(shared_ptr<DescribeLiveDomainStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainStagingConfigResponse describeLiveDomainStagingConfig(shared_ptr<DescribeLiveDomainStagingConfigRequest> request);
  DescribeLiveDomainStreamTranscodeDataResponse describeLiveDomainStreamTranscodeDataWithOptions(shared_ptr<DescribeLiveDomainStreamTranscodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainStreamTranscodeDataResponse describeLiveDomainStreamTranscodeData(shared_ptr<DescribeLiveDomainStreamTranscodeDataRequest> request);
  DescribeLiveDomainTimeShiftDataResponse describeLiveDomainTimeShiftDataWithOptions(shared_ptr<DescribeLiveDomainTimeShiftDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainTimeShiftDataResponse describeLiveDomainTimeShiftData(shared_ptr<DescribeLiveDomainTimeShiftDataRequest> request);
  DescribeLiveDomainTrafficDataResponse describeLiveDomainTrafficDataWithOptions(shared_ptr<DescribeLiveDomainTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainTrafficDataResponse describeLiveDomainTrafficData(shared_ptr<DescribeLiveDomainTrafficDataRequest> request);
  DescribeLiveDomainTranscodeParamsResponse describeLiveDomainTranscodeParamsWithOptions(shared_ptr<DescribeLiveDomainTranscodeParamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDomainTranscodeParamsResponse describeLiveDomainTranscodeParams(shared_ptr<DescribeLiveDomainTranscodeParamsRequest> request);
  DescribeLiveDrmUsageDataResponse describeLiveDrmUsageDataWithOptions(shared_ptr<DescribeLiveDrmUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveDrmUsageDataResponse describeLiveDrmUsageData(shared_ptr<DescribeLiveDrmUsageDataRequest> request);
  DescribeLiveEdgeTransferResponse describeLiveEdgeTransferWithOptions(shared_ptr<DescribeLiveEdgeTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveEdgeTransferResponse describeLiveEdgeTransfer(shared_ptr<DescribeLiveEdgeTransferRequest> request);
  DescribeLiveGrtnDurationResponse describeLiveGrtnDurationWithOptions(shared_ptr<DescribeLiveGrtnDurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveGrtnDurationResponse describeLiveGrtnDuration(shared_ptr<DescribeLiveGrtnDurationRequest> request);
  DescribeLiveHttpsDomainListResponse describeLiveHttpsDomainListWithOptions(shared_ptr<DescribeLiveHttpsDomainListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveHttpsDomainListResponse describeLiveHttpsDomainList(shared_ptr<DescribeLiveHttpsDomainListRequest> request);
  DescribeLiveInteractionMetricDataResponse describeLiveInteractionMetricDataWithOptions(shared_ptr<DescribeLiveInteractionMetricDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveInteractionMetricDataResponse describeLiveInteractionMetricData(shared_ptr<DescribeLiveInteractionMetricDataRequest> request);
  DescribeLiveIpInfoResponse describeLiveIpInfoWithOptions(shared_ptr<DescribeLiveIpInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveIpInfoResponse describeLiveIpInfo(shared_ptr<DescribeLiveIpInfoRequest> request);
  DescribeLiveLazyPullStreamConfigResponse describeLiveLazyPullStreamConfigWithOptions(shared_ptr<DescribeLiveLazyPullStreamConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveLazyPullStreamConfigResponse describeLiveLazyPullStreamConfig(shared_ptr<DescribeLiveLazyPullStreamConfigRequest> request);
  DescribeLiveMessageAppResponse describeLiveMessageAppWithOptions(shared_ptr<DescribeLiveMessageAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveMessageAppResponse describeLiveMessageApp(shared_ptr<DescribeLiveMessageAppRequest> request);
  DescribeLiveMessageGroupResponse describeLiveMessageGroupWithOptions(shared_ptr<DescribeLiveMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveMessageGroupResponse describeLiveMessageGroup(shared_ptr<DescribeLiveMessageGroupRequest> request);
  DescribeLiveMessageGroupBandResponse describeLiveMessageGroupBandWithOptions(shared_ptr<DescribeLiveMessageGroupBandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveMessageGroupBandResponse describeLiveMessageGroupBand(shared_ptr<DescribeLiveMessageGroupBandRequest> request);
  DescribeLivePackageConfigResponse describeLivePackageConfigWithOptions(shared_ptr<DescribeLivePackageConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLivePackageConfigResponse describeLivePackageConfig(shared_ptr<DescribeLivePackageConfigRequest> request);
  DescribeLivePrivateLineAreasResponse describeLivePrivateLineAreasWithOptions(shared_ptr<DescribeLivePrivateLineAreasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLivePrivateLineAreasResponse describeLivePrivateLineAreas(shared_ptr<DescribeLivePrivateLineAreasRequest> request);
  DescribeLivePrivateLineAvailGAResponse describeLivePrivateLineAvailGAWithOptions(shared_ptr<DescribeLivePrivateLineAvailGARequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLivePrivateLineAvailGAResponse describeLivePrivateLineAvailGA(shared_ptr<DescribeLivePrivateLineAvailGARequest> request);
  DescribeLiveProducerUsageDataResponse describeLiveProducerUsageDataWithOptions(shared_ptr<DescribeLiveProducerUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveProducerUsageDataResponse describeLiveProducerUsageData(shared_ptr<DescribeLiveProducerUsageDataRequest> request);
  DescribeLivePullStreamConfigResponse describeLivePullStreamConfigWithOptions(shared_ptr<DescribeLivePullStreamConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLivePullStreamConfigResponse describeLivePullStreamConfig(shared_ptr<DescribeLivePullStreamConfigRequest> request);
  DescribeLivePullToPushResponse describeLivePullToPushWithOptions(shared_ptr<DescribeLivePullToPushRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLivePullToPushResponse describeLivePullToPush(shared_ptr<DescribeLivePullToPushRequest> request);
  DescribeLivePullToPushListResponse describeLivePullToPushListWithOptions(shared_ptr<DescribeLivePullToPushListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLivePullToPushListResponse describeLivePullToPushList(shared_ptr<DescribeLivePullToPushListRequest> request);
  DescribeLivePushProxyLogResponse describeLivePushProxyLogWithOptions(shared_ptr<DescribeLivePushProxyLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLivePushProxyLogResponse describeLivePushProxyLog(shared_ptr<DescribeLivePushProxyLogRequest> request);
  DescribeLivePushProxyUsageDataResponse describeLivePushProxyUsageDataWithOptions(shared_ptr<DescribeLivePushProxyUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLivePushProxyUsageDataResponse describeLivePushProxyUsageData(shared_ptr<DescribeLivePushProxyUsageDataRequest> request);
  DescribeLiveRealtimeDeliveryAccResponse describeLiveRealtimeDeliveryAccWithOptions(shared_ptr<DescribeLiveRealtimeDeliveryAccRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveRealtimeDeliveryAccResponse describeLiveRealtimeDeliveryAcc(shared_ptr<DescribeLiveRealtimeDeliveryAccRequest> request);
  DescribeLiveRealtimeLogAuthorizedResponse describeLiveRealtimeLogAuthorizedWithOptions(shared_ptr<DescribeLiveRealtimeLogAuthorizedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveRealtimeLogAuthorizedResponse describeLiveRealtimeLogAuthorized(shared_ptr<DescribeLiveRealtimeLogAuthorizedRequest> request);
  DescribeLiveRecordConfigResponse describeLiveRecordConfigWithOptions(shared_ptr<DescribeLiveRecordConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveRecordConfigResponse describeLiveRecordConfig(shared_ptr<DescribeLiveRecordConfigRequest> request);
  DescribeLiveRecordNotifyConfigResponse describeLiveRecordNotifyConfigWithOptions(shared_ptr<DescribeLiveRecordNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveRecordNotifyConfigResponse describeLiveRecordNotifyConfig(shared_ptr<DescribeLiveRecordNotifyConfigRequest> request);
  DescribeLiveRecordNotifyRecordsResponse describeLiveRecordNotifyRecordsWithOptions(shared_ptr<DescribeLiveRecordNotifyRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveRecordNotifyRecordsResponse describeLiveRecordNotifyRecords(shared_ptr<DescribeLiveRecordNotifyRecordsRequest> request);
  DescribeLiveRecordVodConfigsResponse describeLiveRecordVodConfigsWithOptions(shared_ptr<DescribeLiveRecordVodConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveRecordVodConfigsResponse describeLiveRecordVodConfigs(shared_ptr<DescribeLiveRecordVodConfigsRequest> request);
  DescribeLiveShiftConfigsResponse describeLiveShiftConfigsWithOptions(shared_ptr<DescribeLiveShiftConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveShiftConfigsResponse describeLiveShiftConfigs(shared_ptr<DescribeLiveShiftConfigsRequest> request);
  DescribeLiveSnapshotConfigResponse describeLiveSnapshotConfigWithOptions(shared_ptr<DescribeLiveSnapshotConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveSnapshotConfigResponse describeLiveSnapshotConfig(shared_ptr<DescribeLiveSnapshotConfigRequest> request);
  DescribeLiveSnapshotDetectPornConfigResponse describeLiveSnapshotDetectPornConfigWithOptions(shared_ptr<DescribeLiveSnapshotDetectPornConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveSnapshotDetectPornConfigResponse describeLiveSnapshotDetectPornConfig(shared_ptr<DescribeLiveSnapshotDetectPornConfigRequest> request);
  DescribeLiveSnapshotNotifyConfigResponse describeLiveSnapshotNotifyConfigWithOptions(shared_ptr<DescribeLiveSnapshotNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveSnapshotNotifyConfigResponse describeLiveSnapshotNotifyConfig(shared_ptr<DescribeLiveSnapshotNotifyConfigRequest> request);
  DescribeLiveStreamAuthCheckingResponse describeLiveStreamAuthCheckingWithOptions(shared_ptr<DescribeLiveStreamAuthCheckingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamAuthCheckingResponse describeLiveStreamAuthChecking(shared_ptr<DescribeLiveStreamAuthCheckingRequest> request);
  DescribeLiveStreamBitRateDataResponse describeLiveStreamBitRateDataWithOptions(shared_ptr<DescribeLiveStreamBitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamBitRateDataResponse describeLiveStreamBitRateData(shared_ptr<DescribeLiveStreamBitRateDataRequest> request);
  DescribeLiveStreamCountResponse describeLiveStreamCountWithOptions(shared_ptr<DescribeLiveStreamCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamCountResponse describeLiveStreamCount(shared_ptr<DescribeLiveStreamCountRequest> request);
  DescribeLiveStreamDelayConfigResponse describeLiveStreamDelayConfigWithOptions(shared_ptr<DescribeLiveStreamDelayConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamDelayConfigResponse describeLiveStreamDelayConfig(shared_ptr<DescribeLiveStreamDelayConfigRequest> request);
  DescribeLiveStreamDetailFrameRateAndBitRateDataResponse describeLiveStreamDetailFrameRateAndBitRateDataWithOptions(shared_ptr<DescribeLiveStreamDetailFrameRateAndBitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamDetailFrameRateAndBitRateDataResponse describeLiveStreamDetailFrameRateAndBitRateData(shared_ptr<DescribeLiveStreamDetailFrameRateAndBitRateDataRequest> request);
  DescribeLiveStreamHistoryUserNumResponse describeLiveStreamHistoryUserNumWithOptions(shared_ptr<DescribeLiveStreamHistoryUserNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamHistoryUserNumResponse describeLiveStreamHistoryUserNum(shared_ptr<DescribeLiveStreamHistoryUserNumRequest> request);
  DescribeLiveStreamMergeResponse describeLiveStreamMergeWithOptions(shared_ptr<DescribeLiveStreamMergeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamMergeResponse describeLiveStreamMerge(shared_ptr<DescribeLiveStreamMergeRequest> request);
  DescribeLiveStreamMetricDetailDataResponse describeLiveStreamMetricDetailDataWithOptions(shared_ptr<DescribeLiveStreamMetricDetailDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamMetricDetailDataResponse describeLiveStreamMetricDetailData(shared_ptr<DescribeLiveStreamMetricDetailDataRequest> request);
  DescribeLiveStreamMonitorListResponse describeLiveStreamMonitorListWithOptions(shared_ptr<DescribeLiveStreamMonitorListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamMonitorListResponse describeLiveStreamMonitorList(shared_ptr<DescribeLiveStreamMonitorListRequest> request);
  DescribeLiveStreamPreloadTasksResponse describeLiveStreamPreloadTasksWithOptions(shared_ptr<DescribeLiveStreamPreloadTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamPreloadTasksResponse describeLiveStreamPreloadTasks(shared_ptr<DescribeLiveStreamPreloadTasksRequest> request);
  DescribeLiveStreamPushMetricDetailDataResponse describeLiveStreamPushMetricDetailDataWithOptions(shared_ptr<DescribeLiveStreamPushMetricDetailDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamPushMetricDetailDataResponse describeLiveStreamPushMetricDetailData(shared_ptr<DescribeLiveStreamPushMetricDetailDataRequest> request);
  DescribeLiveStreamRecordContentResponse describeLiveStreamRecordContentWithOptions(shared_ptr<DescribeLiveStreamRecordContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamRecordContentResponse describeLiveStreamRecordContent(shared_ptr<DescribeLiveStreamRecordContentRequest> request);
  DescribeLiveStreamRecordIndexFileResponse describeLiveStreamRecordIndexFileWithOptions(shared_ptr<DescribeLiveStreamRecordIndexFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamRecordIndexFileResponse describeLiveStreamRecordIndexFile(shared_ptr<DescribeLiveStreamRecordIndexFileRequest> request);
  DescribeLiveStreamRecordIndexFilesResponse describeLiveStreamRecordIndexFilesWithOptions(shared_ptr<DescribeLiveStreamRecordIndexFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamRecordIndexFilesResponse describeLiveStreamRecordIndexFiles(shared_ptr<DescribeLiveStreamRecordIndexFilesRequest> request);
  DescribeLiveStreamSnapshotInfoResponse describeLiveStreamSnapshotInfoWithOptions(shared_ptr<DescribeLiveStreamSnapshotInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamSnapshotInfoResponse describeLiveStreamSnapshotInfo(shared_ptr<DescribeLiveStreamSnapshotInfoRequest> request);
  DescribeLiveStreamStateResponse describeLiveStreamStateWithOptions(shared_ptr<DescribeLiveStreamStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamStateResponse describeLiveStreamState(shared_ptr<DescribeLiveStreamStateRequest> request);
  DescribeLiveStreamTranscodeInfoResponse describeLiveStreamTranscodeInfoWithOptions(shared_ptr<DescribeLiveStreamTranscodeInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamTranscodeInfoResponse describeLiveStreamTranscodeInfo(shared_ptr<DescribeLiveStreamTranscodeInfoRequest> request);
  DescribeLiveStreamTranscodeMetricDataResponse describeLiveStreamTranscodeMetricDataWithOptions(shared_ptr<DescribeLiveStreamTranscodeMetricDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamTranscodeMetricDataResponse describeLiveStreamTranscodeMetricData(shared_ptr<DescribeLiveStreamTranscodeMetricDataRequest> request);
  DescribeLiveStreamTranscodeStreamNumResponse describeLiveStreamTranscodeStreamNumWithOptions(shared_ptr<DescribeLiveStreamTranscodeStreamNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamTranscodeStreamNumResponse describeLiveStreamTranscodeStreamNum(shared_ptr<DescribeLiveStreamTranscodeStreamNumRequest> request);
  DescribeLiveStreamWatermarkRulesResponse describeLiveStreamWatermarkRulesWithOptions(shared_ptr<DescribeLiveStreamWatermarkRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamWatermarkRulesResponse describeLiveStreamWatermarkRules(shared_ptr<DescribeLiveStreamWatermarkRulesRequest> request);
  DescribeLiveStreamWatermarksResponse describeLiveStreamWatermarksWithOptions(shared_ptr<DescribeLiveStreamWatermarksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamWatermarksResponse describeLiveStreamWatermarks(shared_ptr<DescribeLiveStreamWatermarksRequest> request);
  DescribeLiveStreamsBlockListResponse describeLiveStreamsBlockListWithOptions(shared_ptr<DescribeLiveStreamsBlockListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsBlockListResponse describeLiveStreamsBlockList(shared_ptr<DescribeLiveStreamsBlockListRequest> request);
  DescribeLiveStreamsControlHistoryResponse describeLiveStreamsControlHistoryWithOptions(shared_ptr<DescribeLiveStreamsControlHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsControlHistoryResponse describeLiveStreamsControlHistory(shared_ptr<DescribeLiveStreamsControlHistoryRequest> request);
  DescribeLiveStreamsNotifyRecordsResponse describeLiveStreamsNotifyRecordsWithOptions(shared_ptr<DescribeLiveStreamsNotifyRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsNotifyRecordsResponse describeLiveStreamsNotifyRecords(shared_ptr<DescribeLiveStreamsNotifyRecordsRequest> request);
  DescribeLiveStreamsNotifyUrlConfigResponse describeLiveStreamsNotifyUrlConfigWithOptions(shared_ptr<DescribeLiveStreamsNotifyUrlConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsNotifyUrlConfigResponse describeLiveStreamsNotifyUrlConfig(shared_ptr<DescribeLiveStreamsNotifyUrlConfigRequest> request);
  DescribeLiveStreamsOnlineListResponse describeLiveStreamsOnlineListWithOptions(shared_ptr<DescribeLiveStreamsOnlineListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsOnlineListResponse describeLiveStreamsOnlineList(shared_ptr<DescribeLiveStreamsOnlineListRequest> request);
  DescribeLiveStreamsPublishListResponse describeLiveStreamsPublishListWithOptions(shared_ptr<DescribeLiveStreamsPublishListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsPublishListResponse describeLiveStreamsPublishList(shared_ptr<DescribeLiveStreamsPublishListRequest> request);
  DescribeLiveStreamsTotalCountResponse describeLiveStreamsTotalCountWithOptions(shared_ptr<DescribeLiveStreamsTotalCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveStreamsTotalCountResponse describeLiveStreamsTotalCount(shared_ptr<DescribeLiveStreamsTotalCountRequest> request);
  DescribeLiveTopDomainsByFlowResponse describeLiveTopDomainsByFlowWithOptions(shared_ptr<DescribeLiveTopDomainsByFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveTopDomainsByFlowResponse describeLiveTopDomainsByFlow(shared_ptr<DescribeLiveTopDomainsByFlowRequest> request);
  DescribeLiveTrafficDomainLogResponse describeLiveTrafficDomainLogWithOptions(shared_ptr<DescribeLiveTrafficDomainLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveTrafficDomainLogResponse describeLiveTrafficDomainLog(shared_ptr<DescribeLiveTrafficDomainLogRequest> request);
  DescribeLiveUpVideoAudioInfoResponse describeLiveUpVideoAudioInfoWithOptions(shared_ptr<DescribeLiveUpVideoAudioInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveUpVideoAudioInfoResponse describeLiveUpVideoAudioInfo(shared_ptr<DescribeLiveUpVideoAudioInfoRequest> request);
  DescribeLiveUserBillPredictionResponse describeLiveUserBillPredictionWithOptions(shared_ptr<DescribeLiveUserBillPredictionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveUserBillPredictionResponse describeLiveUserBillPrediction(shared_ptr<DescribeLiveUserBillPredictionRequest> request);
  DescribeLiveUserDomainsResponse describeLiveUserDomainsWithOptions(shared_ptr<DescribeLiveUserDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveUserDomainsResponse describeLiveUserDomains(shared_ptr<DescribeLiveUserDomainsRequest> request);
  DescribeLiveUserStreamMetricDataResponse describeLiveUserStreamMetricDataWithOptions(shared_ptr<DescribeLiveUserStreamMetricDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveUserStreamMetricDataResponse describeLiveUserStreamMetricData(shared_ptr<DescribeLiveUserStreamMetricDataRequest> request);
  DescribeLiveUserTagsResponse describeLiveUserTagsWithOptions(shared_ptr<DescribeLiveUserTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveUserTagsResponse describeLiveUserTags(shared_ptr<DescribeLiveUserTagsRequest> request);
  DescribeLiveUserTrafficLogResponse describeLiveUserTrafficLogWithOptions(shared_ptr<DescribeLiveUserTrafficLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveUserTrafficLogResponse describeLiveUserTrafficLog(shared_ptr<DescribeLiveUserTrafficLogRequest> request);
  DescribeLiveVerifyContentResponse describeLiveVerifyContentWithOptions(shared_ptr<DescribeLiveVerifyContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLiveVerifyContentResponse describeLiveVerifyContent(shared_ptr<DescribeLiveVerifyContentRequest> request);
  DescribeMeterLiveBypassDurationResponse describeMeterLiveBypassDurationWithOptions(shared_ptr<DescribeMeterLiveBypassDurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterLiveBypassDurationResponse describeMeterLiveBypassDuration(shared_ptr<DescribeMeterLiveBypassDurationRequest> request);
  DescribeMixStreamListResponse describeMixStreamListWithOptions(shared_ptr<DescribeMixStreamListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMixStreamListResponse describeMixStreamList(shared_ptr<DescribeMixStreamListRequest> request);
  DescribeRTSNativeSDKFirstFrameCostResponse describeRTSNativeSDKFirstFrameCostWithOptions(shared_ptr<DescribeRTSNativeSDKFirstFrameCostRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRTSNativeSDKFirstFrameCostResponse describeRTSNativeSDKFirstFrameCost(shared_ptr<DescribeRTSNativeSDKFirstFrameCostRequest> request);
  DescribeRTSNativeSDKFirstFrameDelayResponse describeRTSNativeSDKFirstFrameDelayWithOptions(shared_ptr<DescribeRTSNativeSDKFirstFrameDelayRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRTSNativeSDKFirstFrameDelayResponse describeRTSNativeSDKFirstFrameDelay(shared_ptr<DescribeRTSNativeSDKFirstFrameDelayRequest> request);
  DescribeRTSNativeSDKPlayFailStatusResponse describeRTSNativeSDKPlayFailStatusWithOptions(shared_ptr<DescribeRTSNativeSDKPlayFailStatusRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRTSNativeSDKPlayFailStatusResponse describeRTSNativeSDKPlayFailStatus(shared_ptr<DescribeRTSNativeSDKPlayFailStatusRequest> request);
  DescribeRTSNativeSDKPlayTimeResponse describeRTSNativeSDKPlayTimeWithOptions(shared_ptr<DescribeRTSNativeSDKPlayTimeRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRTSNativeSDKPlayTimeResponse describeRTSNativeSDKPlayTime(shared_ptr<DescribeRTSNativeSDKPlayTimeRequest> request);
  DescribeRTSNativeSDKVvDataResponse describeRTSNativeSDKVvDataWithOptions(shared_ptr<DescribeRTSNativeSDKVvDataRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRTSNativeSDKVvDataResponse describeRTSNativeSDKVvData(shared_ptr<DescribeRTSNativeSDKVvDataRequest> request);
  DescribeRtcCloudRecordingFilesResponse describeRtcCloudRecordingFilesWithOptions(shared_ptr<DescribeRtcCloudRecordingFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRtcCloudRecordingFilesResponse describeRtcCloudRecordingFiles(shared_ptr<DescribeRtcCloudRecordingFilesRequest> request);
  DescribeRtcMPUEventSubResponse describeRtcMPUEventSubWithOptions(shared_ptr<DescribeRtcMPUEventSubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRtcMPUEventSubResponse describeRtcMPUEventSub(shared_ptr<DescribeRtcMPUEventSubRequest> request);
  DescribeShowListResponse describeShowListWithOptions(shared_ptr<DescribeShowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeShowListResponse describeShowList(shared_ptr<DescribeShowListRequest> request);
  DescribeStreamLocationBlockResponse describeStreamLocationBlockWithOptions(shared_ptr<DescribeStreamLocationBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStreamLocationBlockResponse describeStreamLocationBlock(shared_ptr<DescribeStreamLocationBlockRequest> request);
  DescribeStudioLayoutsResponse describeStudioLayoutsWithOptions(shared_ptr<DescribeStudioLayoutsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStudioLayoutsResponse describeStudioLayouts(shared_ptr<DescribeStudioLayoutsRequest> request);
  DescribeToutiaoLivePlayResponse describeToutiaoLivePlayWithOptions(shared_ptr<DescribeToutiaoLivePlayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeToutiaoLivePlayResponse describeToutiaoLivePlay(shared_ptr<DescribeToutiaoLivePlayRequest> request);
  DescribeToutiaoLivePublishResponse describeToutiaoLivePublishWithOptions(shared_ptr<DescribeToutiaoLivePublishRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeToutiaoLivePublishResponse describeToutiaoLivePublish(shared_ptr<DescribeToutiaoLivePublishRequest> request);
  DescribeUidOnlineStreamsResponse describeUidOnlineStreamsWithOptions(shared_ptr<DescribeUidOnlineStreamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUidOnlineStreamsResponse describeUidOnlineStreams(shared_ptr<DescribeUidOnlineStreamsRequest> request);
  DescribeUpBpsPeakDataResponse describeUpBpsPeakDataWithOptions(shared_ptr<DescribeUpBpsPeakDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUpBpsPeakDataResponse describeUpBpsPeakData(shared_ptr<DescribeUpBpsPeakDataRequest> request);
  DescribeUpBpsPeakOfLineResponse describeUpBpsPeakOfLineWithOptions(shared_ptr<DescribeUpBpsPeakOfLineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUpBpsPeakOfLineResponse describeUpBpsPeakOfLine(shared_ptr<DescribeUpBpsPeakOfLineRequest> request);
  DescribeUpPeakPublishStreamDataResponse describeUpPeakPublishStreamDataWithOptions(shared_ptr<DescribeUpPeakPublishStreamDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUpPeakPublishStreamDataResponse describeUpPeakPublishStreamData(shared_ptr<DescribeUpPeakPublishStreamDataRequest> request);
  DisableLiveRealtimeLogDeliveryResponse disableLiveRealtimeLogDeliveryWithOptions(shared_ptr<DisableLiveRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableLiveRealtimeLogDeliveryResponse disableLiveRealtimeLogDelivery(shared_ptr<DisableLiveRealtimeLogDeliveryRequest> request);
  DynamicUpdateWaterMarkStreamRuleResponse dynamicUpdateWaterMarkStreamRuleWithOptions(shared_ptr<DynamicUpdateWaterMarkStreamRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DynamicUpdateWaterMarkStreamRuleResponse dynamicUpdateWaterMarkStreamRule(shared_ptr<DynamicUpdateWaterMarkStreamRuleRequest> request);
  EditPlaylistResponse editPlaylistWithOptions(shared_ptr<EditPlaylistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EditPlaylistResponse editPlaylist(shared_ptr<EditPlaylistRequest> request);
  EditShowAndReplaceResponse editShowAndReplaceWithOptions(shared_ptr<EditShowAndReplaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EditShowAndReplaceResponse editShowAndReplace(shared_ptr<EditShowAndReplaceRequest> request);
  EffectCasterUrgentResponse effectCasterUrgentWithOptions(shared_ptr<EffectCasterUrgentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EffectCasterUrgentResponse effectCasterUrgent(shared_ptr<EffectCasterUrgentRequest> request);
  EffectCasterVideoResourceResponse effectCasterVideoResourceWithOptions(shared_ptr<EffectCasterVideoResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EffectCasterVideoResourceResponse effectCasterVideoResource(shared_ptr<EffectCasterVideoResourceRequest> request);
  EnableLiveRealtimeLogDeliveryResponse enableLiveRealtimeLogDeliveryWithOptions(shared_ptr<EnableLiveRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableLiveRealtimeLogDeliveryResponse enableLiveRealtimeLogDelivery(shared_ptr<EnableLiveRealtimeLogDeliveryRequest> request);
  ForbidLiveStreamResponse forbidLiveStreamWithOptions(shared_ptr<ForbidLiveStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ForbidLiveStreamResponse forbidLiveStream(shared_ptr<ForbidLiveStreamRequest> request);
  GetAllCustomTemplatesResponse getAllCustomTemplatesWithOptions(shared_ptr<GetAllCustomTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAllCustomTemplatesResponse getAllCustomTemplates(shared_ptr<GetAllCustomTemplatesRequest> request);
  GetCustomTemplateResponse getCustomTemplateWithOptions(shared_ptr<GetCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomTemplateResponse getCustomTemplate(shared_ptr<GetCustomTemplateRequest> request);
  GetEdgeTranscodeJobResponse getEdgeTranscodeJobWithOptions(shared_ptr<GetEdgeTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeTranscodeJobResponse getEdgeTranscodeJob(shared_ptr<GetEdgeTranscodeJobRequest> request);
  GetEdgeTranscodeTemplateResponse getEdgeTranscodeTemplateWithOptions(shared_ptr<GetEdgeTranscodeTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEdgeTranscodeTemplateResponse getEdgeTranscodeTemplate(shared_ptr<GetEdgeTranscodeTemplateRequest> request);
  GetEditingJobInfoResponse getEditingJobInfoWithOptions(shared_ptr<GetEditingJobInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEditingJobInfoResponse getEditingJobInfo(shared_ptr<GetEditingJobInfoRequest> request);
  GetMessageAppResponse getMessageAppWithOptions(shared_ptr<GetMessageAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMessageAppResponse getMessageApp(shared_ptr<GetMessageAppRequest> request);
  GetMessageGroupResponse getMessageGroupWithOptions(shared_ptr<GetMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMessageGroupResponse getMessageGroup(shared_ptr<GetMessageGroupRequest> request);
  GetMessageTokenResponse getMessageTokenWithOptions(shared_ptr<GetMessageTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMessageTokenResponse getMessageToken(shared_ptr<GetMessageTokenRequest> request);
  GetTranscodeTaskStatusResponse getTranscodeTaskStatusWithOptions(shared_ptr<GetTranscodeTaskStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTranscodeTaskStatusResponse getTranscodeTaskStatus(shared_ptr<GetTranscodeTaskStatusRequest> request);
  HotLiveRtcStreamResponse hotLiveRtcStreamWithOptions(shared_ptr<HotLiveRtcStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotLiveRtcStreamResponse hotLiveRtcStream(shared_ptr<HotLiveRtcStreamRequest> request);
  InitializeAutoShowListTaskResponse initializeAutoShowListTaskWithOptions(shared_ptr<InitializeAutoShowListTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitializeAutoShowListTaskResponse initializeAutoShowListTask(shared_ptr<InitializeAutoShowListTaskRequest> request);
  JoinMessageGroupResponse joinMessageGroupWithOptions(shared_ptr<JoinMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinMessageGroupResponse joinMessageGroup(shared_ptr<JoinMessageGroupRequest> request);
  KickLiveMessageGroupUserResponse kickLiveMessageGroupUserWithOptions(shared_ptr<KickLiveMessageGroupUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  KickLiveMessageGroupUserResponse kickLiveMessageGroupUser(shared_ptr<KickLiveMessageGroupUserRequest> request);
  LeaveMessageGroupResponse leaveMessageGroupWithOptions(shared_ptr<LeaveMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LeaveMessageGroupResponse leaveMessageGroup(shared_ptr<LeaveMessageGroupRequest> request);
  ListEdgeTranscodeJobResponse listEdgeTranscodeJobWithOptions(shared_ptr<ListEdgeTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEdgeTranscodeJobResponse listEdgeTranscodeJob(shared_ptr<ListEdgeTranscodeJobRequest> request);
  ListEdgeTranscodeTemplateResponse listEdgeTranscodeTemplateWithOptions(shared_ptr<ListEdgeTranscodeTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEdgeTranscodeTemplateResponse listEdgeTranscodeTemplate(shared_ptr<ListEdgeTranscodeTemplateRequest> request);
  ListEventSubResponse listEventSubWithOptions(shared_ptr<ListEventSubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEventSubResponse listEventSub(shared_ptr<ListEventSubRequest> request);
  ListEventSubEventResponse listEventSubEventWithOptions(shared_ptr<ListEventSubEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEventSubEventResponse listEventSubEvent(shared_ptr<ListEventSubEventRequest> request);
  ListLiveDelayConfigResponse listLiveDelayConfigWithOptions(shared_ptr<ListLiveDelayConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveDelayConfigResponse listLiveDelayConfig(shared_ptr<ListLiveDelayConfigRequest> request);
  ListLiveMessageAppsResponse listLiveMessageAppsWithOptions(shared_ptr<ListLiveMessageAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveMessageAppsResponse listLiveMessageApps(shared_ptr<ListLiveMessageAppsRequest> request);
  ListLiveMessageGroupByPageResponse listLiveMessageGroupByPageWithOptions(shared_ptr<ListLiveMessageGroupByPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveMessageGroupByPageResponse listLiveMessageGroupByPage(shared_ptr<ListLiveMessageGroupByPageRequest> request);
  ListLiveMessageGroupMessagesResponse listLiveMessageGroupMessagesWithOptions(shared_ptr<ListLiveMessageGroupMessagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveMessageGroupMessagesResponse listLiveMessageGroupMessages(shared_ptr<ListLiveMessageGroupMessagesRequest> request);
  ListLiveMessageGroupUsersResponse listLiveMessageGroupUsersWithOptions(shared_ptr<ListLiveMessageGroupUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveMessageGroupUsersResponse listLiveMessageGroupUsers(shared_ptr<ListLiveMessageGroupUsersRequest> request);
  ListLiveMessageGroupsResponse listLiveMessageGroupsWithOptions(shared_ptr<ListLiveMessageGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveMessageGroupsResponse listLiveMessageGroups(shared_ptr<ListLiveMessageGroupsRequest> request);
  ListLiveRealtimeLogDeliveryResponse listLiveRealtimeLogDeliveryWithOptions(shared_ptr<ListLiveRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRealtimeLogDeliveryResponse listLiveRealtimeLogDelivery(shared_ptr<ListLiveRealtimeLogDeliveryRequest> request);
  ListLiveRealtimeLogDeliveryDomainsResponse listLiveRealtimeLogDeliveryDomainsWithOptions(shared_ptr<ListLiveRealtimeLogDeliveryDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRealtimeLogDeliveryDomainsResponse listLiveRealtimeLogDeliveryDomains(shared_ptr<ListLiveRealtimeLogDeliveryDomainsRequest> request);
  ListLiveRealtimeLogDeliveryInfosResponse listLiveRealtimeLogDeliveryInfosWithOptions(shared_ptr<ListLiveRealtimeLogDeliveryInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRealtimeLogDeliveryInfosResponse listLiveRealtimeLogDeliveryInfos(shared_ptr<ListLiveRealtimeLogDeliveryInfosRequest> request);
  ListMessageResponse listMessageWithOptions(shared_ptr<ListMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageResponse listMessage(shared_ptr<ListMessageRequest> request);
  ListMessageAppResponse listMessageAppWithOptions(shared_ptr<ListMessageAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageAppResponse listMessageApp(shared_ptr<ListMessageAppRequest> request);
  ListMessageGroupResponse listMessageGroupWithOptions(shared_ptr<ListMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageGroupResponse listMessageGroup(shared_ptr<ListMessageGroupRequest> request);
  ListMessageGroupUserResponse listMessageGroupUserWithOptions(shared_ptr<ListMessageGroupUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageGroupUserResponse listMessageGroupUser(shared_ptr<ListMessageGroupUserRequest> request);
  ListMessageGroupUserByIdResponse listMessageGroupUserByIdWithOptions(shared_ptr<ListMessageGroupUserByIdRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageGroupUserByIdResponse listMessageGroupUserById(shared_ptr<ListMessageGroupUserByIdRequest> request);
  ListMuteGroupUserResponse listMuteGroupUserWithOptions(shared_ptr<ListMuteGroupUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMuteGroupUserResponse listMuteGroupUser(shared_ptr<ListMuteGroupUserRequest> request);
  ListPlaylistResponse listPlaylistWithOptions(shared_ptr<ListPlaylistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPlaylistResponse listPlaylist(shared_ptr<ListPlaylistRequest> request);
  ListPlaylistItemsResponse listPlaylistItemsWithOptions(shared_ptr<ListPlaylistItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPlaylistItemsResponse listPlaylistItems(shared_ptr<ListPlaylistItemsRequest> request);
  ListRtcMPUEventSubRecordResponse listRtcMPUEventSubRecordWithOptions(shared_ptr<ListRtcMPUEventSubRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRtcMPUEventSubRecordResponse listRtcMPUEventSubRecord(shared_ptr<ListRtcMPUEventSubRecordRequest> request);
  ListRtcMPUTaskDetailResponse listRtcMPUTaskDetailWithOptions(shared_ptr<ListRtcMPUTaskDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRtcMPUTaskDetailResponse listRtcMPUTaskDetail(shared_ptr<ListRtcMPUTaskDetailRequest> request);
  LiveUpstreamQosDataResponse liveUpstreamQosDataWithOptions(shared_ptr<LiveUpstreamQosDataRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LiveUpstreamQosDataResponse liveUpstreamQosData(shared_ptr<LiveUpstreamQosDataRequest> request);
  MiguLivePullToPushStartResponse miguLivePullToPushStartWithOptions(shared_ptr<MiguLivePullToPushStartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MiguLivePullToPushStartResponse miguLivePullToPushStart(shared_ptr<MiguLivePullToPushStartRequest> request);
  MiguLivePullToPushStatusResponse miguLivePullToPushStatusWithOptions(shared_ptr<MiguLivePullToPushStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MiguLivePullToPushStatusResponse miguLivePullToPushStatus(shared_ptr<MiguLivePullToPushStatusRequest> request);
  ModifyCasterComponentResponse modifyCasterComponentWithOptions(shared_ptr<ModifyCasterComponentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCasterComponentResponse modifyCasterComponent(shared_ptr<ModifyCasterComponentRequest> request);
  ModifyCasterEpisodeResponse modifyCasterEpisodeWithOptions(shared_ptr<ModifyCasterEpisodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCasterEpisodeResponse modifyCasterEpisode(shared_ptr<ModifyCasterEpisodeRequest> request);
  ModifyCasterLayoutResponse modifyCasterLayoutWithOptions(shared_ptr<ModifyCasterLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCasterLayoutResponse modifyCasterLayout(shared_ptr<ModifyCasterLayoutRequest> request);
  ModifyCasterProgramResponse modifyCasterProgramWithOptions(shared_ptr<ModifyCasterProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCasterProgramResponse modifyCasterProgram(shared_ptr<ModifyCasterProgramRequest> request);
  ModifyCasterVideoResourceResponse modifyCasterVideoResourceWithOptions(shared_ptr<ModifyCasterVideoResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCasterVideoResourceResponse modifyCasterVideoResource(shared_ptr<ModifyCasterVideoResourceRequest> request);
  ModifyLiveAIStudioResponse modifyLiveAIStudioWithOptions(shared_ptr<ModifyLiveAIStudioRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLiveAIStudioResponse modifyLiveAIStudio(shared_ptr<ModifyLiveAIStudioRequest> request);
  ModifyLiveDomainSchdmByPropertyResponse modifyLiveDomainSchdmByPropertyWithOptions(shared_ptr<ModifyLiveDomainSchdmByPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLiveDomainSchdmByPropertyResponse modifyLiveDomainSchdmByProperty(shared_ptr<ModifyLiveDomainSchdmByPropertyRequest> request);
  ModifyLiveMessageAppAuditResponse modifyLiveMessageAppAuditWithOptions(shared_ptr<ModifyLiveMessageAppAuditRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLiveMessageAppAuditResponse modifyLiveMessageAppAudit(shared_ptr<ModifyLiveMessageAppAuditRequest> request);
  ModifyLiveMessageAppCallbackResponse modifyLiveMessageAppCallbackWithOptions(shared_ptr<ModifyLiveMessageAppCallbackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLiveMessageAppCallbackResponse modifyLiveMessageAppCallback(shared_ptr<ModifyLiveMessageAppCallbackRequest> request);
  ModifyLiveMessageAppDisableResponse modifyLiveMessageAppDisableWithOptions(shared_ptr<ModifyLiveMessageAppDisableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLiveMessageAppDisableResponse modifyLiveMessageAppDisable(shared_ptr<ModifyLiveMessageAppDisableRequest> request);
  ModifyLiveMessageGroupResponse modifyLiveMessageGroupWithOptions(shared_ptr<ModifyLiveMessageGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLiveMessageGroupResponse modifyLiveMessageGroup(shared_ptr<ModifyLiveMessageGroupRequest> request);
  ModifyLiveMessageGroupBandResponse modifyLiveMessageGroupBandWithOptions(shared_ptr<ModifyLiveMessageGroupBandRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLiveMessageGroupBandResponse modifyLiveMessageGroupBand(shared_ptr<ModifyLiveMessageGroupBandRequest> request);
  ModifyLiveMessageUserInfoResponse modifyLiveMessageUserInfoWithOptions(shared_ptr<ModifyLiveMessageUserInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLiveMessageUserInfoResponse modifyLiveMessageUserInfo(shared_ptr<ModifyLiveMessageUserInfoRequest> request);
  ModifyLiveRealtimeLogDeliveryResponse modifyLiveRealtimeLogDeliveryWithOptions(shared_ptr<ModifyLiveRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLiveRealtimeLogDeliveryResponse modifyLiveRealtimeLogDelivery(shared_ptr<ModifyLiveRealtimeLogDeliveryRequest> request);
  ModifyShowListResponse modifyShowListWithOptions(shared_ptr<ModifyShowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyShowListResponse modifyShowList(shared_ptr<ModifyShowListRequest> request);
  ModifyStudioLayoutResponse modifyStudioLayoutWithOptions(shared_ptr<ModifyStudioLayoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyStudioLayoutResponse modifyStudioLayout(shared_ptr<ModifyStudioLayoutRequest> request);
  MuteAllGroupUserResponse muteAllGroupUserWithOptions(shared_ptr<MuteAllGroupUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MuteAllGroupUserResponse muteAllGroupUser(shared_ptr<MuteAllGroupUserRequest> request);
  MuteGroupUserResponse muteGroupUserWithOptions(shared_ptr<MuteGroupUserRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MuteGroupUserResponse muteGroupUser(shared_ptr<MuteGroupUserRequest> request);
  OpenLiveShiftResponse openLiveShiftWithOptions(shared_ptr<OpenLiveShiftRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenLiveShiftResponse openLiveShift(shared_ptr<OpenLiveShiftRequest> request);
  PlayChoosenShowResponse playChoosenShowWithOptions(shared_ptr<PlayChoosenShowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PlayChoosenShowResponse playChoosenShow(shared_ptr<PlayChoosenShowRequest> request);
  PublishLiveStagingConfigToProductionResponse publishLiveStagingConfigToProductionWithOptions(shared_ptr<PublishLiveStagingConfigToProductionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishLiveStagingConfigToProductionResponse publishLiveStagingConfigToProduction(shared_ptr<PublishLiveStagingConfigToProductionRequest> request);
  QueryLiveDomainMultiStreamListResponse queryLiveDomainMultiStreamListWithOptions(shared_ptr<QueryLiveDomainMultiStreamListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLiveDomainMultiStreamListResponse queryLiveDomainMultiStreamList(shared_ptr<QueryLiveDomainMultiStreamListRequest> request);
  QueryMessageAppResponse queryMessageAppWithOptions(shared_ptr<QueryMessageAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMessageAppResponse queryMessageApp(shared_ptr<QueryMessageAppRequest> request);
  QueryRtcAsrTasksResponse queryRtcAsrTasksWithOptions(shared_ptr<QueryRtcAsrTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryRtcAsrTasksResponse queryRtcAsrTasks(shared_ptr<QueryRtcAsrTasksRequest> request);
  QuerySnapshotCallbackAuthResponse querySnapshotCallbackAuthWithOptions(shared_ptr<QuerySnapshotCallbackAuthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySnapshotCallbackAuthResponse querySnapshotCallbackAuth(shared_ptr<QuerySnapshotCallbackAuthRequest> request);
  RealTimeRecordCommandResponse realTimeRecordCommandWithOptions(shared_ptr<RealTimeRecordCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RealTimeRecordCommandResponse realTimeRecordCommand(shared_ptr<RealTimeRecordCommandRequest> request);
  RecoverLiveMessageDeletedGroupResponse recoverLiveMessageDeletedGroupWithOptions(shared_ptr<RecoverLiveMessageDeletedGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecoverLiveMessageDeletedGroupResponse recoverLiveMessageDeletedGroup(shared_ptr<RecoverLiveMessageDeletedGroupRequest> request);
  RemoveLiveMessageGroupBandResponse removeLiveMessageGroupBandWithOptions(shared_ptr<RemoveLiveMessageGroupBandRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveLiveMessageGroupBandResponse removeLiveMessageGroupBand(shared_ptr<RemoveLiveMessageGroupBandRequest> request);
  RemoveShowFromShowListResponse removeShowFromShowListWithOptions(shared_ptr<RemoveShowFromShowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveShowFromShowListResponse removeShowFromShowList(shared_ptr<RemoveShowFromShowListRequest> request);
  RemoveTerminalsResponse removeTerminalsWithOptions(shared_ptr<RemoveTerminalsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveTerminalsResponse removeTerminals(shared_ptr<RemoveTerminalsRequest> request);
  RestartCasterResponse restartCasterWithOptions(shared_ptr<RestartCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartCasterResponse restartCaster(shared_ptr<RestartCasterRequest> request);
  RestartLivePullToPushResponse restartLivePullToPushWithOptions(shared_ptr<RestartLivePullToPushRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartLivePullToPushResponse restartLivePullToPush(shared_ptr<RestartLivePullToPushRequest> request);
  RestartTranscodeTaskResponse restartTranscodeTaskWithOptions(shared_ptr<RestartTranscodeTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartTranscodeTaskResponse restartTranscodeTask(shared_ptr<RestartTranscodeTaskRequest> request);
  ResumeLiveStreamResponse resumeLiveStreamWithOptions(shared_ptr<ResumeLiveStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeLiveStreamResponse resumeLiveStream(shared_ptr<ResumeLiveStreamRequest> request);
  RollbackLiveStagingConfigResponse rollbackLiveStagingConfigWithOptions(shared_ptr<RollbackLiveStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackLiveStagingConfigResponse rollbackLiveStagingConfig(shared_ptr<RollbackLiveStagingConfigRequest> request);
  SendLikeResponse sendLikeWithOptions(shared_ptr<SendLikeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendLikeResponse sendLike(shared_ptr<SendLikeRequest> request);
  SendLiveMessageGroupResponse sendLiveMessageGroupWithOptions(shared_ptr<SendLiveMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendLiveMessageGroupResponse sendLiveMessageGroup(shared_ptr<SendLiveMessageGroupRequest> request);
  SendLiveMessageUserResponse sendLiveMessageUserWithOptions(shared_ptr<SendLiveMessageUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendLiveMessageUserResponse sendLiveMessageUser(shared_ptr<SendLiveMessageUserRequest> request);
  SendMessageToGroupResponse sendMessageToGroupWithOptions(shared_ptr<SendMessageToGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendMessageToGroupResponse sendMessageToGroup(shared_ptr<SendMessageToGroupRequest> request);
  SendMessageToGroupUsersResponse sendMessageToGroupUsersWithOptions(shared_ptr<SendMessageToGroupUsersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendMessageToGroupUsersResponse sendMessageToGroupUsers(shared_ptr<SendMessageToGroupUsersRequest> request);
  SetCasterChannelResponse setCasterChannelWithOptions(shared_ptr<SetCasterChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCasterChannelResponse setCasterChannel(shared_ptr<SetCasterChannelRequest> request);
  SetCasterConfigResponse setCasterConfigWithOptions(shared_ptr<SetCasterConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCasterConfigResponse setCasterConfig(shared_ptr<SetCasterConfigRequest> request);
  SetCasterSceneConfigResponse setCasterSceneConfigWithOptions(shared_ptr<SetCasterSceneConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCasterSceneConfigResponse setCasterSceneConfig(shared_ptr<SetCasterSceneConfigRequest> request);
  SetLiveDomainCertificateResponse setLiveDomainCertificateWithOptions(shared_ptr<SetLiveDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveDomainCertificateResponse setLiveDomainCertificate(shared_ptr<SetLiveDomainCertificateRequest> request);
  SetLiveDomainMultiStreamConfigResponse setLiveDomainMultiStreamConfigWithOptions(shared_ptr<SetLiveDomainMultiStreamConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveDomainMultiStreamConfigResponse setLiveDomainMultiStreamConfig(shared_ptr<SetLiveDomainMultiStreamConfigRequest> request);
  SetLiveDomainMultiStreamMasterResponse setLiveDomainMultiStreamMasterWithOptions(shared_ptr<SetLiveDomainMultiStreamMasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveDomainMultiStreamMasterResponse setLiveDomainMultiStreamMaster(shared_ptr<SetLiveDomainMultiStreamMasterRequest> request);
  SetLiveDomainMultiStreamOptimalModeResponse setLiveDomainMultiStreamOptimalModeWithOptions(shared_ptr<SetLiveDomainMultiStreamOptimalModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveDomainMultiStreamOptimalModeResponse setLiveDomainMultiStreamOptimalMode(shared_ptr<SetLiveDomainMultiStreamOptimalModeRequest> request);
  SetLiveDomainStagingConfigResponse setLiveDomainStagingConfigWithOptions(shared_ptr<SetLiveDomainStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveDomainStagingConfigResponse setLiveDomainStagingConfig(shared_ptr<SetLiveDomainStagingConfigRequest> request);
  SetLiveEdgeTransferResponse setLiveEdgeTransferWithOptions(shared_ptr<SetLiveEdgeTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveEdgeTransferResponse setLiveEdgeTransfer(shared_ptr<SetLiveEdgeTransferRequest> request);
  SetLiveLazyPullStreamInfoConfigResponse setLiveLazyPullStreamInfoConfigWithOptions(shared_ptr<SetLiveLazyPullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveLazyPullStreamInfoConfigResponse setLiveLazyPullStreamInfoConfig(shared_ptr<SetLiveLazyPullStreamInfoConfigRequest> request);
  SetLiveMpuTaskSeiResponse setLiveMpuTaskSeiWithOptions(shared_ptr<SetLiveMpuTaskSeiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveMpuTaskSeiResponse setLiveMpuTaskSei(shared_ptr<SetLiveMpuTaskSeiRequest> request);
  SetLiveStreamBlockResponse setLiveStreamBlockWithOptions(shared_ptr<SetLiveStreamBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveStreamBlockResponse setLiveStreamBlock(shared_ptr<SetLiveStreamBlockRequest> request);
  SetLiveStreamDelayConfigResponse setLiveStreamDelayConfigWithOptions(shared_ptr<SetLiveStreamDelayConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveStreamDelayConfigResponse setLiveStreamDelayConfig(shared_ptr<SetLiveStreamDelayConfigRequest> request);
  SetLiveStreamPreloadTasksResponse setLiveStreamPreloadTasksWithOptions(shared_ptr<SetLiveStreamPreloadTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveStreamPreloadTasksResponse setLiveStreamPreloadTasks(shared_ptr<SetLiveStreamPreloadTasksRequest> request);
  SetLiveStreamsNotifyUrlConfigResponse setLiveStreamsNotifyUrlConfigWithOptions(shared_ptr<SetLiveStreamsNotifyUrlConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetLiveStreamsNotifyUrlConfigResponse setLiveStreamsNotifyUrlConfig(shared_ptr<SetLiveStreamsNotifyUrlConfigRequest> request);
  SetShowListBackgroundResponse setShowListBackgroundWithOptions(shared_ptr<SetShowListBackgroundRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetShowListBackgroundResponse setShowListBackground(shared_ptr<SetShowListBackgroundRequest> request);
  SetSnapshotCallbackAuthResponse setSnapshotCallbackAuthWithOptions(shared_ptr<SetSnapshotCallbackAuthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetSnapshotCallbackAuthResponse setSnapshotCallbackAuth(shared_ptr<SetSnapshotCallbackAuthRequest> request);
  StartCasterResponse startCasterWithOptions(shared_ptr<StartCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartCasterResponse startCaster(shared_ptr<StartCasterRequest> request);
  StartCasterSceneResponse startCasterSceneWithOptions(shared_ptr<StartCasterSceneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartCasterSceneResponse startCasterScene(shared_ptr<StartCasterSceneRequest> request);
  StartEdgeTranscodeJobResponse startEdgeTranscodeJobWithOptions(shared_ptr<StartEdgeTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartEdgeTranscodeJobResponse startEdgeTranscodeJob(shared_ptr<StartEdgeTranscodeJobRequest> request);
  StartLiveDomainResponse startLiveDomainWithOptions(shared_ptr<StartLiveDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartLiveDomainResponse startLiveDomain(shared_ptr<StartLiveDomainRequest> request);
  StartLiveMPUTaskResponse startLiveMPUTaskWithOptions(shared_ptr<StartLiveMPUTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartLiveMPUTaskResponse startLiveMPUTask(shared_ptr<StartLiveMPUTaskRequest> request);
  StartLiveStreamMonitorResponse startLiveStreamMonitorWithOptions(shared_ptr<StartLiveStreamMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartLiveStreamMonitorResponse startLiveStreamMonitor(shared_ptr<StartLiveStreamMonitorRequest> request);
  StartPlaylistResponse startPlaylistWithOptions(shared_ptr<StartPlaylistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartPlaylistResponse startPlaylist(shared_ptr<StartPlaylistRequest> request);
  StartRtcCloudRecordingResponse startRtcCloudRecordingWithOptions(shared_ptr<StartRtcCloudRecordingRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartRtcCloudRecordingResponse startRtcCloudRecording(shared_ptr<StartRtcCloudRecordingRequest> request);
  StopCasterResponse stopCasterWithOptions(shared_ptr<StopCasterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopCasterResponse stopCaster(shared_ptr<StopCasterRequest> request);
  StopCasterSceneResponse stopCasterSceneWithOptions(shared_ptr<StopCasterSceneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopCasterSceneResponse stopCasterScene(shared_ptr<StopCasterSceneRequest> request);
  StopEdgeTranscodeJobResponse stopEdgeTranscodeJobWithOptions(shared_ptr<StopEdgeTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopEdgeTranscodeJobResponse stopEdgeTranscodeJob(shared_ptr<StopEdgeTranscodeJobRequest> request);
  StopLiveDomainResponse stopLiveDomainWithOptions(shared_ptr<StopLiveDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopLiveDomainResponse stopLiveDomain(shared_ptr<StopLiveDomainRequest> request);
  StopLiveMPUTaskResponse stopLiveMPUTaskWithOptions(shared_ptr<StopLiveMPUTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopLiveMPUTaskResponse stopLiveMPUTask(shared_ptr<StopLiveMPUTaskRequest> request);
  StopLivePullToPushResponse stopLivePullToPushWithOptions(shared_ptr<StopLivePullToPushRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopLivePullToPushResponse stopLivePullToPush(shared_ptr<StopLivePullToPushRequest> request);
  StopLiveStreamMonitorResponse stopLiveStreamMonitorWithOptions(shared_ptr<StopLiveStreamMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopLiveStreamMonitorResponse stopLiveStreamMonitor(shared_ptr<StopLiveStreamMonitorRequest> request);
  StopPlaylistResponse stopPlaylistWithOptions(shared_ptr<StopPlaylistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopPlaylistResponse stopPlaylist(shared_ptr<StopPlaylistRequest> request);
  StopRtcAsrTaskResponse stopRtcAsrTaskWithOptions(shared_ptr<StopRtcAsrTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopRtcAsrTaskResponse stopRtcAsrTask(shared_ptr<StopRtcAsrTaskRequest> request);
  StopRtcCloudRecordingResponse stopRtcCloudRecordingWithOptions(shared_ptr<StopRtcCloudRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopRtcCloudRecordingResponse stopRtcCloudRecording(shared_ptr<StopRtcCloudRecordingRequest> request);
  TagLiveResourcesResponse tagLiveResourcesWithOptions(shared_ptr<TagLiveResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagLiveResourcesResponse tagLiveResources(shared_ptr<TagLiveResourcesRequest> request);
  UnTagLiveResourcesResponse unTagLiveResourcesWithOptions(shared_ptr<UnTagLiveResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnTagLiveResourcesResponse unTagLiveResources(shared_ptr<UnTagLiveResourcesRequest> request);
  UnbanLiveMessageGroupResponse unbanLiveMessageGroupWithOptions(shared_ptr<UnbanLiveMessageGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbanLiveMessageGroupResponse unbanLiveMessageGroup(shared_ptr<UnbanLiveMessageGroupRequest> request);
  UpdateCasterResourceGroupResponse updateCasterResourceGroupWithOptions(shared_ptr<UpdateCasterResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCasterResourceGroupResponse updateCasterResourceGroup(shared_ptr<UpdateCasterResourceGroupRequest> request);
  UpdateCasterSceneAudioResponse updateCasterSceneAudioWithOptions(shared_ptr<UpdateCasterSceneAudioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCasterSceneAudioResponse updateCasterSceneAudio(shared_ptr<UpdateCasterSceneAudioRequest> request);
  UpdateCasterSceneConfigResponse updateCasterSceneConfigWithOptions(shared_ptr<UpdateCasterSceneConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCasterSceneConfigResponse updateCasterSceneConfig(shared_ptr<UpdateCasterSceneConfigRequest> request);
  UpdateCustomLiveStreamTranscodeResponse updateCustomLiveStreamTranscodeWithOptions(shared_ptr<UpdateCustomLiveStreamTranscodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomLiveStreamTranscodeResponse updateCustomLiveStreamTranscode(shared_ptr<UpdateCustomLiveStreamTranscodeRequest> request);
  UpdateEdgeTranscodeJobResponse updateEdgeTranscodeJobWithOptions(shared_ptr<UpdateEdgeTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEdgeTranscodeJobResponse updateEdgeTranscodeJob(shared_ptr<UpdateEdgeTranscodeJobRequest> request);
  UpdateEventSubResponse updateEventSubWithOptions(shared_ptr<UpdateEventSubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEventSubResponse updateEventSub(shared_ptr<UpdateEventSubRequest> request);
  UpdateLiveAIProduceRulesResponse updateLiveAIProduceRulesWithOptions(shared_ptr<UpdateLiveAIProduceRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveAIProduceRulesResponse updateLiveAIProduceRules(shared_ptr<UpdateLiveAIProduceRulesRequest> request);
  UpdateLiveAISubtitleResponse updateLiveAISubtitleWithOptions(shared_ptr<UpdateLiveAISubtitleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveAISubtitleResponse updateLiveAISubtitle(shared_ptr<UpdateLiveAISubtitleRequest> request);
  UpdateLiveAppRecordConfigResponse updateLiveAppRecordConfigWithOptions(shared_ptr<UpdateLiveAppRecordConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveAppRecordConfigResponse updateLiveAppRecordConfig(shared_ptr<UpdateLiveAppRecordConfigRequest> request);
  UpdateLiveAppSnapshotConfigResponse updateLiveAppSnapshotConfigWithOptions(shared_ptr<UpdateLiveAppSnapshotConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveAppSnapshotConfigResponse updateLiveAppSnapshotConfig(shared_ptr<UpdateLiveAppSnapshotConfigRequest> request);
  UpdateLiveAudioAuditConfigResponse updateLiveAudioAuditConfigWithOptions(shared_ptr<UpdateLiveAudioAuditConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveAudioAuditConfigResponse updateLiveAudioAuditConfig(shared_ptr<UpdateLiveAudioAuditConfigRequest> request);
  UpdateLiveAudioAuditNotifyConfigResponse updateLiveAudioAuditNotifyConfigWithOptions(shared_ptr<UpdateLiveAudioAuditNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveAudioAuditNotifyConfigResponse updateLiveAudioAuditNotifyConfig(shared_ptr<UpdateLiveAudioAuditNotifyConfigRequest> request);
  UpdateLiveCenterTransferResponse updateLiveCenterTransferWithOptions(shared_ptr<UpdateLiveCenterTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveCenterTransferResponse updateLiveCenterTransfer(shared_ptr<UpdateLiveCenterTransferRequest> request);
  UpdateLiveDelayConfigResponse updateLiveDelayConfigWithOptions(shared_ptr<UpdateLiveDelayConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveDelayConfigResponse updateLiveDelayConfig(shared_ptr<UpdateLiveDelayConfigRequest> request);
  UpdateLiveDetectNotifyConfigResponse updateLiveDetectNotifyConfigWithOptions(shared_ptr<UpdateLiveDetectNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveDetectNotifyConfigResponse updateLiveDetectNotifyConfig(shared_ptr<UpdateLiveDetectNotifyConfigRequest> request);
  UpdateLiveMPUTaskResponse updateLiveMPUTaskWithOptions(shared_ptr<UpdateLiveMPUTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveMPUTaskResponse updateLiveMPUTask(shared_ptr<UpdateLiveMPUTaskRequest> request);
  UpdateLivePackageConfigResponse updateLivePackageConfigWithOptions(shared_ptr<UpdateLivePackageConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLivePackageConfigResponse updateLivePackageConfig(shared_ptr<UpdateLivePackageConfigRequest> request);
  UpdateLivePullStreamInfoConfigResponse updateLivePullStreamInfoConfigWithOptions(shared_ptr<UpdateLivePullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLivePullStreamInfoConfigResponse updateLivePullStreamInfoConfig(shared_ptr<UpdateLivePullStreamInfoConfigRequest> request);
  UpdateLivePullToPushResponse updateLivePullToPushWithOptions(shared_ptr<UpdateLivePullToPushRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLivePullToPushResponse updateLivePullToPush(shared_ptr<UpdateLivePullToPushRequest> request);
  UpdateLiveRecordNotifyConfigResponse updateLiveRecordNotifyConfigWithOptions(shared_ptr<UpdateLiveRecordNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveRecordNotifyConfigResponse updateLiveRecordNotifyConfig(shared_ptr<UpdateLiveRecordNotifyConfigRequest> request);
  UpdateLiveRecordVodConfigResponse updateLiveRecordVodConfigWithOptions(shared_ptr<UpdateLiveRecordVodConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveRecordVodConfigResponse updateLiveRecordVodConfig(shared_ptr<UpdateLiveRecordVodConfigRequest> request);
  UpdateLiveSnapshotDetectPornConfigResponse updateLiveSnapshotDetectPornConfigWithOptions(shared_ptr<UpdateLiveSnapshotDetectPornConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveSnapshotDetectPornConfigResponse updateLiveSnapshotDetectPornConfig(shared_ptr<UpdateLiveSnapshotDetectPornConfigRequest> request);
  UpdateLiveSnapshotNotifyConfigResponse updateLiveSnapshotNotifyConfigWithOptions(shared_ptr<UpdateLiveSnapshotNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveSnapshotNotifyConfigResponse updateLiveSnapshotNotifyConfig(shared_ptr<UpdateLiveSnapshotNotifyConfigRequest> request);
  UpdateLiveStreamMonitorResponse updateLiveStreamMonitorWithOptions(shared_ptr<UpdateLiveStreamMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveStreamMonitorResponse updateLiveStreamMonitor(shared_ptr<UpdateLiveStreamMonitorRequest> request);
  UpdateLiveStreamTranscodeResponse updateLiveStreamTranscodeWithOptions(shared_ptr<UpdateLiveStreamTranscodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveStreamTranscodeResponse updateLiveStreamTranscode(shared_ptr<UpdateLiveStreamTranscodeRequest> request);
  UpdateLiveStreamWatermarkResponse updateLiveStreamWatermarkWithOptions(shared_ptr<UpdateLiveStreamWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveStreamWatermarkResponse updateLiveStreamWatermark(shared_ptr<UpdateLiveStreamWatermarkRequest> request);
  UpdateLiveStreamWatermarkRuleResponse updateLiveStreamWatermarkRuleWithOptions(shared_ptr<UpdateLiveStreamWatermarkRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveStreamWatermarkRuleResponse updateLiveStreamWatermarkRule(shared_ptr<UpdateLiveStreamWatermarkRuleRequest> request);
  UpdateMessageAppResponse updateMessageAppWithOptions(shared_ptr<UpdateMessageAppRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMessageAppResponse updateMessageApp(shared_ptr<UpdateMessageAppRequest> request);
  UpdateMessageGroupResponse updateMessageGroupWithOptions(shared_ptr<UpdateMessageGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMessageGroupResponse updateMessageGroup(shared_ptr<UpdateMessageGroupRequest> request);
  UpdateMixStreamResponse updateMixStreamWithOptions(shared_ptr<UpdateMixStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMixStreamResponse updateMixStream(shared_ptr<UpdateMixStreamRequest> request);
  UpdateRtcCloudRecordingResponse updateRtcCloudRecordingWithOptions(shared_ptr<UpdateRtcCloudRecordingRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRtcCloudRecordingResponse updateRtcCloudRecording(shared_ptr<UpdateRtcCloudRecordingRequest> request);
  UpdateRtcMPUEventSubResponse updateRtcMPUEventSubWithOptions(shared_ptr<UpdateRtcMPUEventSubRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRtcMPUEventSubResponse updateRtcMPUEventSub(shared_ptr<UpdateRtcMPUEventSubRequest> request);
  UpdateRtsLiveStreamTranscodeResponse updateRtsLiveStreamTranscodeWithOptions(shared_ptr<UpdateRtsLiveStreamTranscodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRtsLiveStreamTranscodeResponse updateRtsLiveStreamTranscode(shared_ptr<UpdateRtsLiveStreamTranscodeRequest> request);
  VerifyLiveDomainOwnerResponse verifyLiveDomainOwnerWithOptions(shared_ptr<VerifyLiveDomainOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyLiveDomainOwnerResponse verifyLiveDomainOwner(shared_ptr<VerifyLiveDomainOwnerRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Live20161101

#endif
