// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_YUNDUN-BASTIONHOST20191209_H_
#define ALIBABACLOUD_YUNDUN-BASTIONHOST20191209_H_

#include <alibabacloud/open_api.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Yundun-bastionhost20191209 {
class AcceptApproveCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> commandId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  AcceptApproveCommandRequest() {}

  explicit AcceptApproveCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AcceptApproveCommandRequest() = default;
};
class AcceptApproveCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AcceptApproveCommandResponseBody() {}

  explicit AcceptApproveCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AcceptApproveCommandResponseBody() = default;
};
class AcceptApproveCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AcceptApproveCommandResponseBody> body{};

  AcceptApproveCommandResponse() {}

  explicit AcceptApproveCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AcceptApproveCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AcceptApproveCommandResponseBody>(model1);
      }
    }
  }


  virtual ~AcceptApproveCommandResponse() = default;
};
class AcceptOperationTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> effectCount{};
  shared_ptr<string> effectEndTime{};
  shared_ptr<string> effectStartTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> operationTicketId{};
  shared_ptr<string> regionId{};

  AcceptOperationTicketRequest() {}

  explicit AcceptOperationTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (effectCount) {
      res["EffectCount"] = boost::any(*effectCount);
    }
    if (effectEndTime) {
      res["EffectEndTime"] = boost::any(*effectEndTime);
    }
    if (effectStartTime) {
      res["EffectStartTime"] = boost::any(*effectStartTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (operationTicketId) {
      res["OperationTicketId"] = boost::any(*operationTicketId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("EffectCount") != m.end() && !m["EffectCount"].empty()) {
      effectCount = make_shared<string>(boost::any_cast<string>(m["EffectCount"]));
    }
    if (m.find("EffectEndTime") != m.end() && !m["EffectEndTime"].empty()) {
      effectEndTime = make_shared<string>(boost::any_cast<string>(m["EffectEndTime"]));
    }
    if (m.find("EffectStartTime") != m.end() && !m["EffectStartTime"].empty()) {
      effectStartTime = make_shared<string>(boost::any_cast<string>(m["EffectStartTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OperationTicketId") != m.end() && !m["OperationTicketId"].empty()) {
      operationTicketId = make_shared<string>(boost::any_cast<string>(m["OperationTicketId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AcceptOperationTicketRequest() = default;
};
class AcceptOperationTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AcceptOperationTicketResponseBody() {}

  explicit AcceptOperationTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AcceptOperationTicketResponseBody() = default;
};
class AcceptOperationTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AcceptOperationTicketResponseBody> body{};

  AcceptOperationTicketResponse() {}

  explicit AcceptOperationTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AcceptOperationTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AcceptOperationTicketResponseBody>(model1);
      }
    }
  }


  virtual ~AcceptOperationTicketResponse() = default;
};
class AddDatabasesToGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> databaseIds{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  AddDatabasesToGroupRequest() {}

  explicit AddDatabasesToGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseIds) {
      res["DatabaseIds"] = boost::any(*databaseIds);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseIds") != m.end() && !m["DatabaseIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddDatabasesToGroupRequest() = default;
};
class AddDatabasesToGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> message{};

  AddDatabasesToGroupResponseBodyResults() {}

  explicit AddDatabasesToGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~AddDatabasesToGroupResponseBodyResults() = default;
};
class AddDatabasesToGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<AddDatabasesToGroupResponseBodyResults>> results{};

  AddDatabasesToGroupResponseBody() {}

  explicit AddDatabasesToGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<AddDatabasesToGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDatabasesToGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<AddDatabasesToGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~AddDatabasesToGroupResponseBody() = default;
};
class AddDatabasesToGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDatabasesToGroupResponseBody> body{};

  AddDatabasesToGroupResponse() {}

  explicit AddDatabasesToGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDatabasesToGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDatabasesToGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddDatabasesToGroupResponse() = default;
};
class AddHostsToGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  AddHostsToGroupRequest() {}

  explicit AddHostsToGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostIds) {
      res["HostIds"] = boost::any(*hostIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostIds") != m.end() && !m["HostIds"].empty()) {
      hostIds = make_shared<string>(boost::any_cast<string>(m["HostIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddHostsToGroupRequest() = default;
};
class AddHostsToGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostId{};
  shared_ptr<string> message{};

  AddHostsToGroupResponseBodyResults() {}

  explicit AddHostsToGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~AddHostsToGroupResponseBodyResults() = default;
};
class AddHostsToGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<AddHostsToGroupResponseBodyResults>> results{};

  AddHostsToGroupResponseBody() {}

  explicit AddHostsToGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<AddHostsToGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddHostsToGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<AddHostsToGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~AddHostsToGroupResponseBody() = default;
};
class AddHostsToGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddHostsToGroupResponseBody> body{};

  AddHostsToGroupResponse() {}

  explicit AddHostsToGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddHostsToGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddHostsToGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddHostsToGroupResponse() = default;
};
class AddUsersToGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};
  shared_ptr<string> userIds{};

  AddUsersToGroupRequest() {}

  explicit AddUsersToGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIds = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~AddUsersToGroupRequest() = default;
};
class AddUsersToGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> userGroupId{};
  shared_ptr<string> userId{};

  AddUsersToGroupResponseBodyResults() {}

  explicit AddUsersToGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AddUsersToGroupResponseBodyResults() = default;
};
class AddUsersToGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<AddUsersToGroupResponseBodyResults>> results{};

  AddUsersToGroupResponseBody() {}

  explicit AddUsersToGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<AddUsersToGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddUsersToGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<AddUsersToGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~AddUsersToGroupResponseBody() = default;
};
class AddUsersToGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddUsersToGroupResponseBody> body{};

  AddUsersToGroupResponse() {}

  explicit AddUsersToGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddUsersToGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddUsersToGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddUsersToGroupResponse() = default;
};
class AttachDatabaseAccountsToUserRequestDatabases : public Darabonba::Model {
public:
  shared_ptr<vector<string>> databaseAccountIds{};
  shared_ptr<string> databaseId{};

  AttachDatabaseAccountsToUserRequestDatabases() {}

  explicit AttachDatabaseAccountsToUserRequestDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountIds) {
      res["DatabaseAccountIds"] = boost::any(*databaseAccountIds);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountIds") != m.end() && !m["DatabaseAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
  }


  virtual ~AttachDatabaseAccountsToUserRequestDatabases() = default;
};
class AttachDatabaseAccountsToUserRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AttachDatabaseAccountsToUserRequestDatabases>> databases{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  AttachDatabaseAccountsToUserRequest() {}

  explicit AttachDatabaseAccountsToUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<AttachDatabaseAccountsToUserRequestDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachDatabaseAccountsToUserRequestDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<AttachDatabaseAccountsToUserRequestDatabases>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AttachDatabaseAccountsToUserRequest() = default;
};
class AttachDatabaseAccountsToUserResponseBodyResultsDatabaseAccounts : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> message{};

  AttachDatabaseAccountsToUserResponseBodyResultsDatabaseAccounts() {}

  explicit AttachDatabaseAccountsToUserResponseBodyResultsDatabaseAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~AttachDatabaseAccountsToUserResponseBodyResultsDatabaseAccounts() = default;
};
class AttachDatabaseAccountsToUserResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<AttachDatabaseAccountsToUserResponseBodyResultsDatabaseAccounts>> databaseAccounts{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> message{};
  shared_ptr<string> userId{};

  AttachDatabaseAccountsToUserResponseBodyResults() {}

  explicit AttachDatabaseAccountsToUserResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (databaseAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*databaseAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseAccounts"] = boost::any(temp1);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatabaseAccounts") != m.end() && !m["DatabaseAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseAccounts"].type()) {
        vector<AttachDatabaseAccountsToUserResponseBodyResultsDatabaseAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachDatabaseAccountsToUserResponseBodyResultsDatabaseAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseAccounts = make_shared<vector<AttachDatabaseAccountsToUserResponseBodyResultsDatabaseAccounts>>(expect1);
      }
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AttachDatabaseAccountsToUserResponseBodyResults() = default;
};
class AttachDatabaseAccountsToUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<AttachDatabaseAccountsToUserResponseBodyResults>> results{};

  AttachDatabaseAccountsToUserResponseBody() {}

  explicit AttachDatabaseAccountsToUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<AttachDatabaseAccountsToUserResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachDatabaseAccountsToUserResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<AttachDatabaseAccountsToUserResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~AttachDatabaseAccountsToUserResponseBody() = default;
};
class AttachDatabaseAccountsToUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachDatabaseAccountsToUserResponseBody> body{};

  AttachDatabaseAccountsToUserResponse() {}

  explicit AttachDatabaseAccountsToUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachDatabaseAccountsToUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachDatabaseAccountsToUserResponseBody>(model1);
      }
    }
  }


  virtual ~AttachDatabaseAccountsToUserResponse() = default;
};
class AttachDatabaseAccountsToUserGroupRequestDatabases : public Darabonba::Model {
public:
  shared_ptr<vector<string>> databaseAccountIds{};
  shared_ptr<string> databaseId{};

  AttachDatabaseAccountsToUserGroupRequestDatabases() {}

  explicit AttachDatabaseAccountsToUserGroupRequestDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountIds) {
      res["DatabaseAccountIds"] = boost::any(*databaseAccountIds);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountIds") != m.end() && !m["DatabaseAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
  }


  virtual ~AttachDatabaseAccountsToUserGroupRequestDatabases() = default;
};
class AttachDatabaseAccountsToUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AttachDatabaseAccountsToUserGroupRequestDatabases>> databases{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  AttachDatabaseAccountsToUserGroupRequest() {}

  explicit AttachDatabaseAccountsToUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<AttachDatabaseAccountsToUserGroupRequestDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachDatabaseAccountsToUserGroupRequestDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<AttachDatabaseAccountsToUserGroupRequestDatabases>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~AttachDatabaseAccountsToUserGroupRequest() = default;
};
class AttachDatabaseAccountsToUserGroupResponseBodyResultsDatabaseAccounts : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> message{};

  AttachDatabaseAccountsToUserGroupResponseBodyResultsDatabaseAccounts() {}

  explicit AttachDatabaseAccountsToUserGroupResponseBodyResultsDatabaseAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~AttachDatabaseAccountsToUserGroupResponseBodyResultsDatabaseAccounts() = default;
};
class AttachDatabaseAccountsToUserGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<AttachDatabaseAccountsToUserGroupResponseBodyResultsDatabaseAccounts>> databaseAccounts{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> message{};
  shared_ptr<string> userGroupId{};

  AttachDatabaseAccountsToUserGroupResponseBodyResults() {}

  explicit AttachDatabaseAccountsToUserGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (databaseAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*databaseAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseAccounts"] = boost::any(temp1);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatabaseAccounts") != m.end() && !m["DatabaseAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseAccounts"].type()) {
        vector<AttachDatabaseAccountsToUserGroupResponseBodyResultsDatabaseAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachDatabaseAccountsToUserGroupResponseBodyResultsDatabaseAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseAccounts = make_shared<vector<AttachDatabaseAccountsToUserGroupResponseBodyResultsDatabaseAccounts>>(expect1);
      }
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~AttachDatabaseAccountsToUserGroupResponseBodyResults() = default;
};
class AttachDatabaseAccountsToUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<AttachDatabaseAccountsToUserGroupResponseBodyResults>> results{};

  AttachDatabaseAccountsToUserGroupResponseBody() {}

  explicit AttachDatabaseAccountsToUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<AttachDatabaseAccountsToUserGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachDatabaseAccountsToUserGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<AttachDatabaseAccountsToUserGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~AttachDatabaseAccountsToUserGroupResponseBody() = default;
};
class AttachDatabaseAccountsToUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachDatabaseAccountsToUserGroupResponseBody> body{};

  AttachDatabaseAccountsToUserGroupResponse() {}

  explicit AttachDatabaseAccountsToUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachDatabaseAccountsToUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachDatabaseAccountsToUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AttachDatabaseAccountsToUserGroupResponse() = default;
};
class AttachHostAccountsToHostShareKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountIds{};
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  AttachHostAccountsToHostShareKeyRequest() {}

  explicit AttachHostAccountsToHostShareKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountIds) {
      res["HostAccountIds"] = boost::any(*hostAccountIds);
    }
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountIds") != m.end() && !m["HostAccountIds"].empty()) {
      hostAccountIds = make_shared<string>(boost::any_cast<string>(m["HostAccountIds"]));
    }
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AttachHostAccountsToHostShareKeyRequest() = default;
};
class AttachHostAccountsToHostShareKeyResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> message{};

  AttachHostAccountsToHostShareKeyResponseBodyResults() {}

  explicit AttachHostAccountsToHostShareKeyResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~AttachHostAccountsToHostShareKeyResponseBodyResults() = default;
};
class AttachHostAccountsToHostShareKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<AttachHostAccountsToHostShareKeyResponseBodyResults>> results{};

  AttachHostAccountsToHostShareKeyResponseBody() {}

  explicit AttachHostAccountsToHostShareKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<AttachHostAccountsToHostShareKeyResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachHostAccountsToHostShareKeyResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<AttachHostAccountsToHostShareKeyResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~AttachHostAccountsToHostShareKeyResponseBody() = default;
};
class AttachHostAccountsToHostShareKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachHostAccountsToHostShareKeyResponseBody> body{};

  AttachHostAccountsToHostShareKeyResponse() {}

  explicit AttachHostAccountsToHostShareKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachHostAccountsToHostShareKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachHostAccountsToHostShareKeyResponseBody>(model1);
      }
    }
  }


  virtual ~AttachHostAccountsToHostShareKeyResponse() = default;
};
class AttachHostAccountsToUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  AttachHostAccountsToUserRequest() {}

  explicit AttachHostAccountsToUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      res["Hosts"] = boost::any(*hosts);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      hosts = make_shared<string>(boost::any_cast<string>(m["Hosts"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AttachHostAccountsToUserRequest() = default;
};
class AttachHostAccountsToUserResponseBodyResultsHostAccounts : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> message{};

  AttachHostAccountsToUserResponseBodyResultsHostAccounts() {}

  explicit AttachHostAccountsToUserResponseBodyResultsHostAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~AttachHostAccountsToUserResponseBodyResultsHostAccounts() = default;
};
class AttachHostAccountsToUserResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<AttachHostAccountsToUserResponseBodyResultsHostAccounts>> hostAccounts{};
  shared_ptr<string> hostId{};
  shared_ptr<string> message{};
  shared_ptr<string> userId{};

  AttachHostAccountsToUserResponseBodyResults() {}

  explicit AttachHostAccountsToUserResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccounts"] = boost::any(temp1);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccounts") != m.end() && !m["HostAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccounts"].type()) {
        vector<AttachHostAccountsToUserResponseBodyResultsHostAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachHostAccountsToUserResponseBodyResultsHostAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccounts = make_shared<vector<AttachHostAccountsToUserResponseBodyResultsHostAccounts>>(expect1);
      }
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AttachHostAccountsToUserResponseBodyResults() = default;
};
class AttachHostAccountsToUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<AttachHostAccountsToUserResponseBodyResults>> results{};

  AttachHostAccountsToUserResponseBody() {}

  explicit AttachHostAccountsToUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<AttachHostAccountsToUserResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachHostAccountsToUserResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<AttachHostAccountsToUserResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~AttachHostAccountsToUserResponseBody() = default;
};
class AttachHostAccountsToUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachHostAccountsToUserResponseBody> body{};

  AttachHostAccountsToUserResponse() {}

  explicit AttachHostAccountsToUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachHostAccountsToUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachHostAccountsToUserResponseBody>(model1);
      }
    }
  }


  virtual ~AttachHostAccountsToUserResponse() = default;
};
class AttachHostAccountsToUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  AttachHostAccountsToUserGroupRequest() {}

  explicit AttachHostAccountsToUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      res["Hosts"] = boost::any(*hosts);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      hosts = make_shared<string>(boost::any_cast<string>(m["Hosts"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~AttachHostAccountsToUserGroupRequest() = default;
};
class AttachHostAccountsToUserGroupResponseBodyResultsHostAccounts : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> message{};

  AttachHostAccountsToUserGroupResponseBodyResultsHostAccounts() {}

  explicit AttachHostAccountsToUserGroupResponseBodyResultsHostAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~AttachHostAccountsToUserGroupResponseBodyResultsHostAccounts() = default;
};
class AttachHostAccountsToUserGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<AttachHostAccountsToUserGroupResponseBodyResultsHostAccounts>> hostAccounts{};
  shared_ptr<string> hostId{};
  shared_ptr<string> message{};
  shared_ptr<string> userGroupId{};

  AttachHostAccountsToUserGroupResponseBodyResults() {}

  explicit AttachHostAccountsToUserGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccounts"] = boost::any(temp1);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccounts") != m.end() && !m["HostAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccounts"].type()) {
        vector<AttachHostAccountsToUserGroupResponseBodyResultsHostAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachHostAccountsToUserGroupResponseBodyResultsHostAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccounts = make_shared<vector<AttachHostAccountsToUserGroupResponseBodyResultsHostAccounts>>(expect1);
      }
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~AttachHostAccountsToUserGroupResponseBodyResults() = default;
};
class AttachHostAccountsToUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<AttachHostAccountsToUserGroupResponseBodyResults>> results{};

  AttachHostAccountsToUserGroupResponseBody() {}

  explicit AttachHostAccountsToUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<AttachHostAccountsToUserGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachHostAccountsToUserGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<AttachHostAccountsToUserGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~AttachHostAccountsToUserGroupResponseBody() = default;
};
class AttachHostAccountsToUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachHostAccountsToUserGroupResponseBody> body{};

  AttachHostAccountsToUserGroupResponse() {}

  explicit AttachHostAccountsToUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachHostAccountsToUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachHostAccountsToUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AttachHostAccountsToUserGroupResponse() = default;
};
class AttachHostGroupAccountsToUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroups{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  AttachHostGroupAccountsToUserRequest() {}

  explicit AttachHostGroupAccountsToUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroups) {
      res["HostGroups"] = boost::any(*hostGroups);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      hostGroups = make_shared<string>(boost::any_cast<string>(m["HostGroups"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AttachHostGroupAccountsToUserRequest() = default;
};
class AttachHostGroupAccountsToUserResponseBodyResultsHostAccountNames : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> message{};

  AttachHostGroupAccountsToUserResponseBodyResultsHostAccountNames() {}

  explicit AttachHostGroupAccountsToUserResponseBodyResultsHostAccountNames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~AttachHostGroupAccountsToUserResponseBodyResultsHostAccountNames() = default;
};
class AttachHostGroupAccountsToUserResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<AttachHostGroupAccountsToUserResponseBodyResultsHostAccountNames>> hostAccountNames{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> message{};
  shared_ptr<string> userId{};

  AttachHostGroupAccountsToUserResponseBodyResults() {}

  explicit AttachHostGroupAccountsToUserResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountNames) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccountNames){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccountNames"] = boost::any(temp1);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountNames") != m.end() && !m["HostAccountNames"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccountNames"].type()) {
        vector<AttachHostGroupAccountsToUserResponseBodyResultsHostAccountNames> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccountNames"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachHostGroupAccountsToUserResponseBodyResultsHostAccountNames model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccountNames = make_shared<vector<AttachHostGroupAccountsToUserResponseBodyResultsHostAccountNames>>(expect1);
      }
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AttachHostGroupAccountsToUserResponseBodyResults() = default;
};
class AttachHostGroupAccountsToUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<AttachHostGroupAccountsToUserResponseBodyResults>> results{};

  AttachHostGroupAccountsToUserResponseBody() {}

  explicit AttachHostGroupAccountsToUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<AttachHostGroupAccountsToUserResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachHostGroupAccountsToUserResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<AttachHostGroupAccountsToUserResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~AttachHostGroupAccountsToUserResponseBody() = default;
};
class AttachHostGroupAccountsToUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachHostGroupAccountsToUserResponseBody> body{};

  AttachHostGroupAccountsToUserResponse() {}

  explicit AttachHostGroupAccountsToUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachHostGroupAccountsToUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachHostGroupAccountsToUserResponseBody>(model1);
      }
    }
  }


  virtual ~AttachHostGroupAccountsToUserResponse() = default;
};
class AttachHostGroupAccountsToUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroups{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  AttachHostGroupAccountsToUserGroupRequest() {}

  explicit AttachHostGroupAccountsToUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroups) {
      res["HostGroups"] = boost::any(*hostGroups);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      hostGroups = make_shared<string>(boost::any_cast<string>(m["HostGroups"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~AttachHostGroupAccountsToUserGroupRequest() = default;
};
class AttachHostGroupAccountsToUserGroupResponseBodyResultsHostAccountNames : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> message{};

  AttachHostGroupAccountsToUserGroupResponseBodyResultsHostAccountNames() {}

  explicit AttachHostGroupAccountsToUserGroupResponseBodyResultsHostAccountNames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~AttachHostGroupAccountsToUserGroupResponseBodyResultsHostAccountNames() = default;
};
class AttachHostGroupAccountsToUserGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<AttachHostGroupAccountsToUserGroupResponseBodyResultsHostAccountNames>> hostAccountNames{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> message{};
  shared_ptr<string> userGroupId{};

  AttachHostGroupAccountsToUserGroupResponseBodyResults() {}

  explicit AttachHostGroupAccountsToUserGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountNames) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccountNames){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccountNames"] = boost::any(temp1);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountNames") != m.end() && !m["HostAccountNames"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccountNames"].type()) {
        vector<AttachHostGroupAccountsToUserGroupResponseBodyResultsHostAccountNames> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccountNames"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachHostGroupAccountsToUserGroupResponseBodyResultsHostAccountNames model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccountNames = make_shared<vector<AttachHostGroupAccountsToUserGroupResponseBodyResultsHostAccountNames>>(expect1);
      }
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~AttachHostGroupAccountsToUserGroupResponseBodyResults() = default;
};
class AttachHostGroupAccountsToUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<AttachHostGroupAccountsToUserGroupResponseBodyResults>> results{};

  AttachHostGroupAccountsToUserGroupResponseBody() {}

  explicit AttachHostGroupAccountsToUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<AttachHostGroupAccountsToUserGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachHostGroupAccountsToUserGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<AttachHostGroupAccountsToUserGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~AttachHostGroupAccountsToUserGroupResponseBody() = default;
};
class AttachHostGroupAccountsToUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachHostGroupAccountsToUserGroupResponseBody> body{};

  AttachHostGroupAccountsToUserGroupResponse() {}

  explicit AttachHostGroupAccountsToUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachHostGroupAccountsToUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachHostGroupAccountsToUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AttachHostGroupAccountsToUserGroupResponse() = default;
};
class ConfigInstanceSecurityGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> authorizedSecurityGroups{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> regionId{};

  ConfigInstanceSecurityGroupsRequest() {}

  explicit ConfigInstanceSecurityGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedSecurityGroups) {
      res["AuthorizedSecurityGroups"] = boost::any(*authorizedSecurityGroups);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedSecurityGroups") != m.end() && !m["AuthorizedSecurityGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AuthorizedSecurityGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AuthorizedSecurityGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      authorizedSecurityGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ConfigInstanceSecurityGroupsRequest() = default;
};
class ConfigInstanceSecurityGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  ConfigInstanceSecurityGroupsResponseBody() {}

  explicit ConfigInstanceSecurityGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigInstanceSecurityGroupsResponseBody() = default;
};
class ConfigInstanceSecurityGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigInstanceSecurityGroupsResponseBody> body{};

  ConfigInstanceSecurityGroupsResponse() {}

  explicit ConfigInstanceSecurityGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigInstanceSecurityGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigInstanceSecurityGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigInstanceSecurityGroupsResponse() = default;
};
class ConfigInstanceWhiteListRequestWhiteListPolicies : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> entry{};

  ConfigInstanceWhiteListRequestWhiteListPolicies() {}

  explicit ConfigInstanceWhiteListRequestWhiteListPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (entry) {
      res["Entry"] = boost::any(*entry);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Entry") != m.end() && !m["Entry"].empty()) {
      entry = make_shared<string>(boost::any_cast<string>(m["Entry"]));
    }
  }


  virtual ~ConfigInstanceWhiteListRequestWhiteListPolicies() = default;
};
class ConfigInstanceWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> whiteList{};
  shared_ptr<vector<ConfigInstanceWhiteListRequestWhiteListPolicies>> whiteListPolicies{};

  ConfigInstanceWhiteListRequest() {}

  explicit ConfigInstanceWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    if (whiteListPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*whiteListPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WhiteListPolicies"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      whiteList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhiteListPolicies") != m.end() && !m["WhiteListPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["WhiteListPolicies"].type()) {
        vector<ConfigInstanceWhiteListRequestWhiteListPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WhiteListPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ConfigInstanceWhiteListRequestWhiteListPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whiteListPolicies = make_shared<vector<ConfigInstanceWhiteListRequestWhiteListPolicies>>(expect1);
      }
    }
  }


  virtual ~ConfigInstanceWhiteListRequest() = default;
};
class ConfigInstanceWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  ConfigInstanceWhiteListResponseBody() {}

  explicit ConfigInstanceWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigInstanceWhiteListResponseBody() = default;
};
class ConfigInstanceWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigInstanceWhiteListResponseBody> body{};

  ConfigInstanceWhiteListResponse() {}

  explicit ConfigInstanceWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigInstanceWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigInstanceWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigInstanceWhiteListResponse() = default;
};
class CreateDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<string> databaseName{};
  shared_ptr<long> databasePort{};
  shared_ptr<string> databasePrivateAddress{};
  shared_ptr<string> databasePublicAddress{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> polarDBEndpointType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceRegionId{};

  CreateDatabaseRequest() {}

  explicit CreateDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databasePort) {
      res["DatabasePort"] = boost::any(*databasePort);
    }
    if (databasePrivateAddress) {
      res["DatabasePrivateAddress"] = boost::any(*databasePrivateAddress);
    }
    if (databasePublicAddress) {
      res["DatabasePublicAddress"] = boost::any(*databasePublicAddress);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (polarDBEndpointType) {
      res["PolarDBEndpointType"] = boost::any(*polarDBEndpointType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceRegionId) {
      res["SourceInstanceRegionId"] = boost::any(*sourceInstanceRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabasePort") != m.end() && !m["DatabasePort"].empty()) {
      databasePort = make_shared<long>(boost::any_cast<long>(m["DatabasePort"]));
    }
    if (m.find("DatabasePrivateAddress") != m.end() && !m["DatabasePrivateAddress"].empty()) {
      databasePrivateAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePrivateAddress"]));
    }
    if (m.find("DatabasePublicAddress") != m.end() && !m["DatabasePublicAddress"].empty()) {
      databasePublicAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePublicAddress"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("PolarDBEndpointType") != m.end() && !m["PolarDBEndpointType"].empty()) {
      polarDBEndpointType = make_shared<string>(boost::any_cast<string>(m["PolarDBEndpointType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceRegionId") != m.end() && !m["SourceInstanceRegionId"].empty()) {
      sourceInstanceRegionId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceRegionId"]));
    }
  }


  virtual ~CreateDatabaseRequest() = default;
};
class CreateDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> databaseId{};
  shared_ptr<string> requestId{};

  CreateDatabaseResponseBody() {}

  explicit CreateDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDatabaseResponseBody() = default;
};
class CreateDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDatabaseResponseBody> body{};

  CreateDatabaseResponse() {}

  explicit CreateDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDatabaseResponse() = default;
};
class CreateDatabaseAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> databaseSchema{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginAttribute{};
  shared_ptr<string> password{};
  shared_ptr<string> regionId{};

  CreateDatabaseAccountRequest() {}

  explicit CreateDatabaseAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountName) {
      res["DatabaseAccountName"] = boost::any(*databaseAccountName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (databaseSchema) {
      res["DatabaseSchema"] = boost::any(*databaseSchema);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginAttribute) {
      res["LoginAttribute"] = boost::any(*loginAttribute);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountName") != m.end() && !m["DatabaseAccountName"].empty()) {
      databaseAccountName = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatabaseSchema") != m.end() && !m["DatabaseSchema"].empty()) {
      databaseSchema = make_shared<string>(boost::any_cast<string>(m["DatabaseSchema"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginAttribute") != m.end() && !m["LoginAttribute"].empty()) {
      loginAttribute = make_shared<string>(boost::any_cast<string>(m["LoginAttribute"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateDatabaseAccountRequest() = default;
};
class CreateDatabaseAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> requestId{};

  CreateDatabaseAccountResponseBody() {}

  explicit CreateDatabaseAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDatabaseAccountResponseBody() = default;
};
class CreateDatabaseAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDatabaseAccountResponseBody> body{};

  CreateDatabaseAccountResponse() {}

  explicit CreateDatabaseAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDatabaseAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDatabaseAccountResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDatabaseAccountResponse() = default;
};
class CreateExportConfigJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  CreateExportConfigJobRequest() {}

  explicit CreateExportConfigJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateExportConfigJobRequest() = default;
};
class CreateExportConfigJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  CreateExportConfigJobResponseBody() {}

  explicit CreateExportConfigJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateExportConfigJobResponseBody() = default;
};
class CreateExportConfigJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateExportConfigJobResponseBody> body{};

  CreateExportConfigJobResponse() {}

  explicit CreateExportConfigJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateExportConfigJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateExportConfigJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateExportConfigJobResponse() = default;
};
class CreateHostRequest : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hostPrivateAddress{};
  shared_ptr<string> hostPublicAddress{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceRegionId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> OSType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};

  CreateHostRequest() {}

  explicit CreateHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostPrivateAddress) {
      res["HostPrivateAddress"] = boost::any(*hostPrivateAddress);
    }
    if (hostPublicAddress) {
      res["HostPublicAddress"] = boost::any(*hostPublicAddress);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceRegionId) {
      res["InstanceRegionId"] = boost::any(*instanceRegionId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostPrivateAddress") != m.end() && !m["HostPrivateAddress"].empty()) {
      hostPrivateAddress = make_shared<string>(boost::any_cast<string>(m["HostPrivateAddress"]));
    }
    if (m.find("HostPublicAddress") != m.end() && !m["HostPublicAddress"].empty()) {
      hostPublicAddress = make_shared<string>(boost::any_cast<string>(m["HostPublicAddress"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceRegionId") != m.end() && !m["InstanceRegionId"].empty()) {
      instanceRegionId = make_shared<string>(boost::any_cast<string>(m["InstanceRegionId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
  }


  virtual ~CreateHostRequest() = default;
};
class CreateHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> hostId{};
  shared_ptr<string> requestId{};

  CreateHostResponseBody() {}

  explicit CreateHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateHostResponseBody() = default;
};
class CreateHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHostResponseBody> body{};

  CreateHostResponse() {}

  explicit CreateHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHostResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHostResponse() = default;
};
class CreateHostAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> passPhrase{};
  shared_ptr<string> password{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> protocolName{};
  shared_ptr<string> regionId{};

  CreateHostAccountRequest() {}

  explicit CreateHostAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (passPhrase) {
      res["PassPhrase"] = boost::any(*passPhrase);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PassPhrase") != m.end() && !m["PassPhrase"].empty()) {
      passPhrase = make_shared<string>(boost::any_cast<string>(m["PassPhrase"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateHostAccountRequest() = default;
};
class CreateHostAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> requestId{};

  CreateHostAccountResponseBody() {}

  explicit CreateHostAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateHostAccountResponseBody() = default;
};
class CreateHostAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHostAccountResponseBody> body{};

  CreateHostAccountResponse() {}

  explicit CreateHostAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHostAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHostAccountResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHostAccountResponse() = default;
};
class CreateHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  CreateHostGroupRequest() {}

  explicit CreateHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateHostGroupRequest() = default;
};
class CreateHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> requestId{};

  CreateHostGroupResponseBody() {}

  explicit CreateHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateHostGroupResponseBody() = default;
};
class CreateHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHostGroupResponseBody> body{};

  CreateHostGroupResponse() {}

  explicit CreateHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHostGroupResponse() = default;
};
class CreateHostShareKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostShareKeyName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> passPhrase{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> regionId{};

  CreateHostShareKeyRequest() {}

  explicit CreateHostShareKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostShareKeyName) {
      res["HostShareKeyName"] = boost::any(*hostShareKeyName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (passPhrase) {
      res["PassPhrase"] = boost::any(*passPhrase);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostShareKeyName") != m.end() && !m["HostShareKeyName"].empty()) {
      hostShareKeyName = make_shared<string>(boost::any_cast<string>(m["HostShareKeyName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PassPhrase") != m.end() && !m["PassPhrase"].empty()) {
      passPhrase = make_shared<string>(boost::any_cast<string>(m["PassPhrase"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateHostShareKeyRequest() = default;
};
class CreateHostShareKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> hostShareKeyId{};
  shared_ptr<string> requestId{};

  CreateHostShareKeyResponseBody() {}

  explicit CreateHostShareKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<long>(boost::any_cast<long>(m["HostShareKeyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateHostShareKeyResponseBody() = default;
};
class CreateHostShareKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHostShareKeyResponseBody> body{};

  CreateHostShareKeyResponse() {}

  explicit CreateHostShareKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHostShareKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHostShareKeyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHostShareKeyResponse() = default;
};
class CreateNetworkDomainRequestProxies : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> password{};
  shared_ptr<long> port{};
  shared_ptr<string> proxyType{};
  shared_ptr<string> user{};

  CreateNetworkDomainRequestProxies() {}

  explicit CreateNetworkDomainRequestProxies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (proxyType) {
      res["ProxyType"] = boost::any(*proxyType);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ProxyType") != m.end() && !m["ProxyType"].empty()) {
      proxyType = make_shared<string>(boost::any_cast<string>(m["ProxyType"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~CreateNetworkDomainRequestProxies() = default;
};
class CreateNetworkDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainName{};
  shared_ptr<string> networkDomainType{};
  shared_ptr<vector<CreateNetworkDomainRequestProxies>> proxies{};
  shared_ptr<string> regionId{};

  CreateNetworkDomainRequest() {}

  explicit CreateNetworkDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainName) {
      res["NetworkDomainName"] = boost::any(*networkDomainName);
    }
    if (networkDomainType) {
      res["NetworkDomainType"] = boost::any(*networkDomainType);
    }
    if (proxies) {
      vector<boost::any> temp1;
      for(auto item1:*proxies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Proxies"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainName") != m.end() && !m["NetworkDomainName"].empty()) {
      networkDomainName = make_shared<string>(boost::any_cast<string>(m["NetworkDomainName"]));
    }
    if (m.find("NetworkDomainType") != m.end() && !m["NetworkDomainType"].empty()) {
      networkDomainType = make_shared<string>(boost::any_cast<string>(m["NetworkDomainType"]));
    }
    if (m.find("Proxies") != m.end() && !m["Proxies"].empty()) {
      if (typeid(vector<boost::any>) == m["Proxies"].type()) {
        vector<CreateNetworkDomainRequestProxies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Proxies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNetworkDomainRequestProxies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proxies = make_shared<vector<CreateNetworkDomainRequestProxies>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateNetworkDomainRequest() = default;
};
class CreateNetworkDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> requestId{};

  CreateNetworkDomainResponseBody() {}

  explicit CreateNetworkDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNetworkDomainResponseBody() = default;
};
class CreateNetworkDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkDomainResponseBody> body{};

  CreateNetworkDomainResponse() {}

  explicit CreateNetworkDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkDomainResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkDomainResponse() = default;
};
class CreateOperationTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> approveComment{};
  shared_ptr<string> assetAccountName{};
  shared_ptr<string> assetId{};
  shared_ptr<long> effectEndTime{};
  shared_ptr<long> effectStartTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isOneTimeEffect{};
  shared_ptr<string> protocolName{};
  shared_ptr<string> regionId{};

  CreateOperationTicketRequest() {}

  explicit CreateOperationTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approveComment) {
      res["ApproveComment"] = boost::any(*approveComment);
    }
    if (assetAccountName) {
      res["AssetAccountName"] = boost::any(*assetAccountName);
    }
    if (assetId) {
      res["AssetId"] = boost::any(*assetId);
    }
    if (effectEndTime) {
      res["EffectEndTime"] = boost::any(*effectEndTime);
    }
    if (effectStartTime) {
      res["EffectStartTime"] = boost::any(*effectStartTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isOneTimeEffect) {
      res["IsOneTimeEffect"] = boost::any(*isOneTimeEffect);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApproveComment") != m.end() && !m["ApproveComment"].empty()) {
      approveComment = make_shared<string>(boost::any_cast<string>(m["ApproveComment"]));
    }
    if (m.find("AssetAccountName") != m.end() && !m["AssetAccountName"].empty()) {
      assetAccountName = make_shared<string>(boost::any_cast<string>(m["AssetAccountName"]));
    }
    if (m.find("AssetId") != m.end() && !m["AssetId"].empty()) {
      assetId = make_shared<string>(boost::any_cast<string>(m["AssetId"]));
    }
    if (m.find("EffectEndTime") != m.end() && !m["EffectEndTime"].empty()) {
      effectEndTime = make_shared<long>(boost::any_cast<long>(m["EffectEndTime"]));
    }
    if (m.find("EffectStartTime") != m.end() && !m["EffectStartTime"].empty()) {
      effectStartTime = make_shared<long>(boost::any_cast<long>(m["EffectStartTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsOneTimeEffect") != m.end() && !m["IsOneTimeEffect"].empty()) {
      isOneTimeEffect = make_shared<bool>(boost::any_cast<bool>(m["IsOneTimeEffect"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateOperationTicketRequest() = default;
};
class CreateOperationTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationTicketId{};
  shared_ptr<string> requestId{};

  CreateOperationTicketResponseBody() {}

  explicit CreateOperationTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationTicketId) {
      res["OperationTicketId"] = boost::any(*operationTicketId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationTicketId") != m.end() && !m["OperationTicketId"].empty()) {
      operationTicketId = make_shared<string>(boost::any_cast<string>(m["OperationTicketId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOperationTicketResponseBody() = default;
};
class CreateOperationTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOperationTicketResponseBody> body{};

  CreateOperationTicketResponse() {}

  explicit CreateOperationTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOperationTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOperationTicketResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOperationTicketResponse() = default;
};
class CreatePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> priority{};
  shared_ptr<string> regionId{};

  CreatePolicyRequest() {}

  explicit CreatePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreatePolicyRequest() = default;
};
class CreatePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policyId{};
  shared_ptr<string> requestId{};

  CreatePolicyResponseBody() {}

  explicit CreatePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePolicyResponseBody() = default;
};
class CreatePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePolicyResponseBody> body{};

  CreatePolicyResponse() {}

  explicit CreatePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePolicyResponse() = default;
};
class CreateRuleRequestDatabases : public Darabonba::Model {
public:
  shared_ptr<vector<string>> databaseAccountIds{};
  shared_ptr<string> databaseId{};

  CreateRuleRequestDatabases() {}

  explicit CreateRuleRequestDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountIds) {
      res["DatabaseAccountIds"] = boost::any(*databaseAccountIds);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountIds") != m.end() && !m["DatabaseAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
  }


  virtual ~CreateRuleRequestDatabases() = default;
};
class CreateRuleRequestHostGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostAccountNames{};
  shared_ptr<string> hostGroupId{};

  CreateRuleRequestHostGroups() {}

  explicit CreateRuleRequestHostGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountNames) {
      res["HostAccountNames"] = boost::any(*hostAccountNames);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountNames") != m.end() && !m["HostAccountNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostAccountNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostAccountNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostAccountNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
  }


  virtual ~CreateRuleRequestHostGroups() = default;
};
class CreateRuleRequestHosts : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostAccountIds{};
  shared_ptr<string> hostId{};

  CreateRuleRequestHosts() {}

  explicit CreateRuleRequestHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountIds) {
      res["HostAccountIds"] = boost::any(*hostAccountIds);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountIds") != m.end() && !m["HostAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
  }


  virtual ~CreateRuleRequestHosts() = default;
};
class CreateRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<CreateRuleRequestDatabases>> databases{};
  shared_ptr<long> effectiveEndTime{};
  shared_ptr<long> effectiveStartTime{};
  shared_ptr<vector<CreateRuleRequestHostGroups>> hostGroups{};
  shared_ptr<vector<CreateRuleRequestHosts>> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleName{};
  shared_ptr<vector<string>> userGroupIds{};
  shared_ptr<vector<string>> userIds{};

  CreateRuleRequest() {}

  explicit CreateRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (effectiveEndTime) {
      res["EffectiveEndTime"] = boost::any(*effectiveEndTime);
    }
    if (effectiveStartTime) {
      res["EffectiveStartTime"] = boost::any(*effectiveStartTime);
    }
    if (hostGroups) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroups"] = boost::any(temp1);
    }
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (userGroupIds) {
      res["UserGroupIds"] = boost::any(*userGroupIds);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<CreateRuleRequestDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRuleRequestDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<CreateRuleRequestDatabases>>(expect1);
      }
    }
    if (m.find("EffectiveEndTime") != m.end() && !m["EffectiveEndTime"].empty()) {
      effectiveEndTime = make_shared<long>(boost::any_cast<long>(m["EffectiveEndTime"]));
    }
    if (m.find("EffectiveStartTime") != m.end() && !m["EffectiveStartTime"].empty()) {
      effectiveStartTime = make_shared<long>(boost::any_cast<long>(m["EffectiveStartTime"]));
    }
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroups"].type()) {
        vector<CreateRuleRequestHostGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRuleRequestHostGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroups = make_shared<vector<CreateRuleRequestHostGroups>>(expect1);
      }
    }
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<CreateRuleRequestHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRuleRequestHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<CreateRuleRequestHosts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("UserGroupIds") != m.end() && !m["UserGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateRuleRequest() = default;
};
class CreateRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleId{};

  CreateRuleResponseBody() {}

  explicit CreateRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~CreateRuleResponseBody() = default;
};
class CreateRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRuleResponseBody> body{};

  CreateRuleResponse() {}

  explicit CreateRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRuleResponse() = default;
};
class CreateUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> displayName{};
  shared_ptr<long> effectiveEndTime{};
  shared_ptr<long> effectiveStartTime{};
  shared_ptr<string> email{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> language{};
  shared_ptr<string> languageStatus{};
  shared_ptr<string> mobile{};
  shared_ptr<string> mobileCountryCode{};
  shared_ptr<bool> needResetPassword{};
  shared_ptr<string> password{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceUserId{};
  shared_ptr<string> twoFactorMethods{};
  shared_ptr<string> twoFactorStatus{};
  shared_ptr<string> userName{};

  CreateUserRequest() {}

  explicit CreateUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (effectiveEndTime) {
      res["EffectiveEndTime"] = boost::any(*effectiveEndTime);
    }
    if (effectiveStartTime) {
      res["EffectiveStartTime"] = boost::any(*effectiveStartTime);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (languageStatus) {
      res["LanguageStatus"] = boost::any(*languageStatus);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (mobileCountryCode) {
      res["MobileCountryCode"] = boost::any(*mobileCountryCode);
    }
    if (needResetPassword) {
      res["NeedResetPassword"] = boost::any(*needResetPassword);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceUserId) {
      res["SourceUserId"] = boost::any(*sourceUserId);
    }
    if (twoFactorMethods) {
      res["TwoFactorMethods"] = boost::any(*twoFactorMethods);
    }
    if (twoFactorStatus) {
      res["TwoFactorStatus"] = boost::any(*twoFactorStatus);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("EffectiveEndTime") != m.end() && !m["EffectiveEndTime"].empty()) {
      effectiveEndTime = make_shared<long>(boost::any_cast<long>(m["EffectiveEndTime"]));
    }
    if (m.find("EffectiveStartTime") != m.end() && !m["EffectiveStartTime"].empty()) {
      effectiveStartTime = make_shared<long>(boost::any_cast<long>(m["EffectiveStartTime"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LanguageStatus") != m.end() && !m["LanguageStatus"].empty()) {
      languageStatus = make_shared<string>(boost::any_cast<string>(m["LanguageStatus"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("MobileCountryCode") != m.end() && !m["MobileCountryCode"].empty()) {
      mobileCountryCode = make_shared<string>(boost::any_cast<string>(m["MobileCountryCode"]));
    }
    if (m.find("NeedResetPassword") != m.end() && !m["NeedResetPassword"].empty()) {
      needResetPassword = make_shared<bool>(boost::any_cast<bool>(m["NeedResetPassword"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceUserId") != m.end() && !m["SourceUserId"].empty()) {
      sourceUserId = make_shared<string>(boost::any_cast<string>(m["SourceUserId"]));
    }
    if (m.find("TwoFactorMethods") != m.end() && !m["TwoFactorMethods"].empty()) {
      twoFactorMethods = make_shared<string>(boost::any_cast<string>(m["TwoFactorMethods"]));
    }
    if (m.find("TwoFactorStatus") != m.end() && !m["TwoFactorStatus"].empty()) {
      twoFactorStatus = make_shared<string>(boost::any_cast<string>(m["TwoFactorStatus"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~CreateUserRequest() = default;
};
class CreateUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> userId{};

  CreateUserResponseBody() {}

  explicit CreateUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateUserResponseBody() = default;
};
class CreateUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserResponseBody> body{};

  CreateUserResponse() {}

  explicit CreateUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserResponse() = default;
};
class CreateUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupName{};

  CreateUserGroupRequest() {}

  explicit CreateUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupName) {
      res["UserGroupName"] = boost::any(*userGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupName") != m.end() && !m["UserGroupName"].empty()) {
      userGroupName = make_shared<string>(boost::any_cast<string>(m["UserGroupName"]));
    }
  }


  virtual ~CreateUserGroupRequest() = default;
};
class CreateUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> userGroupId{};

  CreateUserGroupResponseBody() {}

  explicit CreateUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~CreateUserGroupResponseBody() = default;
};
class CreateUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserGroupResponseBody> body{};

  CreateUserGroupResponse() {}

  explicit CreateUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserGroupResponse() = default;
};
class CreateUserPublicKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> publicKeyName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  CreateUserPublicKeyRequest() {}

  explicit CreateUserPublicKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (publicKeyName) {
      res["PublicKeyName"] = boost::any(*publicKeyName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("PublicKeyName") != m.end() && !m["PublicKeyName"].empty()) {
      publicKeyName = make_shared<string>(boost::any_cast<string>(m["PublicKeyName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateUserPublicKeyRequest() = default;
};
class CreateUserPublicKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> publicKeyId{};
  shared_ptr<string> requestId{};

  CreateUserPublicKeyResponseBody() {}

  explicit CreateUserPublicKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateUserPublicKeyResponseBody() = default;
};
class CreateUserPublicKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserPublicKeyResponseBody> body{};

  CreateUserPublicKeyResponse() {}

  explicit CreateUserPublicKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserPublicKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserPublicKeyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserPublicKeyResponse() = default;
};
class DeleteDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DeleteDatabaseRequest() {}

  explicit DeleteDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDatabaseRequest() = default;
};
class DeleteDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDatabaseResponseBody() {}

  explicit DeleteDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDatabaseResponseBody() = default;
};
class DeleteDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDatabaseResponseBody> body{};

  DeleteDatabaseResponse() {}

  explicit DeleteDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDatabaseResponse() = default;
};
class DeleteDatabaseAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DeleteDatabaseAccountRequest() {}

  explicit DeleteDatabaseAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDatabaseAccountRequest() = default;
};
class DeleteDatabaseAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDatabaseAccountResponseBody() {}

  explicit DeleteDatabaseAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDatabaseAccountResponseBody() = default;
};
class DeleteDatabaseAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDatabaseAccountResponseBody> body{};

  DeleteDatabaseAccountResponse() {}

  explicit DeleteDatabaseAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDatabaseAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDatabaseAccountResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDatabaseAccountResponse() = default;
};
class DeleteHostRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DeleteHostRequest() {}

  explicit DeleteHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteHostRequest() = default;
};
class DeleteHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteHostResponseBody() {}

  explicit DeleteHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteHostResponseBody() = default;
};
class DeleteHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHostResponseBody> body{};

  DeleteHostResponse() {}

  explicit DeleteHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHostResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHostResponse() = default;
};
class DeleteHostAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DeleteHostAccountRequest() {}

  explicit DeleteHostAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteHostAccountRequest() = default;
};
class DeleteHostAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteHostAccountResponseBody() {}

  explicit DeleteHostAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteHostAccountResponseBody() = default;
};
class DeleteHostAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHostAccountResponseBody> body{};

  DeleteHostAccountResponse() {}

  explicit DeleteHostAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHostAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHostAccountResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHostAccountResponse() = default;
};
class DeleteHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DeleteHostGroupRequest() {}

  explicit DeleteHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteHostGroupRequest() = default;
};
class DeleteHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteHostGroupResponseBody() {}

  explicit DeleteHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteHostGroupResponseBody() = default;
};
class DeleteHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHostGroupResponseBody> body{};

  DeleteHostGroupResponse() {}

  explicit DeleteHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHostGroupResponse() = default;
};
class DeleteHostShareKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DeleteHostShareKeyRequest() {}

  explicit DeleteHostShareKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteHostShareKeyRequest() = default;
};
class DeleteHostShareKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteHostShareKeyResponseBody() {}

  explicit DeleteHostShareKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteHostShareKeyResponseBody() = default;
};
class DeleteHostShareKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHostShareKeyResponseBody> body{};

  DeleteHostShareKeyResponse() {}

  explicit DeleteHostShareKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHostShareKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHostShareKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHostShareKeyResponse() = default;
};
class DeleteNetworkDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> regionId{};

  DeleteNetworkDomainRequest() {}

  explicit DeleteNetworkDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteNetworkDomainRequest() = default;
};
class DeleteNetworkDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkDomainResponseBody() {}

  explicit DeleteNetworkDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkDomainResponseBody() = default;
};
class DeleteNetworkDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkDomainResponseBody> body{};

  DeleteNetworkDomainResponse() {}

  explicit DeleteNetworkDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkDomainResponse() = default;
};
class DeletePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  DeletePolicyRequest() {}

  explicit DeletePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeletePolicyRequest() = default;
};
class DeletePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePolicyResponseBody() {}

  explicit DeletePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePolicyResponseBody() = default;
};
class DeletePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePolicyResponseBody> body{};

  DeletePolicyResponse() {}

  explicit DeletePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePolicyResponse() = default;
};
class DeleteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};

  DeleteRuleRequest() {}

  explicit DeleteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DeleteRuleRequest() = default;
};
class DeleteRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRuleResponseBody() {}

  explicit DeleteRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRuleResponseBody() = default;
};
class DeleteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRuleResponseBody> body{};

  DeleteRuleResponse() {}

  explicit DeleteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRuleResponse() = default;
};
class DeleteUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  DeleteUserRequest() {}

  explicit DeleteUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DeleteUserRequest() = default;
};
class DeleteUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUserResponseBody() {}

  explicit DeleteUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUserResponseBody() = default;
};
class DeleteUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserResponseBody> body{};

  DeleteUserResponse() {}

  explicit DeleteUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserResponse() = default;
};
class DeleteUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  DeleteUserGroupRequest() {}

  explicit DeleteUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DeleteUserGroupRequest() = default;
};
class DeleteUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUserGroupResponseBody() {}

  explicit DeleteUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUserGroupResponseBody() = default;
};
class DeleteUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserGroupResponseBody> body{};

  DeleteUserGroupResponse() {}

  explicit DeleteUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserGroupResponse() = default;
};
class DeleteUserPublicKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> publicKeyId{};
  shared_ptr<string> regionId{};

  DeleteUserPublicKeyRequest() {}

  explicit DeleteUserPublicKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteUserPublicKeyRequest() = default;
};
class DeleteUserPublicKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUserPublicKeyResponseBody() {}

  explicit DeleteUserPublicKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUserPublicKeyResponseBody() = default;
};
class DeleteUserPublicKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserPublicKeyResponseBody> body{};

  DeleteUserPublicKeyResponse() {}

  explicit DeleteUserPublicKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserPublicKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserPublicKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserPublicKeyResponse() = default;
};
class DescribeInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DescribeInstanceAttributeRequest() {}

  explicit DescribeInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeInstanceAttributeRequest() = default;
};
class DescribeInstanceAttributeResponseBodyInstanceAttributePorts : public Darabonba::Model {
public:
  shared_ptr<long> customPort{};
  shared_ptr<long> standardPort{};

  DescribeInstanceAttributeResponseBodyInstanceAttributePorts() {}

  explicit DescribeInstanceAttributeResponseBodyInstanceAttributePorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customPort) {
      res["CustomPort"] = boost::any(*customPort);
    }
    if (standardPort) {
      res["StandardPort"] = boost::any(*standardPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomPort") != m.end() && !m["CustomPort"].empty()) {
      customPort = make_shared<long>(boost::any_cast<long>(m["CustomPort"]));
    }
    if (m.find("StandardPort") != m.end() && !m["StandardPort"].empty()) {
      standardPort = make_shared<long>(boost::any_cast<long>(m["StandardPort"]));
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodyInstanceAttributePorts() = default;
};
class DescribeInstanceAttributeResponseBodyInstanceAttributeWhiteListPolicies : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> entry{};

  DescribeInstanceAttributeResponseBodyInstanceAttributeWhiteListPolicies() {}

  explicit DescribeInstanceAttributeResponseBodyInstanceAttributeWhiteListPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (entry) {
      res["Entry"] = boost::any(*entry);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Entry") != m.end() && !m["Entry"].empty()) {
      entry = make_shared<string>(boost::any_cast<string>(m["Entry"]));
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodyInstanceAttributeWhiteListPolicies() = default;
};
class DescribeInstanceAttributeResponseBodyInstanceAttribute : public Darabonba::Model {
public:
  shared_ptr<string> appOperationModule{};
  shared_ptr<vector<string>> authorizedSecurityGroups{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> bandwidthPackage{};
  shared_ptr<string> dbOperationModule{};
  shared_ptr<string> description{};
  shared_ptr<string> eniInstanceId{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> HSMModule{};
  shared_ptr<string> IDaaSModule{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<string> internetEndpoint{};
  shared_ptr<string> intranetEndpoint{};
  shared_ptr<string> kmsSecretModule{};
  shared_ptr<string> licenseCode{};
  shared_ptr<string> modifyPasswordModule{};
  shared_ptr<string> networkProxyModule{};
  shared_ptr<vector<DescribeInstanceAttributeResponseBodyInstanceAttributePorts>> ports{};
  shared_ptr<vector<string>> privateExportIps{};
  shared_ptr<vector<string>> privateWhiteList{};
  shared_ptr<vector<string>> publicExportIps{};
  shared_ptr<vector<string>> publicIps{};
  shared_ptr<bool> publicNetworkAccess{};
  shared_ptr<vector<string>> publicWhiteList{};
  shared_ptr<string> RDModule{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> routerRules{};
  shared_ptr<string> scriptDeliverModule{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> slaveVswitchId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> storage{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};
  shared_ptr<string> webTerminalModule{};
  shared_ptr<vector<DescribeInstanceAttributeResponseBodyInstanceAttributeWhiteListPolicies>> whiteListPolicies{};

  DescribeInstanceAttributeResponseBodyInstanceAttribute() {}

  explicit DescribeInstanceAttributeResponseBodyInstanceAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appOperationModule) {
      res["AppOperationModule"] = boost::any(*appOperationModule);
    }
    if (authorizedSecurityGroups) {
      res["AuthorizedSecurityGroups"] = boost::any(*authorizedSecurityGroups);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthPackage) {
      res["BandwidthPackage"] = boost::any(*bandwidthPackage);
    }
    if (dbOperationModule) {
      res["DbOperationModule"] = boost::any(*dbOperationModule);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eniInstanceId) {
      res["EniInstanceId"] = boost::any(*eniInstanceId);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (HSMModule) {
      res["HSMModule"] = boost::any(*HSMModule);
    }
    if (IDaaSModule) {
      res["IDaaSModule"] = boost::any(*IDaaSModule);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (internetEndpoint) {
      res["InternetEndpoint"] = boost::any(*internetEndpoint);
    }
    if (intranetEndpoint) {
      res["IntranetEndpoint"] = boost::any(*intranetEndpoint);
    }
    if (kmsSecretModule) {
      res["KmsSecretModule"] = boost::any(*kmsSecretModule);
    }
    if (licenseCode) {
      res["LicenseCode"] = boost::any(*licenseCode);
    }
    if (modifyPasswordModule) {
      res["ModifyPasswordModule"] = boost::any(*modifyPasswordModule);
    }
    if (networkProxyModule) {
      res["NetworkProxyModule"] = boost::any(*networkProxyModule);
    }
    if (ports) {
      vector<boost::any> temp1;
      for(auto item1:*ports){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ports"] = boost::any(temp1);
    }
    if (privateExportIps) {
      res["PrivateExportIps"] = boost::any(*privateExportIps);
    }
    if (privateWhiteList) {
      res["PrivateWhiteList"] = boost::any(*privateWhiteList);
    }
    if (publicExportIps) {
      res["PublicExportIps"] = boost::any(*publicExportIps);
    }
    if (publicIps) {
      res["PublicIps"] = boost::any(*publicIps);
    }
    if (publicNetworkAccess) {
      res["PublicNetworkAccess"] = boost::any(*publicNetworkAccess);
    }
    if (publicWhiteList) {
      res["PublicWhiteList"] = boost::any(*publicWhiteList);
    }
    if (RDModule) {
      res["RDModule"] = boost::any(*RDModule);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (routerRules) {
      res["RouterRules"] = boost::any(*routerRules);
    }
    if (scriptDeliverModule) {
      res["ScriptDeliverModule"] = boost::any(*scriptDeliverModule);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (slaveVswitchId) {
      res["SlaveVswitchId"] = boost::any(*slaveVswitchId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (storage) {
      res["Storage"] = boost::any(*storage);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (webTerminalModule) {
      res["WebTerminalModule"] = boost::any(*webTerminalModule);
    }
    if (whiteListPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*whiteListPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WhiteListPolicies"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppOperationModule") != m.end() && !m["AppOperationModule"].empty()) {
      appOperationModule = make_shared<string>(boost::any_cast<string>(m["AppOperationModule"]));
    }
    if (m.find("AuthorizedSecurityGroups") != m.end() && !m["AuthorizedSecurityGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AuthorizedSecurityGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AuthorizedSecurityGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      authorizedSecurityGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("BandwidthPackage") != m.end() && !m["BandwidthPackage"].empty()) {
      bandwidthPackage = make_shared<string>(boost::any_cast<string>(m["BandwidthPackage"]));
    }
    if (m.find("DbOperationModule") != m.end() && !m["DbOperationModule"].empty()) {
      dbOperationModule = make_shared<string>(boost::any_cast<string>(m["DbOperationModule"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EniInstanceId") != m.end() && !m["EniInstanceId"].empty()) {
      eniInstanceId = make_shared<string>(boost::any_cast<string>(m["EniInstanceId"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("HSMModule") != m.end() && !m["HSMModule"].empty()) {
      HSMModule = make_shared<string>(boost::any_cast<string>(m["HSMModule"]));
    }
    if (m.find("IDaaSModule") != m.end() && !m["IDaaSModule"].empty()) {
      IDaaSModule = make_shared<string>(boost::any_cast<string>(m["IDaaSModule"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("InternetEndpoint") != m.end() && !m["InternetEndpoint"].empty()) {
      internetEndpoint = make_shared<string>(boost::any_cast<string>(m["InternetEndpoint"]));
    }
    if (m.find("IntranetEndpoint") != m.end() && !m["IntranetEndpoint"].empty()) {
      intranetEndpoint = make_shared<string>(boost::any_cast<string>(m["IntranetEndpoint"]));
    }
    if (m.find("KmsSecretModule") != m.end() && !m["KmsSecretModule"].empty()) {
      kmsSecretModule = make_shared<string>(boost::any_cast<string>(m["KmsSecretModule"]));
    }
    if (m.find("LicenseCode") != m.end() && !m["LicenseCode"].empty()) {
      licenseCode = make_shared<string>(boost::any_cast<string>(m["LicenseCode"]));
    }
    if (m.find("ModifyPasswordModule") != m.end() && !m["ModifyPasswordModule"].empty()) {
      modifyPasswordModule = make_shared<string>(boost::any_cast<string>(m["ModifyPasswordModule"]));
    }
    if (m.find("NetworkProxyModule") != m.end() && !m["NetworkProxyModule"].empty()) {
      networkProxyModule = make_shared<string>(boost::any_cast<string>(m["NetworkProxyModule"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<DescribeInstanceAttributeResponseBodyInstanceAttributePorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ports"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceAttributeResponseBodyInstanceAttributePorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ports = make_shared<vector<DescribeInstanceAttributeResponseBodyInstanceAttributePorts>>(expect1);
      }
    }
    if (m.find("PrivateExportIps") != m.end() && !m["PrivateExportIps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrivateExportIps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrivateExportIps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateExportIps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PrivateWhiteList") != m.end() && !m["PrivateWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrivateWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrivateWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateWhiteList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PublicExportIps") != m.end() && !m["PublicExportIps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PublicExportIps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PublicExportIps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      publicExportIps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PublicIps") != m.end() && !m["PublicIps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PublicIps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PublicIps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      publicIps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PublicNetworkAccess") != m.end() && !m["PublicNetworkAccess"].empty()) {
      publicNetworkAccess = make_shared<bool>(boost::any_cast<bool>(m["PublicNetworkAccess"]));
    }
    if (m.find("PublicWhiteList") != m.end() && !m["PublicWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PublicWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PublicWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      publicWhiteList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RDModule") != m.end() && !m["RDModule"].empty()) {
      RDModule = make_shared<string>(boost::any_cast<string>(m["RDModule"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RouterRules") != m.end() && !m["RouterRules"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RouterRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouterRules"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routerRules = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScriptDeliverModule") != m.end() && !m["ScriptDeliverModule"].empty()) {
      scriptDeliverModule = make_shared<string>(boost::any_cast<string>(m["ScriptDeliverModule"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SlaveVswitchId") != m.end() && !m["SlaveVswitchId"].empty()) {
      slaveVswitchId = make_shared<string>(boost::any_cast<string>(m["SlaveVswitchId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      storage = make_shared<long>(boost::any_cast<long>(m["Storage"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
    if (m.find("WebTerminalModule") != m.end() && !m["WebTerminalModule"].empty()) {
      webTerminalModule = make_shared<string>(boost::any_cast<string>(m["WebTerminalModule"]));
    }
    if (m.find("WhiteListPolicies") != m.end() && !m["WhiteListPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["WhiteListPolicies"].type()) {
        vector<DescribeInstanceAttributeResponseBodyInstanceAttributeWhiteListPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WhiteListPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceAttributeResponseBodyInstanceAttributeWhiteListPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whiteListPolicies = make_shared<vector<DescribeInstanceAttributeResponseBodyInstanceAttributeWhiteListPolicies>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceAttributeResponseBodyInstanceAttribute() = default;
};
class DescribeInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceAttributeResponseBodyInstanceAttribute> instanceAttribute{};
  shared_ptr<string> requestId{};

  DescribeInstanceAttributeResponseBody() {}

  explicit DescribeInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceAttribute) {
      res["InstanceAttribute"] = instanceAttribute ? boost::any(instanceAttribute->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceAttribute") != m.end() && !m["InstanceAttribute"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceAttribute"].type()) {
        DescribeInstanceAttributeResponseBodyInstanceAttribute model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceAttribute"]));
        instanceAttribute = make_shared<DescribeInstanceAttributeResponseBodyInstanceAttribute>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceAttributeResponseBody() = default;
};
class DescribeInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceAttributeResponseBody> body{};

  DescribeInstanceAttributeResponse() {}

  explicit DescribeInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAttributeResponse() = default;
};
class DescribeInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeInstancesRequestTag() {}

  explicit DescribeInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeInstancesRequestTag() = default;
};
class DescribeInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceId{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<DescribeInstancesRequestTag>> tag{};

  DescribeInstancesRequest() {}

  explicit DescribeInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeInstancesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesRequest() = default;
};
class DescribeInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<long> bandWidth{};
  shared_ptr<string> description{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> imageVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<string> internetEndpoint{};
  shared_ptr<string> intranetEndpoint{};
  shared_ptr<bool> legacy{};
  shared_ptr<string> licenseCode{};
  shared_ptr<string> planCode{};
  shared_ptr<bool> publicNetworkAccess{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> slaveVswitchId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  DescribeInstancesResponseBodyInstances() {}

  explicit DescribeInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (imageVersion) {
      res["ImageVersion"] = boost::any(*imageVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (internetEndpoint) {
      res["InternetEndpoint"] = boost::any(*internetEndpoint);
    }
    if (intranetEndpoint) {
      res["IntranetEndpoint"] = boost::any(*intranetEndpoint);
    }
    if (legacy) {
      res["Legacy"] = boost::any(*legacy);
    }
    if (licenseCode) {
      res["LicenseCode"] = boost::any(*licenseCode);
    }
    if (planCode) {
      res["PlanCode"] = boost::any(*planCode);
    }
    if (publicNetworkAccess) {
      res["PublicNetworkAccess"] = boost::any(*publicNetworkAccess);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (slaveVswitchId) {
      res["SlaveVswitchId"] = boost::any(*slaveVswitchId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<long>(boost::any_cast<long>(m["BandWidth"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("ImageVersion") != m.end() && !m["ImageVersion"].empty()) {
      imageVersion = make_shared<string>(boost::any_cast<string>(m["ImageVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("InternetEndpoint") != m.end() && !m["InternetEndpoint"].empty()) {
      internetEndpoint = make_shared<string>(boost::any_cast<string>(m["InternetEndpoint"]));
    }
    if (m.find("IntranetEndpoint") != m.end() && !m["IntranetEndpoint"].empty()) {
      intranetEndpoint = make_shared<string>(boost::any_cast<string>(m["IntranetEndpoint"]));
    }
    if (m.find("Legacy") != m.end() && !m["Legacy"].empty()) {
      legacy = make_shared<bool>(boost::any_cast<bool>(m["Legacy"]));
    }
    if (m.find("LicenseCode") != m.end() && !m["LicenseCode"].empty()) {
      licenseCode = make_shared<string>(boost::any_cast<string>(m["LicenseCode"]));
    }
    if (m.find("PlanCode") != m.end() && !m["PlanCode"].empty()) {
      planCode = make_shared<string>(boost::any_cast<string>(m["PlanCode"]));
    }
    if (m.find("PublicNetworkAccess") != m.end() && !m["PublicNetworkAccess"].empty()) {
      publicNetworkAccess = make_shared<bool>(boost::any_cast<bool>(m["PublicNetworkAccess"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SlaveVswitchId") != m.end() && !m["SlaveVswitchId"].empty()) {
      slaveVswitchId = make_shared<string>(boost::any_cast<string>(m["SlaveVswitchId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstances() = default;
};
class DescribeInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstances>> instances{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstancesResponseBody() {}

  explicit DescribeInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<DescribeInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<DescribeInstancesResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstancesResponseBody() = default;
};
class DescribeInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstancesResponseBody> body{};

  DescribeInstancesResponse() {}

  explicit DescribeInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> regionId{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<DescribeRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<DescribeRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DetachDatabaseAccountsFromUserRequestDatabases : public Darabonba::Model {
public:
  shared_ptr<vector<string>> databaseAccountIds{};
  shared_ptr<string> databaseId{};

  DetachDatabaseAccountsFromUserRequestDatabases() {}

  explicit DetachDatabaseAccountsFromUserRequestDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountIds) {
      res["DatabaseAccountIds"] = boost::any(*databaseAccountIds);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountIds") != m.end() && !m["DatabaseAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
  }


  virtual ~DetachDatabaseAccountsFromUserRequestDatabases() = default;
};
class DetachDatabaseAccountsFromUserRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DetachDatabaseAccountsFromUserRequestDatabases>> databases{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  DetachDatabaseAccountsFromUserRequest() {}

  explicit DetachDatabaseAccountsFromUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<DetachDatabaseAccountsFromUserRequestDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachDatabaseAccountsFromUserRequestDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<DetachDatabaseAccountsFromUserRequestDatabases>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DetachDatabaseAccountsFromUserRequest() = default;
};
class DetachDatabaseAccountsFromUserResponseBodyResultsDatabaseAccounts : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> message{};

  DetachDatabaseAccountsFromUserResponseBodyResultsDatabaseAccounts() {}

  explicit DetachDatabaseAccountsFromUserResponseBodyResultsDatabaseAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DetachDatabaseAccountsFromUserResponseBodyResultsDatabaseAccounts() = default;
};
class DetachDatabaseAccountsFromUserResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DetachDatabaseAccountsFromUserResponseBodyResultsDatabaseAccounts>> databaseAccounts{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> message{};
  shared_ptr<string> userId{};

  DetachDatabaseAccountsFromUserResponseBodyResults() {}

  explicit DetachDatabaseAccountsFromUserResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (databaseAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*databaseAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseAccounts"] = boost::any(temp1);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatabaseAccounts") != m.end() && !m["DatabaseAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseAccounts"].type()) {
        vector<DetachDatabaseAccountsFromUserResponseBodyResultsDatabaseAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachDatabaseAccountsFromUserResponseBodyResultsDatabaseAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseAccounts = make_shared<vector<DetachDatabaseAccountsFromUserResponseBodyResultsDatabaseAccounts>>(expect1);
      }
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DetachDatabaseAccountsFromUserResponseBodyResults() = default;
};
class DetachDatabaseAccountsFromUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DetachDatabaseAccountsFromUserResponseBodyResults>> results{};

  DetachDatabaseAccountsFromUserResponseBody() {}

  explicit DetachDatabaseAccountsFromUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<DetachDatabaseAccountsFromUserResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachDatabaseAccountsFromUserResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<DetachDatabaseAccountsFromUserResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~DetachDatabaseAccountsFromUserResponseBody() = default;
};
class DetachDatabaseAccountsFromUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachDatabaseAccountsFromUserResponseBody> body{};

  DetachDatabaseAccountsFromUserResponse() {}

  explicit DetachDatabaseAccountsFromUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachDatabaseAccountsFromUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachDatabaseAccountsFromUserResponseBody>(model1);
      }
    }
  }


  virtual ~DetachDatabaseAccountsFromUserResponse() = default;
};
class DetachDatabaseAccountsFromUserGroupRequestDatabases : public Darabonba::Model {
public:
  shared_ptr<vector<string>> databaseAccountIds{};
  shared_ptr<string> databaseId{};

  DetachDatabaseAccountsFromUserGroupRequestDatabases() {}

  explicit DetachDatabaseAccountsFromUserGroupRequestDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountIds) {
      res["DatabaseAccountIds"] = boost::any(*databaseAccountIds);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountIds") != m.end() && !m["DatabaseAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
  }


  virtual ~DetachDatabaseAccountsFromUserGroupRequestDatabases() = default;
};
class DetachDatabaseAccountsFromUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DetachDatabaseAccountsFromUserGroupRequestDatabases>> databases{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  DetachDatabaseAccountsFromUserGroupRequest() {}

  explicit DetachDatabaseAccountsFromUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<DetachDatabaseAccountsFromUserGroupRequestDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachDatabaseAccountsFromUserGroupRequestDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<DetachDatabaseAccountsFromUserGroupRequestDatabases>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DetachDatabaseAccountsFromUserGroupRequest() = default;
};
class DetachDatabaseAccountsFromUserGroupResponseBodyResultsDatabaseAccounts : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> message{};

  DetachDatabaseAccountsFromUserGroupResponseBodyResultsDatabaseAccounts() {}

  explicit DetachDatabaseAccountsFromUserGroupResponseBodyResultsDatabaseAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DetachDatabaseAccountsFromUserGroupResponseBodyResultsDatabaseAccounts() = default;
};
class DetachDatabaseAccountsFromUserGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DetachDatabaseAccountsFromUserGroupResponseBodyResultsDatabaseAccounts>> databaseAccounts{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> message{};
  shared_ptr<string> userGroupId{};

  DetachDatabaseAccountsFromUserGroupResponseBodyResults() {}

  explicit DetachDatabaseAccountsFromUserGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (databaseAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*databaseAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseAccounts"] = boost::any(temp1);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatabaseAccounts") != m.end() && !m["DatabaseAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseAccounts"].type()) {
        vector<DetachDatabaseAccountsFromUserGroupResponseBodyResultsDatabaseAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachDatabaseAccountsFromUserGroupResponseBodyResultsDatabaseAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseAccounts = make_shared<vector<DetachDatabaseAccountsFromUserGroupResponseBodyResultsDatabaseAccounts>>(expect1);
      }
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DetachDatabaseAccountsFromUserGroupResponseBodyResults() = default;
};
class DetachDatabaseAccountsFromUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DetachDatabaseAccountsFromUserGroupResponseBodyResults>> results{};

  DetachDatabaseAccountsFromUserGroupResponseBody() {}

  explicit DetachDatabaseAccountsFromUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<DetachDatabaseAccountsFromUserGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachDatabaseAccountsFromUserGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<DetachDatabaseAccountsFromUserGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~DetachDatabaseAccountsFromUserGroupResponseBody() = default;
};
class DetachDatabaseAccountsFromUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachDatabaseAccountsFromUserGroupResponseBody> body{};

  DetachDatabaseAccountsFromUserGroupResponse() {}

  explicit DetachDatabaseAccountsFromUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachDatabaseAccountsFromUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachDatabaseAccountsFromUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DetachDatabaseAccountsFromUserGroupResponse() = default;
};
class DetachHostAccountsFromHostShareKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountIds{};
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DetachHostAccountsFromHostShareKeyRequest() {}

  explicit DetachHostAccountsFromHostShareKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountIds) {
      res["HostAccountIds"] = boost::any(*hostAccountIds);
    }
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountIds") != m.end() && !m["HostAccountIds"].empty()) {
      hostAccountIds = make_shared<string>(boost::any_cast<string>(m["HostAccountIds"]));
    }
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DetachHostAccountsFromHostShareKeyRequest() = default;
};
class DetachHostAccountsFromHostShareKeyResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> message{};

  DetachHostAccountsFromHostShareKeyResponseBodyResults() {}

  explicit DetachHostAccountsFromHostShareKeyResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DetachHostAccountsFromHostShareKeyResponseBodyResults() = default;
};
class DetachHostAccountsFromHostShareKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DetachHostAccountsFromHostShareKeyResponseBodyResults>> results{};

  DetachHostAccountsFromHostShareKeyResponseBody() {}

  explicit DetachHostAccountsFromHostShareKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<DetachHostAccountsFromHostShareKeyResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachHostAccountsFromHostShareKeyResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<DetachHostAccountsFromHostShareKeyResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~DetachHostAccountsFromHostShareKeyResponseBody() = default;
};
class DetachHostAccountsFromHostShareKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachHostAccountsFromHostShareKeyResponseBody> body{};

  DetachHostAccountsFromHostShareKeyResponse() {}

  explicit DetachHostAccountsFromHostShareKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachHostAccountsFromHostShareKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachHostAccountsFromHostShareKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DetachHostAccountsFromHostShareKeyResponse() = default;
};
class DetachHostAccountsFromUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  DetachHostAccountsFromUserRequest() {}

  explicit DetachHostAccountsFromUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      res["Hosts"] = boost::any(*hosts);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      hosts = make_shared<string>(boost::any_cast<string>(m["Hosts"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DetachHostAccountsFromUserRequest() = default;
};
class DetachHostAccountsFromUserResponseBodyResultsHostAccounts : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> message{};

  DetachHostAccountsFromUserResponseBodyResultsHostAccounts() {}

  explicit DetachHostAccountsFromUserResponseBodyResultsHostAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DetachHostAccountsFromUserResponseBodyResultsHostAccounts() = default;
};
class DetachHostAccountsFromUserResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DetachHostAccountsFromUserResponseBodyResultsHostAccounts>> hostAccounts{};
  shared_ptr<string> hostId{};
  shared_ptr<string> message{};
  shared_ptr<string> userId{};

  DetachHostAccountsFromUserResponseBodyResults() {}

  explicit DetachHostAccountsFromUserResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccounts"] = boost::any(temp1);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccounts") != m.end() && !m["HostAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccounts"].type()) {
        vector<DetachHostAccountsFromUserResponseBodyResultsHostAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachHostAccountsFromUserResponseBodyResultsHostAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccounts = make_shared<vector<DetachHostAccountsFromUserResponseBodyResultsHostAccounts>>(expect1);
      }
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DetachHostAccountsFromUserResponseBodyResults() = default;
};
class DetachHostAccountsFromUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DetachHostAccountsFromUserResponseBodyResults>> results{};

  DetachHostAccountsFromUserResponseBody() {}

  explicit DetachHostAccountsFromUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<DetachHostAccountsFromUserResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachHostAccountsFromUserResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<DetachHostAccountsFromUserResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~DetachHostAccountsFromUserResponseBody() = default;
};
class DetachHostAccountsFromUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachHostAccountsFromUserResponseBody> body{};

  DetachHostAccountsFromUserResponse() {}

  explicit DetachHostAccountsFromUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachHostAccountsFromUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachHostAccountsFromUserResponseBody>(model1);
      }
    }
  }


  virtual ~DetachHostAccountsFromUserResponse() = default;
};
class DetachHostAccountsFromUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  DetachHostAccountsFromUserGroupRequest() {}

  explicit DetachHostAccountsFromUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      res["Hosts"] = boost::any(*hosts);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      hosts = make_shared<string>(boost::any_cast<string>(m["Hosts"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DetachHostAccountsFromUserGroupRequest() = default;
};
class DetachHostAccountsFromUserGroupResponseBodyResultsHostAccounts : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> message{};

  DetachHostAccountsFromUserGroupResponseBodyResultsHostAccounts() {}

  explicit DetachHostAccountsFromUserGroupResponseBodyResultsHostAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DetachHostAccountsFromUserGroupResponseBodyResultsHostAccounts() = default;
};
class DetachHostAccountsFromUserGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DetachHostAccountsFromUserGroupResponseBodyResultsHostAccounts>> hostAccounts{};
  shared_ptr<string> hostId{};
  shared_ptr<string> message{};
  shared_ptr<string> userGroupId{};

  DetachHostAccountsFromUserGroupResponseBodyResults() {}

  explicit DetachHostAccountsFromUserGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccounts"] = boost::any(temp1);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccounts") != m.end() && !m["HostAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccounts"].type()) {
        vector<DetachHostAccountsFromUserGroupResponseBodyResultsHostAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachHostAccountsFromUserGroupResponseBodyResultsHostAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccounts = make_shared<vector<DetachHostAccountsFromUserGroupResponseBodyResultsHostAccounts>>(expect1);
      }
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DetachHostAccountsFromUserGroupResponseBodyResults() = default;
};
class DetachHostAccountsFromUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DetachHostAccountsFromUserGroupResponseBodyResults>> results{};

  DetachHostAccountsFromUserGroupResponseBody() {}

  explicit DetachHostAccountsFromUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<DetachHostAccountsFromUserGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachHostAccountsFromUserGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<DetachHostAccountsFromUserGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~DetachHostAccountsFromUserGroupResponseBody() = default;
};
class DetachHostAccountsFromUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachHostAccountsFromUserGroupResponseBody> body{};

  DetachHostAccountsFromUserGroupResponse() {}

  explicit DetachHostAccountsFromUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachHostAccountsFromUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachHostAccountsFromUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DetachHostAccountsFromUserGroupResponse() = default;
};
class DetachHostGroupAccountsFromUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroups{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  DetachHostGroupAccountsFromUserRequest() {}

  explicit DetachHostGroupAccountsFromUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroups) {
      res["HostGroups"] = boost::any(*hostGroups);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      hostGroups = make_shared<string>(boost::any_cast<string>(m["HostGroups"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DetachHostGroupAccountsFromUserRequest() = default;
};
class DetachHostGroupAccountsFromUserResponseBodyResultsHostAccountNames : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> message{};

  DetachHostGroupAccountsFromUserResponseBodyResultsHostAccountNames() {}

  explicit DetachHostGroupAccountsFromUserResponseBodyResultsHostAccountNames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DetachHostGroupAccountsFromUserResponseBodyResultsHostAccountNames() = default;
};
class DetachHostGroupAccountsFromUserResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DetachHostGroupAccountsFromUserResponseBodyResultsHostAccountNames>> hostAccountNames{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> message{};
  shared_ptr<string> userId{};

  DetachHostGroupAccountsFromUserResponseBodyResults() {}

  explicit DetachHostGroupAccountsFromUserResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountNames) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccountNames){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccountNames"] = boost::any(temp1);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountNames") != m.end() && !m["HostAccountNames"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccountNames"].type()) {
        vector<DetachHostGroupAccountsFromUserResponseBodyResultsHostAccountNames> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccountNames"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachHostGroupAccountsFromUserResponseBodyResultsHostAccountNames model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccountNames = make_shared<vector<DetachHostGroupAccountsFromUserResponseBodyResultsHostAccountNames>>(expect1);
      }
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DetachHostGroupAccountsFromUserResponseBodyResults() = default;
};
class DetachHostGroupAccountsFromUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DetachHostGroupAccountsFromUserResponseBodyResults>> results{};

  DetachHostGroupAccountsFromUserResponseBody() {}

  explicit DetachHostGroupAccountsFromUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<DetachHostGroupAccountsFromUserResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachHostGroupAccountsFromUserResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<DetachHostGroupAccountsFromUserResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~DetachHostGroupAccountsFromUserResponseBody() = default;
};
class DetachHostGroupAccountsFromUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachHostGroupAccountsFromUserResponseBody> body{};

  DetachHostGroupAccountsFromUserResponse() {}

  explicit DetachHostGroupAccountsFromUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachHostGroupAccountsFromUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachHostGroupAccountsFromUserResponseBody>(model1);
      }
    }
  }


  virtual ~DetachHostGroupAccountsFromUserResponse() = default;
};
class DetachHostGroupAccountsFromUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroups{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  DetachHostGroupAccountsFromUserGroupRequest() {}

  explicit DetachHostGroupAccountsFromUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroups) {
      res["HostGroups"] = boost::any(*hostGroups);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      hostGroups = make_shared<string>(boost::any_cast<string>(m["HostGroups"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DetachHostGroupAccountsFromUserGroupRequest() = default;
};
class DetachHostGroupAccountsFromUserGroupResponseBodyResultsHostAccountNames : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> message{};

  DetachHostGroupAccountsFromUserGroupResponseBodyResultsHostAccountNames() {}

  explicit DetachHostGroupAccountsFromUserGroupResponseBodyResultsHostAccountNames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DetachHostGroupAccountsFromUserGroupResponseBodyResultsHostAccountNames() = default;
};
class DetachHostGroupAccountsFromUserGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DetachHostGroupAccountsFromUserGroupResponseBodyResultsHostAccountNames>> hostAccountNames{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> message{};
  shared_ptr<string> userGroupId{};

  DetachHostGroupAccountsFromUserGroupResponseBodyResults() {}

  explicit DetachHostGroupAccountsFromUserGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostAccountNames) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccountNames){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccountNames"] = boost::any(temp1);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostAccountNames") != m.end() && !m["HostAccountNames"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccountNames"].type()) {
        vector<DetachHostGroupAccountsFromUserGroupResponseBodyResultsHostAccountNames> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccountNames"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachHostGroupAccountsFromUserGroupResponseBodyResultsHostAccountNames model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccountNames = make_shared<vector<DetachHostGroupAccountsFromUserGroupResponseBodyResultsHostAccountNames>>(expect1);
      }
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DetachHostGroupAccountsFromUserGroupResponseBodyResults() = default;
};
class DetachHostGroupAccountsFromUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DetachHostGroupAccountsFromUserGroupResponseBodyResults>> results{};

  DetachHostGroupAccountsFromUserGroupResponseBody() {}

  explicit DetachHostGroupAccountsFromUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<DetachHostGroupAccountsFromUserGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachHostGroupAccountsFromUserGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<DetachHostGroupAccountsFromUserGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~DetachHostGroupAccountsFromUserGroupResponseBody() = default;
};
class DetachHostGroupAccountsFromUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachHostGroupAccountsFromUserGroupResponseBody> body{};

  DetachHostGroupAccountsFromUserGroupResponse() {}

  explicit DetachHostGroupAccountsFromUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachHostGroupAccountsFromUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachHostGroupAccountsFromUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DetachHostGroupAccountsFromUserGroupResponse() = default;
};
class DisableInstancePublicAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DisableInstancePublicAccessRequest() {}

  explicit DisableInstancePublicAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DisableInstancePublicAccessRequest() = default;
};
class DisableInstancePublicAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  DisableInstancePublicAccessResponseBody() {}

  explicit DisableInstancePublicAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableInstancePublicAccessResponseBody() = default;
};
class DisableInstancePublicAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableInstancePublicAccessResponseBody> body{};

  DisableInstancePublicAccessResponse() {}

  explicit DisableInstancePublicAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableInstancePublicAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableInstancePublicAccessResponseBody>(model1);
      }
    }
  }


  virtual ~DisableInstancePublicAccessResponse() = default;
};
class DisableRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};

  DisableRuleRequest() {}

  explicit DisableRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DisableRuleRequest() = default;
};
class DisableRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableRuleResponseBody() {}

  explicit DisableRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableRuleResponseBody() = default;
};
class DisableRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableRuleResponseBody> body{};

  DisableRuleResponse() {}

  explicit DisableRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DisableRuleResponse() = default;
};
class EnableInstancePublicAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  EnableInstancePublicAccessRequest() {}

  explicit EnableInstancePublicAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~EnableInstancePublicAccessRequest() = default;
};
class EnableInstancePublicAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  EnableInstancePublicAccessResponseBody() {}

  explicit EnableInstancePublicAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableInstancePublicAccessResponseBody() = default;
};
class EnableInstancePublicAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableInstancePublicAccessResponseBody> body{};

  EnableInstancePublicAccessResponse() {}

  explicit EnableInstancePublicAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableInstancePublicAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableInstancePublicAccessResponseBody>(model1);
      }
    }
  }


  virtual ~EnableInstancePublicAccessResponse() = default;
};
class EnableRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};

  EnableRuleRequest() {}

  explicit EnableRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~EnableRuleRequest() = default;
};
class EnableRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableRuleResponseBody() {}

  explicit EnableRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableRuleResponseBody() = default;
};
class EnableRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableRuleResponseBody> body{};

  EnableRuleResponse() {}

  explicit EnableRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableRuleResponseBody>(model1);
      }
    }
  }


  virtual ~EnableRuleResponse() = default;
};
class GenerateAssetOperationTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> assetAccountId{};
  shared_ptr<string> assetAccountName{};
  shared_ptr<string> assetAccountPassword{};
  shared_ptr<string> assetAccountProtocolName{};
  shared_ptr<string> assetId{};
  shared_ptr<string> assetType{};
  shared_ptr<string> databaseSchema{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginAttribute{};
  shared_ptr<string> operationMode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ssoClient{};

  GenerateAssetOperationTokenRequest() {}

  explicit GenerateAssetOperationTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetAccountId) {
      res["AssetAccountId"] = boost::any(*assetAccountId);
    }
    if (assetAccountName) {
      res["AssetAccountName"] = boost::any(*assetAccountName);
    }
    if (assetAccountPassword) {
      res["AssetAccountPassword"] = boost::any(*assetAccountPassword);
    }
    if (assetAccountProtocolName) {
      res["AssetAccountProtocolName"] = boost::any(*assetAccountProtocolName);
    }
    if (assetId) {
      res["AssetId"] = boost::any(*assetId);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (databaseSchema) {
      res["DatabaseSchema"] = boost::any(*databaseSchema);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginAttribute) {
      res["LoginAttribute"] = boost::any(*loginAttribute);
    }
    if (operationMode) {
      res["OperationMode"] = boost::any(*operationMode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ssoClient) {
      res["SsoClient"] = boost::any(*ssoClient);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetAccountId") != m.end() && !m["AssetAccountId"].empty()) {
      assetAccountId = make_shared<string>(boost::any_cast<string>(m["AssetAccountId"]));
    }
    if (m.find("AssetAccountName") != m.end() && !m["AssetAccountName"].empty()) {
      assetAccountName = make_shared<string>(boost::any_cast<string>(m["AssetAccountName"]));
    }
    if (m.find("AssetAccountPassword") != m.end() && !m["AssetAccountPassword"].empty()) {
      assetAccountPassword = make_shared<string>(boost::any_cast<string>(m["AssetAccountPassword"]));
    }
    if (m.find("AssetAccountProtocolName") != m.end() && !m["AssetAccountProtocolName"].empty()) {
      assetAccountProtocolName = make_shared<string>(boost::any_cast<string>(m["AssetAccountProtocolName"]));
    }
    if (m.find("AssetId") != m.end() && !m["AssetId"].empty()) {
      assetId = make_shared<string>(boost::any_cast<string>(m["AssetId"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("DatabaseSchema") != m.end() && !m["DatabaseSchema"].empty()) {
      databaseSchema = make_shared<string>(boost::any_cast<string>(m["DatabaseSchema"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginAttribute") != m.end() && !m["LoginAttribute"].empty()) {
      loginAttribute = make_shared<string>(boost::any_cast<string>(m["LoginAttribute"]));
    }
    if (m.find("OperationMode") != m.end() && !m["OperationMode"].empty()) {
      operationMode = make_shared<string>(boost::any_cast<string>(m["OperationMode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SsoClient") != m.end() && !m["SsoClient"].empty()) {
      ssoClient = make_shared<string>(boost::any_cast<string>(m["SsoClient"]));
    }
  }


  virtual ~GenerateAssetOperationTokenRequest() = default;
};
class GenerateAssetOperationTokenResponseBodyAssetOperationToken : public Darabonba::Model {
public:
  shared_ptr<long> countLeft{};
  shared_ptr<long> expireTime{};
  shared_ptr<bool> hasCountLimit{};
  shared_ptr<long> maxRenewCount{};
  shared_ptr<long> renewCount{};
  shared_ptr<string> ssoUrl{};
  shared_ptr<string> token{};
  shared_ptr<string> tokenId{};

  GenerateAssetOperationTokenResponseBodyAssetOperationToken() {}

  explicit GenerateAssetOperationTokenResponseBodyAssetOperationToken(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (countLeft) {
      res["CountLeft"] = boost::any(*countLeft);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (hasCountLimit) {
      res["HasCountLimit"] = boost::any(*hasCountLimit);
    }
    if (maxRenewCount) {
      res["MaxRenewCount"] = boost::any(*maxRenewCount);
    }
    if (renewCount) {
      res["RenewCount"] = boost::any(*renewCount);
    }
    if (ssoUrl) {
      res["SsoUrl"] = boost::any(*ssoUrl);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (tokenId) {
      res["TokenId"] = boost::any(*tokenId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CountLeft") != m.end() && !m["CountLeft"].empty()) {
      countLeft = make_shared<long>(boost::any_cast<long>(m["CountLeft"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("HasCountLimit") != m.end() && !m["HasCountLimit"].empty()) {
      hasCountLimit = make_shared<bool>(boost::any_cast<bool>(m["HasCountLimit"]));
    }
    if (m.find("MaxRenewCount") != m.end() && !m["MaxRenewCount"].empty()) {
      maxRenewCount = make_shared<long>(boost::any_cast<long>(m["MaxRenewCount"]));
    }
    if (m.find("RenewCount") != m.end() && !m["RenewCount"].empty()) {
      renewCount = make_shared<long>(boost::any_cast<long>(m["RenewCount"]));
    }
    if (m.find("SsoUrl") != m.end() && !m["SsoUrl"].empty()) {
      ssoUrl = make_shared<string>(boost::any_cast<string>(m["SsoUrl"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("TokenId") != m.end() && !m["TokenId"].empty()) {
      tokenId = make_shared<string>(boost::any_cast<string>(m["TokenId"]));
    }
  }


  virtual ~GenerateAssetOperationTokenResponseBodyAssetOperationToken() = default;
};
class GenerateAssetOperationTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<GenerateAssetOperationTokenResponseBodyAssetOperationToken> assetOperationToken{};
  shared_ptr<string> requestId{};

  GenerateAssetOperationTokenResponseBody() {}

  explicit GenerateAssetOperationTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetOperationToken) {
      res["AssetOperationToken"] = assetOperationToken ? boost::any(assetOperationToken->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetOperationToken") != m.end() && !m["AssetOperationToken"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssetOperationToken"].type()) {
        GenerateAssetOperationTokenResponseBodyAssetOperationToken model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssetOperationToken"]));
        assetOperationToken = make_shared<GenerateAssetOperationTokenResponseBodyAssetOperationToken>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GenerateAssetOperationTokenResponseBody() = default;
};
class GenerateAssetOperationTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateAssetOperationTokenResponseBody> body{};

  GenerateAssetOperationTokenResponse() {}

  explicit GenerateAssetOperationTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateAssetOperationTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateAssetOperationTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateAssetOperationTokenResponse() = default;
};
class GetDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  GetDatabaseRequest() {}

  explicit GetDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDatabaseRequest() = default;
};
class GetDatabaseResponseBodyDatabase : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> databaseName{};
  shared_ptr<long> databasePort{};
  shared_ptr<string> databasePrivateAddress{};
  shared_ptr<string> databasePublicAddress{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceRegionId{};
  shared_ptr<string> sourceInstanceState{};

  GetDatabaseResponseBodyDatabase() {}

  explicit GetDatabaseResponseBodyDatabase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databasePort) {
      res["DatabasePort"] = boost::any(*databasePort);
    }
    if (databasePrivateAddress) {
      res["DatabasePrivateAddress"] = boost::any(*databasePrivateAddress);
    }
    if (databasePublicAddress) {
      res["DatabasePublicAddress"] = boost::any(*databasePublicAddress);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceRegionId) {
      res["SourceInstanceRegionId"] = boost::any(*sourceInstanceRegionId);
    }
    if (sourceInstanceState) {
      res["SourceInstanceState"] = boost::any(*sourceInstanceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabasePort") != m.end() && !m["DatabasePort"].empty()) {
      databasePort = make_shared<long>(boost::any_cast<long>(m["DatabasePort"]));
    }
    if (m.find("DatabasePrivateAddress") != m.end() && !m["DatabasePrivateAddress"].empty()) {
      databasePrivateAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePrivateAddress"]));
    }
    if (m.find("DatabasePublicAddress") != m.end() && !m["DatabasePublicAddress"].empty()) {
      databasePublicAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePublicAddress"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceRegionId") != m.end() && !m["SourceInstanceRegionId"].empty()) {
      sourceInstanceRegionId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceRegionId"]));
    }
    if (m.find("SourceInstanceState") != m.end() && !m["SourceInstanceState"].empty()) {
      sourceInstanceState = make_shared<string>(boost::any_cast<string>(m["SourceInstanceState"]));
    }
  }


  virtual ~GetDatabaseResponseBodyDatabase() = default;
};
class GetDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDatabaseResponseBodyDatabase> database{};
  shared_ptr<string> requestId{};

  GetDatabaseResponseBody() {}

  explicit GetDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = database ? boost::any(database->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      if (typeid(map<string, boost::any>) == m["Database"].type()) {
        GetDatabaseResponseBodyDatabase model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Database"]));
        database = make_shared<GetDatabaseResponseBodyDatabase>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDatabaseResponseBody() = default;
};
class GetDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDatabaseResponseBody> body{};

  GetDatabaseResponse() {}

  explicit GetDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~GetDatabaseResponse() = default;
};
class GetDatabaseAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  GetDatabaseAccountRequest() {}

  explicit GetDatabaseAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetDatabaseAccountRequest() = default;
};
class GetDatabaseAccountResponseBodyDatabaseAccount : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> databaseAccountName{};
  shared_ptr<string> databaseSchema{};
  shared_ptr<bool> hasPassword{};
  shared_ptr<string> loginAttribute{};

  GetDatabaseAccountResponseBodyDatabaseAccount() {}

  explicit GetDatabaseAccountResponseBodyDatabaseAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (databaseAccountName) {
      res["DatabaseAccountName"] = boost::any(*databaseAccountName);
    }
    if (databaseSchema) {
      res["DatabaseSchema"] = boost::any(*databaseSchema);
    }
    if (hasPassword) {
      res["HasPassword"] = boost::any(*hasPassword);
    }
    if (loginAttribute) {
      res["LoginAttribute"] = boost::any(*loginAttribute);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("DatabaseAccountName") != m.end() && !m["DatabaseAccountName"].empty()) {
      databaseAccountName = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountName"]));
    }
    if (m.find("DatabaseSchema") != m.end() && !m["DatabaseSchema"].empty()) {
      databaseSchema = make_shared<string>(boost::any_cast<string>(m["DatabaseSchema"]));
    }
    if (m.find("HasPassword") != m.end() && !m["HasPassword"].empty()) {
      hasPassword = make_shared<bool>(boost::any_cast<bool>(m["HasPassword"]));
    }
    if (m.find("LoginAttribute") != m.end() && !m["LoginAttribute"].empty()) {
      loginAttribute = make_shared<string>(boost::any_cast<string>(m["LoginAttribute"]));
    }
  }


  virtual ~GetDatabaseAccountResponseBodyDatabaseAccount() = default;
};
class GetDatabaseAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDatabaseAccountResponseBodyDatabaseAccount> databaseAccount{};
  shared_ptr<string> requestId{};

  GetDatabaseAccountResponseBody() {}

  explicit GetDatabaseAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccount) {
      res["DatabaseAccount"] = databaseAccount ? boost::any(databaseAccount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccount") != m.end() && !m["DatabaseAccount"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatabaseAccount"].type()) {
        GetDatabaseAccountResponseBodyDatabaseAccount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatabaseAccount"]));
        databaseAccount = make_shared<GetDatabaseAccountResponseBodyDatabaseAccount>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDatabaseAccountResponseBody() = default;
};
class GetDatabaseAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDatabaseAccountResponseBody> body{};

  GetDatabaseAccountResponse() {}

  explicit GetDatabaseAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDatabaseAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDatabaseAccountResponseBody>(model1);
      }
    }
  }


  virtual ~GetDatabaseAccountResponse() = default;
};
class GetExportConfigJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> regionId{};

  GetExportConfigJobRequest() {}

  explicit GetExportConfigJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetExportConfigJobRequest() = default;
};
class GetExportConfigJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadUrl{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  GetExportConfigJobResponseBody() {}

  explicit GetExportConfigJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetExportConfigJobResponseBody() = default;
};
class GetExportConfigJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetExportConfigJobResponseBody> body{};

  GetExportConfigJobResponse() {}

  explicit GetExportConfigJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetExportConfigJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetExportConfigJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetExportConfigJobResponse() = default;
};
class GetHostRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  GetHostRequest() {}

  explicit GetHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetHostRequest() = default;
};
class GetHostResponseBodyHostProtocols : public Darabonba::Model {
public:
  shared_ptr<string> hostFingerPrint{};
  shared_ptr<long> port{};
  shared_ptr<string> protocolName{};

  GetHostResponseBodyHostProtocols() {}

  explicit GetHostResponseBodyHostProtocols(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostFingerPrint) {
      res["HostFingerPrint"] = boost::any(*hostFingerPrint);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostFingerPrint") != m.end() && !m["HostFingerPrint"].empty()) {
      hostFingerPrint = make_shared<string>(boost::any_cast<string>(m["HostFingerPrint"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
  }


  virtual ~GetHostResponseBodyHostProtocols() = default;
};
class GetHostResponseBodyHost : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hostPrivateAddress{};
  shared_ptr<string> hostPublicAddress{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> OSType{};
  shared_ptr<vector<GetHostResponseBodyHostProtocols>> protocols{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceState{};

  GetHostResponseBodyHost() {}

  explicit GetHostResponseBodyHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostPrivateAddress) {
      res["HostPrivateAddress"] = boost::any(*hostPrivateAddress);
    }
    if (hostPublicAddress) {
      res["HostPublicAddress"] = boost::any(*hostPublicAddress);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (protocols) {
      vector<boost::any> temp1;
      for(auto item1:*protocols){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Protocols"] = boost::any(temp1);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceState) {
      res["SourceInstanceState"] = boost::any(*sourceInstanceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostPrivateAddress") != m.end() && !m["HostPrivateAddress"].empty()) {
      hostPrivateAddress = make_shared<string>(boost::any_cast<string>(m["HostPrivateAddress"]));
    }
    if (m.find("HostPublicAddress") != m.end() && !m["HostPublicAddress"].empty()) {
      hostPublicAddress = make_shared<string>(boost::any_cast<string>(m["HostPublicAddress"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<GetHostResponseBodyHostProtocols> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Protocols"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHostResponseBodyHostProtocols model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        protocols = make_shared<vector<GetHostResponseBodyHostProtocols>>(expect1);
      }
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceState") != m.end() && !m["SourceInstanceState"].empty()) {
      sourceInstanceState = make_shared<string>(boost::any_cast<string>(m["SourceInstanceState"]));
    }
  }


  virtual ~GetHostResponseBodyHost() = default;
};
class GetHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetHostResponseBodyHost> host{};
  shared_ptr<string> requestId{};

  GetHostResponseBody() {}

  explicit GetHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = host ? boost::any(host->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      if (typeid(map<string, boost::any>) == m["Host"].type()) {
        GetHostResponseBodyHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Host"]));
        host = make_shared<GetHostResponseBodyHost>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetHostResponseBody() = default;
};
class GetHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHostResponseBody> body{};

  GetHostResponse() {}

  explicit GetHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHostResponseBody>(model1);
      }
    }
  }


  virtual ~GetHostResponse() = default;
};
class GetHostAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  GetHostAccountRequest() {}

  explicit GetHostAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetHostAccountRequest() = default;
};
class GetHostAccountResponseBodyHostAccount : public Darabonba::Model {
public:
  shared_ptr<bool> hasPassword{};
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> hostShareKeyName{};
  shared_ptr<string> privateKeyFingerprint{};
  shared_ptr<string> protocolName{};

  GetHostAccountResponseBodyHostAccount() {}

  explicit GetHostAccountResponseBodyHostAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasPassword) {
      res["HasPassword"] = boost::any(*hasPassword);
    }
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (hostShareKeyName) {
      res["HostShareKeyName"] = boost::any(*hostShareKeyName);
    }
    if (privateKeyFingerprint) {
      res["PrivateKeyFingerprint"] = boost::any(*privateKeyFingerprint);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasPassword") != m.end() && !m["HasPassword"].empty()) {
      hasPassword = make_shared<bool>(boost::any_cast<bool>(m["HasPassword"]));
    }
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("HostShareKeyName") != m.end() && !m["HostShareKeyName"].empty()) {
      hostShareKeyName = make_shared<string>(boost::any_cast<string>(m["HostShareKeyName"]));
    }
    if (m.find("PrivateKeyFingerprint") != m.end() && !m["PrivateKeyFingerprint"].empty()) {
      privateKeyFingerprint = make_shared<string>(boost::any_cast<string>(m["PrivateKeyFingerprint"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
  }


  virtual ~GetHostAccountResponseBodyHostAccount() = default;
};
class GetHostAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetHostAccountResponseBodyHostAccount> hostAccount{};
  shared_ptr<string> requestId{};

  GetHostAccountResponseBody() {}

  explicit GetHostAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccount) {
      res["HostAccount"] = hostAccount ? boost::any(hostAccount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccount") != m.end() && !m["HostAccount"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostAccount"].type()) {
        GetHostAccountResponseBodyHostAccount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostAccount"]));
        hostAccount = make_shared<GetHostAccountResponseBodyHostAccount>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetHostAccountResponseBody() = default;
};
class GetHostAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHostAccountResponseBody> body{};

  GetHostAccountResponse() {}

  explicit GetHostAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHostAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHostAccountResponseBody>(model1);
      }
    }
  }


  virtual ~GetHostAccountResponse() = default;
};
class GetHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  GetHostGroupRequest() {}

  explicit GetHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetHostGroupRequest() = default;
};
class GetHostGroupResponseBodyHostGroup : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};

  GetHostGroupResponseBodyHostGroup() {}

  explicit GetHostGroupResponseBodyHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
  }


  virtual ~GetHostGroupResponseBodyHostGroup() = default;
};
class GetHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetHostGroupResponseBodyHostGroup> hostGroup{};
  shared_ptr<string> requestId{};

  GetHostGroupResponseBody() {}

  explicit GetHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroup) {
      res["HostGroup"] = hostGroup ? boost::any(hostGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostGroup"].type()) {
        GetHostGroupResponseBodyHostGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostGroup"]));
        hostGroup = make_shared<GetHostGroupResponseBodyHostGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetHostGroupResponseBody() = default;
};
class GetHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHostGroupResponseBody> body{};

  GetHostGroupResponse() {}

  explicit GetHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetHostGroupResponse() = default;
};
class GetHostShareKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  GetHostShareKeyRequest() {}

  explicit GetHostShareKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetHostShareKeyRequest() = default;
};
class GetHostShareKeyResponseBodyHostShareKey : public Darabonba::Model {
public:
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> hostShareKeyName{};
  shared_ptr<long> lastModifyKeyAt{};
  shared_ptr<string> privateKeyFingerPrint{};

  GetHostShareKeyResponseBodyHostShareKey() {}

  explicit GetHostShareKeyResponseBodyHostShareKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (hostShareKeyName) {
      res["HostShareKeyName"] = boost::any(*hostShareKeyName);
    }
    if (lastModifyKeyAt) {
      res["LastModifyKeyAt"] = boost::any(*lastModifyKeyAt);
    }
    if (privateKeyFingerPrint) {
      res["PrivateKeyFingerPrint"] = boost::any(*privateKeyFingerPrint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("HostShareKeyName") != m.end() && !m["HostShareKeyName"].empty()) {
      hostShareKeyName = make_shared<string>(boost::any_cast<string>(m["HostShareKeyName"]));
    }
    if (m.find("LastModifyKeyAt") != m.end() && !m["LastModifyKeyAt"].empty()) {
      lastModifyKeyAt = make_shared<long>(boost::any_cast<long>(m["LastModifyKeyAt"]));
    }
    if (m.find("PrivateKeyFingerPrint") != m.end() && !m["PrivateKeyFingerPrint"].empty()) {
      privateKeyFingerPrint = make_shared<string>(boost::any_cast<string>(m["PrivateKeyFingerPrint"]));
    }
  }


  virtual ~GetHostShareKeyResponseBodyHostShareKey() = default;
};
class GetHostShareKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetHostShareKeyResponseBodyHostShareKey> hostShareKey{};
  shared_ptr<string> requestId{};

  GetHostShareKeyResponseBody() {}

  explicit GetHostShareKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostShareKey) {
      res["HostShareKey"] = hostShareKey ? boost::any(hostShareKey->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostShareKey") != m.end() && !m["HostShareKey"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostShareKey"].type()) {
        GetHostShareKeyResponseBodyHostShareKey model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostShareKey"]));
        hostShareKey = make_shared<GetHostShareKeyResponseBodyHostShareKey>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetHostShareKeyResponseBody() = default;
};
class GetHostShareKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHostShareKeyResponseBody> body{};

  GetHostShareKeyResponse() {}

  explicit GetHostShareKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHostShareKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHostShareKeyResponseBody>(model1);
      }
    }
  }


  virtual ~GetHostShareKeyResponse() = default;
};
class GetInstanceADAuthServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  GetInstanceADAuthServerRequest() {}

  explicit GetInstanceADAuthServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetInstanceADAuthServerRequest() = default;
};
class GetInstanceADAuthServerResponseBodyAD : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> baseDN{};
  shared_ptr<string> domain{};
  shared_ptr<string> emailMapping{};
  shared_ptr<string> filter{};
  shared_ptr<bool> hasPassword{};
  shared_ptr<bool> isSSL{};
  shared_ptr<string> mobileMapping{};
  shared_ptr<string> nameMapping{};
  shared_ptr<long> port{};
  shared_ptr<string> server{};
  shared_ptr<string> standbyServer{};

  GetInstanceADAuthServerResponseBodyAD() {}

  explicit GetInstanceADAuthServerResponseBodyAD(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (baseDN) {
      res["BaseDN"] = boost::any(*baseDN);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (emailMapping) {
      res["EmailMapping"] = boost::any(*emailMapping);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (hasPassword) {
      res["HasPassword"] = boost::any(*hasPassword);
    }
    if (isSSL) {
      res["IsSSL"] = boost::any(*isSSL);
    }
    if (mobileMapping) {
      res["MobileMapping"] = boost::any(*mobileMapping);
    }
    if (nameMapping) {
      res["NameMapping"] = boost::any(*nameMapping);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (standbyServer) {
      res["StandbyServer"] = boost::any(*standbyServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("BaseDN") != m.end() && !m["BaseDN"].empty()) {
      baseDN = make_shared<string>(boost::any_cast<string>(m["BaseDN"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EmailMapping") != m.end() && !m["EmailMapping"].empty()) {
      emailMapping = make_shared<string>(boost::any_cast<string>(m["EmailMapping"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("HasPassword") != m.end() && !m["HasPassword"].empty()) {
      hasPassword = make_shared<bool>(boost::any_cast<bool>(m["HasPassword"]));
    }
    if (m.find("IsSSL") != m.end() && !m["IsSSL"].empty()) {
      isSSL = make_shared<bool>(boost::any_cast<bool>(m["IsSSL"]));
    }
    if (m.find("MobileMapping") != m.end() && !m["MobileMapping"].empty()) {
      mobileMapping = make_shared<string>(boost::any_cast<string>(m["MobileMapping"]));
    }
    if (m.find("NameMapping") != m.end() && !m["NameMapping"].empty()) {
      nameMapping = make_shared<string>(boost::any_cast<string>(m["NameMapping"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("StandbyServer") != m.end() && !m["StandbyServer"].empty()) {
      standbyServer = make_shared<string>(boost::any_cast<string>(m["StandbyServer"]));
    }
  }


  virtual ~GetInstanceADAuthServerResponseBodyAD() = default;
};
class GetInstanceADAuthServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetInstanceADAuthServerResponseBodyAD> AD{};
  shared_ptr<string> requestId{};

  GetInstanceADAuthServerResponseBody() {}

  explicit GetInstanceADAuthServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AD) {
      res["AD"] = AD ? boost::any(AD->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AD") != m.end() && !m["AD"].empty()) {
      if (typeid(map<string, boost::any>) == m["AD"].type()) {
        GetInstanceADAuthServerResponseBodyAD model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AD"]));
        AD = make_shared<GetInstanceADAuthServerResponseBodyAD>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInstanceADAuthServerResponseBody() = default;
};
class GetInstanceADAuthServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceADAuthServerResponseBody> body{};

  GetInstanceADAuthServerResponse() {}

  explicit GetInstanceADAuthServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceADAuthServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceADAuthServerResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceADAuthServerResponse() = default;
};
class GetInstanceLDAPAuthServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  GetInstanceLDAPAuthServerRequest() {}

  explicit GetInstanceLDAPAuthServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetInstanceLDAPAuthServerRequest() = default;
};
class GetInstanceLDAPAuthServerResponseBodyLDAP : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> baseDN{};
  shared_ptr<string> emailMapping{};
  shared_ptr<string> filter{};
  shared_ptr<string> hasPassword{};
  shared_ptr<bool> isSSL{};
  shared_ptr<string> loginNameMapping{};
  shared_ptr<string> mobileMapping{};
  shared_ptr<string> nameMapping{};
  shared_ptr<long> port{};
  shared_ptr<string> server{};
  shared_ptr<string> standbyServer{};

  GetInstanceLDAPAuthServerResponseBodyLDAP() {}

  explicit GetInstanceLDAPAuthServerResponseBodyLDAP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (baseDN) {
      res["BaseDN"] = boost::any(*baseDN);
    }
    if (emailMapping) {
      res["EmailMapping"] = boost::any(*emailMapping);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (hasPassword) {
      res["HasPassword"] = boost::any(*hasPassword);
    }
    if (isSSL) {
      res["IsSSL"] = boost::any(*isSSL);
    }
    if (loginNameMapping) {
      res["LoginNameMapping"] = boost::any(*loginNameMapping);
    }
    if (mobileMapping) {
      res["MobileMapping"] = boost::any(*mobileMapping);
    }
    if (nameMapping) {
      res["NameMapping"] = boost::any(*nameMapping);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (standbyServer) {
      res["StandbyServer"] = boost::any(*standbyServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("BaseDN") != m.end() && !m["BaseDN"].empty()) {
      baseDN = make_shared<string>(boost::any_cast<string>(m["BaseDN"]));
    }
    if (m.find("EmailMapping") != m.end() && !m["EmailMapping"].empty()) {
      emailMapping = make_shared<string>(boost::any_cast<string>(m["EmailMapping"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("HasPassword") != m.end() && !m["HasPassword"].empty()) {
      hasPassword = make_shared<string>(boost::any_cast<string>(m["HasPassword"]));
    }
    if (m.find("IsSSL") != m.end() && !m["IsSSL"].empty()) {
      isSSL = make_shared<bool>(boost::any_cast<bool>(m["IsSSL"]));
    }
    if (m.find("LoginNameMapping") != m.end() && !m["LoginNameMapping"].empty()) {
      loginNameMapping = make_shared<string>(boost::any_cast<string>(m["LoginNameMapping"]));
    }
    if (m.find("MobileMapping") != m.end() && !m["MobileMapping"].empty()) {
      mobileMapping = make_shared<string>(boost::any_cast<string>(m["MobileMapping"]));
    }
    if (m.find("NameMapping") != m.end() && !m["NameMapping"].empty()) {
      nameMapping = make_shared<string>(boost::any_cast<string>(m["NameMapping"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("StandbyServer") != m.end() && !m["StandbyServer"].empty()) {
      standbyServer = make_shared<string>(boost::any_cast<string>(m["StandbyServer"]));
    }
  }


  virtual ~GetInstanceLDAPAuthServerResponseBodyLDAP() = default;
};
class GetInstanceLDAPAuthServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetInstanceLDAPAuthServerResponseBodyLDAP> LDAP{};
  shared_ptr<string> requestId{};

  GetInstanceLDAPAuthServerResponseBody() {}

  explicit GetInstanceLDAPAuthServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (LDAP) {
      res["LDAP"] = LDAP ? boost::any(LDAP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LDAP") != m.end() && !m["LDAP"].empty()) {
      if (typeid(map<string, boost::any>) == m["LDAP"].type()) {
        GetInstanceLDAPAuthServerResponseBodyLDAP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LDAP"]));
        LDAP = make_shared<GetInstanceLDAPAuthServerResponseBodyLDAP>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInstanceLDAPAuthServerResponseBody() = default;
};
class GetInstanceLDAPAuthServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceLDAPAuthServerResponseBody> body{};

  GetInstanceLDAPAuthServerResponse() {}

  explicit GetInstanceLDAPAuthServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceLDAPAuthServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceLDAPAuthServerResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceLDAPAuthServerResponse() = default;
};
class GetInstanceStoreInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  GetInstanceStoreInfoRequest() {}

  explicit GetInstanceStoreInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetInstanceStoreInfoRequest() = default;
};
class GetInstanceStoreInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> max{};
  shared_ptr<string> requestId{};
  shared_ptr<long> usage{};

  GetInstanceStoreInfoResponseBody() {}

  explicit GetInstanceStoreInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<long>(boost::any_cast<long>(m["Max"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<long>(boost::any_cast<long>(m["Usage"]));
    }
  }


  virtual ~GetInstanceStoreInfoResponseBody() = default;
};
class GetInstanceStoreInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceStoreInfoResponseBody> body{};

  GetInstanceStoreInfoResponse() {}

  explicit GetInstanceStoreInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceStoreInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceStoreInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceStoreInfoResponse() = default;
};
class GetInstanceTwoFactorRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  GetInstanceTwoFactorRequest() {}

  explicit GetInstanceTwoFactorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetInstanceTwoFactorRequest() = default;
};
class GetInstanceTwoFactorResponseBodyConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableTwoFactor{};
  shared_ptr<long> skipTwoFactorTime{};
  shared_ptr<vector<string>> twoFactorMethods{};

  GetInstanceTwoFactorResponseBodyConfig() {}

  explicit GetInstanceTwoFactorResponseBodyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableTwoFactor) {
      res["EnableTwoFactor"] = boost::any(*enableTwoFactor);
    }
    if (skipTwoFactorTime) {
      res["SkipTwoFactorTime"] = boost::any(*skipTwoFactorTime);
    }
    if (twoFactorMethods) {
      res["TwoFactorMethods"] = boost::any(*twoFactorMethods);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableTwoFactor") != m.end() && !m["EnableTwoFactor"].empty()) {
      enableTwoFactor = make_shared<bool>(boost::any_cast<bool>(m["EnableTwoFactor"]));
    }
    if (m.find("SkipTwoFactorTime") != m.end() && !m["SkipTwoFactorTime"].empty()) {
      skipTwoFactorTime = make_shared<long>(boost::any_cast<long>(m["SkipTwoFactorTime"]));
    }
    if (m.find("TwoFactorMethods") != m.end() && !m["TwoFactorMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TwoFactorMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TwoFactorMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      twoFactorMethods = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetInstanceTwoFactorResponseBodyConfig() = default;
};
class GetInstanceTwoFactorResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetInstanceTwoFactorResponseBodyConfig> config{};
  shared_ptr<string> requestId{};

  GetInstanceTwoFactorResponseBody() {}

  explicit GetInstanceTwoFactorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        GetInstanceTwoFactorResponseBodyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<GetInstanceTwoFactorResponseBodyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInstanceTwoFactorResponseBody() = default;
};
class GetInstanceTwoFactorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceTwoFactorResponseBody> body{};

  GetInstanceTwoFactorResponse() {}

  explicit GetInstanceTwoFactorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceTwoFactorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceTwoFactorResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceTwoFactorResponse() = default;
};
class GetNetworkDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> regionId{};

  GetNetworkDomainRequest() {}

  explicit GetNetworkDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetNetworkDomainRequest() = default;
};
class GetNetworkDomainResponseBodyNetworkDomainProxies : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<bool> hasPassword{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> port{};
  shared_ptr<string> proxyState{};
  shared_ptr<string> proxyStateErrorCode{};
  shared_ptr<string> proxyType{};
  shared_ptr<string> user{};

  GetNetworkDomainResponseBodyNetworkDomainProxies() {}

  explicit GetNetworkDomainResponseBodyNetworkDomainProxies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (hasPassword) {
      res["HasPassword"] = boost::any(*hasPassword);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (proxyState) {
      res["ProxyState"] = boost::any(*proxyState);
    }
    if (proxyStateErrorCode) {
      res["ProxyStateErrorCode"] = boost::any(*proxyStateErrorCode);
    }
    if (proxyType) {
      res["ProxyType"] = boost::any(*proxyType);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("HasPassword") != m.end() && !m["HasPassword"].empty()) {
      hasPassword = make_shared<bool>(boost::any_cast<bool>(m["HasPassword"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ProxyState") != m.end() && !m["ProxyState"].empty()) {
      proxyState = make_shared<string>(boost::any_cast<string>(m["ProxyState"]));
    }
    if (m.find("ProxyStateErrorCode") != m.end() && !m["ProxyStateErrorCode"].empty()) {
      proxyStateErrorCode = make_shared<string>(boost::any_cast<string>(m["ProxyStateErrorCode"]));
    }
    if (m.find("ProxyType") != m.end() && !m["ProxyType"].empty()) {
      proxyType = make_shared<string>(boost::any_cast<string>(m["ProxyType"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~GetNetworkDomainResponseBodyNetworkDomainProxies() = default;
};
class GetNetworkDomainResponseBodyNetworkDomain : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<bool> default_{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> networkDomainName{};
  shared_ptr<string> networkDomainType{};
  shared_ptr<vector<GetNetworkDomainResponseBodyNetworkDomainProxies>> proxies{};

  GetNetworkDomainResponseBodyNetworkDomain() {}

  explicit GetNetworkDomainResponseBodyNetworkDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (default_) {
      res["Default"] = boost::any(*default_);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (networkDomainName) {
      res["NetworkDomainName"] = boost::any(*networkDomainName);
    }
    if (networkDomainType) {
      res["NetworkDomainType"] = boost::any(*networkDomainType);
    }
    if (proxies) {
      vector<boost::any> temp1;
      for(auto item1:*proxies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Proxies"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Default") != m.end() && !m["Default"].empty()) {
      default_ = make_shared<bool>(boost::any_cast<bool>(m["Default"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("NetworkDomainName") != m.end() && !m["NetworkDomainName"].empty()) {
      networkDomainName = make_shared<string>(boost::any_cast<string>(m["NetworkDomainName"]));
    }
    if (m.find("NetworkDomainType") != m.end() && !m["NetworkDomainType"].empty()) {
      networkDomainType = make_shared<string>(boost::any_cast<string>(m["NetworkDomainType"]));
    }
    if (m.find("Proxies") != m.end() && !m["Proxies"].empty()) {
      if (typeid(vector<boost::any>) == m["Proxies"].type()) {
        vector<GetNetworkDomainResponseBodyNetworkDomainProxies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Proxies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNetworkDomainResponseBodyNetworkDomainProxies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proxies = make_shared<vector<GetNetworkDomainResponseBodyNetworkDomainProxies>>(expect1);
      }
    }
  }


  virtual ~GetNetworkDomainResponseBodyNetworkDomain() = default;
};
class GetNetworkDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNetworkDomainResponseBodyNetworkDomain> networkDomain{};
  shared_ptr<string> requestId{};

  GetNetworkDomainResponseBody() {}

  explicit GetNetworkDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkDomain) {
      res["NetworkDomain"] = networkDomain ? boost::any(networkDomain->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkDomain") != m.end() && !m["NetworkDomain"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkDomain"].type()) {
        GetNetworkDomainResponseBodyNetworkDomain model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkDomain"]));
        networkDomain = make_shared<GetNetworkDomainResponseBodyNetworkDomain>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetNetworkDomainResponseBody() = default;
};
class GetNetworkDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNetworkDomainResponseBody> body{};

  GetNetworkDomainResponse() {}

  explicit GetNetworkDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNetworkDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNetworkDomainResponseBody>(model1);
      }
    }
  }


  virtual ~GetNetworkDomainResponse() = default;
};
class GetPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  GetPolicyRequest() {}

  explicit GetPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPolicyRequest() = default;
};
class GetPolicyResponseBodyPolicyAccessTimeRangeConfigEffectiveTime : public Darabonba::Model {
public:
  shared_ptr<vector<string>> days{};
  shared_ptr<vector<string>> hours{};

  GetPolicyResponseBodyPolicyAccessTimeRangeConfigEffectiveTime() {}

  explicit GetPolicyResponseBodyPolicyAccessTimeRangeConfigEffectiveTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["Days"] = boost::any(*days);
    }
    if (hours) {
      res["Hours"] = boost::any(*hours);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Days"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Days"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      days = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Hours") != m.end() && !m["Hours"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Hours"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Hours"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hours = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetPolicyResponseBodyPolicyAccessTimeRangeConfigEffectiveTime() = default;
};
class GetPolicyResponseBodyPolicyAccessTimeRangeConfig : public Darabonba::Model {
public:
  shared_ptr<vector<GetPolicyResponseBodyPolicyAccessTimeRangeConfigEffectiveTime>> effectiveTime{};

  GetPolicyResponseBodyPolicyAccessTimeRangeConfig() {}

  explicit GetPolicyResponseBodyPolicyAccessTimeRangeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveTime) {
      vector<boost::any> temp1;
      for(auto item1:*effectiveTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EffectiveTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      if (typeid(vector<boost::any>) == m["EffectiveTime"].type()) {
        vector<GetPolicyResponseBodyPolicyAccessTimeRangeConfigEffectiveTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EffectiveTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPolicyResponseBodyPolicyAccessTimeRangeConfigEffectiveTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        effectiveTime = make_shared<vector<GetPolicyResponseBodyPolicyAccessTimeRangeConfigEffectiveTime>>(expect1);
      }
    }
  }


  virtual ~GetPolicyResponseBodyPolicyAccessTimeRangeConfig() = default;
};
class GetPolicyResponseBodyPolicyApprovalConfig : public Darabonba::Model {
public:
  shared_ptr<string> switchStatus{};

  GetPolicyResponseBodyPolicyApprovalConfig() {}

  explicit GetPolicyResponseBodyPolicyApprovalConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (switchStatus) {
      res["SwitchStatus"] = boost::any(*switchStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SwitchStatus") != m.end() && !m["SwitchStatus"].empty()) {
      switchStatus = make_shared<string>(boost::any_cast<string>(m["SwitchStatus"]));
    }
  }


  virtual ~GetPolicyResponseBodyPolicyApprovalConfig() = default;
};
class GetPolicyResponseBodyPolicyCommandConfigApproval : public Darabonba::Model {
public:
  shared_ptr<vector<string>> commands{};

  GetPolicyResponseBodyPolicyCommandConfigApproval() {}

  explicit GetPolicyResponseBodyPolicyCommandConfigApproval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetPolicyResponseBodyPolicyCommandConfigApproval() = default;
};
class GetPolicyResponseBodyPolicyCommandConfigDeny : public Darabonba::Model {
public:
  shared_ptr<string> aclType{};
  shared_ptr<vector<string>> commands{};

  GetPolicyResponseBodyPolicyCommandConfigDeny() {}

  explicit GetPolicyResponseBodyPolicyCommandConfigDeny(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetPolicyResponseBodyPolicyCommandConfigDeny() = default;
};
class GetPolicyResponseBodyPolicyCommandConfig : public Darabonba::Model {
public:
  shared_ptr<GetPolicyResponseBodyPolicyCommandConfigApproval> approval{};
  shared_ptr<GetPolicyResponseBodyPolicyCommandConfigDeny> deny{};

  GetPolicyResponseBodyPolicyCommandConfig() {}

  explicit GetPolicyResponseBodyPolicyCommandConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approval) {
      res["Approval"] = approval ? boost::any(approval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deny) {
      res["Deny"] = deny ? boost::any(deny->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Approval") != m.end() && !m["Approval"].empty()) {
      if (typeid(map<string, boost::any>) == m["Approval"].type()) {
        GetPolicyResponseBodyPolicyCommandConfigApproval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Approval"]));
        approval = make_shared<GetPolicyResponseBodyPolicyCommandConfigApproval>(model1);
      }
    }
    if (m.find("Deny") != m.end() && !m["Deny"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deny"].type()) {
        GetPolicyResponseBodyPolicyCommandConfigDeny model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deny"]));
        deny = make_shared<GetPolicyResponseBodyPolicyCommandConfigDeny>(model1);
      }
    }
  }


  virtual ~GetPolicyResponseBodyPolicyCommandConfig() = default;
};
class GetPolicyResponseBodyPolicyIPAclConfig : public Darabonba::Model {
public:
  shared_ptr<string> aclType{};
  shared_ptr<vector<string>> IPs{};

  GetPolicyResponseBodyPolicyIPAclConfig() {}

  explicit GetPolicyResponseBodyPolicyIPAclConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (IPs) {
      res["IPs"] = boost::any(*IPs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("IPs") != m.end() && !m["IPs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPs = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetPolicyResponseBodyPolicyIPAclConfig() = default;
};
class GetPolicyResponseBodyPolicyProtocolConfigRDP : public Darabonba::Model {
public:
  shared_ptr<string> clipboardDownload{};
  shared_ptr<string> clipboardUpload{};
  shared_ptr<string> diskRedirection{};
  shared_ptr<string> recordKeyboard{};

  GetPolicyResponseBodyPolicyProtocolConfigRDP() {}

  explicit GetPolicyResponseBodyPolicyProtocolConfigRDP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipboardDownload) {
      res["ClipboardDownload"] = boost::any(*clipboardDownload);
    }
    if (clipboardUpload) {
      res["ClipboardUpload"] = boost::any(*clipboardUpload);
    }
    if (diskRedirection) {
      res["DiskRedirection"] = boost::any(*diskRedirection);
    }
    if (recordKeyboard) {
      res["RecordKeyboard"] = boost::any(*recordKeyboard);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipboardDownload") != m.end() && !m["ClipboardDownload"].empty()) {
      clipboardDownload = make_shared<string>(boost::any_cast<string>(m["ClipboardDownload"]));
    }
    if (m.find("ClipboardUpload") != m.end() && !m["ClipboardUpload"].empty()) {
      clipboardUpload = make_shared<string>(boost::any_cast<string>(m["ClipboardUpload"]));
    }
    if (m.find("DiskRedirection") != m.end() && !m["DiskRedirection"].empty()) {
      diskRedirection = make_shared<string>(boost::any_cast<string>(m["DiskRedirection"]));
    }
    if (m.find("RecordKeyboard") != m.end() && !m["RecordKeyboard"].empty()) {
      recordKeyboard = make_shared<string>(boost::any_cast<string>(m["RecordKeyboard"]));
    }
  }


  virtual ~GetPolicyResponseBodyPolicyProtocolConfigRDP() = default;
};
class GetPolicyResponseBodyPolicyProtocolConfigSSH : public Darabonba::Model {
public:
  shared_ptr<string> execCommand{};
  shared_ptr<string> SFTPChannel{};
  shared_ptr<string> SFTPDownloadFile{};
  shared_ptr<string> SFTPMkdir{};
  shared_ptr<string> SFTPRemoveFile{};
  shared_ptr<string> SFTPRenameFile{};
  shared_ptr<string> SFTPRmdir{};
  shared_ptr<string> SFTPUploadFile{};
  shared_ptr<string> SSHChannel{};
  shared_ptr<string> x11Forwarding{};

  GetPolicyResponseBodyPolicyProtocolConfigSSH() {}

  explicit GetPolicyResponseBodyPolicyProtocolConfigSSH(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (execCommand) {
      res["ExecCommand"] = boost::any(*execCommand);
    }
    if (SFTPChannel) {
      res["SFTPChannel"] = boost::any(*SFTPChannel);
    }
    if (SFTPDownloadFile) {
      res["SFTPDownloadFile"] = boost::any(*SFTPDownloadFile);
    }
    if (SFTPMkdir) {
      res["SFTPMkdir"] = boost::any(*SFTPMkdir);
    }
    if (SFTPRemoveFile) {
      res["SFTPRemoveFile"] = boost::any(*SFTPRemoveFile);
    }
    if (SFTPRenameFile) {
      res["SFTPRenameFile"] = boost::any(*SFTPRenameFile);
    }
    if (SFTPRmdir) {
      res["SFTPRmdir"] = boost::any(*SFTPRmdir);
    }
    if (SFTPUploadFile) {
      res["SFTPUploadFile"] = boost::any(*SFTPUploadFile);
    }
    if (SSHChannel) {
      res["SSHChannel"] = boost::any(*SSHChannel);
    }
    if (x11Forwarding) {
      res["X11Forwarding"] = boost::any(*x11Forwarding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecCommand") != m.end() && !m["ExecCommand"].empty()) {
      execCommand = make_shared<string>(boost::any_cast<string>(m["ExecCommand"]));
    }
    if (m.find("SFTPChannel") != m.end() && !m["SFTPChannel"].empty()) {
      SFTPChannel = make_shared<string>(boost::any_cast<string>(m["SFTPChannel"]));
    }
    if (m.find("SFTPDownloadFile") != m.end() && !m["SFTPDownloadFile"].empty()) {
      SFTPDownloadFile = make_shared<string>(boost::any_cast<string>(m["SFTPDownloadFile"]));
    }
    if (m.find("SFTPMkdir") != m.end() && !m["SFTPMkdir"].empty()) {
      SFTPMkdir = make_shared<string>(boost::any_cast<string>(m["SFTPMkdir"]));
    }
    if (m.find("SFTPRemoveFile") != m.end() && !m["SFTPRemoveFile"].empty()) {
      SFTPRemoveFile = make_shared<string>(boost::any_cast<string>(m["SFTPRemoveFile"]));
    }
    if (m.find("SFTPRenameFile") != m.end() && !m["SFTPRenameFile"].empty()) {
      SFTPRenameFile = make_shared<string>(boost::any_cast<string>(m["SFTPRenameFile"]));
    }
    if (m.find("SFTPRmdir") != m.end() && !m["SFTPRmdir"].empty()) {
      SFTPRmdir = make_shared<string>(boost::any_cast<string>(m["SFTPRmdir"]));
    }
    if (m.find("SFTPUploadFile") != m.end() && !m["SFTPUploadFile"].empty()) {
      SFTPUploadFile = make_shared<string>(boost::any_cast<string>(m["SFTPUploadFile"]));
    }
    if (m.find("SSHChannel") != m.end() && !m["SSHChannel"].empty()) {
      SSHChannel = make_shared<string>(boost::any_cast<string>(m["SSHChannel"]));
    }
    if (m.find("X11Forwarding") != m.end() && !m["X11Forwarding"].empty()) {
      x11Forwarding = make_shared<string>(boost::any_cast<string>(m["X11Forwarding"]));
    }
  }


  virtual ~GetPolicyResponseBodyPolicyProtocolConfigSSH() = default;
};
class GetPolicyResponseBodyPolicyProtocolConfig : public Darabonba::Model {
public:
  shared_ptr<GetPolicyResponseBodyPolicyProtocolConfigRDP> RDP{};
  shared_ptr<GetPolicyResponseBodyPolicyProtocolConfigSSH> SSH{};

  GetPolicyResponseBodyPolicyProtocolConfig() {}

  explicit GetPolicyResponseBodyPolicyProtocolConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (RDP) {
      res["RDP"] = RDP ? boost::any(RDP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (SSH) {
      res["SSH"] = SSH ? boost::any(SSH->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RDP") != m.end() && !m["RDP"].empty()) {
      if (typeid(map<string, boost::any>) == m["RDP"].type()) {
        GetPolicyResponseBodyPolicyProtocolConfigRDP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RDP"]));
        RDP = make_shared<GetPolicyResponseBodyPolicyProtocolConfigRDP>(model1);
      }
    }
    if (m.find("SSH") != m.end() && !m["SSH"].empty()) {
      if (typeid(map<string, boost::any>) == m["SSH"].type()) {
        GetPolicyResponseBodyPolicyProtocolConfigSSH model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SSH"]));
        SSH = make_shared<GetPolicyResponseBodyPolicyProtocolConfigSSH>(model1);
      }
    }
  }


  virtual ~GetPolicyResponseBodyPolicyProtocolConfig() = default;
};
class GetPolicyResponseBodyPolicy : public Darabonba::Model {
public:
  shared_ptr<GetPolicyResponseBodyPolicyAccessTimeRangeConfig> accessTimeRangeConfig{};
  shared_ptr<GetPolicyResponseBodyPolicyApprovalConfig> approvalConfig{};
  shared_ptr<GetPolicyResponseBodyPolicyCommandConfig> commandConfig{};
  shared_ptr<string> comment{};
  shared_ptr<GetPolicyResponseBodyPolicyIPAclConfig> IPAclConfig{};
  shared_ptr<string> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<long> priority{};
  shared_ptr<GetPolicyResponseBodyPolicyProtocolConfig> protocolConfig{};

  GetPolicyResponseBodyPolicy() {}

  explicit GetPolicyResponseBodyPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessTimeRangeConfig) {
      res["AccessTimeRangeConfig"] = accessTimeRangeConfig ? boost::any(accessTimeRangeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (approvalConfig) {
      res["ApprovalConfig"] = approvalConfig ? boost::any(approvalConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (commandConfig) {
      res["CommandConfig"] = commandConfig ? boost::any(commandConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (IPAclConfig) {
      res["IPAclConfig"] = IPAclConfig ? boost::any(IPAclConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (protocolConfig) {
      res["ProtocolConfig"] = protocolConfig ? boost::any(protocolConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessTimeRangeConfig") != m.end() && !m["AccessTimeRangeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccessTimeRangeConfig"].type()) {
        GetPolicyResponseBodyPolicyAccessTimeRangeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccessTimeRangeConfig"]));
        accessTimeRangeConfig = make_shared<GetPolicyResponseBodyPolicyAccessTimeRangeConfig>(model1);
      }
    }
    if (m.find("ApprovalConfig") != m.end() && !m["ApprovalConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApprovalConfig"].type()) {
        GetPolicyResponseBodyPolicyApprovalConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApprovalConfig"]));
        approvalConfig = make_shared<GetPolicyResponseBodyPolicyApprovalConfig>(model1);
      }
    }
    if (m.find("CommandConfig") != m.end() && !m["CommandConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommandConfig"].type()) {
        GetPolicyResponseBodyPolicyCommandConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommandConfig"]));
        commandConfig = make_shared<GetPolicyResponseBodyPolicyCommandConfig>(model1);
      }
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("IPAclConfig") != m.end() && !m["IPAclConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IPAclConfig"].type()) {
        GetPolicyResponseBodyPolicyIPAclConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IPAclConfig"]));
        IPAclConfig = make_shared<GetPolicyResponseBodyPolicyIPAclConfig>(model1);
      }
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProtocolConfig") != m.end() && !m["ProtocolConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProtocolConfig"].type()) {
        GetPolicyResponseBodyPolicyProtocolConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProtocolConfig"]));
        protocolConfig = make_shared<GetPolicyResponseBodyPolicyProtocolConfig>(model1);
      }
    }
  }


  virtual ~GetPolicyResponseBodyPolicy() = default;
};
class GetPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPolicyResponseBodyPolicy> policy{};
  shared_ptr<string> requestId{};

  GetPolicyResponseBody() {}

  explicit GetPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policy) {
      res["Policy"] = policy ? boost::any(policy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Policy"].type()) {
        GetPolicyResponseBodyPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Policy"]));
        policy = make_shared<GetPolicyResponseBodyPolicy>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPolicyResponseBody() = default;
};
class GetPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPolicyResponseBody> body{};

  GetPolicyResponse() {}

  explicit GetPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~GetPolicyResponse() = default;
};
class GetPolicyAssetScopeRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  GetPolicyAssetScopeRequest() {}

  explicit GetPolicyAssetScopeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPolicyAssetScopeRequest() = default;
};
class GetPolicyAssetScopeResponseBodyAssetScopeDatabases : public Darabonba::Model {
public:
  shared_ptr<string> accountScopeType{};
  shared_ptr<vector<string>> databaseAccountIds{};
  shared_ptr<string> databaseId{};

  GetPolicyAssetScopeResponseBodyAssetScopeDatabases() {}

  explicit GetPolicyAssetScopeResponseBodyAssetScopeDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountScopeType) {
      res["AccountScopeType"] = boost::any(*accountScopeType);
    }
    if (databaseAccountIds) {
      res["DatabaseAccountIds"] = boost::any(*databaseAccountIds);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountScopeType") != m.end() && !m["AccountScopeType"].empty()) {
      accountScopeType = make_shared<string>(boost::any_cast<string>(m["AccountScopeType"]));
    }
    if (m.find("DatabaseAccountIds") != m.end() && !m["DatabaseAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
  }


  virtual ~GetPolicyAssetScopeResponseBodyAssetScopeDatabases() = default;
};
class GetPolicyAssetScopeResponseBodyAssetScopeHostGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> accountNames{};
  shared_ptr<string> accountScopeType{};
  shared_ptr<string> hostGroupId{};

  GetPolicyAssetScopeResponseBodyAssetScopeHostGroups() {}

  explicit GetPolicyAssetScopeResponseBodyAssetScopeHostGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountNames) {
      res["AccountNames"] = boost::any(*accountNames);
    }
    if (accountScopeType) {
      res["AccountScopeType"] = boost::any(*accountScopeType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountNames") != m.end() && !m["AccountNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AccountNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AccountNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      accountNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AccountScopeType") != m.end() && !m["AccountScopeType"].empty()) {
      accountScopeType = make_shared<string>(boost::any_cast<string>(m["AccountScopeType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
  }


  virtual ~GetPolicyAssetScopeResponseBodyAssetScopeHostGroups() = default;
};
class GetPolicyAssetScopeResponseBodyAssetScopeHosts : public Darabonba::Model {
public:
  shared_ptr<string> accountScopeType{};
  shared_ptr<vector<string>> hostAccountIds{};
  shared_ptr<string> hostId{};

  GetPolicyAssetScopeResponseBodyAssetScopeHosts() {}

  explicit GetPolicyAssetScopeResponseBodyAssetScopeHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountScopeType) {
      res["AccountScopeType"] = boost::any(*accountScopeType);
    }
    if (hostAccountIds) {
      res["HostAccountIds"] = boost::any(*hostAccountIds);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountScopeType") != m.end() && !m["AccountScopeType"].empty()) {
      accountScopeType = make_shared<string>(boost::any_cast<string>(m["AccountScopeType"]));
    }
    if (m.find("HostAccountIds") != m.end() && !m["HostAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
  }


  virtual ~GetPolicyAssetScopeResponseBodyAssetScopeHosts() = default;
};
class GetPolicyAssetScopeResponseBodyAssetScope : public Darabonba::Model {
public:
  shared_ptr<vector<GetPolicyAssetScopeResponseBodyAssetScopeDatabases>> databases{};
  shared_ptr<vector<GetPolicyAssetScopeResponseBodyAssetScopeHostGroups>> hostGroups{};
  shared_ptr<vector<GetPolicyAssetScopeResponseBodyAssetScopeHosts>> hosts{};
  shared_ptr<string> scopeType{};

  GetPolicyAssetScopeResponseBodyAssetScope() {}

  explicit GetPolicyAssetScopeResponseBodyAssetScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (hostGroups) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroups"] = boost::any(temp1);
    }
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<GetPolicyAssetScopeResponseBodyAssetScopeDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPolicyAssetScopeResponseBodyAssetScopeDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<GetPolicyAssetScopeResponseBodyAssetScopeDatabases>>(expect1);
      }
    }
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroups"].type()) {
        vector<GetPolicyAssetScopeResponseBodyAssetScopeHostGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPolicyAssetScopeResponseBodyAssetScopeHostGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroups = make_shared<vector<GetPolicyAssetScopeResponseBodyAssetScopeHostGroups>>(expect1);
      }
    }
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<GetPolicyAssetScopeResponseBodyAssetScopeHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPolicyAssetScopeResponseBodyAssetScopeHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<GetPolicyAssetScopeResponseBodyAssetScopeHosts>>(expect1);
      }
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
  }


  virtual ~GetPolicyAssetScopeResponseBodyAssetScope() = default;
};
class GetPolicyAssetScopeResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPolicyAssetScopeResponseBodyAssetScope> assetScope{};
  shared_ptr<string> requestId{};

  GetPolicyAssetScopeResponseBody() {}

  explicit GetPolicyAssetScopeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetScope) {
      res["AssetScope"] = assetScope ? boost::any(assetScope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetScope") != m.end() && !m["AssetScope"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssetScope"].type()) {
        GetPolicyAssetScopeResponseBodyAssetScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssetScope"]));
        assetScope = make_shared<GetPolicyAssetScopeResponseBodyAssetScope>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPolicyAssetScopeResponseBody() = default;
};
class GetPolicyAssetScopeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPolicyAssetScopeResponseBody> body{};

  GetPolicyAssetScopeResponse() {}

  explicit GetPolicyAssetScopeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPolicyAssetScopeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPolicyAssetScopeResponseBody>(model1);
      }
    }
  }


  virtual ~GetPolicyAssetScopeResponse() = default;
};
class GetPolicyUserScopeRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  GetPolicyUserScopeRequest() {}

  explicit GetPolicyUserScopeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetPolicyUserScopeRequest() = default;
};
class GetPolicyUserScopeResponseBodyUserScope : public Darabonba::Model {
public:
  shared_ptr<string> scopeType{};
  shared_ptr<vector<string>> userGroupIds{};
  shared_ptr<vector<string>> userIds{};

  GetPolicyUserScopeResponseBodyUserScope() {}

  explicit GetPolicyUserScopeResponseBodyUserScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (userGroupIds) {
      res["UserGroupIds"] = boost::any(*userGroupIds);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
    if (m.find("UserGroupIds") != m.end() && !m["UserGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetPolicyUserScopeResponseBodyUserScope() = default;
};
class GetPolicyUserScopeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetPolicyUserScopeResponseBodyUserScope> userScope{};

  GetPolicyUserScopeResponseBody() {}

  explicit GetPolicyUserScopeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userScope) {
      res["UserScope"] = userScope ? boost::any(userScope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserScope") != m.end() && !m["UserScope"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserScope"].type()) {
        GetPolicyUserScopeResponseBodyUserScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserScope"]));
        userScope = make_shared<GetPolicyUserScopeResponseBodyUserScope>(model1);
      }
    }
  }


  virtual ~GetPolicyUserScopeResponseBody() = default;
};
class GetPolicyUserScopeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPolicyUserScopeResponseBody> body{};

  GetPolicyUserScopeResponse() {}

  explicit GetPolicyUserScopeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPolicyUserScopeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPolicyUserScopeResponseBody>(model1);
      }
    }
  }


  virtual ~GetPolicyUserScopeResponse() = default;
};
class GetRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};

  GetRuleRequest() {}

  explicit GetRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~GetRuleRequest() = default;
};
class GetRuleResponseBodyRuleDatabasesDatabaseAccounts : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountId{};

  GetRuleResponseBodyRuleDatabasesDatabaseAccounts() {}

  explicit GetRuleResponseBodyRuleDatabasesDatabaseAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
  }


  virtual ~GetRuleResponseBodyRuleDatabasesDatabaseAccounts() = default;
};
class GetRuleResponseBodyRuleDatabases : public Darabonba::Model {
public:
  shared_ptr<vector<GetRuleResponseBodyRuleDatabasesDatabaseAccounts>> databaseAccounts{};
  shared_ptr<string> databaseId{};

  GetRuleResponseBodyRuleDatabases() {}

  explicit GetRuleResponseBodyRuleDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*databaseAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseAccounts"] = boost::any(temp1);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccounts") != m.end() && !m["DatabaseAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseAccounts"].type()) {
        vector<GetRuleResponseBodyRuleDatabasesDatabaseAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRuleResponseBodyRuleDatabasesDatabaseAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseAccounts = make_shared<vector<GetRuleResponseBodyRuleDatabasesDatabaseAccounts>>(expect1);
      }
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
  }


  virtual ~GetRuleResponseBodyRuleDatabases() = default;
};
class GetRuleResponseBodyRuleHostGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostAccountNames{};
  shared_ptr<string> hostGroupId{};

  GetRuleResponseBodyRuleHostGroups() {}

  explicit GetRuleResponseBodyRuleHostGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountNames) {
      res["HostAccountNames"] = boost::any(*hostAccountNames);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountNames") != m.end() && !m["HostAccountNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostAccountNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostAccountNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostAccountNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
  }


  virtual ~GetRuleResponseBodyRuleHostGroups() = default;
};
class GetRuleResponseBodyRuleHostsHostAccounts : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountId{};

  GetRuleResponseBodyRuleHostsHostAccounts() {}

  explicit GetRuleResponseBodyRuleHostsHostAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
  }


  virtual ~GetRuleResponseBodyRuleHostsHostAccounts() = default;
};
class GetRuleResponseBodyRuleHosts : public Darabonba::Model {
public:
  shared_ptr<vector<GetRuleResponseBodyRuleHostsHostAccounts>> hostAccounts{};
  shared_ptr<string> hostId{};

  GetRuleResponseBodyRuleHosts() {}

  explicit GetRuleResponseBodyRuleHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccounts"] = boost::any(temp1);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccounts") != m.end() && !m["HostAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccounts"].type()) {
        vector<GetRuleResponseBodyRuleHostsHostAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRuleResponseBodyRuleHostsHostAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccounts = make_shared<vector<GetRuleResponseBodyRuleHostsHostAccounts>>(expect1);
      }
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
  }


  virtual ~GetRuleResponseBodyRuleHosts() = default;
};
class GetRuleResponseBodyRuleUserGroups : public Darabonba::Model {
public:
  shared_ptr<string> userGroupId{};

  GetRuleResponseBodyRuleUserGroups() {}

  explicit GetRuleResponseBodyRuleUserGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~GetRuleResponseBodyRuleUserGroups() = default;
};
class GetRuleResponseBodyRuleUsers : public Darabonba::Model {
public:
  shared_ptr<string> userId{};

  GetRuleResponseBodyRuleUsers() {}

  explicit GetRuleResponseBodyRuleUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetRuleResponseBodyRuleUsers() = default;
};
class GetRuleResponseBodyRule : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<GetRuleResponseBodyRuleDatabases>> databases{};
  shared_ptr<string> effectiveEndTime{};
  shared_ptr<string> effectiveStartTime{};
  shared_ptr<vector<GetRuleResponseBodyRuleHostGroups>> hostGroups{};
  shared_ptr<vector<GetRuleResponseBodyRuleHosts>> hosts{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<vector<GetRuleResponseBodyRuleUserGroups>> userGroups{};
  shared_ptr<vector<GetRuleResponseBodyRuleUsers>> users{};

  GetRuleResponseBodyRule() {}

  explicit GetRuleResponseBodyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (effectiveEndTime) {
      res["EffectiveEndTime"] = boost::any(*effectiveEndTime);
    }
    if (effectiveStartTime) {
      res["EffectiveStartTime"] = boost::any(*effectiveStartTime);
    }
    if (hostGroups) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroups"] = boost::any(temp1);
    }
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (userGroups) {
      vector<boost::any> temp1;
      for(auto item1:*userGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserGroups"] = boost::any(temp1);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<GetRuleResponseBodyRuleDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRuleResponseBodyRuleDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<GetRuleResponseBodyRuleDatabases>>(expect1);
      }
    }
    if (m.find("EffectiveEndTime") != m.end() && !m["EffectiveEndTime"].empty()) {
      effectiveEndTime = make_shared<string>(boost::any_cast<string>(m["EffectiveEndTime"]));
    }
    if (m.find("EffectiveStartTime") != m.end() && !m["EffectiveStartTime"].empty()) {
      effectiveStartTime = make_shared<string>(boost::any_cast<string>(m["EffectiveStartTime"]));
    }
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroups"].type()) {
        vector<GetRuleResponseBodyRuleHostGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRuleResponseBodyRuleHostGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroups = make_shared<vector<GetRuleResponseBodyRuleHostGroups>>(expect1);
      }
    }
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<GetRuleResponseBodyRuleHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRuleResponseBodyRuleHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<GetRuleResponseBodyRuleHosts>>(expect1);
      }
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("UserGroups") != m.end() && !m["UserGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["UserGroups"].type()) {
        vector<GetRuleResponseBodyRuleUserGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRuleResponseBodyRuleUserGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userGroups = make_shared<vector<GetRuleResponseBodyRuleUserGroups>>(expect1);
      }
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<GetRuleResponseBodyRuleUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRuleResponseBodyRuleUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<GetRuleResponseBodyRuleUsers>>(expect1);
      }
    }
  }


  virtual ~GetRuleResponseBodyRule() = default;
};
class GetRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetRuleResponseBodyRule> rule{};

  GetRuleResponseBody() {}

  explicit GetRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rule) {
      res["Rule"] = rule ? boost::any(rule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rule"].type()) {
        GetRuleResponseBodyRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rule"]));
        rule = make_shared<GetRuleResponseBodyRule>(model1);
      }
    }
  }


  virtual ~GetRuleResponseBody() = default;
};
class GetRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRuleResponseBody> body{};

  GetRuleResponse() {}

  explicit GetRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetRuleResponse() = default;
};
class GetUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  GetUserRequest() {}

  explicit GetUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetUserRequest() = default;
};
class GetUserResponseBodyUser : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> displayName{};
  shared_ptr<long> effectiveEndTime{};
  shared_ptr<long> effectiveStartTime{};
  shared_ptr<string> email{};
  shared_ptr<string> language{};
  shared_ptr<string> languageStatus{};
  shared_ptr<string> mobile{};
  shared_ptr<string> mobileCountryCode{};
  shared_ptr<bool> needResetPassword{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceUserId{};
  shared_ptr<vector<string>> twoFactorMethods{};
  shared_ptr<string> twoFactorStatus{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<vector<string>> userState{};

  GetUserResponseBodyUser() {}

  explicit GetUserResponseBodyUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (effectiveEndTime) {
      res["EffectiveEndTime"] = boost::any(*effectiveEndTime);
    }
    if (effectiveStartTime) {
      res["EffectiveStartTime"] = boost::any(*effectiveStartTime);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (languageStatus) {
      res["LanguageStatus"] = boost::any(*languageStatus);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (mobileCountryCode) {
      res["MobileCountryCode"] = boost::any(*mobileCountryCode);
    }
    if (needResetPassword) {
      res["NeedResetPassword"] = boost::any(*needResetPassword);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceUserId) {
      res["SourceUserId"] = boost::any(*sourceUserId);
    }
    if (twoFactorMethods) {
      res["TwoFactorMethods"] = boost::any(*twoFactorMethods);
    }
    if (twoFactorStatus) {
      res["TwoFactorStatus"] = boost::any(*twoFactorStatus);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("EffectiveEndTime") != m.end() && !m["EffectiveEndTime"].empty()) {
      effectiveEndTime = make_shared<long>(boost::any_cast<long>(m["EffectiveEndTime"]));
    }
    if (m.find("EffectiveStartTime") != m.end() && !m["EffectiveStartTime"].empty()) {
      effectiveStartTime = make_shared<long>(boost::any_cast<long>(m["EffectiveStartTime"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LanguageStatus") != m.end() && !m["LanguageStatus"].empty()) {
      languageStatus = make_shared<string>(boost::any_cast<string>(m["LanguageStatus"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("MobileCountryCode") != m.end() && !m["MobileCountryCode"].empty()) {
      mobileCountryCode = make_shared<string>(boost::any_cast<string>(m["MobileCountryCode"]));
    }
    if (m.find("NeedResetPassword") != m.end() && !m["NeedResetPassword"].empty()) {
      needResetPassword = make_shared<bool>(boost::any_cast<bool>(m["NeedResetPassword"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceUserId") != m.end() && !m["SourceUserId"].empty()) {
      sourceUserId = make_shared<string>(boost::any_cast<string>(m["SourceUserId"]));
    }
    if (m.find("TwoFactorMethods") != m.end() && !m["TwoFactorMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TwoFactorMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TwoFactorMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      twoFactorMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TwoFactorStatus") != m.end() && !m["TwoFactorStatus"].empty()) {
      twoFactorStatus = make_shared<string>(boost::any_cast<string>(m["TwoFactorStatus"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserState"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserState"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userState = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetUserResponseBodyUser() = default;
};
class GetUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetUserResponseBodyUser> user{};

  GetUserResponseBody() {}

  explicit GetUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (user) {
      res["User"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(map<string, boost::any>) == m["User"].type()) {
        GetUserResponseBodyUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["User"]));
        user = make_shared<GetUserResponseBodyUser>(model1);
      }
    }
  }


  virtual ~GetUserResponseBody() = default;
};
class GetUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserResponseBody> body{};

  GetUserResponse() {}

  explicit GetUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserResponse() = default;
};
class GetUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  GetUserGroupRequest() {}

  explicit GetUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~GetUserGroupRequest() = default;
};
class GetUserGroupResponseBodyUserGroup : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> userGroupId{};
  shared_ptr<string> userGroupName{};

  GetUserGroupResponseBodyUserGroup() {}

  explicit GetUserGroupResponseBodyUserGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userGroupName) {
      res["UserGroupName"] = boost::any(*userGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserGroupName") != m.end() && !m["UserGroupName"].empty()) {
      userGroupName = make_shared<string>(boost::any_cast<string>(m["UserGroupName"]));
    }
  }


  virtual ~GetUserGroupResponseBodyUserGroup() = default;
};
class GetUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetUserGroupResponseBodyUserGroup> userGroup{};

  GetUserGroupResponseBody() {}

  explicit GetUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userGroup) {
      res["UserGroup"] = userGroup ? boost::any(userGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserGroup") != m.end() && !m["UserGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserGroup"].type()) {
        GetUserGroupResponseBodyUserGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserGroup"]));
        userGroup = make_shared<GetUserGroupResponseBodyUserGroup>(model1);
      }
    }
  }


  virtual ~GetUserGroupResponseBody() = default;
};
class GetUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserGroupResponseBody> body{};

  GetUserGroupResponse() {}

  explicit GetUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserGroupResponse() = default;
};
class ListApproveCommandsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListApproveCommandsRequest() {}

  explicit ListApproveCommandsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListApproveCommandsRequest() = default;
};
class ListApproveCommandsResponseBodyApproveCommands : public Darabonba::Model {
public:
  shared_ptr<string> approveCommandId{};
  shared_ptr<string> assetAccountName{};
  shared_ptr<string> assetIp{};
  shared_ptr<string> assetName{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> clientUser{};
  shared_ptr<string> command{};
  shared_ptr<string> createTime{};
  shared_ptr<string> protocolName{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> state{};

  ListApproveCommandsResponseBodyApproveCommands() {}

  explicit ListApproveCommandsResponseBodyApproveCommands(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approveCommandId) {
      res["ApproveCommandId"] = boost::any(*approveCommandId);
    }
    if (assetAccountName) {
      res["AssetAccountName"] = boost::any(*assetAccountName);
    }
    if (assetIp) {
      res["AssetIp"] = boost::any(*assetIp);
    }
    if (assetName) {
      res["AssetName"] = boost::any(*assetName);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (clientUser) {
      res["ClientUser"] = boost::any(*clientUser);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApproveCommandId") != m.end() && !m["ApproveCommandId"].empty()) {
      approveCommandId = make_shared<string>(boost::any_cast<string>(m["ApproveCommandId"]));
    }
    if (m.find("AssetAccountName") != m.end() && !m["AssetAccountName"].empty()) {
      assetAccountName = make_shared<string>(boost::any_cast<string>(m["AssetAccountName"]));
    }
    if (m.find("AssetIp") != m.end() && !m["AssetIp"].empty()) {
      assetIp = make_shared<string>(boost::any_cast<string>(m["AssetIp"]));
    }
    if (m.find("AssetName") != m.end() && !m["AssetName"].empty()) {
      assetName = make_shared<string>(boost::any_cast<string>(m["AssetName"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ClientUser") != m.end() && !m["ClientUser"].empty()) {
      clientUser = make_shared<string>(boost::any_cast<string>(m["ClientUser"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListApproveCommandsResponseBodyApproveCommands() = default;
};
class ListApproveCommandsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApproveCommandsResponseBodyApproveCommands>> approveCommands{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApproveCommandsResponseBody() {}

  explicit ListApproveCommandsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approveCommands) {
      vector<boost::any> temp1;
      for(auto item1:*approveCommands){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApproveCommands"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApproveCommands") != m.end() && !m["ApproveCommands"].empty()) {
      if (typeid(vector<boost::any>) == m["ApproveCommands"].type()) {
        vector<ListApproveCommandsResponseBodyApproveCommands> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApproveCommands"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApproveCommandsResponseBodyApproveCommands model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        approveCommands = make_shared<vector<ListApproveCommandsResponseBodyApproveCommands>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApproveCommandsResponseBody() = default;
};
class ListApproveCommandsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApproveCommandsResponseBody> body{};

  ListApproveCommandsResponse() {}

  explicit ListApproveCommandsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApproveCommandsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApproveCommandsResponseBody>(model1);
      }
    }
  }


  virtual ~ListApproveCommandsResponse() = default;
};
class ListDatabaseAccountsRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListDatabaseAccountsRequest() {}

  explicit ListDatabaseAccountsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountName) {
      res["DatabaseAccountName"] = boost::any(*databaseAccountName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountName") != m.end() && !m["DatabaseAccountName"].empty()) {
      databaseAccountName = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListDatabaseAccountsRequest() = default;
};
class ListDatabaseAccountsResponseBodyDatabaseAccounts : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> databaseAccountName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> databaseSchema{};
  shared_ptr<string> hasPassword{};

  ListDatabaseAccountsResponseBodyDatabaseAccounts() {}

  explicit ListDatabaseAccountsResponseBodyDatabaseAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (databaseAccountName) {
      res["DatabaseAccountName"] = boost::any(*databaseAccountName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (databaseSchema) {
      res["DatabaseSchema"] = boost::any(*databaseSchema);
    }
    if (hasPassword) {
      res["HasPassword"] = boost::any(*hasPassword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("DatabaseAccountName") != m.end() && !m["DatabaseAccountName"].empty()) {
      databaseAccountName = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatabaseSchema") != m.end() && !m["DatabaseSchema"].empty()) {
      databaseSchema = make_shared<string>(boost::any_cast<string>(m["DatabaseSchema"]));
    }
    if (m.find("HasPassword") != m.end() && !m["HasPassword"].empty()) {
      hasPassword = make_shared<string>(boost::any_cast<string>(m["HasPassword"]));
    }
  }


  virtual ~ListDatabaseAccountsResponseBodyDatabaseAccounts() = default;
};
class ListDatabaseAccountsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDatabaseAccountsResponseBodyDatabaseAccounts>> databaseAccounts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDatabaseAccountsResponseBody() {}

  explicit ListDatabaseAccountsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*databaseAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseAccounts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccounts") != m.end() && !m["DatabaseAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseAccounts"].type()) {
        vector<ListDatabaseAccountsResponseBodyDatabaseAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatabaseAccountsResponseBodyDatabaseAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseAccounts = make_shared<vector<ListDatabaseAccountsResponseBodyDatabaseAccounts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDatabaseAccountsResponseBody() = default;
};
class ListDatabaseAccountsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatabaseAccountsResponseBody> body{};

  ListDatabaseAccountsResponse() {}

  explicit ListDatabaseAccountsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatabaseAccountsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatabaseAccountsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatabaseAccountsResponse() = default;
};
class ListDatabaseAccountsForUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  ListDatabaseAccountsForUserRequest() {}

  explicit ListDatabaseAccountsForUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountName) {
      res["DatabaseAccountName"] = boost::any(*databaseAccountName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountName") != m.end() && !m["DatabaseAccountName"].empty()) {
      databaseAccountName = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListDatabaseAccountsForUserRequest() = default;
};
class ListDatabaseAccountsForUserResponseBodyDatabaseAccounts : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> databaseAccountName{};
  shared_ptr<string> databaseId{};
  shared_ptr<bool> isAuthorized{};
  shared_ptr<string> protocolName{};

  ListDatabaseAccountsForUserResponseBodyDatabaseAccounts() {}

  explicit ListDatabaseAccountsForUserResponseBodyDatabaseAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (databaseAccountName) {
      res["DatabaseAccountName"] = boost::any(*databaseAccountName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (isAuthorized) {
      res["IsAuthorized"] = boost::any(*isAuthorized);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("DatabaseAccountName") != m.end() && !m["DatabaseAccountName"].empty()) {
      databaseAccountName = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("IsAuthorized") != m.end() && !m["IsAuthorized"].empty()) {
      isAuthorized = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorized"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
  }


  virtual ~ListDatabaseAccountsForUserResponseBodyDatabaseAccounts() = default;
};
class ListDatabaseAccountsForUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDatabaseAccountsForUserResponseBodyDatabaseAccounts>> databaseAccounts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDatabaseAccountsForUserResponseBody() {}

  explicit ListDatabaseAccountsForUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*databaseAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseAccounts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccounts") != m.end() && !m["DatabaseAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseAccounts"].type()) {
        vector<ListDatabaseAccountsForUserResponseBodyDatabaseAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatabaseAccountsForUserResponseBodyDatabaseAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseAccounts = make_shared<vector<ListDatabaseAccountsForUserResponseBodyDatabaseAccounts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDatabaseAccountsForUserResponseBody() = default;
};
class ListDatabaseAccountsForUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatabaseAccountsForUserResponseBody> body{};

  ListDatabaseAccountsForUserResponse() {}

  explicit ListDatabaseAccountsForUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatabaseAccountsForUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatabaseAccountsForUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatabaseAccountsForUserResponse() = default;
};
class ListDatabaseAccountsForUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  ListDatabaseAccountsForUserGroupRequest() {}

  explicit ListDatabaseAccountsForUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountName) {
      res["DatabaseAccountName"] = boost::any(*databaseAccountName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountName") != m.end() && !m["DatabaseAccountName"].empty()) {
      databaseAccountName = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~ListDatabaseAccountsForUserGroupRequest() = default;
};
class ListDatabaseAccountsForUserGroupResponseBodyDatabaseAccounts : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> databaseAccountName{};
  shared_ptr<string> databaseId{};
  shared_ptr<bool> isAuthorized{};
  shared_ptr<string> protocolName{};

  ListDatabaseAccountsForUserGroupResponseBodyDatabaseAccounts() {}

  explicit ListDatabaseAccountsForUserGroupResponseBodyDatabaseAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (databaseAccountName) {
      res["DatabaseAccountName"] = boost::any(*databaseAccountName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (isAuthorized) {
      res["IsAuthorized"] = boost::any(*isAuthorized);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("DatabaseAccountName") != m.end() && !m["DatabaseAccountName"].empty()) {
      databaseAccountName = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("IsAuthorized") != m.end() && !m["IsAuthorized"].empty()) {
      isAuthorized = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorized"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
  }


  virtual ~ListDatabaseAccountsForUserGroupResponseBodyDatabaseAccounts() = default;
};
class ListDatabaseAccountsForUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDatabaseAccountsForUserGroupResponseBodyDatabaseAccounts>> databaseAccounts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDatabaseAccountsForUserGroupResponseBody() {}

  explicit ListDatabaseAccountsForUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*databaseAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseAccounts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccounts") != m.end() && !m["DatabaseAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseAccounts"].type()) {
        vector<ListDatabaseAccountsForUserGroupResponseBodyDatabaseAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatabaseAccountsForUserGroupResponseBodyDatabaseAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseAccounts = make_shared<vector<ListDatabaseAccountsForUserGroupResponseBodyDatabaseAccounts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDatabaseAccountsForUserGroupResponseBody() = default;
};
class ListDatabaseAccountsForUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatabaseAccountsForUserGroupResponseBody> body{};

  ListDatabaseAccountsForUserGroupResponse() {}

  explicit ListDatabaseAccountsForUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatabaseAccountsForUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatabaseAccountsForUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatabaseAccountsForUserGroupResponse() = default;
};
class ListDatabasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};

  ListDatabasesRequest() {}

  explicit ListDatabasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~ListDatabasesRequest() = default;
};
class ListDatabasesResponseBodyDatabases : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> databaseName{};
  shared_ptr<long> databasePort{};
  shared_ptr<string> databasePrivateAddress{};
  shared_ptr<string> databasePublicAddress{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceRegionId{};
  shared_ptr<string> sourceInstanceState{};

  ListDatabasesResponseBodyDatabases() {}

  explicit ListDatabasesResponseBodyDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databasePort) {
      res["DatabasePort"] = boost::any(*databasePort);
    }
    if (databasePrivateAddress) {
      res["DatabasePrivateAddress"] = boost::any(*databasePrivateAddress);
    }
    if (databasePublicAddress) {
      res["DatabasePublicAddress"] = boost::any(*databasePublicAddress);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceRegionId) {
      res["SourceInstanceRegionId"] = boost::any(*sourceInstanceRegionId);
    }
    if (sourceInstanceState) {
      res["SourceInstanceState"] = boost::any(*sourceInstanceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabasePort") != m.end() && !m["DatabasePort"].empty()) {
      databasePort = make_shared<long>(boost::any_cast<long>(m["DatabasePort"]));
    }
    if (m.find("DatabasePrivateAddress") != m.end() && !m["DatabasePrivateAddress"].empty()) {
      databasePrivateAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePrivateAddress"]));
    }
    if (m.find("DatabasePublicAddress") != m.end() && !m["DatabasePublicAddress"].empty()) {
      databasePublicAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePublicAddress"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceRegionId") != m.end() && !m["SourceInstanceRegionId"].empty()) {
      sourceInstanceRegionId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceRegionId"]));
    }
    if (m.find("SourceInstanceState") != m.end() && !m["SourceInstanceState"].empty()) {
      sourceInstanceState = make_shared<string>(boost::any_cast<string>(m["SourceInstanceState"]));
    }
  }


  virtual ~ListDatabasesResponseBodyDatabases() = default;
};
class ListDatabasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDatabasesResponseBodyDatabases>> databases{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDatabasesResponseBody() {}

  explicit ListDatabasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<ListDatabasesResponseBodyDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatabasesResponseBodyDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<ListDatabasesResponseBodyDatabases>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDatabasesResponseBody() = default;
};
class ListDatabasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatabasesResponseBody> body{};

  ListDatabasesResponse() {}

  explicit ListDatabasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatabasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatabasesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatabasesResponse() = default;
};
class ListDatabasesForUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseAddress{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  ListDatabasesForUserRequest() {}

  explicit ListDatabasesForUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAddress) {
      res["DatabaseAddress"] = boost::any(*databaseAddress);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAddress") != m.end() && !m["DatabaseAddress"].empty()) {
      databaseAddress = make_shared<string>(boost::any_cast<string>(m["DatabaseAddress"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListDatabasesForUserRequest() = default;
};
class ListDatabasesForUserResponseBodyDatabases : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> databaseName{};
  shared_ptr<long> databasePort{};
  shared_ptr<string> databasePrivateAddress{};
  shared_ptr<string> databasePublicAddress{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};

  ListDatabasesForUserResponseBodyDatabases() {}

  explicit ListDatabasesForUserResponseBodyDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databasePort) {
      res["DatabasePort"] = boost::any(*databasePort);
    }
    if (databasePrivateAddress) {
      res["DatabasePrivateAddress"] = boost::any(*databasePrivateAddress);
    }
    if (databasePublicAddress) {
      res["DatabasePublicAddress"] = boost::any(*databasePublicAddress);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabasePort") != m.end() && !m["DatabasePort"].empty()) {
      databasePort = make_shared<long>(boost::any_cast<long>(m["DatabasePort"]));
    }
    if (m.find("DatabasePrivateAddress") != m.end() && !m["DatabasePrivateAddress"].empty()) {
      databasePrivateAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePrivateAddress"]));
    }
    if (m.find("DatabasePublicAddress") != m.end() && !m["DatabasePublicAddress"].empty()) {
      databasePublicAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePublicAddress"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
  }


  virtual ~ListDatabasesForUserResponseBodyDatabases() = default;
};
class ListDatabasesForUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDatabasesForUserResponseBodyDatabases>> databases{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDatabasesForUserResponseBody() {}

  explicit ListDatabasesForUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<ListDatabasesForUserResponseBodyDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatabasesForUserResponseBodyDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<ListDatabasesForUserResponseBodyDatabases>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDatabasesForUserResponseBody() = default;
};
class ListDatabasesForUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatabasesForUserResponseBody> body{};

  ListDatabasesForUserResponse() {}

  explicit ListDatabasesForUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatabasesForUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatabasesForUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatabasesForUserResponse() = default;
};
class ListDatabasesForUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseAddress{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  ListDatabasesForUserGroupRequest() {}

  explicit ListDatabasesForUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAddress) {
      res["DatabaseAddress"] = boost::any(*databaseAddress);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAddress") != m.end() && !m["DatabaseAddress"].empty()) {
      databaseAddress = make_shared<string>(boost::any_cast<string>(m["DatabaseAddress"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~ListDatabasesForUserGroupRequest() = default;
};
class ListDatabasesForUserGroupResponseBodyDatabases : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<long> databaseAccountCount{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> databaseName{};
  shared_ptr<long> databasePort{};
  shared_ptr<string> databasePrivateAddress{};
  shared_ptr<string> databasePublicAddress{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};

  ListDatabasesForUserGroupResponseBodyDatabases() {}

  explicit ListDatabasesForUserGroupResponseBodyDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (databaseAccountCount) {
      res["DatabaseAccountCount"] = boost::any(*databaseAccountCount);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databasePort) {
      res["DatabasePort"] = boost::any(*databasePort);
    }
    if (databasePrivateAddress) {
      res["DatabasePrivateAddress"] = boost::any(*databasePrivateAddress);
    }
    if (databasePublicAddress) {
      res["DatabasePublicAddress"] = boost::any(*databasePublicAddress);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DatabaseAccountCount") != m.end() && !m["DatabaseAccountCount"].empty()) {
      databaseAccountCount = make_shared<long>(boost::any_cast<long>(m["DatabaseAccountCount"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabasePort") != m.end() && !m["DatabasePort"].empty()) {
      databasePort = make_shared<long>(boost::any_cast<long>(m["DatabasePort"]));
    }
    if (m.find("DatabasePrivateAddress") != m.end() && !m["DatabasePrivateAddress"].empty()) {
      databasePrivateAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePrivateAddress"]));
    }
    if (m.find("DatabasePublicAddress") != m.end() && !m["DatabasePublicAddress"].empty()) {
      databasePublicAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePublicAddress"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
  }


  virtual ~ListDatabasesForUserGroupResponseBodyDatabases() = default;
};
class ListDatabasesForUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDatabasesForUserGroupResponseBodyDatabases>> databases{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDatabasesForUserGroupResponseBody() {}

  explicit ListDatabasesForUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<ListDatabasesForUserGroupResponseBodyDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatabasesForUserGroupResponseBodyDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<ListDatabasesForUserGroupResponseBodyDatabases>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDatabasesForUserGroupResponseBody() = default;
};
class ListDatabasesForUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatabasesForUserGroupResponseBody> body{};

  ListDatabasesForUserGroupResponse() {}

  explicit ListDatabasesForUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatabasesForUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatabasesForUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatabasesForUserGroupResponse() = default;
};
class ListHostAccountsRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> protocolName{};
  shared_ptr<string> regionId{};

  ListHostAccountsRequest() {}

  explicit ListHostAccountsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListHostAccountsRequest() = default;
};
class ListHostAccountsResponseBodyHostAccounts : public Darabonba::Model {
public:
  shared_ptr<bool> hasPassword{};
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> hostShareKeyName{};
  shared_ptr<string> privateKeyFingerprint{};
  shared_ptr<string> protocolName{};

  ListHostAccountsResponseBodyHostAccounts() {}

  explicit ListHostAccountsResponseBodyHostAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasPassword) {
      res["HasPassword"] = boost::any(*hasPassword);
    }
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (hostShareKeyName) {
      res["HostShareKeyName"] = boost::any(*hostShareKeyName);
    }
    if (privateKeyFingerprint) {
      res["PrivateKeyFingerprint"] = boost::any(*privateKeyFingerprint);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasPassword") != m.end() && !m["HasPassword"].empty()) {
      hasPassword = make_shared<bool>(boost::any_cast<bool>(m["HasPassword"]));
    }
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("HostShareKeyName") != m.end() && !m["HostShareKeyName"].empty()) {
      hostShareKeyName = make_shared<string>(boost::any_cast<string>(m["HostShareKeyName"]));
    }
    if (m.find("PrivateKeyFingerprint") != m.end() && !m["PrivateKeyFingerprint"].empty()) {
      privateKeyFingerprint = make_shared<string>(boost::any_cast<string>(m["PrivateKeyFingerprint"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
  }


  virtual ~ListHostAccountsResponseBodyHostAccounts() = default;
};
class ListHostAccountsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHostAccountsResponseBodyHostAccounts>> hostAccounts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHostAccountsResponseBody() {}

  explicit ListHostAccountsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccounts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccounts") != m.end() && !m["HostAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccounts"].type()) {
        vector<ListHostAccountsResponseBodyHostAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostAccountsResponseBodyHostAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccounts = make_shared<vector<ListHostAccountsResponseBodyHostAccounts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHostAccountsResponseBody() = default;
};
class ListHostAccountsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostAccountsResponseBody> body{};

  ListHostAccountsResponse() {}

  explicit ListHostAccountsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostAccountsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostAccountsResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostAccountsResponse() = default;
};
class ListHostAccountsForHostShareKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListHostAccountsForHostShareKeyRequest() {}

  explicit ListHostAccountsForHostShareKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListHostAccountsForHostShareKeyRequest() = default;
};
class ListHostAccountsForHostShareKeyResponseBodyHostAccounts : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostsAccountId{};
  shared_ptr<string> protocolName{};

  ListHostAccountsForHostShareKeyResponseBodyHostAccounts() {}

  explicit ListHostAccountsForHostShareKeyResponseBodyHostAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostsAccountId) {
      res["HostsAccountId"] = boost::any(*hostsAccountId);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostsAccountId") != m.end() && !m["HostsAccountId"].empty()) {
      hostsAccountId = make_shared<string>(boost::any_cast<string>(m["HostsAccountId"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
  }


  virtual ~ListHostAccountsForHostShareKeyResponseBodyHostAccounts() = default;
};
class ListHostAccountsForHostShareKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHostAccountsForHostShareKeyResponseBodyHostAccounts>> hostAccounts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHostAccountsForHostShareKeyResponseBody() {}

  explicit ListHostAccountsForHostShareKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccounts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccounts") != m.end() && !m["HostAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccounts"].type()) {
        vector<ListHostAccountsForHostShareKeyResponseBodyHostAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostAccountsForHostShareKeyResponseBodyHostAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccounts = make_shared<vector<ListHostAccountsForHostShareKeyResponseBodyHostAccounts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHostAccountsForHostShareKeyResponseBody() = default;
};
class ListHostAccountsForHostShareKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostAccountsForHostShareKeyResponseBody> body{};

  ListHostAccountsForHostShareKeyResponse() {}

  explicit ListHostAccountsForHostShareKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostAccountsForHostShareKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostAccountsForHostShareKeyResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostAccountsForHostShareKeyResponse() = default;
};
class ListHostAccountsForUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  ListHostAccountsForUserRequest() {}

  explicit ListHostAccountsForUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListHostAccountsForUserRequest() = default;
};
class ListHostAccountsForUserResponseBodyHostAccounts : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostId{};
  shared_ptr<bool> isAuthorized{};
  shared_ptr<string> protocolName{};

  ListHostAccountsForUserResponseBodyHostAccounts() {}

  explicit ListHostAccountsForUserResponseBodyHostAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (isAuthorized) {
      res["IsAuthorized"] = boost::any(*isAuthorized);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("IsAuthorized") != m.end() && !m["IsAuthorized"].empty()) {
      isAuthorized = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorized"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
  }


  virtual ~ListHostAccountsForUserResponseBodyHostAccounts() = default;
};
class ListHostAccountsForUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHostAccountsForUserResponseBodyHostAccounts>> hostAccounts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHostAccountsForUserResponseBody() {}

  explicit ListHostAccountsForUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccounts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccounts") != m.end() && !m["HostAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccounts"].type()) {
        vector<ListHostAccountsForUserResponseBodyHostAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostAccountsForUserResponseBodyHostAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccounts = make_shared<vector<ListHostAccountsForUserResponseBodyHostAccounts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHostAccountsForUserResponseBody() = default;
};
class ListHostAccountsForUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostAccountsForUserResponseBody> body{};

  ListHostAccountsForUserResponse() {}

  explicit ListHostAccountsForUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostAccountsForUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostAccountsForUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostAccountsForUserResponse() = default;
};
class ListHostAccountsForUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  ListHostAccountsForUserGroupRequest() {}

  explicit ListHostAccountsForUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~ListHostAccountsForUserGroupRequest() = default;
};
class ListHostAccountsForUserGroupResponseBodyHostAccounts : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostId{};
  shared_ptr<bool> isAuthorized{};
  shared_ptr<string> protocolName{};

  ListHostAccountsForUserGroupResponseBodyHostAccounts() {}

  explicit ListHostAccountsForUserGroupResponseBodyHostAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (isAuthorized) {
      res["IsAuthorized"] = boost::any(*isAuthorized);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("IsAuthorized") != m.end() && !m["IsAuthorized"].empty()) {
      isAuthorized = make_shared<bool>(boost::any_cast<bool>(m["IsAuthorized"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
  }


  virtual ~ListHostAccountsForUserGroupResponseBodyHostAccounts() = default;
};
class ListHostAccountsForUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHostAccountsForUserGroupResponseBodyHostAccounts>> hostAccounts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHostAccountsForUserGroupResponseBody() {}

  explicit ListHostAccountsForUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccounts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccounts") != m.end() && !m["HostAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccounts"].type()) {
        vector<ListHostAccountsForUserGroupResponseBodyHostAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostAccountsForUserGroupResponseBodyHostAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccounts = make_shared<vector<ListHostAccountsForUserGroupResponseBodyHostAccounts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHostAccountsForUserGroupResponseBody() = default;
};
class ListHostAccountsForUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostAccountsForUserGroupResponseBody> body{};

  ListHostAccountsForUserGroupResponse() {}

  explicit ListHostAccountsForUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostAccountsForUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostAccountsForUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostAccountsForUserGroupResponse() = default;
};
class ListHostGroupAccountNamesForUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  ListHostGroupAccountNamesForUserRequest() {}

  explicit ListHostGroupAccountNamesForUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListHostGroupAccountNamesForUserRequest() = default;
};
class ListHostGroupAccountNamesForUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostAccountNames{};
  shared_ptr<string> requestId{};

  ListHostGroupAccountNamesForUserResponseBody() {}

  explicit ListHostGroupAccountNamesForUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountNames) {
      res["HostAccountNames"] = boost::any(*hostAccountNames);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountNames") != m.end() && !m["HostAccountNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostAccountNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostAccountNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostAccountNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListHostGroupAccountNamesForUserResponseBody() = default;
};
class ListHostGroupAccountNamesForUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostGroupAccountNamesForUserResponseBody> body{};

  ListHostGroupAccountNamesForUserResponse() {}

  explicit ListHostGroupAccountNamesForUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostGroupAccountNamesForUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostGroupAccountNamesForUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostGroupAccountNamesForUserResponse() = default;
};
class ListHostGroupAccountNamesForUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  ListHostGroupAccountNamesForUserGroupRequest() {}

  explicit ListHostGroupAccountNamesForUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~ListHostGroupAccountNamesForUserGroupRequest() = default;
};
class ListHostGroupAccountNamesForUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostAccountNames{};
  shared_ptr<string> requestId{};

  ListHostGroupAccountNamesForUserGroupResponseBody() {}

  explicit ListHostGroupAccountNamesForUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountNames) {
      res["HostAccountNames"] = boost::any(*hostAccountNames);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountNames") != m.end() && !m["HostAccountNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostAccountNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostAccountNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostAccountNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListHostGroupAccountNamesForUserGroupResponseBody() = default;
};
class ListHostGroupAccountNamesForUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostGroupAccountNamesForUserGroupResponseBody> body{};

  ListHostGroupAccountNamesForUserGroupResponse() {}

  explicit ListHostGroupAccountNamesForUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostGroupAccountNamesForUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostGroupAccountNamesForUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostGroupAccountNamesForUserGroupResponse() = default;
};
class ListHostGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListHostGroupsRequest() {}

  explicit ListHostGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListHostGroupsRequest() = default;
};
class ListHostGroupsResponseBodyHostGroups : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<long> memberCount{};

  ListHostGroupsResponseBodyHostGroups() {}

  explicit ListHostGroupsResponseBodyHostGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
  }


  virtual ~ListHostGroupsResponseBodyHostGroups() = default;
};
class ListHostGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHostGroupsResponseBodyHostGroups>> hostGroups{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHostGroupsResponseBody() {}

  explicit ListHostGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroups) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroups"].type()) {
        vector<ListHostGroupsResponseBodyHostGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostGroupsResponseBodyHostGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroups = make_shared<vector<ListHostGroupsResponseBodyHostGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHostGroupsResponseBody() = default;
};
class ListHostGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostGroupsResponseBody> body{};

  ListHostGroupsResponse() {}

  explicit ListHostGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostGroupsResponse() = default;
};
class ListHostGroupsForUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mode{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  ListHostGroupsForUserRequest() {}

  explicit ListHostGroupsForUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListHostGroupsForUserRequest() = default;
};
class ListHostGroupsForUserResponseBodyHostGroups : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};

  ListHostGroupsForUserResponseBodyHostGroups() {}

  explicit ListHostGroupsForUserResponseBodyHostGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
  }


  virtual ~ListHostGroupsForUserResponseBodyHostGroups() = default;
};
class ListHostGroupsForUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHostGroupsForUserResponseBodyHostGroups>> hostGroups{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHostGroupsForUserResponseBody() {}

  explicit ListHostGroupsForUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroups) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroups"].type()) {
        vector<ListHostGroupsForUserResponseBodyHostGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostGroupsForUserResponseBodyHostGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroups = make_shared<vector<ListHostGroupsForUserResponseBodyHostGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHostGroupsForUserResponseBody() = default;
};
class ListHostGroupsForUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostGroupsForUserResponseBody> body{};

  ListHostGroupsForUserResponse() {}

  explicit ListHostGroupsForUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostGroupsForUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostGroupsForUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostGroupsForUserResponse() = default;
};
class ListHostGroupsForUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mode{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  ListHostGroupsForUserGroupRequest() {}

  explicit ListHostGroupsForUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~ListHostGroupsForUserGroupRequest() = default;
};
class ListHostGroupsForUserGroupResponseBodyHostGroups : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};

  ListHostGroupsForUserGroupResponseBodyHostGroups() {}

  explicit ListHostGroupsForUserGroupResponseBodyHostGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
  }


  virtual ~ListHostGroupsForUserGroupResponseBodyHostGroups() = default;
};
class ListHostGroupsForUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHostGroupsForUserGroupResponseBodyHostGroups>> hostGroups{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHostGroupsForUserGroupResponseBody() {}

  explicit ListHostGroupsForUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroups) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroups"].type()) {
        vector<ListHostGroupsForUserGroupResponseBodyHostGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostGroupsForUserGroupResponseBodyHostGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroups = make_shared<vector<ListHostGroupsForUserGroupResponseBodyHostGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHostGroupsForUserGroupResponseBody() = default;
};
class ListHostGroupsForUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostGroupsForUserGroupResponseBody> body{};

  ListHostGroupsForUserGroupResponse() {}

  explicit ListHostGroupsForUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostGroupsForUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostGroupsForUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostGroupsForUserGroupResponse() = default;
};
class ListHostShareKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListHostShareKeysRequest() {}

  explicit ListHostShareKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListHostShareKeysRequest() = default;
};
class ListHostShareKeysResponseBodyHostShareKeys : public Darabonba::Model {
public:
  shared_ptr<long> hostAccountCount{};
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> hostShareKeyName{};
  shared_ptr<long> lastModifyKeyAt{};
  shared_ptr<string> privateKeyFingerPrint{};

  ListHostShareKeysResponseBodyHostShareKeys() {}

  explicit ListHostShareKeysResponseBodyHostShareKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountCount) {
      res["HostAccountCount"] = boost::any(*hostAccountCount);
    }
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (hostShareKeyName) {
      res["HostShareKeyName"] = boost::any(*hostShareKeyName);
    }
    if (lastModifyKeyAt) {
      res["LastModifyKeyAt"] = boost::any(*lastModifyKeyAt);
    }
    if (privateKeyFingerPrint) {
      res["PrivateKeyFingerPrint"] = boost::any(*privateKeyFingerPrint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountCount") != m.end() && !m["HostAccountCount"].empty()) {
      hostAccountCount = make_shared<long>(boost::any_cast<long>(m["HostAccountCount"]));
    }
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("HostShareKeyName") != m.end() && !m["HostShareKeyName"].empty()) {
      hostShareKeyName = make_shared<string>(boost::any_cast<string>(m["HostShareKeyName"]));
    }
    if (m.find("LastModifyKeyAt") != m.end() && !m["LastModifyKeyAt"].empty()) {
      lastModifyKeyAt = make_shared<long>(boost::any_cast<long>(m["LastModifyKeyAt"]));
    }
    if (m.find("PrivateKeyFingerPrint") != m.end() && !m["PrivateKeyFingerPrint"].empty()) {
      privateKeyFingerPrint = make_shared<string>(boost::any_cast<string>(m["PrivateKeyFingerPrint"]));
    }
  }


  virtual ~ListHostShareKeysResponseBodyHostShareKeys() = default;
};
class ListHostShareKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHostShareKeysResponseBodyHostShareKeys>> hostShareKeys{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHostShareKeysResponseBody() {}

  explicit ListHostShareKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostShareKeys) {
      vector<boost::any> temp1;
      for(auto item1:*hostShareKeys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostShareKeys"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostShareKeys") != m.end() && !m["HostShareKeys"].empty()) {
      if (typeid(vector<boost::any>) == m["HostShareKeys"].type()) {
        vector<ListHostShareKeysResponseBodyHostShareKeys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostShareKeys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostShareKeysResponseBodyHostShareKeys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostShareKeys = make_shared<vector<ListHostShareKeysResponseBodyHostShareKeys>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHostShareKeysResponseBody() = default;
};
class ListHostShareKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostShareKeysResponseBody> body{};

  ListHostShareKeysResponse() {}

  explicit ListHostShareKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostShareKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostShareKeysResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostShareKeysResponse() = default;
};
class ListHostsRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAddress{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> OSType{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceState{};

  ListHostsRequest() {}

  explicit ListHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAddress) {
      res["HostAddress"] = boost::any(*hostAddress);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceState) {
      res["SourceInstanceState"] = boost::any(*sourceInstanceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAddress") != m.end() && !m["HostAddress"].empty()) {
      hostAddress = make_shared<string>(boost::any_cast<string>(m["HostAddress"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceState") != m.end() && !m["SourceInstanceState"].empty()) {
      sourceInstanceState = make_shared<string>(boost::any_cast<string>(m["SourceInstanceState"]));
    }
  }


  virtual ~ListHostsRequest() = default;
};
class ListHostsResponseBodyHosts : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<long> hostAccountCount{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hostPrivateAddress{};
  shared_ptr<string> hostPublicAddress{};
  shared_ptr<string> OSType{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceState{};

  ListHostsResponseBodyHosts() {}

  explicit ListHostsResponseBodyHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostAccountCount) {
      res["HostAccountCount"] = boost::any(*hostAccountCount);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostPrivateAddress) {
      res["HostPrivateAddress"] = boost::any(*hostPrivateAddress);
    }
    if (hostPublicAddress) {
      res["HostPublicAddress"] = boost::any(*hostPublicAddress);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceState) {
      res["SourceInstanceState"] = boost::any(*sourceInstanceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostAccountCount") != m.end() && !m["HostAccountCount"].empty()) {
      hostAccountCount = make_shared<long>(boost::any_cast<long>(m["HostAccountCount"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostPrivateAddress") != m.end() && !m["HostPrivateAddress"].empty()) {
      hostPrivateAddress = make_shared<string>(boost::any_cast<string>(m["HostPrivateAddress"]));
    }
    if (m.find("HostPublicAddress") != m.end() && !m["HostPublicAddress"].empty()) {
      hostPublicAddress = make_shared<string>(boost::any_cast<string>(m["HostPublicAddress"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceState") != m.end() && !m["SourceInstanceState"].empty()) {
      sourceInstanceState = make_shared<string>(boost::any_cast<string>(m["SourceInstanceState"]));
    }
  }


  virtual ~ListHostsResponseBodyHosts() = default;
};
class ListHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHostsResponseBodyHosts>> hosts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHostsResponseBody() {}

  explicit ListHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<ListHostsResponseBodyHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostsResponseBodyHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<ListHostsResponseBodyHosts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHostsResponseBody() = default;
};
class ListHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostsResponseBody> body{};

  ListHostsResponse() {}

  explicit ListHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostsResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostsResponse() = default;
};
class ListHostsForUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAddress{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mode{};
  shared_ptr<string> OSType{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  ListHostsForUserRequest() {}

  explicit ListHostsForUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAddress) {
      res["HostAddress"] = boost::any(*hostAddress);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAddress") != m.end() && !m["HostAddress"].empty()) {
      hostAddress = make_shared<string>(boost::any_cast<string>(m["HostAddress"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListHostsForUserRequest() = default;
};
class ListHostsForUserResponseBodyHosts : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hostPrivateAddress{};
  shared_ptr<string> hostPublicAddress{};
  shared_ptr<string> OSType{};

  ListHostsForUserResponseBodyHosts() {}

  explicit ListHostsForUserResponseBodyHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostPrivateAddress) {
      res["HostPrivateAddress"] = boost::any(*hostPrivateAddress);
    }
    if (hostPublicAddress) {
      res["HostPublicAddress"] = boost::any(*hostPublicAddress);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostPrivateAddress") != m.end() && !m["HostPrivateAddress"].empty()) {
      hostPrivateAddress = make_shared<string>(boost::any_cast<string>(m["HostPrivateAddress"]));
    }
    if (m.find("HostPublicAddress") != m.end() && !m["HostPublicAddress"].empty()) {
      hostPublicAddress = make_shared<string>(boost::any_cast<string>(m["HostPublicAddress"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
  }


  virtual ~ListHostsForUserResponseBodyHosts() = default;
};
class ListHostsForUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHostsForUserResponseBodyHosts>> hosts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHostsForUserResponseBody() {}

  explicit ListHostsForUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<ListHostsForUserResponseBodyHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostsForUserResponseBodyHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<ListHostsForUserResponseBodyHosts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHostsForUserResponseBody() = default;
};
class ListHostsForUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostsForUserResponseBody> body{};

  ListHostsForUserResponse() {}

  explicit ListHostsForUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostsForUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostsForUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostsForUserResponse() = default;
};
class ListHostsForUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAddress{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mode{};
  shared_ptr<string> OSType{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};

  ListHostsForUserGroupRequest() {}

  explicit ListHostsForUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAddress) {
      res["HostAddress"] = boost::any(*hostAddress);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAddress") != m.end() && !m["HostAddress"].empty()) {
      hostAddress = make_shared<string>(boost::any_cast<string>(m["HostAddress"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~ListHostsForUserGroupRequest() = default;
};
class ListHostsForUserGroupResponseBodyHosts : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hostPrivateAddress{};
  shared_ptr<string> hostPublicAddress{};
  shared_ptr<string> OSType{};

  ListHostsForUserGroupResponseBodyHosts() {}

  explicit ListHostsForUserGroupResponseBodyHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostPrivateAddress) {
      res["HostPrivateAddress"] = boost::any(*hostPrivateAddress);
    }
    if (hostPublicAddress) {
      res["HostPublicAddress"] = boost::any(*hostPublicAddress);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostPrivateAddress") != m.end() && !m["HostPrivateAddress"].empty()) {
      hostPrivateAddress = make_shared<string>(boost::any_cast<string>(m["HostPrivateAddress"]));
    }
    if (m.find("HostPublicAddress") != m.end() && !m["HostPublicAddress"].empty()) {
      hostPublicAddress = make_shared<string>(boost::any_cast<string>(m["HostPublicAddress"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
  }


  virtual ~ListHostsForUserGroupResponseBodyHosts() = default;
};
class ListHostsForUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHostsForUserGroupResponseBodyHosts>> hosts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHostsForUserGroupResponseBody() {}

  explicit ListHostsForUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<ListHostsForUserGroupResponseBodyHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostsForUserGroupResponseBodyHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<ListHostsForUserGroupResponseBodyHosts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHostsForUserGroupResponseBody() = default;
};
class ListHostsForUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHostsForUserGroupResponseBody> body{};

  ListHostsForUserGroupResponse() {}

  explicit ListHostsForUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostsForUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostsForUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostsForUserGroupResponse() = default;
};
class ListNetworkDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainName{};
  shared_ptr<string> networkDomainType{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListNetworkDomainsRequest() {}

  explicit ListNetworkDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainName) {
      res["NetworkDomainName"] = boost::any(*networkDomainName);
    }
    if (networkDomainType) {
      res["NetworkDomainType"] = boost::any(*networkDomainType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainName") != m.end() && !m["NetworkDomainName"].empty()) {
      networkDomainName = make_shared<string>(boost::any_cast<string>(m["NetworkDomainName"]));
    }
    if (m.find("NetworkDomainType") != m.end() && !m["NetworkDomainType"].empty()) {
      networkDomainType = make_shared<string>(boost::any_cast<string>(m["NetworkDomainType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListNetworkDomainsRequest() = default;
};
class ListNetworkDomainsResponseBodyNetworkDomainsProxiesState : public Darabonba::Model {
public:
  shared_ptr<string> nodeType{};
  shared_ptr<string> proxyState{};

  ListNetworkDomainsResponseBodyNetworkDomainsProxiesState() {}

  explicit ListNetworkDomainsResponseBodyNetworkDomainsProxiesState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (proxyState) {
      res["ProxyState"] = boost::any(*proxyState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("ProxyState") != m.end() && !m["ProxyState"].empty()) {
      proxyState = make_shared<string>(boost::any_cast<string>(m["ProxyState"]));
    }
  }


  virtual ~ListNetworkDomainsResponseBodyNetworkDomainsProxiesState() = default;
};
class ListNetworkDomainsResponseBodyNetworkDomains : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<bool> default_{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> networkDomainName{};
  shared_ptr<string> networkDomainType{};
  shared_ptr<vector<ListNetworkDomainsResponseBodyNetworkDomainsProxiesState>> proxiesState{};

  ListNetworkDomainsResponseBodyNetworkDomains() {}

  explicit ListNetworkDomainsResponseBodyNetworkDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (default_) {
      res["Default"] = boost::any(*default_);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (networkDomainName) {
      res["NetworkDomainName"] = boost::any(*networkDomainName);
    }
    if (networkDomainType) {
      res["NetworkDomainType"] = boost::any(*networkDomainType);
    }
    if (proxiesState) {
      vector<boost::any> temp1;
      for(auto item1:*proxiesState){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProxiesState"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Default") != m.end() && !m["Default"].empty()) {
      default_ = make_shared<bool>(boost::any_cast<bool>(m["Default"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("NetworkDomainName") != m.end() && !m["NetworkDomainName"].empty()) {
      networkDomainName = make_shared<string>(boost::any_cast<string>(m["NetworkDomainName"]));
    }
    if (m.find("NetworkDomainType") != m.end() && !m["NetworkDomainType"].empty()) {
      networkDomainType = make_shared<string>(boost::any_cast<string>(m["NetworkDomainType"]));
    }
    if (m.find("ProxiesState") != m.end() && !m["ProxiesState"].empty()) {
      if (typeid(vector<boost::any>) == m["ProxiesState"].type()) {
        vector<ListNetworkDomainsResponseBodyNetworkDomainsProxiesState> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProxiesState"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNetworkDomainsResponseBodyNetworkDomainsProxiesState model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proxiesState = make_shared<vector<ListNetworkDomainsResponseBodyNetworkDomainsProxiesState>>(expect1);
      }
    }
  }


  virtual ~ListNetworkDomainsResponseBodyNetworkDomains() = default;
};
class ListNetworkDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListNetworkDomainsResponseBodyNetworkDomains>> networkDomains{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListNetworkDomainsResponseBody() {}

  explicit ListNetworkDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkDomains) {
      vector<boost::any> temp1;
      for(auto item1:*networkDomains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkDomains"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkDomains") != m.end() && !m["NetworkDomains"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkDomains"].type()) {
        vector<ListNetworkDomainsResponseBodyNetworkDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkDomains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNetworkDomainsResponseBodyNetworkDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkDomains = make_shared<vector<ListNetworkDomainsResponseBodyNetworkDomains>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListNetworkDomainsResponseBody() = default;
};
class ListNetworkDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNetworkDomainsResponseBody> body{};

  ListNetworkDomainsResponse() {}

  explicit ListNetworkDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNetworkDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNetworkDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~ListNetworkDomainsResponse() = default;
};
class ListOperationDatabaseAccountsRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListOperationDatabaseAccountsRequest() {}

  explicit ListOperationDatabaseAccountsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountName) {
      res["DatabaseAccountName"] = boost::any(*databaseAccountName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountName") != m.end() && !m["DatabaseAccountName"].empty()) {
      databaseAccountName = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListOperationDatabaseAccountsRequest() = default;
};
class ListOperationDatabaseAccountsResponseBodyDatabaseAccounts : public Darabonba::Model {
public:
  shared_ptr<string> DBName{};
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> databaseAccountName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> hasPassword{};
  shared_ptr<string> loginAttribute{};
  shared_ptr<string> protocolName{};

  ListOperationDatabaseAccountsResponseBodyDatabaseAccounts() {}

  explicit ListOperationDatabaseAccountsResponseBodyDatabaseAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBName) {
      res["DBName"] = boost::any(*DBName);
    }
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (databaseAccountName) {
      res["DatabaseAccountName"] = boost::any(*databaseAccountName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (hasPassword) {
      res["HasPassword"] = boost::any(*hasPassword);
    }
    if (loginAttribute) {
      res["LoginAttribute"] = boost::any(*loginAttribute);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBName") != m.end() && !m["DBName"].empty()) {
      DBName = make_shared<string>(boost::any_cast<string>(m["DBName"]));
    }
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("DatabaseAccountName") != m.end() && !m["DatabaseAccountName"].empty()) {
      databaseAccountName = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("HasPassword") != m.end() && !m["HasPassword"].empty()) {
      hasPassword = make_shared<string>(boost::any_cast<string>(m["HasPassword"]));
    }
    if (m.find("LoginAttribute") != m.end() && !m["LoginAttribute"].empty()) {
      loginAttribute = make_shared<string>(boost::any_cast<string>(m["LoginAttribute"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
  }


  virtual ~ListOperationDatabaseAccountsResponseBodyDatabaseAccounts() = default;
};
class ListOperationDatabaseAccountsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListOperationDatabaseAccountsResponseBodyDatabaseAccounts>> databaseAccounts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListOperationDatabaseAccountsResponseBody() {}

  explicit ListOperationDatabaseAccountsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*databaseAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseAccounts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccounts") != m.end() && !m["DatabaseAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseAccounts"].type()) {
        vector<ListOperationDatabaseAccountsResponseBodyDatabaseAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOperationDatabaseAccountsResponseBodyDatabaseAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseAccounts = make_shared<vector<ListOperationDatabaseAccountsResponseBodyDatabaseAccounts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOperationDatabaseAccountsResponseBody() = default;
};
class ListOperationDatabaseAccountsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOperationDatabaseAccountsResponseBody> body{};

  ListOperationDatabaseAccountsResponse() {}

  explicit ListOperationDatabaseAccountsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOperationDatabaseAccountsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOperationDatabaseAccountsResponseBody>(model1);
      }
    }
  }


  virtual ~ListOperationDatabaseAccountsResponse() = default;
};
class ListOperationDatabasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseAddress{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceState{};

  ListOperationDatabasesRequest() {}

  explicit ListOperationDatabasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAddress) {
      res["DatabaseAddress"] = boost::any(*databaseAddress);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceState) {
      res["SourceInstanceState"] = boost::any(*sourceInstanceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAddress") != m.end() && !m["DatabaseAddress"].empty()) {
      databaseAddress = make_shared<string>(boost::any_cast<string>(m["DatabaseAddress"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceState") != m.end() && !m["SourceInstanceState"].empty()) {
      sourceInstanceState = make_shared<string>(boost::any_cast<string>(m["SourceInstanceState"]));
    }
  }


  virtual ~ListOperationDatabasesRequest() = default;
};
class ListOperationDatabasesResponseBodyDatabases : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> databaseName{};
  shared_ptr<long> databasePort{};
  shared_ptr<string> databasePrivateAddress{};
  shared_ptr<string> databasePublicAddress{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceRegionId{};
  shared_ptr<string> sourceInstanceState{};

  ListOperationDatabasesResponseBodyDatabases() {}

  explicit ListOperationDatabasesResponseBodyDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databasePort) {
      res["DatabasePort"] = boost::any(*databasePort);
    }
    if (databasePrivateAddress) {
      res["DatabasePrivateAddress"] = boost::any(*databasePrivateAddress);
    }
    if (databasePublicAddress) {
      res["DatabasePublicAddress"] = boost::any(*databasePublicAddress);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceRegionId) {
      res["SourceInstanceRegionId"] = boost::any(*sourceInstanceRegionId);
    }
    if (sourceInstanceState) {
      res["SourceInstanceState"] = boost::any(*sourceInstanceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabasePort") != m.end() && !m["DatabasePort"].empty()) {
      databasePort = make_shared<long>(boost::any_cast<long>(m["DatabasePort"]));
    }
    if (m.find("DatabasePrivateAddress") != m.end() && !m["DatabasePrivateAddress"].empty()) {
      databasePrivateAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePrivateAddress"]));
    }
    if (m.find("DatabasePublicAddress") != m.end() && !m["DatabasePublicAddress"].empty()) {
      databasePublicAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePublicAddress"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceRegionId") != m.end() && !m["SourceInstanceRegionId"].empty()) {
      sourceInstanceRegionId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceRegionId"]));
    }
    if (m.find("SourceInstanceState") != m.end() && !m["SourceInstanceState"].empty()) {
      sourceInstanceState = make_shared<string>(boost::any_cast<string>(m["SourceInstanceState"]));
    }
  }


  virtual ~ListOperationDatabasesResponseBodyDatabases() = default;
};
class ListOperationDatabasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListOperationDatabasesResponseBodyDatabases>> databases{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListOperationDatabasesResponseBody() {}

  explicit ListOperationDatabasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<ListOperationDatabasesResponseBodyDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOperationDatabasesResponseBodyDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<ListOperationDatabasesResponseBodyDatabases>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOperationDatabasesResponseBody() = default;
};
class ListOperationDatabasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOperationDatabasesResponseBody> body{};

  ListOperationDatabasesResponse() {}

  explicit ListOperationDatabasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOperationDatabasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOperationDatabasesResponseBody>(model1);
      }
    }
  }


  virtual ~ListOperationDatabasesResponse() = default;
};
class ListOperationHostAccountsRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListOperationHostAccountsRequest() {}

  explicit ListOperationHostAccountsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListOperationHostAccountsRequest() = default;
};
class ListOperationHostAccountsResponseBodyHostAccountsSSHConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableSFTPChannel{};
  shared_ptr<bool> enableSSHChannel{};

  ListOperationHostAccountsResponseBodyHostAccountsSSHConfig() {}

  explicit ListOperationHostAccountsResponseBodyHostAccountsSSHConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableSFTPChannel) {
      res["EnableSFTPChannel"] = boost::any(*enableSFTPChannel);
    }
    if (enableSSHChannel) {
      res["EnableSSHChannel"] = boost::any(*enableSSHChannel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableSFTPChannel") != m.end() && !m["EnableSFTPChannel"].empty()) {
      enableSFTPChannel = make_shared<bool>(boost::any_cast<bool>(m["EnableSFTPChannel"]));
    }
    if (m.find("EnableSSHChannel") != m.end() && !m["EnableSSHChannel"].empty()) {
      enableSSHChannel = make_shared<bool>(boost::any_cast<bool>(m["EnableSSHChannel"]));
    }
  }


  virtual ~ListOperationHostAccountsResponseBodyHostAccountsSSHConfig() = default;
};
class ListOperationHostAccountsResponseBodyHostAccounts : public Darabonba::Model {
public:
  shared_ptr<bool> hasPassword{};
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> privateKeyFingerprint{};
  shared_ptr<string> protocolName{};
  shared_ptr<ListOperationHostAccountsResponseBodyHostAccountsSSHConfig> SSHConfig{};

  ListOperationHostAccountsResponseBodyHostAccounts() {}

  explicit ListOperationHostAccountsResponseBodyHostAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasPassword) {
      res["HasPassword"] = boost::any(*hasPassword);
    }
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (privateKeyFingerprint) {
      res["PrivateKeyFingerprint"] = boost::any(*privateKeyFingerprint);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    if (SSHConfig) {
      res["SSHConfig"] = SSHConfig ? boost::any(SSHConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasPassword") != m.end() && !m["HasPassword"].empty()) {
      hasPassword = make_shared<bool>(boost::any_cast<bool>(m["HasPassword"]));
    }
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("PrivateKeyFingerprint") != m.end() && !m["PrivateKeyFingerprint"].empty()) {
      privateKeyFingerprint = make_shared<string>(boost::any_cast<string>(m["PrivateKeyFingerprint"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
    if (m.find("SSHConfig") != m.end() && !m["SSHConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SSHConfig"].type()) {
        ListOperationHostAccountsResponseBodyHostAccountsSSHConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SSHConfig"]));
        SSHConfig = make_shared<ListOperationHostAccountsResponseBodyHostAccountsSSHConfig>(model1);
      }
    }
  }


  virtual ~ListOperationHostAccountsResponseBodyHostAccounts() = default;
};
class ListOperationHostAccountsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListOperationHostAccountsResponseBodyHostAccounts>> hostAccounts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListOperationHostAccountsResponseBody() {}

  explicit ListOperationHostAccountsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*hostAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostAccounts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccounts") != m.end() && !m["HostAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["HostAccounts"].type()) {
        vector<ListOperationHostAccountsResponseBodyHostAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOperationHostAccountsResponseBodyHostAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostAccounts = make_shared<vector<ListOperationHostAccountsResponseBodyHostAccounts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOperationHostAccountsResponseBody() = default;
};
class ListOperationHostAccountsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOperationHostAccountsResponseBody> body{};

  ListOperationHostAccountsResponse() {}

  explicit ListOperationHostAccountsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOperationHostAccountsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOperationHostAccountsResponseBody>(model1);
      }
    }
  }


  virtual ~ListOperationHostAccountsResponse() = default;
};
class ListOperationHostsRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAddress{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> OSType{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceState{};

  ListOperationHostsRequest() {}

  explicit ListOperationHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAddress) {
      res["HostAddress"] = boost::any(*hostAddress);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceState) {
      res["SourceInstanceState"] = boost::any(*sourceInstanceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAddress") != m.end() && !m["HostAddress"].empty()) {
      hostAddress = make_shared<string>(boost::any_cast<string>(m["HostAddress"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceState") != m.end() && !m["SourceInstanceState"].empty()) {
      sourceInstanceState = make_shared<string>(boost::any_cast<string>(m["SourceInstanceState"]));
    }
  }


  virtual ~ListOperationHostsRequest() = default;
};
class ListOperationHostsResponseBodyHosts : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hostPrivateAddress{};
  shared_ptr<string> hostPublicAddress{};
  shared_ptr<string> OSType{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceInstanceId{};
  shared_ptr<string> sourceInstanceState{};

  ListOperationHostsResponseBodyHosts() {}

  explicit ListOperationHostsResponseBodyHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostPrivateAddress) {
      res["HostPrivateAddress"] = boost::any(*hostPrivateAddress);
    }
    if (hostPublicAddress) {
      res["HostPublicAddress"] = boost::any(*hostPublicAddress);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    if (sourceInstanceState) {
      res["SourceInstanceState"] = boost::any(*sourceInstanceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostPrivateAddress") != m.end() && !m["HostPrivateAddress"].empty()) {
      hostPrivateAddress = make_shared<string>(boost::any_cast<string>(m["HostPrivateAddress"]));
    }
    if (m.find("HostPublicAddress") != m.end() && !m["HostPublicAddress"].empty()) {
      hostPublicAddress = make_shared<string>(boost::any_cast<string>(m["HostPublicAddress"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
    if (m.find("SourceInstanceState") != m.end() && !m["SourceInstanceState"].empty()) {
      sourceInstanceState = make_shared<string>(boost::any_cast<string>(m["SourceInstanceState"]));
    }
  }


  virtual ~ListOperationHostsResponseBodyHosts() = default;
};
class ListOperationHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListOperationHostsResponseBodyHosts>> hosts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListOperationHostsResponseBody() {}

  explicit ListOperationHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<ListOperationHostsResponseBodyHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOperationHostsResponseBodyHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<ListOperationHostsResponseBodyHosts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOperationHostsResponseBody() = default;
};
class ListOperationHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOperationHostsResponseBody> body{};

  ListOperationHostsResponse() {}

  explicit ListOperationHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOperationHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOperationHostsResponseBody>(model1);
      }
    }
  }


  virtual ~ListOperationHostsResponse() = default;
};
class ListOperationTicketsRequest : public Darabonba::Model {
public:
  shared_ptr<string> assetAddress{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListOperationTicketsRequest() {}

  explicit ListOperationTicketsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetAddress) {
      res["AssetAddress"] = boost::any(*assetAddress);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetAddress") != m.end() && !m["AssetAddress"].empty()) {
      assetAddress = make_shared<string>(boost::any_cast<string>(m["AssetAddress"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListOperationTicketsRequest() = default;
};
class ListOperationTicketsResponseBodyOperationTickets : public Darabonba::Model {
public:
  shared_ptr<string> applyUserId{};
  shared_ptr<string> applyUsername{};
  shared_ptr<string> approveComment{};
  shared_ptr<string> assetAccountId{};
  shared_ptr<string> assetAccountName{};
  shared_ptr<string> assetAddress{};
  shared_ptr<string> assetId{};
  shared_ptr<string> assetName{};
  shared_ptr<string> assetNetworkDomainId{};
  shared_ptr<string> assetOs{};
  shared_ptr<string> assetSource{};
  shared_ptr<string> assetSourceInstanceId{};
  shared_ptr<long> createdTime{};
  shared_ptr<long> effectCount{};
  shared_ptr<long> effectEndTime{};
  shared_ptr<long> effectStartTime{};
  shared_ptr<string> operationTicketId{};
  shared_ptr<string> protocolName{};
  shared_ptr<string> state{};

  ListOperationTicketsResponseBodyOperationTickets() {}

  explicit ListOperationTicketsResponseBodyOperationTickets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyUserId) {
      res["ApplyUserId"] = boost::any(*applyUserId);
    }
    if (applyUsername) {
      res["ApplyUsername"] = boost::any(*applyUsername);
    }
    if (approveComment) {
      res["ApproveComment"] = boost::any(*approveComment);
    }
    if (assetAccountId) {
      res["AssetAccountId"] = boost::any(*assetAccountId);
    }
    if (assetAccountName) {
      res["AssetAccountName"] = boost::any(*assetAccountName);
    }
    if (assetAddress) {
      res["AssetAddress"] = boost::any(*assetAddress);
    }
    if (assetId) {
      res["AssetId"] = boost::any(*assetId);
    }
    if (assetName) {
      res["AssetName"] = boost::any(*assetName);
    }
    if (assetNetworkDomainId) {
      res["AssetNetworkDomainId"] = boost::any(*assetNetworkDomainId);
    }
    if (assetOs) {
      res["AssetOs"] = boost::any(*assetOs);
    }
    if (assetSource) {
      res["AssetSource"] = boost::any(*assetSource);
    }
    if (assetSourceInstanceId) {
      res["AssetSourceInstanceId"] = boost::any(*assetSourceInstanceId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (effectCount) {
      res["EffectCount"] = boost::any(*effectCount);
    }
    if (effectEndTime) {
      res["EffectEndTime"] = boost::any(*effectEndTime);
    }
    if (effectStartTime) {
      res["EffectStartTime"] = boost::any(*effectStartTime);
    }
    if (operationTicketId) {
      res["OperationTicketId"] = boost::any(*operationTicketId);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyUserId") != m.end() && !m["ApplyUserId"].empty()) {
      applyUserId = make_shared<string>(boost::any_cast<string>(m["ApplyUserId"]));
    }
    if (m.find("ApplyUsername") != m.end() && !m["ApplyUsername"].empty()) {
      applyUsername = make_shared<string>(boost::any_cast<string>(m["ApplyUsername"]));
    }
    if (m.find("ApproveComment") != m.end() && !m["ApproveComment"].empty()) {
      approveComment = make_shared<string>(boost::any_cast<string>(m["ApproveComment"]));
    }
    if (m.find("AssetAccountId") != m.end() && !m["AssetAccountId"].empty()) {
      assetAccountId = make_shared<string>(boost::any_cast<string>(m["AssetAccountId"]));
    }
    if (m.find("AssetAccountName") != m.end() && !m["AssetAccountName"].empty()) {
      assetAccountName = make_shared<string>(boost::any_cast<string>(m["AssetAccountName"]));
    }
    if (m.find("AssetAddress") != m.end() && !m["AssetAddress"].empty()) {
      assetAddress = make_shared<string>(boost::any_cast<string>(m["AssetAddress"]));
    }
    if (m.find("AssetId") != m.end() && !m["AssetId"].empty()) {
      assetId = make_shared<string>(boost::any_cast<string>(m["AssetId"]));
    }
    if (m.find("AssetName") != m.end() && !m["AssetName"].empty()) {
      assetName = make_shared<string>(boost::any_cast<string>(m["AssetName"]));
    }
    if (m.find("AssetNetworkDomainId") != m.end() && !m["AssetNetworkDomainId"].empty()) {
      assetNetworkDomainId = make_shared<string>(boost::any_cast<string>(m["AssetNetworkDomainId"]));
    }
    if (m.find("AssetOs") != m.end() && !m["AssetOs"].empty()) {
      assetOs = make_shared<string>(boost::any_cast<string>(m["AssetOs"]));
    }
    if (m.find("AssetSource") != m.end() && !m["AssetSource"].empty()) {
      assetSource = make_shared<string>(boost::any_cast<string>(m["AssetSource"]));
    }
    if (m.find("AssetSourceInstanceId") != m.end() && !m["AssetSourceInstanceId"].empty()) {
      assetSourceInstanceId = make_shared<string>(boost::any_cast<string>(m["AssetSourceInstanceId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("EffectCount") != m.end() && !m["EffectCount"].empty()) {
      effectCount = make_shared<long>(boost::any_cast<long>(m["EffectCount"]));
    }
    if (m.find("EffectEndTime") != m.end() && !m["EffectEndTime"].empty()) {
      effectEndTime = make_shared<long>(boost::any_cast<long>(m["EffectEndTime"]));
    }
    if (m.find("EffectStartTime") != m.end() && !m["EffectStartTime"].empty()) {
      effectStartTime = make_shared<long>(boost::any_cast<long>(m["EffectStartTime"]));
    }
    if (m.find("OperationTicketId") != m.end() && !m["OperationTicketId"].empty()) {
      operationTicketId = make_shared<string>(boost::any_cast<string>(m["OperationTicketId"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListOperationTicketsResponseBodyOperationTickets() = default;
};
class ListOperationTicketsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListOperationTicketsResponseBodyOperationTickets>> operationTickets{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListOperationTicketsResponseBody() {}

  explicit ListOperationTicketsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationTickets) {
      vector<boost::any> temp1;
      for(auto item1:*operationTickets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationTickets"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationTickets") != m.end() && !m["OperationTickets"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationTickets"].type()) {
        vector<ListOperationTicketsResponseBodyOperationTickets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationTickets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOperationTicketsResponseBodyOperationTickets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationTickets = make_shared<vector<ListOperationTicketsResponseBodyOperationTickets>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOperationTicketsResponseBody() = default;
};
class ListOperationTicketsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOperationTicketsResponseBody> body{};

  ListOperationTicketsResponse() {}

  explicit ListOperationTicketsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOperationTicketsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOperationTicketsResponseBody>(model1);
      }
    }
  }


  virtual ~ListOperationTicketsResponse() = default;
};
class ListPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> policyName{};
  shared_ptr<string> regionId{};

  ListPoliciesRequest() {}

  explicit ListPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListPoliciesRequest() = default;
};
class ListPoliciesResponseBodyPolicies : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<long> priority{};

  ListPoliciesResponseBodyPolicies() {}

  explicit ListPoliciesResponseBodyPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~ListPoliciesResponseBodyPolicies() = default;
};
class ListPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPoliciesResponseBodyPolicies>> policies{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListPoliciesResponseBody() {}

  explicit ListPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<ListPoliciesResponseBodyPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPoliciesResponseBodyPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<ListPoliciesResponseBodyPolicies>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPoliciesResponseBody() = default;
};
class ListPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPoliciesResponseBody> body{};

  ListPoliciesResponse() {}

  explicit ListPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPoliciesResponse() = default;
};
class ListRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleState{};

  ListRulesRequest() {}

  explicit ListRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleState) {
      res["RuleState"] = boost::any(*ruleState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleState") != m.end() && !m["RuleState"].empty()) {
      ruleState = make_shared<string>(boost::any_cast<string>(m["RuleState"]));
    }
  }


  virtual ~ListRulesRequest() = default;
};
class ListRulesResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> effectiveEndTime{};
  shared_ptr<long> effectiveStartTime{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleState{};

  ListRulesResponseBodyRules() {}

  explicit ListRulesResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (effectiveEndTime) {
      res["EffectiveEndTime"] = boost::any(*effectiveEndTime);
    }
    if (effectiveStartTime) {
      res["EffectiveStartTime"] = boost::any(*effectiveStartTime);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleState) {
      res["RuleState"] = boost::any(*ruleState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("EffectiveEndTime") != m.end() && !m["EffectiveEndTime"].empty()) {
      effectiveEndTime = make_shared<long>(boost::any_cast<long>(m["EffectiveEndTime"]));
    }
    if (m.find("EffectiveStartTime") != m.end() && !m["EffectiveStartTime"].empty()) {
      effectiveStartTime = make_shared<long>(boost::any_cast<long>(m["EffectiveStartTime"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleState") != m.end() && !m["RuleState"].empty()) {
      ruleState = make_shared<string>(boost::any_cast<string>(m["RuleState"]));
    }
  }


  virtual ~ListRulesResponseBodyRules() = default;
};
class ListRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRulesResponseBodyRules>> rules{};
  shared_ptr<long> totalCount{};

  ListRulesResponseBody() {}

  explicit ListRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<ListRulesResponseBodyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRulesResponseBodyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<ListRulesResponseBodyRules>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRulesResponseBody() = default;
};
class ListRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRulesResponseBody> body{};

  ListRulesResponse() {}

  explicit ListRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRulesResponse() = default;
};
class ListTagKeysRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceType{};

  ListTagKeysRequest() {}

  explicit ListTagKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListTagKeysRequest() = default;
};
class ListTagKeysResponseBodyTagKeys : public Darabonba::Model {
public:
  shared_ptr<long> tagCount{};
  shared_ptr<string> tagKey{};

  ListTagKeysResponseBodyTagKeys() {}

  explicit ListTagKeysResponseBodyTagKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagCount) {
      res["TagCount"] = boost::any(*tagCount);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagCount") != m.end() && !m["TagCount"].empty()) {
      tagCount = make_shared<long>(boost::any_cast<long>(m["TagCount"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~ListTagKeysResponseBodyTagKeys() = default;
};
class ListTagKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagKeysResponseBodyTagKeys>> tagKeys{};
  shared_ptr<long> totalCount{};

  ListTagKeysResponseBody() {}

  explicit ListTagKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagKeys) {
      vector<boost::any> temp1;
      for(auto item1:*tagKeys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagKeys"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      if (typeid(vector<boost::any>) == m["TagKeys"].type()) {
        vector<ListTagKeysResponseBodyTagKeys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagKeys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagKeysResponseBodyTagKeys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagKeys = make_shared<vector<ListTagKeysResponseBodyTagKeys>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTagKeysResponseBody() = default;
};
class ListTagKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagKeysResponseBody> body{};

  ListTagKeysResponse() {}

  explicit ListTagKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagKeysResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagKeysResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagResourcesResponseBodyTagResources>> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListUserGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupName{};

  ListUserGroupsRequest() {}

  explicit ListUserGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupName) {
      res["UserGroupName"] = boost::any(*userGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupName") != m.end() && !m["UserGroupName"].empty()) {
      userGroupName = make_shared<string>(boost::any_cast<string>(m["UserGroupName"]));
    }
  }


  virtual ~ListUserGroupsRequest() = default;
};
class ListUserGroupsResponseBodyUserGroups : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> memberCount{};
  shared_ptr<string> userGroupId{};
  shared_ptr<string> userGroupName{};

  ListUserGroupsResponseBodyUserGroups() {}

  explicit ListUserGroupsResponseBodyUserGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userGroupName) {
      res["UserGroupName"] = boost::any(*userGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserGroupName") != m.end() && !m["UserGroupName"].empty()) {
      userGroupName = make_shared<string>(boost::any_cast<string>(m["UserGroupName"]));
    }
  }


  virtual ~ListUserGroupsResponseBodyUserGroups() = default;
};
class ListUserGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListUserGroupsResponseBodyUserGroups>> userGroups{};

  ListUserGroupsResponseBody() {}

  explicit ListUserGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userGroups) {
      vector<boost::any> temp1;
      for(auto item1:*userGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserGroups") != m.end() && !m["UserGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["UserGroups"].type()) {
        vector<ListUserGroupsResponseBodyUserGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserGroupsResponseBodyUserGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userGroups = make_shared<vector<ListUserGroupsResponseBodyUserGroups>>(expect1);
      }
    }
  }


  virtual ~ListUserGroupsResponseBody() = default;
};
class ListUserGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserGroupsResponseBody> body{};

  ListUserGroupsResponse() {}

  explicit ListUserGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserGroupsResponse() = default;
};
class ListUserPublicKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userId{};

  ListUserPublicKeysRequest() {}

  explicit ListUserPublicKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListUserPublicKeysRequest() = default;
};
class ListUserPublicKeysResponseBodyPublicKeys : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> fingerPrint{};
  shared_ptr<string> publicKeyId{};
  shared_ptr<string> publicKeyName{};
  shared_ptr<string> userId{};

  ListUserPublicKeysResponseBodyPublicKeys() {}

  explicit ListUserPublicKeysResponseBodyPublicKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (fingerPrint) {
      res["FingerPrint"] = boost::any(*fingerPrint);
    }
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    if (publicKeyName) {
      res["PublicKeyName"] = boost::any(*publicKeyName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("FingerPrint") != m.end() && !m["FingerPrint"].empty()) {
      fingerPrint = make_shared<string>(boost::any_cast<string>(m["FingerPrint"]));
    }
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
    if (m.find("PublicKeyName") != m.end() && !m["PublicKeyName"].empty()) {
      publicKeyName = make_shared<string>(boost::any_cast<string>(m["PublicKeyName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListUserPublicKeysResponseBodyPublicKeys() = default;
};
class ListUserPublicKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListUserPublicKeysResponseBodyPublicKeys>> publicKeys{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListUserPublicKeysResponseBody() {}

  explicit ListUserPublicKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicKeys) {
      vector<boost::any> temp1;
      for(auto item1:*publicKeys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicKeys"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicKeys") != m.end() && !m["PublicKeys"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicKeys"].type()) {
        vector<ListUserPublicKeysResponseBodyPublicKeys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicKeys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserPublicKeysResponseBodyPublicKeys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicKeys = make_shared<vector<ListUserPublicKeysResponseBodyPublicKeys>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUserPublicKeysResponseBody() = default;
};
class ListUserPublicKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserPublicKeysResponseBody> body{};

  ListUserPublicKeysResponse() {}

  explicit ListUserPublicKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserPublicKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserPublicKeysResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserPublicKeysResponse() = default;
};
class ListUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mobile{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceUserId{};
  shared_ptr<string> userGroupId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userState{};

  ListUsersRequest() {}

  explicit ListUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceUserId) {
      res["SourceUserId"] = boost::any(*sourceUserId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceUserId") != m.end() && !m["SourceUserId"].empty()) {
      sourceUserId = make_shared<string>(boost::any_cast<string>(m["SourceUserId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
  }


  virtual ~ListUsersRequest() = default;
};
class ListUsersResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> displayName{};
  shared_ptr<long> effectiveEndTime{};
  shared_ptr<long> effectiveStartTime{};
  shared_ptr<string> email{};
  shared_ptr<string> language{};
  shared_ptr<string> languageStatus{};
  shared_ptr<string> mobile{};
  shared_ptr<string> mobileCountryCode{};
  shared_ptr<bool> needResetPassword{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceUserId{};
  shared_ptr<vector<string>> twoFactorMethods{};
  shared_ptr<string> twoFactorStatus{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<vector<string>> userState{};

  ListUsersResponseBodyUsers() {}

  explicit ListUsersResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (effectiveEndTime) {
      res["EffectiveEndTime"] = boost::any(*effectiveEndTime);
    }
    if (effectiveStartTime) {
      res["EffectiveStartTime"] = boost::any(*effectiveStartTime);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (languageStatus) {
      res["LanguageStatus"] = boost::any(*languageStatus);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (mobileCountryCode) {
      res["MobileCountryCode"] = boost::any(*mobileCountryCode);
    }
    if (needResetPassword) {
      res["NeedResetPassword"] = boost::any(*needResetPassword);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceUserId) {
      res["SourceUserId"] = boost::any(*sourceUserId);
    }
    if (twoFactorMethods) {
      res["TwoFactorMethods"] = boost::any(*twoFactorMethods);
    }
    if (twoFactorStatus) {
      res["TwoFactorStatus"] = boost::any(*twoFactorStatus);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("EffectiveEndTime") != m.end() && !m["EffectiveEndTime"].empty()) {
      effectiveEndTime = make_shared<long>(boost::any_cast<long>(m["EffectiveEndTime"]));
    }
    if (m.find("EffectiveStartTime") != m.end() && !m["EffectiveStartTime"].empty()) {
      effectiveStartTime = make_shared<long>(boost::any_cast<long>(m["EffectiveStartTime"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LanguageStatus") != m.end() && !m["LanguageStatus"].empty()) {
      languageStatus = make_shared<string>(boost::any_cast<string>(m["LanguageStatus"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("MobileCountryCode") != m.end() && !m["MobileCountryCode"].empty()) {
      mobileCountryCode = make_shared<string>(boost::any_cast<string>(m["MobileCountryCode"]));
    }
    if (m.find("NeedResetPassword") != m.end() && !m["NeedResetPassword"].empty()) {
      needResetPassword = make_shared<bool>(boost::any_cast<bool>(m["NeedResetPassword"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceUserId") != m.end() && !m["SourceUserId"].empty()) {
      sourceUserId = make_shared<string>(boost::any_cast<string>(m["SourceUserId"]));
    }
    if (m.find("TwoFactorMethods") != m.end() && !m["TwoFactorMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TwoFactorMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TwoFactorMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      twoFactorMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TwoFactorStatus") != m.end() && !m["TwoFactorStatus"].empty()) {
      twoFactorStatus = make_shared<string>(boost::any_cast<string>(m["TwoFactorStatus"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserState"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserState"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userState = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListUsersResponseBodyUsers() = default;
};
class ListUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListUsersResponseBodyUsers>> users{};

  ListUsersResponseBody() {}

  explicit ListUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<ListUsersResponseBodyUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<ListUsersResponseBodyUsers>>(expect1);
      }
    }
  }


  virtual ~ListUsersResponseBody() = default;
};
class ListUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUsersResponseBody> body{};

  ListUsersResponse() {}

  explicit ListUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUsersResponse() = default;
};
class LockUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userIds{};

  LockUsersRequest() {}

  explicit LockUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIds = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~LockUsersRequest() = default;
};
class LockUsersResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> userId{};

  LockUsersResponseBodyResults() {}

  explicit LockUsersResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~LockUsersResponseBodyResults() = default;
};
class LockUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<LockUsersResponseBodyResults>> results{};

  LockUsersResponseBody() {}

  explicit LockUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<LockUsersResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LockUsersResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<LockUsersResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~LockUsersResponseBody() = default;
};
class LockUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LockUsersResponseBody> body{};

  LockUsersResponse() {}

  explicit LockUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LockUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LockUsersResponseBody>(model1);
      }
    }
  }


  virtual ~LockUsersResponse() = default;
};
class ModifyDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> comment{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> databasePort{};
  shared_ptr<string> databasePrivateAddress{};
  shared_ptr<string> databasePublicAddress{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourceInstanceId{};

  ModifyDatabaseRequest() {}

  explicit ModifyDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databasePort) {
      res["DatabasePort"] = boost::any(*databasePort);
    }
    if (databasePrivateAddress) {
      res["DatabasePrivateAddress"] = boost::any(*databasePrivateAddress);
    }
    if (databasePublicAddress) {
      res["DatabasePublicAddress"] = boost::any(*databasePublicAddress);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourceInstanceId) {
      res["SourceInstanceId"] = boost::any(*sourceInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabasePort") != m.end() && !m["DatabasePort"].empty()) {
      databasePort = make_shared<string>(boost::any_cast<string>(m["DatabasePort"]));
    }
    if (m.find("DatabasePrivateAddress") != m.end() && !m["DatabasePrivateAddress"].empty()) {
      databasePrivateAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePrivateAddress"]));
    }
    if (m.find("DatabasePublicAddress") != m.end() && !m["DatabasePublicAddress"].empty()) {
      databasePublicAddress = make_shared<string>(boost::any_cast<string>(m["DatabasePublicAddress"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourceInstanceId") != m.end() && !m["SourceInstanceId"].empty()) {
      sourceInstanceId = make_shared<string>(boost::any_cast<string>(m["SourceInstanceId"]));
    }
  }


  virtual ~ModifyDatabaseRequest() = default;
};
class ModifyDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDatabaseResponseBody() {}

  explicit ModifyDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDatabaseResponseBody() = default;
};
class ModifyDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDatabaseResponseBody> body{};

  ModifyDatabaseResponse() {}

  explicit ModifyDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDatabaseResponse() = default;
};
class ModifyDatabaseAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseAccountId{};
  shared_ptr<string> databaseAccountName{};
  shared_ptr<string> databaseSchema{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> password{};
  shared_ptr<string> regionId{};

  ModifyDatabaseAccountRequest() {}

  explicit ModifyDatabaseAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountId) {
      res["DatabaseAccountId"] = boost::any(*databaseAccountId);
    }
    if (databaseAccountName) {
      res["DatabaseAccountName"] = boost::any(*databaseAccountName);
    }
    if (databaseSchema) {
      res["DatabaseSchema"] = boost::any(*databaseSchema);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountId") != m.end() && !m["DatabaseAccountId"].empty()) {
      databaseAccountId = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountId"]));
    }
    if (m.find("DatabaseAccountName") != m.end() && !m["DatabaseAccountName"].empty()) {
      databaseAccountName = make_shared<string>(boost::any_cast<string>(m["DatabaseAccountName"]));
    }
    if (m.find("DatabaseSchema") != m.end() && !m["DatabaseSchema"].empty()) {
      databaseSchema = make_shared<string>(boost::any_cast<string>(m["DatabaseSchema"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDatabaseAccountRequest() = default;
};
class ModifyDatabaseAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDatabaseAccountResponseBody() {}

  explicit ModifyDatabaseAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDatabaseAccountResponseBody() = default;
};
class ModifyDatabaseAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDatabaseAccountResponseBody> body{};

  ModifyDatabaseAccountResponse() {}

  explicit ModifyDatabaseAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDatabaseAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDatabaseAccountResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDatabaseAccountResponse() = default;
};
class ModifyHostRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hostPrivateAddress{};
  shared_ptr<string> hostPublicAddress{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> OSType{};
  shared_ptr<string> regionId{};

  ModifyHostRequest() {}

  explicit ModifyHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostPrivateAddress) {
      res["HostPrivateAddress"] = boost::any(*hostPrivateAddress);
    }
    if (hostPublicAddress) {
      res["HostPublicAddress"] = boost::any(*hostPublicAddress);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (OSType) {
      res["OSType"] = boost::any(*OSType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostPrivateAddress") != m.end() && !m["HostPrivateAddress"].empty()) {
      hostPrivateAddress = make_shared<string>(boost::any_cast<string>(m["HostPrivateAddress"]));
    }
    if (m.find("HostPublicAddress") != m.end() && !m["HostPublicAddress"].empty()) {
      hostPublicAddress = make_shared<string>(boost::any_cast<string>(m["HostPublicAddress"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("OSType") != m.end() && !m["OSType"].empty()) {
      OSType = make_shared<string>(boost::any_cast<string>(m["OSType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyHostRequest() = default;
};
class ModifyHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHostResponseBody() {}

  explicit ModifyHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHostResponseBody() = default;
};
class ModifyHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHostResponseBody> body{};

  ModifyHostResponse() {}

  explicit ModifyHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHostResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHostResponse() = default;
};
class ModifyHostAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> hostAccountName{};
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> passPhrase{};
  shared_ptr<string> password{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> regionId{};

  ModifyHostAccountRequest() {}

  explicit ModifyHostAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (hostAccountName) {
      res["HostAccountName"] = boost::any(*hostAccountName);
    }
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (passPhrase) {
      res["PassPhrase"] = boost::any(*passPhrase);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("HostAccountName") != m.end() && !m["HostAccountName"].empty()) {
      hostAccountName = make_shared<string>(boost::any_cast<string>(m["HostAccountName"]));
    }
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PassPhrase") != m.end() && !m["PassPhrase"].empty()) {
      passPhrase = make_shared<string>(boost::any_cast<string>(m["PassPhrase"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyHostAccountRequest() = default;
};
class ModifyHostAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHostAccountResponseBody() {}

  explicit ModifyHostAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHostAccountResponseBody() = default;
};
class ModifyHostAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHostAccountResponseBody> body{};

  ModifyHostAccountResponse() {}

  explicit ModifyHostAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHostAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHostAccountResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHostAccountResponse() = default;
};
class ModifyHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  ModifyHostGroupRequest() {}

  explicit ModifyHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyHostGroupRequest() = default;
};
class ModifyHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHostGroupResponseBody() {}

  explicit ModifyHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHostGroupResponseBody() = default;
};
class ModifyHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHostGroupResponseBody> body{};

  ModifyHostGroupResponse() {}

  explicit ModifyHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHostGroupResponse() = default;
};
class ModifyHostShareKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostShareKeyId{};
  shared_ptr<string> hostShareKeyName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> passPhrase{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> regionId{};

  ModifyHostShareKeyRequest() {}

  explicit ModifyHostShareKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostShareKeyId) {
      res["HostShareKeyId"] = boost::any(*hostShareKeyId);
    }
    if (hostShareKeyName) {
      res["HostShareKeyName"] = boost::any(*hostShareKeyName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (passPhrase) {
      res["PassPhrase"] = boost::any(*passPhrase);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostShareKeyId") != m.end() && !m["HostShareKeyId"].empty()) {
      hostShareKeyId = make_shared<string>(boost::any_cast<string>(m["HostShareKeyId"]));
    }
    if (m.find("HostShareKeyName") != m.end() && !m["HostShareKeyName"].empty()) {
      hostShareKeyName = make_shared<string>(boost::any_cast<string>(m["HostShareKeyName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PassPhrase") != m.end() && !m["PassPhrase"].empty()) {
      passPhrase = make_shared<string>(boost::any_cast<string>(m["PassPhrase"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyHostShareKeyRequest() = default;
};
class ModifyHostShareKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHostShareKeyResponseBody() {}

  explicit ModifyHostShareKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHostShareKeyResponseBody() = default;
};
class ModifyHostShareKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHostShareKeyResponseBody> body{};

  ModifyHostShareKeyResponse() {}

  explicit ModifyHostShareKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHostShareKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHostShareKeyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHostShareKeyResponse() = default;
};
class ModifyHostsActiveAddressTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> activeAddressType{};
  shared_ptr<string> hostIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  ModifyHostsActiveAddressTypeRequest() {}

  explicit ModifyHostsActiveAddressTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeAddressType) {
      res["ActiveAddressType"] = boost::any(*activeAddressType);
    }
    if (hostIds) {
      res["HostIds"] = boost::any(*hostIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveAddressType") != m.end() && !m["ActiveAddressType"].empty()) {
      activeAddressType = make_shared<string>(boost::any_cast<string>(m["ActiveAddressType"]));
    }
    if (m.find("HostIds") != m.end() && !m["HostIds"].empty()) {
      hostIds = make_shared<string>(boost::any_cast<string>(m["HostIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyHostsActiveAddressTypeRequest() = default;
};
class ModifyHostsActiveAddressTypeResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostId{};
  shared_ptr<string> message{};

  ModifyHostsActiveAddressTypeResponseBodyResults() {}

  explicit ModifyHostsActiveAddressTypeResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~ModifyHostsActiveAddressTypeResponseBodyResults() = default;
};
class ModifyHostsActiveAddressTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ModifyHostsActiveAddressTypeResponseBodyResults>> results{};

  ModifyHostsActiveAddressTypeResponseBody() {}

  explicit ModifyHostsActiveAddressTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<ModifyHostsActiveAddressTypeResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyHostsActiveAddressTypeResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<ModifyHostsActiveAddressTypeResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~ModifyHostsActiveAddressTypeResponseBody() = default;
};
class ModifyHostsActiveAddressTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHostsActiveAddressTypeResponseBody> body{};

  ModifyHostsActiveAddressTypeResponse() {}

  explicit ModifyHostsActiveAddressTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHostsActiveAddressTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHostsActiveAddressTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHostsActiveAddressTypeResponse() = default;
};
class ModifyHostsPortRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> port{};
  shared_ptr<string> protocolName{};
  shared_ptr<string> regionId{};

  ModifyHostsPortRequest() {}

  explicit ModifyHostsPortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostIds) {
      res["HostIds"] = boost::any(*hostIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostIds") != m.end() && !m["HostIds"].empty()) {
      hostIds = make_shared<string>(boost::any_cast<string>(m["HostIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyHostsPortRequest() = default;
};
class ModifyHostsPortResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostId{};
  shared_ptr<string> message{};

  ModifyHostsPortResponseBodyResults() {}

  explicit ModifyHostsPortResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~ModifyHostsPortResponseBodyResults() = default;
};
class ModifyHostsPortResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ModifyHostsPortResponseBodyResults>> results{};

  ModifyHostsPortResponseBody() {}

  explicit ModifyHostsPortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<ModifyHostsPortResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyHostsPortResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<ModifyHostsPortResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~ModifyHostsPortResponseBody() = default;
};
class ModifyHostsPortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHostsPortResponseBody> body{};

  ModifyHostsPortResponse() {}

  explicit ModifyHostsPortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHostsPortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHostsPortResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHostsPortResponse() = default;
};
class ModifyInstanceADAuthServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> baseDN{};
  shared_ptr<string> domain{};
  shared_ptr<string> emailMapping{};
  shared_ptr<string> filter{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isSSL{};
  shared_ptr<string> mobileMapping{};
  shared_ptr<string> nameMapping{};
  shared_ptr<string> password{};
  shared_ptr<string> port{};
  shared_ptr<string> regionId{};
  shared_ptr<string> server{};
  shared_ptr<string> standbyServer{};

  ModifyInstanceADAuthServerRequest() {}

  explicit ModifyInstanceADAuthServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (baseDN) {
      res["BaseDN"] = boost::any(*baseDN);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (emailMapping) {
      res["EmailMapping"] = boost::any(*emailMapping);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isSSL) {
      res["IsSSL"] = boost::any(*isSSL);
    }
    if (mobileMapping) {
      res["MobileMapping"] = boost::any(*mobileMapping);
    }
    if (nameMapping) {
      res["NameMapping"] = boost::any(*nameMapping);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (standbyServer) {
      res["StandbyServer"] = boost::any(*standbyServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("BaseDN") != m.end() && !m["BaseDN"].empty()) {
      baseDN = make_shared<string>(boost::any_cast<string>(m["BaseDN"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EmailMapping") != m.end() && !m["EmailMapping"].empty()) {
      emailMapping = make_shared<string>(boost::any_cast<string>(m["EmailMapping"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsSSL") != m.end() && !m["IsSSL"].empty()) {
      isSSL = make_shared<string>(boost::any_cast<string>(m["IsSSL"]));
    }
    if (m.find("MobileMapping") != m.end() && !m["MobileMapping"].empty()) {
      mobileMapping = make_shared<string>(boost::any_cast<string>(m["MobileMapping"]));
    }
    if (m.find("NameMapping") != m.end() && !m["NameMapping"].empty()) {
      nameMapping = make_shared<string>(boost::any_cast<string>(m["NameMapping"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("StandbyServer") != m.end() && !m["StandbyServer"].empty()) {
      standbyServer = make_shared<string>(boost::any_cast<string>(m["StandbyServer"]));
    }
  }


  virtual ~ModifyInstanceADAuthServerRequest() = default;
};
class ModifyInstanceADAuthServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceADAuthServerResponseBody() {}

  explicit ModifyInstanceADAuthServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceADAuthServerResponseBody() = default;
};
class ModifyInstanceADAuthServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceADAuthServerResponseBody> body{};

  ModifyInstanceADAuthServerResponse() {}

  explicit ModifyInstanceADAuthServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceADAuthServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceADAuthServerResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceADAuthServerResponse() = default;
};
class ModifyInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  ModifyInstanceAttributeRequest() {}

  explicit ModifyInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyInstanceAttributeRequest() = default;
};
class ModifyInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceAttributeResponseBody() {}

  explicit ModifyInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAttributeResponseBody() = default;
};
class ModifyInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceAttributeResponseBody> body{};

  ModifyInstanceAttributeResponse() {}

  explicit ModifyInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAttributeResponse() = default;
};
class ModifyInstanceLDAPAuthServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> baseDN{};
  shared_ptr<string> emailMapping{};
  shared_ptr<string> filter{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isSSL{};
  shared_ptr<string> loginNameMapping{};
  shared_ptr<string> mobileMapping{};
  shared_ptr<string> nameMapping{};
  shared_ptr<string> password{};
  shared_ptr<string> port{};
  shared_ptr<string> regionId{};
  shared_ptr<string> server{};
  shared_ptr<string> standbyServer{};

  ModifyInstanceLDAPAuthServerRequest() {}

  explicit ModifyInstanceLDAPAuthServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (baseDN) {
      res["BaseDN"] = boost::any(*baseDN);
    }
    if (emailMapping) {
      res["EmailMapping"] = boost::any(*emailMapping);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isSSL) {
      res["IsSSL"] = boost::any(*isSSL);
    }
    if (loginNameMapping) {
      res["LoginNameMapping"] = boost::any(*loginNameMapping);
    }
    if (mobileMapping) {
      res["MobileMapping"] = boost::any(*mobileMapping);
    }
    if (nameMapping) {
      res["NameMapping"] = boost::any(*nameMapping);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (standbyServer) {
      res["StandbyServer"] = boost::any(*standbyServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("BaseDN") != m.end() && !m["BaseDN"].empty()) {
      baseDN = make_shared<string>(boost::any_cast<string>(m["BaseDN"]));
    }
    if (m.find("EmailMapping") != m.end() && !m["EmailMapping"].empty()) {
      emailMapping = make_shared<string>(boost::any_cast<string>(m["EmailMapping"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsSSL") != m.end() && !m["IsSSL"].empty()) {
      isSSL = make_shared<string>(boost::any_cast<string>(m["IsSSL"]));
    }
    if (m.find("LoginNameMapping") != m.end() && !m["LoginNameMapping"].empty()) {
      loginNameMapping = make_shared<string>(boost::any_cast<string>(m["LoginNameMapping"]));
    }
    if (m.find("MobileMapping") != m.end() && !m["MobileMapping"].empty()) {
      mobileMapping = make_shared<string>(boost::any_cast<string>(m["MobileMapping"]));
    }
    if (m.find("NameMapping") != m.end() && !m["NameMapping"].empty()) {
      nameMapping = make_shared<string>(boost::any_cast<string>(m["NameMapping"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("StandbyServer") != m.end() && !m["StandbyServer"].empty()) {
      standbyServer = make_shared<string>(boost::any_cast<string>(m["StandbyServer"]));
    }
  }


  virtual ~ModifyInstanceLDAPAuthServerRequest() = default;
};
class ModifyInstanceLDAPAuthServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceLDAPAuthServerResponseBody() {}

  explicit ModifyInstanceLDAPAuthServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceLDAPAuthServerResponseBody() = default;
};
class ModifyInstanceLDAPAuthServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceLDAPAuthServerResponseBody> body{};

  ModifyInstanceLDAPAuthServerResponse() {}

  explicit ModifyInstanceLDAPAuthServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceLDAPAuthServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceLDAPAuthServerResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceLDAPAuthServerResponse() = default;
};
class ModifyInstanceTwoFactorRequest : public Darabonba::Model {
public:
  shared_ptr<string> enableTwoFactor{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> skipTwoFactorTime{};
  shared_ptr<string> twoFactorMethods{};

  ModifyInstanceTwoFactorRequest() {}

  explicit ModifyInstanceTwoFactorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableTwoFactor) {
      res["EnableTwoFactor"] = boost::any(*enableTwoFactor);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (skipTwoFactorTime) {
      res["SkipTwoFactorTime"] = boost::any(*skipTwoFactorTime);
    }
    if (twoFactorMethods) {
      res["TwoFactorMethods"] = boost::any(*twoFactorMethods);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableTwoFactor") != m.end() && !m["EnableTwoFactor"].empty()) {
      enableTwoFactor = make_shared<string>(boost::any_cast<string>(m["EnableTwoFactor"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SkipTwoFactorTime") != m.end() && !m["SkipTwoFactorTime"].empty()) {
      skipTwoFactorTime = make_shared<string>(boost::any_cast<string>(m["SkipTwoFactorTime"]));
    }
    if (m.find("TwoFactorMethods") != m.end() && !m["TwoFactorMethods"].empty()) {
      twoFactorMethods = make_shared<string>(boost::any_cast<string>(m["TwoFactorMethods"]));
    }
  }


  virtual ~ModifyInstanceTwoFactorRequest() = default;
};
class ModifyInstanceTwoFactorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceTwoFactorResponseBody() {}

  explicit ModifyInstanceTwoFactorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceTwoFactorResponseBody() = default;
};
class ModifyInstanceTwoFactorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceTwoFactorResponseBody> body{};

  ModifyInstanceTwoFactorResponse() {}

  explicit ModifyInstanceTwoFactorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceTwoFactorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceTwoFactorResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceTwoFactorResponse() = default;
};
class ModifyNetworkDomainRequestProxies : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> password{};
  shared_ptr<long> port{};
  shared_ptr<string> proxyType{};
  shared_ptr<string> user{};

  ModifyNetworkDomainRequestProxies() {}

  explicit ModifyNetworkDomainRequestProxies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (proxyType) {
      res["ProxyType"] = boost::any(*proxyType);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ProxyType") != m.end() && !m["ProxyType"].empty()) {
      proxyType = make_shared<string>(boost::any_cast<string>(m["ProxyType"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~ModifyNetworkDomainRequestProxies() = default;
};
class ModifyNetworkDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> networkDomainName{};
  shared_ptr<string> networkDomainType{};
  shared_ptr<vector<ModifyNetworkDomainRequestProxies>> proxies{};
  shared_ptr<string> regionId{};

  ModifyNetworkDomainRequest() {}

  explicit ModifyNetworkDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (networkDomainName) {
      res["NetworkDomainName"] = boost::any(*networkDomainName);
    }
    if (networkDomainType) {
      res["NetworkDomainType"] = boost::any(*networkDomainType);
    }
    if (proxies) {
      vector<boost::any> temp1;
      for(auto item1:*proxies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Proxies"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("NetworkDomainName") != m.end() && !m["NetworkDomainName"].empty()) {
      networkDomainName = make_shared<string>(boost::any_cast<string>(m["NetworkDomainName"]));
    }
    if (m.find("NetworkDomainType") != m.end() && !m["NetworkDomainType"].empty()) {
      networkDomainType = make_shared<string>(boost::any_cast<string>(m["NetworkDomainType"]));
    }
    if (m.find("Proxies") != m.end() && !m["Proxies"].empty()) {
      if (typeid(vector<boost::any>) == m["Proxies"].type()) {
        vector<ModifyNetworkDomainRequestProxies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Proxies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyNetworkDomainRequestProxies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proxies = make_shared<vector<ModifyNetworkDomainRequestProxies>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyNetworkDomainRequest() = default;
};
class ModifyNetworkDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNetworkDomainResponseBody() {}

  explicit ModifyNetworkDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNetworkDomainResponseBody() = default;
};
class ModifyNetworkDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNetworkDomainResponseBody> body{};

  ModifyNetworkDomainResponse() {}

  explicit ModifyNetworkDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNetworkDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNetworkDomainResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNetworkDomainResponse() = default;
};
class ModifyPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> priority{};
  shared_ptr<string> regionId{};

  ModifyPolicyRequest() {}

  explicit ModifyPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyPolicyRequest() = default;
};
class ModifyPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPolicyResponseBody() {}

  explicit ModifyPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPolicyResponseBody() = default;
};
class ModifyPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPolicyResponseBody> body{};

  ModifyPolicyResponse() {}

  explicit ModifyPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPolicyResponse() = default;
};
class ModifyRuleRequestDatabases : public Darabonba::Model {
public:
  shared_ptr<vector<string>> databaseAccountIds{};
  shared_ptr<string> databaseId{};

  ModifyRuleRequestDatabases() {}

  explicit ModifyRuleRequestDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseAccountIds) {
      res["DatabaseAccountIds"] = boost::any(*databaseAccountIds);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseAccountIds") != m.end() && !m["DatabaseAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
  }


  virtual ~ModifyRuleRequestDatabases() = default;
};
class ModifyRuleRequestHostGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostAccountNames{};
  shared_ptr<string> hostGroupId{};

  ModifyRuleRequestHostGroups() {}

  explicit ModifyRuleRequestHostGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountNames) {
      res["HostAccountNames"] = boost::any(*hostAccountNames);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountNames") != m.end() && !m["HostAccountNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostAccountNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostAccountNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostAccountNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
  }


  virtual ~ModifyRuleRequestHostGroups() = default;
};
class ModifyRuleRequestHosts : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostAccountIds{};
  shared_ptr<string> hostId{};

  ModifyRuleRequestHosts() {}

  explicit ModifyRuleRequestHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAccountIds) {
      res["HostAccountIds"] = boost::any(*hostAccountIds);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAccountIds") != m.end() && !m["HostAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
  }


  virtual ~ModifyRuleRequestHosts() = default;
};
class ModifyRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<vector<ModifyRuleRequestDatabases>> databases{};
  shared_ptr<long> effectiveEndTime{};
  shared_ptr<long> effectiveStartTime{};
  shared_ptr<vector<ModifyRuleRequestHostGroups>> hostGroups{};
  shared_ptr<vector<ModifyRuleRequestHosts>> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<vector<string>> userGroupIds{};
  shared_ptr<vector<string>> userIds{};

  ModifyRuleRequest() {}

  explicit ModifyRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (effectiveEndTime) {
      res["EffectiveEndTime"] = boost::any(*effectiveEndTime);
    }
    if (effectiveStartTime) {
      res["EffectiveStartTime"] = boost::any(*effectiveStartTime);
    }
    if (hostGroups) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroups"] = boost::any(temp1);
    }
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (userGroupIds) {
      res["UserGroupIds"] = boost::any(*userGroupIds);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<ModifyRuleRequestDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyRuleRequestDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<ModifyRuleRequestDatabases>>(expect1);
      }
    }
    if (m.find("EffectiveEndTime") != m.end() && !m["EffectiveEndTime"].empty()) {
      effectiveEndTime = make_shared<long>(boost::any_cast<long>(m["EffectiveEndTime"]));
    }
    if (m.find("EffectiveStartTime") != m.end() && !m["EffectiveStartTime"].empty()) {
      effectiveStartTime = make_shared<long>(boost::any_cast<long>(m["EffectiveStartTime"]));
    }
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroups"].type()) {
        vector<ModifyRuleRequestHostGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyRuleRequestHostGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroups = make_shared<vector<ModifyRuleRequestHostGroups>>(expect1);
      }
    }
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<ModifyRuleRequestHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyRuleRequestHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<ModifyRuleRequestHosts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("UserGroupIds") != m.end() && !m["UserGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyRuleRequest() = default;
};
class ModifyRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRuleResponseBody() {}

  explicit ModifyRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRuleResponseBody() = default;
};
class ModifyRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRuleResponseBody> body{};

  ModifyRuleResponse() {}

  explicit ModifyRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRuleResponse() = default;
};
class ModifyUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> displayName{};
  shared_ptr<long> effectiveEndTime{};
  shared_ptr<long> effectiveStartTime{};
  shared_ptr<string> email{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> language{};
  shared_ptr<string> languageStatus{};
  shared_ptr<string> mobile{};
  shared_ptr<string> mobileCountryCode{};
  shared_ptr<bool> needResetPassword{};
  shared_ptr<string> password{};
  shared_ptr<string> regionId{};
  shared_ptr<string> twoFactorMethods{};
  shared_ptr<string> twoFactorStatus{};
  shared_ptr<string> userId{};

  ModifyUserRequest() {}

  explicit ModifyUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (effectiveEndTime) {
      res["EffectiveEndTime"] = boost::any(*effectiveEndTime);
    }
    if (effectiveStartTime) {
      res["EffectiveStartTime"] = boost::any(*effectiveStartTime);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (languageStatus) {
      res["LanguageStatus"] = boost::any(*languageStatus);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (mobileCountryCode) {
      res["MobileCountryCode"] = boost::any(*mobileCountryCode);
    }
    if (needResetPassword) {
      res["NeedResetPassword"] = boost::any(*needResetPassword);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (twoFactorMethods) {
      res["TwoFactorMethods"] = boost::any(*twoFactorMethods);
    }
    if (twoFactorStatus) {
      res["TwoFactorStatus"] = boost::any(*twoFactorStatus);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("EffectiveEndTime") != m.end() && !m["EffectiveEndTime"].empty()) {
      effectiveEndTime = make_shared<long>(boost::any_cast<long>(m["EffectiveEndTime"]));
    }
    if (m.find("EffectiveStartTime") != m.end() && !m["EffectiveStartTime"].empty()) {
      effectiveStartTime = make_shared<long>(boost::any_cast<long>(m["EffectiveStartTime"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LanguageStatus") != m.end() && !m["LanguageStatus"].empty()) {
      languageStatus = make_shared<string>(boost::any_cast<string>(m["LanguageStatus"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("MobileCountryCode") != m.end() && !m["MobileCountryCode"].empty()) {
      mobileCountryCode = make_shared<string>(boost::any_cast<string>(m["MobileCountryCode"]));
    }
    if (m.find("NeedResetPassword") != m.end() && !m["NeedResetPassword"].empty()) {
      needResetPassword = make_shared<bool>(boost::any_cast<bool>(m["NeedResetPassword"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TwoFactorMethods") != m.end() && !m["TwoFactorMethods"].empty()) {
      twoFactorMethods = make_shared<string>(boost::any_cast<string>(m["TwoFactorMethods"]));
    }
    if (m.find("TwoFactorStatus") != m.end() && !m["TwoFactorStatus"].empty()) {
      twoFactorStatus = make_shared<string>(boost::any_cast<string>(m["TwoFactorStatus"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ModifyUserRequest() = default;
};
class ModifyUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyUserResponseBody() {}

  explicit ModifyUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyUserResponseBody() = default;
};
class ModifyUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyUserResponseBody> body{};

  ModifyUserResponse() {}

  explicit ModifyUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUserResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUserResponse() = default;
};
class ModifyUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};
  shared_ptr<string> userGroupName{};

  ModifyUserGroupRequest() {}

  explicit ModifyUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userGroupName) {
      res["UserGroupName"] = boost::any(*userGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserGroupName") != m.end() && !m["UserGroupName"].empty()) {
      userGroupName = make_shared<string>(boost::any_cast<string>(m["UserGroupName"]));
    }
  }


  virtual ~ModifyUserGroupRequest() = default;
};
class ModifyUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyUserGroupResponseBody() {}

  explicit ModifyUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyUserGroupResponseBody() = default;
};
class ModifyUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyUserGroupResponseBody> body{};

  ModifyUserGroupResponse() {}

  explicit ModifyUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUserGroupResponse() = default;
};
class ModifyUserPublicKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> publicKeyId{};
  shared_ptr<string> publicKeyName{};
  shared_ptr<string> regionId{};

  ModifyUserPublicKeyRequest() {}

  explicit ModifyUserPublicKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    if (publicKeyName) {
      res["PublicKeyName"] = boost::any(*publicKeyName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
    if (m.find("PublicKeyName") != m.end() && !m["PublicKeyName"].empty()) {
      publicKeyName = make_shared<string>(boost::any_cast<string>(m["PublicKeyName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyUserPublicKeyRequest() = default;
};
class ModifyUserPublicKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyUserPublicKeyResponseBody() {}

  explicit ModifyUserPublicKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyUserPublicKeyResponseBody() = default;
};
class ModifyUserPublicKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyUserPublicKeyResponseBody> body{};

  ModifyUserPublicKeyResponse() {}

  explicit ModifyUserPublicKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUserPublicKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUserPublicKeyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUserPublicKeyResponse() = default;
};
class MoveDatabasesToNetworkDomainRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> databaseIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> regionId{};

  MoveDatabasesToNetworkDomainRequest() {}

  explicit MoveDatabasesToNetworkDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseIds) {
      res["DatabaseIds"] = boost::any(*databaseIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseIds") != m.end() && !m["DatabaseIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~MoveDatabasesToNetworkDomainRequest() = default;
};
class MoveDatabasesToNetworkDomainResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> message{};

  MoveDatabasesToNetworkDomainResponseBodyResults() {}

  explicit MoveDatabasesToNetworkDomainResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~MoveDatabasesToNetworkDomainResponseBodyResults() = default;
};
class MoveDatabasesToNetworkDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<MoveDatabasesToNetworkDomainResponseBodyResults>> results{};

  MoveDatabasesToNetworkDomainResponseBody() {}

  explicit MoveDatabasesToNetworkDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<MoveDatabasesToNetworkDomainResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MoveDatabasesToNetworkDomainResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<MoveDatabasesToNetworkDomainResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~MoveDatabasesToNetworkDomainResponseBody() = default;
};
class MoveDatabasesToNetworkDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveDatabasesToNetworkDomainResponseBody> body{};

  MoveDatabasesToNetworkDomainResponse() {}

  explicit MoveDatabasesToNetworkDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveDatabasesToNetworkDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveDatabasesToNetworkDomainResponseBody>(model1);
      }
    }
  }


  virtual ~MoveDatabasesToNetworkDomainResponse() = default;
};
class MoveHostsToNetworkDomainRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hostIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkDomainId{};
  shared_ptr<string> regionId{};

  MoveHostsToNetworkDomainRequest() {}

  explicit MoveHostsToNetworkDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostIds) {
      res["HostIds"] = boost::any(*hostIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkDomainId) {
      res["NetworkDomainId"] = boost::any(*networkDomainId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostIds") != m.end() && !m["HostIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkDomainId") != m.end() && !m["NetworkDomainId"].empty()) {
      networkDomainId = make_shared<string>(boost::any_cast<string>(m["NetworkDomainId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~MoveHostsToNetworkDomainRequest() = default;
};
class MoveHostsToNetworkDomainResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostId{};
  shared_ptr<string> message{};

  MoveHostsToNetworkDomainResponseBodyResults() {}

  explicit MoveHostsToNetworkDomainResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~MoveHostsToNetworkDomainResponseBodyResults() = default;
};
class MoveHostsToNetworkDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<MoveHostsToNetworkDomainResponseBodyResults>> results{};

  MoveHostsToNetworkDomainResponseBody() {}

  explicit MoveHostsToNetworkDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<MoveHostsToNetworkDomainResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MoveHostsToNetworkDomainResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<MoveHostsToNetworkDomainResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~MoveHostsToNetworkDomainResponseBody() = default;
};
class MoveHostsToNetworkDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveHostsToNetworkDomainResponseBody> body{};

  MoveHostsToNetworkDomainResponse() {}

  explicit MoveHostsToNetworkDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveHostsToNetworkDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveHostsToNetworkDomainResponseBody>(model1);
      }
    }
  }


  virtual ~MoveHostsToNetworkDomainResponse() = default;
};
class MoveResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  MoveResourceGroupRequest() {}

  explicit MoveResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~MoveResourceGroupRequest() = default;
};
class MoveResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  MoveResourceGroupResponseBody() {}

  explicit MoveResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MoveResourceGroupResponseBody() = default;
};
class MoveResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveResourceGroupResponseBody> body{};

  MoveResourceGroupResponse() {}

  explicit MoveResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~MoveResourceGroupResponse() = default;
};
class RejectApproveCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> commandId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  RejectApproveCommandRequest() {}

  explicit RejectApproveCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandId) {
      res["CommandId"] = boost::any(*commandId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandId") != m.end() && !m["CommandId"].empty()) {
      commandId = make_shared<string>(boost::any_cast<string>(m["CommandId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RejectApproveCommandRequest() = default;
};
class RejectApproveCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RejectApproveCommandResponseBody() {}

  explicit RejectApproveCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RejectApproveCommandResponseBody() = default;
};
class RejectApproveCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RejectApproveCommandResponseBody> body{};

  RejectApproveCommandResponse() {}

  explicit RejectApproveCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RejectApproveCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RejectApproveCommandResponseBody>(model1);
      }
    }
  }


  virtual ~RejectApproveCommandResponse() = default;
};
class RejectOperationTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> operationTicketId{};
  shared_ptr<string> regionId{};

  RejectOperationTicketRequest() {}

  explicit RejectOperationTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (operationTicketId) {
      res["OperationTicketId"] = boost::any(*operationTicketId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OperationTicketId") != m.end() && !m["OperationTicketId"].empty()) {
      operationTicketId = make_shared<string>(boost::any_cast<string>(m["OperationTicketId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RejectOperationTicketRequest() = default;
};
class RejectOperationTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RejectOperationTicketResponseBody() {}

  explicit RejectOperationTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RejectOperationTicketResponseBody() = default;
};
class RejectOperationTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RejectOperationTicketResponseBody> body{};

  RejectOperationTicketResponse() {}

  explicit RejectOperationTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RejectOperationTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RejectOperationTicketResponseBody>(model1);
      }
    }
  }


  virtual ~RejectOperationTicketResponse() = default;
};
class RemoveDatabasesFromGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> databaseIds{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  RemoveDatabasesFromGroupRequest() {}

  explicit RemoveDatabasesFromGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseIds) {
      res["DatabaseIds"] = boost::any(*databaseIds);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseIds") != m.end() && !m["DatabaseIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RemoveDatabasesFromGroupRequest() = default;
};
class RemoveDatabasesFromGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> message{};

  RemoveDatabasesFromGroupResponseBodyResults() {}

  explicit RemoveDatabasesFromGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~RemoveDatabasesFromGroupResponseBodyResults() = default;
};
class RemoveDatabasesFromGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<RemoveDatabasesFromGroupResponseBodyResults>> results{};

  RemoveDatabasesFromGroupResponseBody() {}

  explicit RemoveDatabasesFromGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<RemoveDatabasesFromGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveDatabasesFromGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<RemoveDatabasesFromGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~RemoveDatabasesFromGroupResponseBody() = default;
};
class RemoveDatabasesFromGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveDatabasesFromGroupResponseBody> body{};

  RemoveDatabasesFromGroupResponse() {}

  explicit RemoveDatabasesFromGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveDatabasesFromGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveDatabasesFromGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveDatabasesFromGroupResponse() = default;
};
class RemoveHostsFromGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  RemoveHostsFromGroupRequest() {}

  explicit RemoveHostsFromGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostIds) {
      res["HostIds"] = boost::any(*hostIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostIds") != m.end() && !m["HostIds"].empty()) {
      hostIds = make_shared<string>(boost::any_cast<string>(m["HostIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RemoveHostsFromGroupRequest() = default;
};
class RemoveHostsFromGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostId{};
  shared_ptr<string> message{};

  RemoveHostsFromGroupResponseBodyResults() {}

  explicit RemoveHostsFromGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~RemoveHostsFromGroupResponseBodyResults() = default;
};
class RemoveHostsFromGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<RemoveHostsFromGroupResponseBodyResults>> results{};

  RemoveHostsFromGroupResponseBody() {}

  explicit RemoveHostsFromGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<RemoveHostsFromGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveHostsFromGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<RemoveHostsFromGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~RemoveHostsFromGroupResponseBody() = default;
};
class RemoveHostsFromGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveHostsFromGroupResponseBody> body{};

  RemoveHostsFromGroupResponse() {}

  explicit RemoveHostsFromGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveHostsFromGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveHostsFromGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveHostsFromGroupResponse() = default;
};
class RemoveUsersFromGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userGroupId{};
  shared_ptr<string> userIds{};

  RemoveUsersFromGroupRequest() {}

  explicit RemoveUsersFromGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIds = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~RemoveUsersFromGroupRequest() = default;
};
class RemoveUsersFromGroupResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> userGroupId{};
  shared_ptr<string> userId{};

  RemoveUsersFromGroupResponseBodyResults() {}

  explicit RemoveUsersFromGroupResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RemoveUsersFromGroupResponseBodyResults() = default;
};
class RemoveUsersFromGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<RemoveUsersFromGroupResponseBodyResults>> results{};

  RemoveUsersFromGroupResponseBody() {}

  explicit RemoveUsersFromGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<RemoveUsersFromGroupResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveUsersFromGroupResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<RemoveUsersFromGroupResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~RemoveUsersFromGroupResponseBody() = default;
};
class RemoveUsersFromGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveUsersFromGroupResponseBody> body{};

  RemoveUsersFromGroupResponse() {}

  explicit RemoveUsersFromGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUsersFromGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUsersFromGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUsersFromGroupResponse() = default;
};
class RenewAssetOperationTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> tokenId{};

  RenewAssetOperationTokenRequest() {}

  explicit RenewAssetOperationTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tokenId) {
      res["TokenId"] = boost::any(*tokenId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TokenId") != m.end() && !m["TokenId"].empty()) {
      tokenId = make_shared<string>(boost::any_cast<string>(m["TokenId"]));
    }
  }


  virtual ~RenewAssetOperationTokenRequest() = default;
};
class RenewAssetOperationTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RenewAssetOperationTokenResponseBody() {}

  explicit RenewAssetOperationTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewAssetOperationTokenResponseBody() = default;
};
class RenewAssetOperationTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewAssetOperationTokenResponseBody> body{};

  RenewAssetOperationTokenResponse() {}

  explicit RenewAssetOperationTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewAssetOperationTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewAssetOperationTokenResponseBody>(model1);
      }
    }
  }


  virtual ~RenewAssetOperationTokenResponse() = default;
};
class ResetHostAccountCredentialRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialType{};
  shared_ptr<string> hostAccountId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  ResetHostAccountCredentialRequest() {}

  explicit ResetHostAccountCredentialRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialType) {
      res["CredentialType"] = boost::any(*credentialType);
    }
    if (hostAccountId) {
      res["HostAccountId"] = boost::any(*hostAccountId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialType") != m.end() && !m["CredentialType"].empty()) {
      credentialType = make_shared<string>(boost::any_cast<string>(m["CredentialType"]));
    }
    if (m.find("HostAccountId") != m.end() && !m["HostAccountId"].empty()) {
      hostAccountId = make_shared<string>(boost::any_cast<string>(m["HostAccountId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ResetHostAccountCredentialRequest() = default;
};
class ResetHostAccountCredentialResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetHostAccountCredentialResponseBody() {}

  explicit ResetHostAccountCredentialResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetHostAccountCredentialResponseBody() = default;
};
class ResetHostAccountCredentialResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetHostAccountCredentialResponseBody> body{};

  ResetHostAccountCredentialResponse() {}

  explicit ResetHostAccountCredentialResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetHostAccountCredentialResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetHostAccountCredentialResponseBody>(model1);
      }
    }
  }


  virtual ~ResetHostAccountCredentialResponse() = default;
};
class SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfigEffectiveTime : public Darabonba::Model {
public:
  shared_ptr<vector<long>> days{};
  shared_ptr<vector<long>> hours{};

  SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfigEffectiveTime() {}

  explicit SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfigEffectiveTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["Days"] = boost::any(*days);
    }
    if (hours) {
      res["Hours"] = boost::any(*hours);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Days"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Days"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      days = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Hours") != m.end() && !m["Hours"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Hours"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Hours"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      hours = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfigEffectiveTime() = default;
};
class SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfig : public Darabonba::Model {
public:
  shared_ptr<vector<SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfigEffectiveTime>> effectiveTime{};

  SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfig() {}

  explicit SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveTime) {
      vector<boost::any> temp1;
      for(auto item1:*effectiveTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EffectiveTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      if (typeid(vector<boost::any>) == m["EffectiveTime"].type()) {
        vector<SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfigEffectiveTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EffectiveTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfigEffectiveTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        effectiveTime = make_shared<vector<SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfigEffectiveTime>>(expect1);
      }
    }
  }


  virtual ~SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfig() = default;
};
class SetPolicyAccessTimeRangeConfigRequest : public Darabonba::Model {
public:
  shared_ptr<SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfig> accessTimeRangeConfig{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  SetPolicyAccessTimeRangeConfigRequest() {}

  explicit SetPolicyAccessTimeRangeConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessTimeRangeConfig) {
      res["AccessTimeRangeConfig"] = accessTimeRangeConfig ? boost::any(accessTimeRangeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessTimeRangeConfig") != m.end() && !m["AccessTimeRangeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccessTimeRangeConfig"].type()) {
        SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccessTimeRangeConfig"]));
        accessTimeRangeConfig = make_shared<SetPolicyAccessTimeRangeConfigRequestAccessTimeRangeConfig>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetPolicyAccessTimeRangeConfigRequest() = default;
};
class SetPolicyAccessTimeRangeConfigShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessTimeRangeConfigShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  SetPolicyAccessTimeRangeConfigShrinkRequest() {}

  explicit SetPolicyAccessTimeRangeConfigShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessTimeRangeConfigShrink) {
      res["AccessTimeRangeConfig"] = boost::any(*accessTimeRangeConfigShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessTimeRangeConfig") != m.end() && !m["AccessTimeRangeConfig"].empty()) {
      accessTimeRangeConfigShrink = make_shared<string>(boost::any_cast<string>(m["AccessTimeRangeConfig"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetPolicyAccessTimeRangeConfigShrinkRequest() = default;
};
class SetPolicyAccessTimeRangeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetPolicyAccessTimeRangeConfigResponseBody() {}

  explicit SetPolicyAccessTimeRangeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPolicyAccessTimeRangeConfigResponseBody() = default;
};
class SetPolicyAccessTimeRangeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPolicyAccessTimeRangeConfigResponseBody> body{};

  SetPolicyAccessTimeRangeConfigResponse() {}

  explicit SetPolicyAccessTimeRangeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPolicyAccessTimeRangeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPolicyAccessTimeRangeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetPolicyAccessTimeRangeConfigResponse() = default;
};
class SetPolicyApprovalConfigRequestApprovalConfig : public Darabonba::Model {
public:
  shared_ptr<string> switchStatus{};

  SetPolicyApprovalConfigRequestApprovalConfig() {}

  explicit SetPolicyApprovalConfigRequestApprovalConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (switchStatus) {
      res["SwitchStatus"] = boost::any(*switchStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SwitchStatus") != m.end() && !m["SwitchStatus"].empty()) {
      switchStatus = make_shared<string>(boost::any_cast<string>(m["SwitchStatus"]));
    }
  }


  virtual ~SetPolicyApprovalConfigRequestApprovalConfig() = default;
};
class SetPolicyApprovalConfigRequest : public Darabonba::Model {
public:
  shared_ptr<SetPolicyApprovalConfigRequestApprovalConfig> approvalConfig{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  SetPolicyApprovalConfigRequest() {}

  explicit SetPolicyApprovalConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalConfig) {
      res["ApprovalConfig"] = approvalConfig ? boost::any(approvalConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApprovalConfig") != m.end() && !m["ApprovalConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApprovalConfig"].type()) {
        SetPolicyApprovalConfigRequestApprovalConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApprovalConfig"]));
        approvalConfig = make_shared<SetPolicyApprovalConfigRequestApprovalConfig>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetPolicyApprovalConfigRequest() = default;
};
class SetPolicyApprovalConfigShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> approvalConfigShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  SetPolicyApprovalConfigShrinkRequest() {}

  explicit SetPolicyApprovalConfigShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalConfigShrink) {
      res["ApprovalConfig"] = boost::any(*approvalConfigShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApprovalConfig") != m.end() && !m["ApprovalConfig"].empty()) {
      approvalConfigShrink = make_shared<string>(boost::any_cast<string>(m["ApprovalConfig"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetPolicyApprovalConfigShrinkRequest() = default;
};
class SetPolicyApprovalConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetPolicyApprovalConfigResponseBody() {}

  explicit SetPolicyApprovalConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPolicyApprovalConfigResponseBody() = default;
};
class SetPolicyApprovalConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPolicyApprovalConfigResponseBody> body{};

  SetPolicyApprovalConfigResponse() {}

  explicit SetPolicyApprovalConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPolicyApprovalConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPolicyApprovalConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetPolicyApprovalConfigResponse() = default;
};
class SetPolicyAssetScopeRequestDatabases : public Darabonba::Model {
public:
  shared_ptr<string> accountScopeType{};
  shared_ptr<vector<string>> databaseAccountIds{};
  shared_ptr<string> databaseId{};

  SetPolicyAssetScopeRequestDatabases() {}

  explicit SetPolicyAssetScopeRequestDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountScopeType) {
      res["AccountScopeType"] = boost::any(*accountScopeType);
    }
    if (databaseAccountIds) {
      res["DatabaseAccountIds"] = boost::any(*databaseAccountIds);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountScopeType") != m.end() && !m["AccountScopeType"].empty()) {
      accountScopeType = make_shared<string>(boost::any_cast<string>(m["AccountScopeType"]));
    }
    if (m.find("DatabaseAccountIds") != m.end() && !m["DatabaseAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      databaseAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
  }


  virtual ~SetPolicyAssetScopeRequestDatabases() = default;
};
class SetPolicyAssetScopeRequestHostGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> accountNames{};
  shared_ptr<string> accountScopeType{};
  shared_ptr<string> hostGroupId{};

  SetPolicyAssetScopeRequestHostGroups() {}

  explicit SetPolicyAssetScopeRequestHostGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountNames) {
      res["AccountNames"] = boost::any(*accountNames);
    }
    if (accountScopeType) {
      res["AccountScopeType"] = boost::any(*accountScopeType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountNames") != m.end() && !m["AccountNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AccountNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AccountNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      accountNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AccountScopeType") != m.end() && !m["AccountScopeType"].empty()) {
      accountScopeType = make_shared<string>(boost::any_cast<string>(m["AccountScopeType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
  }


  virtual ~SetPolicyAssetScopeRequestHostGroups() = default;
};
class SetPolicyAssetScopeRequestHosts : public Darabonba::Model {
public:
  shared_ptr<string> accountScopeType{};
  shared_ptr<vector<string>> hostAccountIds{};
  shared_ptr<string> hostId{};

  SetPolicyAssetScopeRequestHosts() {}

  explicit SetPolicyAssetScopeRequestHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountScopeType) {
      res["AccountScopeType"] = boost::any(*accountScopeType);
    }
    if (hostAccountIds) {
      res["HostAccountIds"] = boost::any(*hostAccountIds);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountScopeType") != m.end() && !m["AccountScopeType"].empty()) {
      accountScopeType = make_shared<string>(boost::any_cast<string>(m["AccountScopeType"]));
    }
    if (m.find("HostAccountIds") != m.end() && !m["HostAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
  }


  virtual ~SetPolicyAssetScopeRequestHosts() = default;
};
class SetPolicyAssetScopeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<SetPolicyAssetScopeRequestDatabases>> databases{};
  shared_ptr<vector<SetPolicyAssetScopeRequestHostGroups>> hostGroups{};
  shared_ptr<vector<SetPolicyAssetScopeRequestHosts>> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scopeType{};

  SetPolicyAssetScopeRequest() {}

  explicit SetPolicyAssetScopeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (hostGroups) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroups"] = boost::any(temp1);
    }
    if (hosts) {
      vector<boost::any> temp1;
      for(auto item1:*hosts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hosts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<SetPolicyAssetScopeRequestDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetPolicyAssetScopeRequestDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<SetPolicyAssetScopeRequestDatabases>>(expect1);
      }
    }
    if (m.find("HostGroups") != m.end() && !m["HostGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroups"].type()) {
        vector<SetPolicyAssetScopeRequestHostGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetPolicyAssetScopeRequestHostGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroups = make_shared<vector<SetPolicyAssetScopeRequestHostGroups>>(expect1);
      }
    }
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(vector<boost::any>) == m["Hosts"].type()) {
        vector<SetPolicyAssetScopeRequestHosts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hosts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetPolicyAssetScopeRequestHosts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hosts = make_shared<vector<SetPolicyAssetScopeRequestHosts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
  }


  virtual ~SetPolicyAssetScopeRequest() = default;
};
class SetPolicyAssetScopeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetPolicyAssetScopeResponseBody() {}

  explicit SetPolicyAssetScopeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPolicyAssetScopeResponseBody() = default;
};
class SetPolicyAssetScopeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPolicyAssetScopeResponseBody> body{};

  SetPolicyAssetScopeResponse() {}

  explicit SetPolicyAssetScopeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPolicyAssetScopeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPolicyAssetScopeResponseBody>(model1);
      }
    }
  }


  virtual ~SetPolicyAssetScopeResponse() = default;
};
class SetPolicyCommandConfigRequestCommandConfigApproval : public Darabonba::Model {
public:
  shared_ptr<vector<string>> commands{};

  SetPolicyCommandConfigRequestCommandConfigApproval() {}

  explicit SetPolicyCommandConfigRequestCommandConfigApproval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SetPolicyCommandConfigRequestCommandConfigApproval() = default;
};
class SetPolicyCommandConfigRequestCommandConfigDeny : public Darabonba::Model {
public:
  shared_ptr<string> aclType{};
  shared_ptr<vector<string>> commands{};

  SetPolicyCommandConfigRequestCommandConfigDeny() {}

  explicit SetPolicyCommandConfigRequestCommandConfigDeny(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Commands"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Commands"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      commands = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SetPolicyCommandConfigRequestCommandConfigDeny() = default;
};
class SetPolicyCommandConfigRequestCommandConfig : public Darabonba::Model {
public:
  shared_ptr<SetPolicyCommandConfigRequestCommandConfigApproval> approval{};
  shared_ptr<SetPolicyCommandConfigRequestCommandConfigDeny> deny{};

  SetPolicyCommandConfigRequestCommandConfig() {}

  explicit SetPolicyCommandConfigRequestCommandConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approval) {
      res["Approval"] = approval ? boost::any(approval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deny) {
      res["Deny"] = deny ? boost::any(deny->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Approval") != m.end() && !m["Approval"].empty()) {
      if (typeid(map<string, boost::any>) == m["Approval"].type()) {
        SetPolicyCommandConfigRequestCommandConfigApproval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Approval"]));
        approval = make_shared<SetPolicyCommandConfigRequestCommandConfigApproval>(model1);
      }
    }
    if (m.find("Deny") != m.end() && !m["Deny"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deny"].type()) {
        SetPolicyCommandConfigRequestCommandConfigDeny model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deny"]));
        deny = make_shared<SetPolicyCommandConfigRequestCommandConfigDeny>(model1);
      }
    }
  }


  virtual ~SetPolicyCommandConfigRequestCommandConfig() = default;
};
class SetPolicyCommandConfigRequest : public Darabonba::Model {
public:
  shared_ptr<SetPolicyCommandConfigRequestCommandConfig> commandConfig{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  SetPolicyCommandConfigRequest() {}

  explicit SetPolicyCommandConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandConfig) {
      res["CommandConfig"] = commandConfig ? boost::any(commandConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandConfig") != m.end() && !m["CommandConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommandConfig"].type()) {
        SetPolicyCommandConfigRequestCommandConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommandConfig"]));
        commandConfig = make_shared<SetPolicyCommandConfigRequestCommandConfig>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetPolicyCommandConfigRequest() = default;
};
class SetPolicyCommandConfigShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> commandConfigShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  SetPolicyCommandConfigShrinkRequest() {}

  explicit SetPolicyCommandConfigShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commandConfigShrink) {
      res["CommandConfig"] = boost::any(*commandConfigShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommandConfig") != m.end() && !m["CommandConfig"].empty()) {
      commandConfigShrink = make_shared<string>(boost::any_cast<string>(m["CommandConfig"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetPolicyCommandConfigShrinkRequest() = default;
};
class SetPolicyCommandConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetPolicyCommandConfigResponseBody() {}

  explicit SetPolicyCommandConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPolicyCommandConfigResponseBody() = default;
};
class SetPolicyCommandConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPolicyCommandConfigResponseBody> body{};

  SetPolicyCommandConfigResponse() {}

  explicit SetPolicyCommandConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPolicyCommandConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPolicyCommandConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetPolicyCommandConfigResponse() = default;
};
class SetPolicyIPAclConfigRequestIPAclConfig : public Darabonba::Model {
public:
  shared_ptr<string> aclType{};
  shared_ptr<vector<string>> IPs{};

  SetPolicyIPAclConfigRequestIPAclConfig() {}

  explicit SetPolicyIPAclConfigRequestIPAclConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (IPs) {
      res["IPs"] = boost::any(*IPs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("IPs") != m.end() && !m["IPs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPs = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SetPolicyIPAclConfigRequestIPAclConfig() = default;
};
class SetPolicyIPAclConfigRequest : public Darabonba::Model {
public:
  shared_ptr<SetPolicyIPAclConfigRequestIPAclConfig> IPAclConfig{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  SetPolicyIPAclConfigRequest() {}

  explicit SetPolicyIPAclConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPAclConfig) {
      res["IPAclConfig"] = IPAclConfig ? boost::any(IPAclConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPAclConfig") != m.end() && !m["IPAclConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IPAclConfig"].type()) {
        SetPolicyIPAclConfigRequestIPAclConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IPAclConfig"]));
        IPAclConfig = make_shared<SetPolicyIPAclConfigRequestIPAclConfig>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetPolicyIPAclConfigRequest() = default;
};
class SetPolicyIPAclConfigShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> IPAclConfigShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  SetPolicyIPAclConfigShrinkRequest() {}

  explicit SetPolicyIPAclConfigShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPAclConfigShrink) {
      res["IPAclConfig"] = boost::any(*IPAclConfigShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPAclConfig") != m.end() && !m["IPAclConfig"].empty()) {
      IPAclConfigShrink = make_shared<string>(boost::any_cast<string>(m["IPAclConfig"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetPolicyIPAclConfigShrinkRequest() = default;
};
class SetPolicyIPAclConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetPolicyIPAclConfigResponseBody() {}

  explicit SetPolicyIPAclConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPolicyIPAclConfigResponseBody() = default;
};
class SetPolicyIPAclConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPolicyIPAclConfigResponseBody> body{};

  SetPolicyIPAclConfigResponse() {}

  explicit SetPolicyIPAclConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPolicyIPAclConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPolicyIPAclConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetPolicyIPAclConfigResponse() = default;
};
class SetPolicyProtocolConfigRequestProtocolConfigRDP : public Darabonba::Model {
public:
  shared_ptr<string> clipboardDownload{};
  shared_ptr<string> clipboardUpload{};
  shared_ptr<string> diskRedirection{};
  shared_ptr<string> recordKeyboard{};

  SetPolicyProtocolConfigRequestProtocolConfigRDP() {}

  explicit SetPolicyProtocolConfigRequestProtocolConfigRDP(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipboardDownload) {
      res["ClipboardDownload"] = boost::any(*clipboardDownload);
    }
    if (clipboardUpload) {
      res["ClipboardUpload"] = boost::any(*clipboardUpload);
    }
    if (diskRedirection) {
      res["DiskRedirection"] = boost::any(*diskRedirection);
    }
    if (recordKeyboard) {
      res["RecordKeyboard"] = boost::any(*recordKeyboard);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipboardDownload") != m.end() && !m["ClipboardDownload"].empty()) {
      clipboardDownload = make_shared<string>(boost::any_cast<string>(m["ClipboardDownload"]));
    }
    if (m.find("ClipboardUpload") != m.end() && !m["ClipboardUpload"].empty()) {
      clipboardUpload = make_shared<string>(boost::any_cast<string>(m["ClipboardUpload"]));
    }
    if (m.find("DiskRedirection") != m.end() && !m["DiskRedirection"].empty()) {
      diskRedirection = make_shared<string>(boost::any_cast<string>(m["DiskRedirection"]));
    }
    if (m.find("RecordKeyboard") != m.end() && !m["RecordKeyboard"].empty()) {
      recordKeyboard = make_shared<string>(boost::any_cast<string>(m["RecordKeyboard"]));
    }
  }


  virtual ~SetPolicyProtocolConfigRequestProtocolConfigRDP() = default;
};
class SetPolicyProtocolConfigRequestProtocolConfigSSH : public Darabonba::Model {
public:
  shared_ptr<string> execCommand{};
  shared_ptr<string> SFTPChannel{};
  shared_ptr<string> SFTPDownloadFile{};
  shared_ptr<string> SFTPMkdir{};
  shared_ptr<string> SFTPRemoveFile{};
  shared_ptr<string> SFTPRenameFile{};
  shared_ptr<string> SFTPRmdir{};
  shared_ptr<string> SFTPUploadFile{};
  shared_ptr<string> SSHChannel{};
  shared_ptr<string> x11Forwarding{};

  SetPolicyProtocolConfigRequestProtocolConfigSSH() {}

  explicit SetPolicyProtocolConfigRequestProtocolConfigSSH(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (execCommand) {
      res["ExecCommand"] = boost::any(*execCommand);
    }
    if (SFTPChannel) {
      res["SFTPChannel"] = boost::any(*SFTPChannel);
    }
    if (SFTPDownloadFile) {
      res["SFTPDownloadFile"] = boost::any(*SFTPDownloadFile);
    }
    if (SFTPMkdir) {
      res["SFTPMkdir"] = boost::any(*SFTPMkdir);
    }
    if (SFTPRemoveFile) {
      res["SFTPRemoveFile"] = boost::any(*SFTPRemoveFile);
    }
    if (SFTPRenameFile) {
      res["SFTPRenameFile"] = boost::any(*SFTPRenameFile);
    }
    if (SFTPRmdir) {
      res["SFTPRmdir"] = boost::any(*SFTPRmdir);
    }
    if (SFTPUploadFile) {
      res["SFTPUploadFile"] = boost::any(*SFTPUploadFile);
    }
    if (SSHChannel) {
      res["SSHChannel"] = boost::any(*SSHChannel);
    }
    if (x11Forwarding) {
      res["X11Forwarding"] = boost::any(*x11Forwarding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecCommand") != m.end() && !m["ExecCommand"].empty()) {
      execCommand = make_shared<string>(boost::any_cast<string>(m["ExecCommand"]));
    }
    if (m.find("SFTPChannel") != m.end() && !m["SFTPChannel"].empty()) {
      SFTPChannel = make_shared<string>(boost::any_cast<string>(m["SFTPChannel"]));
    }
    if (m.find("SFTPDownloadFile") != m.end() && !m["SFTPDownloadFile"].empty()) {
      SFTPDownloadFile = make_shared<string>(boost::any_cast<string>(m["SFTPDownloadFile"]));
    }
    if (m.find("SFTPMkdir") != m.end() && !m["SFTPMkdir"].empty()) {
      SFTPMkdir = make_shared<string>(boost::any_cast<string>(m["SFTPMkdir"]));
    }
    if (m.find("SFTPRemoveFile") != m.end() && !m["SFTPRemoveFile"].empty()) {
      SFTPRemoveFile = make_shared<string>(boost::any_cast<string>(m["SFTPRemoveFile"]));
    }
    if (m.find("SFTPRenameFile") != m.end() && !m["SFTPRenameFile"].empty()) {
      SFTPRenameFile = make_shared<string>(boost::any_cast<string>(m["SFTPRenameFile"]));
    }
    if (m.find("SFTPRmdir") != m.end() && !m["SFTPRmdir"].empty()) {
      SFTPRmdir = make_shared<string>(boost::any_cast<string>(m["SFTPRmdir"]));
    }
    if (m.find("SFTPUploadFile") != m.end() && !m["SFTPUploadFile"].empty()) {
      SFTPUploadFile = make_shared<string>(boost::any_cast<string>(m["SFTPUploadFile"]));
    }
    if (m.find("SSHChannel") != m.end() && !m["SSHChannel"].empty()) {
      SSHChannel = make_shared<string>(boost::any_cast<string>(m["SSHChannel"]));
    }
    if (m.find("X11Forwarding") != m.end() && !m["X11Forwarding"].empty()) {
      x11Forwarding = make_shared<string>(boost::any_cast<string>(m["X11Forwarding"]));
    }
  }


  virtual ~SetPolicyProtocolConfigRequestProtocolConfigSSH() = default;
};
class SetPolicyProtocolConfigRequestProtocolConfig : public Darabonba::Model {
public:
  shared_ptr<SetPolicyProtocolConfigRequestProtocolConfigRDP> RDP{};
  shared_ptr<SetPolicyProtocolConfigRequestProtocolConfigSSH> SSH{};

  SetPolicyProtocolConfigRequestProtocolConfig() {}

  explicit SetPolicyProtocolConfigRequestProtocolConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (RDP) {
      res["RDP"] = RDP ? boost::any(RDP->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (SSH) {
      res["SSH"] = SSH ? boost::any(SSH->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RDP") != m.end() && !m["RDP"].empty()) {
      if (typeid(map<string, boost::any>) == m["RDP"].type()) {
        SetPolicyProtocolConfigRequestProtocolConfigRDP model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RDP"]));
        RDP = make_shared<SetPolicyProtocolConfigRequestProtocolConfigRDP>(model1);
      }
    }
    if (m.find("SSH") != m.end() && !m["SSH"].empty()) {
      if (typeid(map<string, boost::any>) == m["SSH"].type()) {
        SetPolicyProtocolConfigRequestProtocolConfigSSH model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SSH"]));
        SSH = make_shared<SetPolicyProtocolConfigRequestProtocolConfigSSH>(model1);
      }
    }
  }


  virtual ~SetPolicyProtocolConfigRequestProtocolConfig() = default;
};
class SetPolicyProtocolConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<SetPolicyProtocolConfigRequestProtocolConfig> protocolConfig{};
  shared_ptr<string> regionId{};

  SetPolicyProtocolConfigRequest() {}

  explicit SetPolicyProtocolConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (protocolConfig) {
      res["ProtocolConfig"] = protocolConfig ? boost::any(protocolConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("ProtocolConfig") != m.end() && !m["ProtocolConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProtocolConfig"].type()) {
        SetPolicyProtocolConfigRequestProtocolConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProtocolConfig"]));
        protocolConfig = make_shared<SetPolicyProtocolConfigRequestProtocolConfig>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetPolicyProtocolConfigRequest() = default;
};
class SetPolicyProtocolConfigShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> protocolConfigShrink{};
  shared_ptr<string> regionId{};

  SetPolicyProtocolConfigShrinkRequest() {}

  explicit SetPolicyProtocolConfigShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (protocolConfigShrink) {
      res["ProtocolConfig"] = boost::any(*protocolConfigShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("ProtocolConfig") != m.end() && !m["ProtocolConfig"].empty()) {
      protocolConfigShrink = make_shared<string>(boost::any_cast<string>(m["ProtocolConfig"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SetPolicyProtocolConfigShrinkRequest() = default;
};
class SetPolicyProtocolConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetPolicyProtocolConfigResponseBody() {}

  explicit SetPolicyProtocolConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPolicyProtocolConfigResponseBody() = default;
};
class SetPolicyProtocolConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPolicyProtocolConfigResponseBody> body{};

  SetPolicyProtocolConfigResponse() {}

  explicit SetPolicyProtocolConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPolicyProtocolConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPolicyProtocolConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetPolicyProtocolConfigResponse() = default;
};
class SetPolicyUserScopeRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scopeType{};
  shared_ptr<vector<string>> userGroupIds{};
  shared_ptr<vector<string>> userIds{};

  SetPolicyUserScopeRequest() {}

  explicit SetPolicyUserScopeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (userGroupIds) {
      res["UserGroupIds"] = boost::any(*userGroupIds);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
    if (m.find("UserGroupIds") != m.end() && !m["UserGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SetPolicyUserScopeRequest() = default;
};
class SetPolicyUserScopeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetPolicyUserScopeResponseBody() {}

  explicit SetPolicyUserScopeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPolicyUserScopeResponseBody() = default;
};
class SetPolicyUserScopeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPolicyUserScopeResponseBody> body{};

  SetPolicyUserScopeResponse() {}

  explicit SetPolicyUserScopeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPolicyUserScopeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPolicyUserScopeResponseBody>(model1);
      }
    }
  }


  virtual ~SetPolicyUserScopeResponse() = default;
};
class StartInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> clientSecurityGroupIds{};
  shared_ptr<bool> enablePortalPrivateAccess{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> slaveVswitchId{};
  shared_ptr<string> vswitchId{};

  StartInstanceRequest() {}

  explicit StartInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientSecurityGroupIds) {
      res["ClientSecurityGroupIds"] = boost::any(*clientSecurityGroupIds);
    }
    if (enablePortalPrivateAccess) {
      res["EnablePortalPrivateAccess"] = boost::any(*enablePortalPrivateAccess);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (slaveVswitchId) {
      res["SlaveVswitchId"] = boost::any(*slaveVswitchId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientSecurityGroupIds") != m.end() && !m["ClientSecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClientSecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClientSecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clientSecurityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnablePortalPrivateAccess") != m.end() && !m["EnablePortalPrivateAccess"].empty()) {
      enablePortalPrivateAccess = make_shared<bool>(boost::any_cast<bool>(m["EnablePortalPrivateAccess"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SlaveVswitchId") != m.end() && !m["SlaveVswitchId"].empty()) {
      slaveVswitchId = make_shared<string>(boost::any_cast<string>(m["SlaveVswitchId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~StartInstanceRequest() = default;
};
class StartInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  StartInstanceResponseBody() {}

  explicit StartInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartInstanceResponseBody() = default;
};
class StartInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartInstanceResponseBody> body{};

  StartInstanceResponse() {}

  explicit StartInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StartInstanceResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UnlockUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userIds{};

  UnlockUsersRequest() {}

  explicit UnlockUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIds = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~UnlockUsersRequest() = default;
};
class UnlockUsersResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> userId{};

  UnlockUsersResponseBodyResults() {}

  explicit UnlockUsersResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UnlockUsersResponseBodyResults() = default;
};
class UnlockUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<UnlockUsersResponseBodyResults>> results{};

  UnlockUsersResponseBody() {}

  explicit UnlockUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<UnlockUsersResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UnlockUsersResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<UnlockUsersResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~UnlockUsersResponseBody() = default;
};
class UnlockUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnlockUsersResponseBody> body{};

  UnlockUsersResponse() {}

  explicit UnlockUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnlockUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnlockUsersResponseBody>(model1);
      }
    }
  }


  virtual ~UnlockUsersResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class VerifyInstanceADAuthServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> baseDN{};
  shared_ptr<string> domain{};
  shared_ptr<string> filter{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isSSL{};
  shared_ptr<string> password{};
  shared_ptr<string> port{};
  shared_ptr<string> regionId{};
  shared_ptr<string> server{};
  shared_ptr<string> standbyServer{};

  VerifyInstanceADAuthServerRequest() {}

  explicit VerifyInstanceADAuthServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (baseDN) {
      res["BaseDN"] = boost::any(*baseDN);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isSSL) {
      res["IsSSL"] = boost::any(*isSSL);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (standbyServer) {
      res["StandbyServer"] = boost::any(*standbyServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("BaseDN") != m.end() && !m["BaseDN"].empty()) {
      baseDN = make_shared<string>(boost::any_cast<string>(m["BaseDN"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsSSL") != m.end() && !m["IsSSL"].empty()) {
      isSSL = make_shared<string>(boost::any_cast<string>(m["IsSSL"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("StandbyServer") != m.end() && !m["StandbyServer"].empty()) {
      standbyServer = make_shared<string>(boost::any_cast<string>(m["StandbyServer"]));
    }
  }


  virtual ~VerifyInstanceADAuthServerRequest() = default;
};
class VerifyInstanceADAuthServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  VerifyInstanceADAuthServerResponseBody() {}

  explicit VerifyInstanceADAuthServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyInstanceADAuthServerResponseBody() = default;
};
class VerifyInstanceADAuthServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyInstanceADAuthServerResponseBody> body{};

  VerifyInstanceADAuthServerResponse() {}

  explicit VerifyInstanceADAuthServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyInstanceADAuthServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyInstanceADAuthServerResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyInstanceADAuthServerResponse() = default;
};
class VerifyInstanceLDAPAuthServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> baseDN{};
  shared_ptr<string> filter{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isSSL{};
  shared_ptr<string> password{};
  shared_ptr<string> port{};
  shared_ptr<string> regionId{};
  shared_ptr<string> server{};
  shared_ptr<string> standbyServer{};

  VerifyInstanceLDAPAuthServerRequest() {}

  explicit VerifyInstanceLDAPAuthServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (baseDN) {
      res["BaseDN"] = boost::any(*baseDN);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isSSL) {
      res["IsSSL"] = boost::any(*isSSL);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (standbyServer) {
      res["StandbyServer"] = boost::any(*standbyServer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("BaseDN") != m.end() && !m["BaseDN"].empty()) {
      baseDN = make_shared<string>(boost::any_cast<string>(m["BaseDN"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsSSL") != m.end() && !m["IsSSL"].empty()) {
      isSSL = make_shared<string>(boost::any_cast<string>(m["IsSSL"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("StandbyServer") != m.end() && !m["StandbyServer"].empty()) {
      standbyServer = make_shared<string>(boost::any_cast<string>(m["StandbyServer"]));
    }
  }


  virtual ~VerifyInstanceLDAPAuthServerRequest() = default;
};
class VerifyInstanceLDAPAuthServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  VerifyInstanceLDAPAuthServerResponseBody() {}

  explicit VerifyInstanceLDAPAuthServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyInstanceLDAPAuthServerResponseBody() = default;
};
class VerifyInstanceLDAPAuthServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyInstanceLDAPAuthServerResponseBody> body{};

  VerifyInstanceLDAPAuthServerResponse() {}

  explicit VerifyInstanceLDAPAuthServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyInstanceLDAPAuthServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyInstanceLDAPAuthServerResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyInstanceLDAPAuthServerResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AcceptApproveCommandResponse acceptApproveCommandWithOptions(shared_ptr<AcceptApproveCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AcceptApproveCommandResponse acceptApproveCommand(shared_ptr<AcceptApproveCommandRequest> request);
  AcceptOperationTicketResponse acceptOperationTicketWithOptions(shared_ptr<AcceptOperationTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AcceptOperationTicketResponse acceptOperationTicket(shared_ptr<AcceptOperationTicketRequest> request);
  AddDatabasesToGroupResponse addDatabasesToGroupWithOptions(shared_ptr<AddDatabasesToGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDatabasesToGroupResponse addDatabasesToGroup(shared_ptr<AddDatabasesToGroupRequest> request);
  AddHostsToGroupResponse addHostsToGroupWithOptions(shared_ptr<AddHostsToGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddHostsToGroupResponse addHostsToGroup(shared_ptr<AddHostsToGroupRequest> request);
  AddUsersToGroupResponse addUsersToGroupWithOptions(shared_ptr<AddUsersToGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddUsersToGroupResponse addUsersToGroup(shared_ptr<AddUsersToGroupRequest> request);
  AttachDatabaseAccountsToUserResponse attachDatabaseAccountsToUserWithOptions(shared_ptr<AttachDatabaseAccountsToUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachDatabaseAccountsToUserResponse attachDatabaseAccountsToUser(shared_ptr<AttachDatabaseAccountsToUserRequest> request);
  AttachDatabaseAccountsToUserGroupResponse attachDatabaseAccountsToUserGroupWithOptions(shared_ptr<AttachDatabaseAccountsToUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachDatabaseAccountsToUserGroupResponse attachDatabaseAccountsToUserGroup(shared_ptr<AttachDatabaseAccountsToUserGroupRequest> request);
  AttachHostAccountsToHostShareKeyResponse attachHostAccountsToHostShareKeyWithOptions(shared_ptr<AttachHostAccountsToHostShareKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachHostAccountsToHostShareKeyResponse attachHostAccountsToHostShareKey(shared_ptr<AttachHostAccountsToHostShareKeyRequest> request);
  AttachHostAccountsToUserResponse attachHostAccountsToUserWithOptions(shared_ptr<AttachHostAccountsToUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachHostAccountsToUserResponse attachHostAccountsToUser(shared_ptr<AttachHostAccountsToUserRequest> request);
  AttachHostAccountsToUserGroupResponse attachHostAccountsToUserGroupWithOptions(shared_ptr<AttachHostAccountsToUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachHostAccountsToUserGroupResponse attachHostAccountsToUserGroup(shared_ptr<AttachHostAccountsToUserGroupRequest> request);
  AttachHostGroupAccountsToUserResponse attachHostGroupAccountsToUserWithOptions(shared_ptr<AttachHostGroupAccountsToUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachHostGroupAccountsToUserResponse attachHostGroupAccountsToUser(shared_ptr<AttachHostGroupAccountsToUserRequest> request);
  AttachHostGroupAccountsToUserGroupResponse attachHostGroupAccountsToUserGroupWithOptions(shared_ptr<AttachHostGroupAccountsToUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachHostGroupAccountsToUserGroupResponse attachHostGroupAccountsToUserGroup(shared_ptr<AttachHostGroupAccountsToUserGroupRequest> request);
  ConfigInstanceSecurityGroupsResponse configInstanceSecurityGroupsWithOptions(shared_ptr<ConfigInstanceSecurityGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigInstanceSecurityGroupsResponse configInstanceSecurityGroups(shared_ptr<ConfigInstanceSecurityGroupsRequest> request);
  ConfigInstanceWhiteListResponse configInstanceWhiteListWithOptions(shared_ptr<ConfigInstanceWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigInstanceWhiteListResponse configInstanceWhiteList(shared_ptr<ConfigInstanceWhiteListRequest> request);
  CreateDatabaseResponse createDatabaseWithOptions(shared_ptr<CreateDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDatabaseResponse createDatabase(shared_ptr<CreateDatabaseRequest> request);
  CreateDatabaseAccountResponse createDatabaseAccountWithOptions(shared_ptr<CreateDatabaseAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDatabaseAccountResponse createDatabaseAccount(shared_ptr<CreateDatabaseAccountRequest> request);
  CreateExportConfigJobResponse createExportConfigJobWithOptions(shared_ptr<CreateExportConfigJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateExportConfigJobResponse createExportConfigJob(shared_ptr<CreateExportConfigJobRequest> request);
  CreateHostResponse createHostWithOptions(shared_ptr<CreateHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHostResponse createHost(shared_ptr<CreateHostRequest> request);
  CreateHostAccountResponse createHostAccountWithOptions(shared_ptr<CreateHostAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHostAccountResponse createHostAccount(shared_ptr<CreateHostAccountRequest> request);
  CreateHostGroupResponse createHostGroupWithOptions(shared_ptr<CreateHostGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHostGroupResponse createHostGroup(shared_ptr<CreateHostGroupRequest> request);
  CreateHostShareKeyResponse createHostShareKeyWithOptions(shared_ptr<CreateHostShareKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHostShareKeyResponse createHostShareKey(shared_ptr<CreateHostShareKeyRequest> request);
  CreateNetworkDomainResponse createNetworkDomainWithOptions(shared_ptr<CreateNetworkDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkDomainResponse createNetworkDomain(shared_ptr<CreateNetworkDomainRequest> request);
  CreateOperationTicketResponse createOperationTicketWithOptions(shared_ptr<CreateOperationTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOperationTicketResponse createOperationTicket(shared_ptr<CreateOperationTicketRequest> request);
  CreatePolicyResponse createPolicyWithOptions(shared_ptr<CreatePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePolicyResponse createPolicy(shared_ptr<CreatePolicyRequest> request);
  CreateRuleResponse createRuleWithOptions(shared_ptr<CreateRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRuleResponse createRule(shared_ptr<CreateRuleRequest> request);
  CreateUserResponse createUserWithOptions(shared_ptr<CreateUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserResponse createUser(shared_ptr<CreateUserRequest> request);
  CreateUserGroupResponse createUserGroupWithOptions(shared_ptr<CreateUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserGroupResponse createUserGroup(shared_ptr<CreateUserGroupRequest> request);
  CreateUserPublicKeyResponse createUserPublicKeyWithOptions(shared_ptr<CreateUserPublicKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserPublicKeyResponse createUserPublicKey(shared_ptr<CreateUserPublicKeyRequest> request);
  DeleteDatabaseResponse deleteDatabaseWithOptions(shared_ptr<DeleteDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDatabaseResponse deleteDatabase(shared_ptr<DeleteDatabaseRequest> request);
  DeleteDatabaseAccountResponse deleteDatabaseAccountWithOptions(shared_ptr<DeleteDatabaseAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDatabaseAccountResponse deleteDatabaseAccount(shared_ptr<DeleteDatabaseAccountRequest> request);
  DeleteHostResponse deleteHostWithOptions(shared_ptr<DeleteHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHostResponse deleteHost(shared_ptr<DeleteHostRequest> request);
  DeleteHostAccountResponse deleteHostAccountWithOptions(shared_ptr<DeleteHostAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHostAccountResponse deleteHostAccount(shared_ptr<DeleteHostAccountRequest> request);
  DeleteHostGroupResponse deleteHostGroupWithOptions(shared_ptr<DeleteHostGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHostGroupResponse deleteHostGroup(shared_ptr<DeleteHostGroupRequest> request);
  DeleteHostShareKeyResponse deleteHostShareKeyWithOptions(shared_ptr<DeleteHostShareKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHostShareKeyResponse deleteHostShareKey(shared_ptr<DeleteHostShareKeyRequest> request);
  DeleteNetworkDomainResponse deleteNetworkDomainWithOptions(shared_ptr<DeleteNetworkDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkDomainResponse deleteNetworkDomain(shared_ptr<DeleteNetworkDomainRequest> request);
  DeletePolicyResponse deletePolicyWithOptions(shared_ptr<DeletePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePolicyResponse deletePolicy(shared_ptr<DeletePolicyRequest> request);
  DeleteRuleResponse deleteRuleWithOptions(shared_ptr<DeleteRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRuleResponse deleteRule(shared_ptr<DeleteRuleRequest> request);
  DeleteUserResponse deleteUserWithOptions(shared_ptr<DeleteUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserResponse deleteUser(shared_ptr<DeleteUserRequest> request);
  DeleteUserGroupResponse deleteUserGroupWithOptions(shared_ptr<DeleteUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserGroupResponse deleteUserGroup(shared_ptr<DeleteUserGroupRequest> request);
  DeleteUserPublicKeyResponse deleteUserPublicKeyWithOptions(shared_ptr<DeleteUserPublicKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserPublicKeyResponse deleteUserPublicKey(shared_ptr<DeleteUserPublicKeyRequest> request);
  DescribeInstanceAttributeResponse describeInstanceAttributeWithOptions(shared_ptr<DescribeInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceAttributeResponse describeInstanceAttribute(shared_ptr<DescribeInstanceAttributeRequest> request);
  DescribeInstancesResponse describeInstancesWithOptions(shared_ptr<DescribeInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstancesResponse describeInstances(shared_ptr<DescribeInstancesRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DetachDatabaseAccountsFromUserResponse detachDatabaseAccountsFromUserWithOptions(shared_ptr<DetachDatabaseAccountsFromUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachDatabaseAccountsFromUserResponse detachDatabaseAccountsFromUser(shared_ptr<DetachDatabaseAccountsFromUserRequest> request);
  DetachDatabaseAccountsFromUserGroupResponse detachDatabaseAccountsFromUserGroupWithOptions(shared_ptr<DetachDatabaseAccountsFromUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachDatabaseAccountsFromUserGroupResponse detachDatabaseAccountsFromUserGroup(shared_ptr<DetachDatabaseAccountsFromUserGroupRequest> request);
  DetachHostAccountsFromHostShareKeyResponse detachHostAccountsFromHostShareKeyWithOptions(shared_ptr<DetachHostAccountsFromHostShareKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachHostAccountsFromHostShareKeyResponse detachHostAccountsFromHostShareKey(shared_ptr<DetachHostAccountsFromHostShareKeyRequest> request);
  DetachHostAccountsFromUserResponse detachHostAccountsFromUserWithOptions(shared_ptr<DetachHostAccountsFromUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachHostAccountsFromUserResponse detachHostAccountsFromUser(shared_ptr<DetachHostAccountsFromUserRequest> request);
  DetachHostAccountsFromUserGroupResponse detachHostAccountsFromUserGroupWithOptions(shared_ptr<DetachHostAccountsFromUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachHostAccountsFromUserGroupResponse detachHostAccountsFromUserGroup(shared_ptr<DetachHostAccountsFromUserGroupRequest> request);
  DetachHostGroupAccountsFromUserResponse detachHostGroupAccountsFromUserWithOptions(shared_ptr<DetachHostGroupAccountsFromUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachHostGroupAccountsFromUserResponse detachHostGroupAccountsFromUser(shared_ptr<DetachHostGroupAccountsFromUserRequest> request);
  DetachHostGroupAccountsFromUserGroupResponse detachHostGroupAccountsFromUserGroupWithOptions(shared_ptr<DetachHostGroupAccountsFromUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachHostGroupAccountsFromUserGroupResponse detachHostGroupAccountsFromUserGroup(shared_ptr<DetachHostGroupAccountsFromUserGroupRequest> request);
  DisableInstancePublicAccessResponse disableInstancePublicAccessWithOptions(shared_ptr<DisableInstancePublicAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableInstancePublicAccessResponse disableInstancePublicAccess(shared_ptr<DisableInstancePublicAccessRequest> request);
  DisableRuleResponse disableRuleWithOptions(shared_ptr<DisableRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableRuleResponse disableRule(shared_ptr<DisableRuleRequest> request);
  EnableInstancePublicAccessResponse enableInstancePublicAccessWithOptions(shared_ptr<EnableInstancePublicAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableInstancePublicAccessResponse enableInstancePublicAccess(shared_ptr<EnableInstancePublicAccessRequest> request);
  EnableRuleResponse enableRuleWithOptions(shared_ptr<EnableRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableRuleResponse enableRule(shared_ptr<EnableRuleRequest> request);
  GenerateAssetOperationTokenResponse generateAssetOperationTokenWithOptions(shared_ptr<GenerateAssetOperationTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateAssetOperationTokenResponse generateAssetOperationToken(shared_ptr<GenerateAssetOperationTokenRequest> request);
  GetDatabaseResponse getDatabaseWithOptions(shared_ptr<GetDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDatabaseResponse getDatabase(shared_ptr<GetDatabaseRequest> request);
  GetDatabaseAccountResponse getDatabaseAccountWithOptions(shared_ptr<GetDatabaseAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDatabaseAccountResponse getDatabaseAccount(shared_ptr<GetDatabaseAccountRequest> request);
  GetExportConfigJobResponse getExportConfigJobWithOptions(shared_ptr<GetExportConfigJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetExportConfigJobResponse getExportConfigJob(shared_ptr<GetExportConfigJobRequest> request);
  GetHostResponse getHostWithOptions(shared_ptr<GetHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHostResponse getHost(shared_ptr<GetHostRequest> request);
  GetHostAccountResponse getHostAccountWithOptions(shared_ptr<GetHostAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHostAccountResponse getHostAccount(shared_ptr<GetHostAccountRequest> request);
  GetHostGroupResponse getHostGroupWithOptions(shared_ptr<GetHostGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHostGroupResponse getHostGroup(shared_ptr<GetHostGroupRequest> request);
  GetHostShareKeyResponse getHostShareKeyWithOptions(shared_ptr<GetHostShareKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHostShareKeyResponse getHostShareKey(shared_ptr<GetHostShareKeyRequest> request);
  GetInstanceADAuthServerResponse getInstanceADAuthServerWithOptions(shared_ptr<GetInstanceADAuthServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceADAuthServerResponse getInstanceADAuthServer(shared_ptr<GetInstanceADAuthServerRequest> request);
  GetInstanceLDAPAuthServerResponse getInstanceLDAPAuthServerWithOptions(shared_ptr<GetInstanceLDAPAuthServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceLDAPAuthServerResponse getInstanceLDAPAuthServer(shared_ptr<GetInstanceLDAPAuthServerRequest> request);
  GetInstanceStoreInfoResponse getInstanceStoreInfoWithOptions(shared_ptr<GetInstanceStoreInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceStoreInfoResponse getInstanceStoreInfo(shared_ptr<GetInstanceStoreInfoRequest> request);
  GetInstanceTwoFactorResponse getInstanceTwoFactorWithOptions(shared_ptr<GetInstanceTwoFactorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceTwoFactorResponse getInstanceTwoFactor(shared_ptr<GetInstanceTwoFactorRequest> request);
  GetNetworkDomainResponse getNetworkDomainWithOptions(shared_ptr<GetNetworkDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNetworkDomainResponse getNetworkDomain(shared_ptr<GetNetworkDomainRequest> request);
  GetPolicyResponse getPolicyWithOptions(shared_ptr<GetPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPolicyResponse getPolicy(shared_ptr<GetPolicyRequest> request);
  GetPolicyAssetScopeResponse getPolicyAssetScopeWithOptions(shared_ptr<GetPolicyAssetScopeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPolicyAssetScopeResponse getPolicyAssetScope(shared_ptr<GetPolicyAssetScopeRequest> request);
  GetPolicyUserScopeResponse getPolicyUserScopeWithOptions(shared_ptr<GetPolicyUserScopeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPolicyUserScopeResponse getPolicyUserScope(shared_ptr<GetPolicyUserScopeRequest> request);
  GetRuleResponse getRuleWithOptions(shared_ptr<GetRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRuleResponse getRule(shared_ptr<GetRuleRequest> request);
  GetUserResponse getUserWithOptions(shared_ptr<GetUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserResponse getUser(shared_ptr<GetUserRequest> request);
  GetUserGroupResponse getUserGroupWithOptions(shared_ptr<GetUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserGroupResponse getUserGroup(shared_ptr<GetUserGroupRequest> request);
  ListApproveCommandsResponse listApproveCommandsWithOptions(shared_ptr<ListApproveCommandsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApproveCommandsResponse listApproveCommands(shared_ptr<ListApproveCommandsRequest> request);
  ListDatabaseAccountsResponse listDatabaseAccountsWithOptions(shared_ptr<ListDatabaseAccountsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatabaseAccountsResponse listDatabaseAccounts(shared_ptr<ListDatabaseAccountsRequest> request);
  ListDatabaseAccountsForUserResponse listDatabaseAccountsForUserWithOptions(shared_ptr<ListDatabaseAccountsForUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatabaseAccountsForUserResponse listDatabaseAccountsForUser(shared_ptr<ListDatabaseAccountsForUserRequest> request);
  ListDatabaseAccountsForUserGroupResponse listDatabaseAccountsForUserGroupWithOptions(shared_ptr<ListDatabaseAccountsForUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatabaseAccountsForUserGroupResponse listDatabaseAccountsForUserGroup(shared_ptr<ListDatabaseAccountsForUserGroupRequest> request);
  ListDatabasesResponse listDatabasesWithOptions(shared_ptr<ListDatabasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatabasesResponse listDatabases(shared_ptr<ListDatabasesRequest> request);
  ListDatabasesForUserResponse listDatabasesForUserWithOptions(shared_ptr<ListDatabasesForUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatabasesForUserResponse listDatabasesForUser(shared_ptr<ListDatabasesForUserRequest> request);
  ListDatabasesForUserGroupResponse listDatabasesForUserGroupWithOptions(shared_ptr<ListDatabasesForUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatabasesForUserGroupResponse listDatabasesForUserGroup(shared_ptr<ListDatabasesForUserGroupRequest> request);
  ListHostAccountsResponse listHostAccountsWithOptions(shared_ptr<ListHostAccountsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostAccountsResponse listHostAccounts(shared_ptr<ListHostAccountsRequest> request);
  ListHostAccountsForHostShareKeyResponse listHostAccountsForHostShareKeyWithOptions(shared_ptr<ListHostAccountsForHostShareKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostAccountsForHostShareKeyResponse listHostAccountsForHostShareKey(shared_ptr<ListHostAccountsForHostShareKeyRequest> request);
  ListHostAccountsForUserResponse listHostAccountsForUserWithOptions(shared_ptr<ListHostAccountsForUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostAccountsForUserResponse listHostAccountsForUser(shared_ptr<ListHostAccountsForUserRequest> request);
  ListHostAccountsForUserGroupResponse listHostAccountsForUserGroupWithOptions(shared_ptr<ListHostAccountsForUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostAccountsForUserGroupResponse listHostAccountsForUserGroup(shared_ptr<ListHostAccountsForUserGroupRequest> request);
  ListHostGroupAccountNamesForUserResponse listHostGroupAccountNamesForUserWithOptions(shared_ptr<ListHostGroupAccountNamesForUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostGroupAccountNamesForUserResponse listHostGroupAccountNamesForUser(shared_ptr<ListHostGroupAccountNamesForUserRequest> request);
  ListHostGroupAccountNamesForUserGroupResponse listHostGroupAccountNamesForUserGroupWithOptions(shared_ptr<ListHostGroupAccountNamesForUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostGroupAccountNamesForUserGroupResponse listHostGroupAccountNamesForUserGroup(shared_ptr<ListHostGroupAccountNamesForUserGroupRequest> request);
  ListHostGroupsResponse listHostGroupsWithOptions(shared_ptr<ListHostGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostGroupsResponse listHostGroups(shared_ptr<ListHostGroupsRequest> request);
  ListHostGroupsForUserResponse listHostGroupsForUserWithOptions(shared_ptr<ListHostGroupsForUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostGroupsForUserResponse listHostGroupsForUser(shared_ptr<ListHostGroupsForUserRequest> request);
  ListHostGroupsForUserGroupResponse listHostGroupsForUserGroupWithOptions(shared_ptr<ListHostGroupsForUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostGroupsForUserGroupResponse listHostGroupsForUserGroup(shared_ptr<ListHostGroupsForUserGroupRequest> request);
  ListHostShareKeysResponse listHostShareKeysWithOptions(shared_ptr<ListHostShareKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostShareKeysResponse listHostShareKeys(shared_ptr<ListHostShareKeysRequest> request);
  ListHostsResponse listHostsWithOptions(shared_ptr<ListHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostsResponse listHosts(shared_ptr<ListHostsRequest> request);
  ListHostsForUserResponse listHostsForUserWithOptions(shared_ptr<ListHostsForUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostsForUserResponse listHostsForUser(shared_ptr<ListHostsForUserRequest> request);
  ListHostsForUserGroupResponse listHostsForUserGroupWithOptions(shared_ptr<ListHostsForUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostsForUserGroupResponse listHostsForUserGroup(shared_ptr<ListHostsForUserGroupRequest> request);
  ListNetworkDomainsResponse listNetworkDomainsWithOptions(shared_ptr<ListNetworkDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNetworkDomainsResponse listNetworkDomains(shared_ptr<ListNetworkDomainsRequest> request);
  ListOperationDatabaseAccountsResponse listOperationDatabaseAccountsWithOptions(shared_ptr<ListOperationDatabaseAccountsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOperationDatabaseAccountsResponse listOperationDatabaseAccounts(shared_ptr<ListOperationDatabaseAccountsRequest> request);
  ListOperationDatabasesResponse listOperationDatabasesWithOptions(shared_ptr<ListOperationDatabasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOperationDatabasesResponse listOperationDatabases(shared_ptr<ListOperationDatabasesRequest> request);
  ListOperationHostAccountsResponse listOperationHostAccountsWithOptions(shared_ptr<ListOperationHostAccountsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOperationHostAccountsResponse listOperationHostAccounts(shared_ptr<ListOperationHostAccountsRequest> request);
  ListOperationHostsResponse listOperationHostsWithOptions(shared_ptr<ListOperationHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOperationHostsResponse listOperationHosts(shared_ptr<ListOperationHostsRequest> request);
  ListOperationTicketsResponse listOperationTicketsWithOptions(shared_ptr<ListOperationTicketsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOperationTicketsResponse listOperationTickets(shared_ptr<ListOperationTicketsRequest> request);
  ListPoliciesResponse listPoliciesWithOptions(shared_ptr<ListPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPoliciesResponse listPolicies(shared_ptr<ListPoliciesRequest> request);
  ListRulesResponse listRulesWithOptions(shared_ptr<ListRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRulesResponse listRules(shared_ptr<ListRulesRequest> request);
  ListTagKeysResponse listTagKeysWithOptions(shared_ptr<ListTagKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagKeysResponse listTagKeys(shared_ptr<ListTagKeysRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListUserGroupsResponse listUserGroupsWithOptions(shared_ptr<ListUserGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserGroupsResponse listUserGroups(shared_ptr<ListUserGroupsRequest> request);
  ListUserPublicKeysResponse listUserPublicKeysWithOptions(shared_ptr<ListUserPublicKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserPublicKeysResponse listUserPublicKeys(shared_ptr<ListUserPublicKeysRequest> request);
  ListUsersResponse listUsersWithOptions(shared_ptr<ListUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUsersResponse listUsers(shared_ptr<ListUsersRequest> request);
  LockUsersResponse lockUsersWithOptions(shared_ptr<LockUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LockUsersResponse lockUsers(shared_ptr<LockUsersRequest> request);
  ModifyDatabaseResponse modifyDatabaseWithOptions(shared_ptr<ModifyDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDatabaseResponse modifyDatabase(shared_ptr<ModifyDatabaseRequest> request);
  ModifyDatabaseAccountResponse modifyDatabaseAccountWithOptions(shared_ptr<ModifyDatabaseAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDatabaseAccountResponse modifyDatabaseAccount(shared_ptr<ModifyDatabaseAccountRequest> request);
  ModifyHostResponse modifyHostWithOptions(shared_ptr<ModifyHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHostResponse modifyHost(shared_ptr<ModifyHostRequest> request);
  ModifyHostAccountResponse modifyHostAccountWithOptions(shared_ptr<ModifyHostAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHostAccountResponse modifyHostAccount(shared_ptr<ModifyHostAccountRequest> request);
  ModifyHostGroupResponse modifyHostGroupWithOptions(shared_ptr<ModifyHostGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHostGroupResponse modifyHostGroup(shared_ptr<ModifyHostGroupRequest> request);
  ModifyHostShareKeyResponse modifyHostShareKeyWithOptions(shared_ptr<ModifyHostShareKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHostShareKeyResponse modifyHostShareKey(shared_ptr<ModifyHostShareKeyRequest> request);
  ModifyHostsActiveAddressTypeResponse modifyHostsActiveAddressTypeWithOptions(shared_ptr<ModifyHostsActiveAddressTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHostsActiveAddressTypeResponse modifyHostsActiveAddressType(shared_ptr<ModifyHostsActiveAddressTypeRequest> request);
  ModifyHostsPortResponse modifyHostsPortWithOptions(shared_ptr<ModifyHostsPortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHostsPortResponse modifyHostsPort(shared_ptr<ModifyHostsPortRequest> request);
  ModifyInstanceADAuthServerResponse modifyInstanceADAuthServerWithOptions(shared_ptr<ModifyInstanceADAuthServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceADAuthServerResponse modifyInstanceADAuthServer(shared_ptr<ModifyInstanceADAuthServerRequest> request);
  ModifyInstanceAttributeResponse modifyInstanceAttributeWithOptions(shared_ptr<ModifyInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAttributeResponse modifyInstanceAttribute(shared_ptr<ModifyInstanceAttributeRequest> request);
  ModifyInstanceLDAPAuthServerResponse modifyInstanceLDAPAuthServerWithOptions(shared_ptr<ModifyInstanceLDAPAuthServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceLDAPAuthServerResponse modifyInstanceLDAPAuthServer(shared_ptr<ModifyInstanceLDAPAuthServerRequest> request);
  ModifyInstanceTwoFactorResponse modifyInstanceTwoFactorWithOptions(shared_ptr<ModifyInstanceTwoFactorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceTwoFactorResponse modifyInstanceTwoFactor(shared_ptr<ModifyInstanceTwoFactorRequest> request);
  ModifyNetworkDomainResponse modifyNetworkDomainWithOptions(shared_ptr<ModifyNetworkDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNetworkDomainResponse modifyNetworkDomain(shared_ptr<ModifyNetworkDomainRequest> request);
  ModifyPolicyResponse modifyPolicyWithOptions(shared_ptr<ModifyPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPolicyResponse modifyPolicy(shared_ptr<ModifyPolicyRequest> request);
  ModifyRuleResponse modifyRuleWithOptions(shared_ptr<ModifyRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRuleResponse modifyRule(shared_ptr<ModifyRuleRequest> request);
  ModifyUserResponse modifyUserWithOptions(shared_ptr<ModifyUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUserResponse modifyUser(shared_ptr<ModifyUserRequest> request);
  ModifyUserGroupResponse modifyUserGroupWithOptions(shared_ptr<ModifyUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUserGroupResponse modifyUserGroup(shared_ptr<ModifyUserGroupRequest> request);
  ModifyUserPublicKeyResponse modifyUserPublicKeyWithOptions(shared_ptr<ModifyUserPublicKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUserPublicKeyResponse modifyUserPublicKey(shared_ptr<ModifyUserPublicKeyRequest> request);
  MoveDatabasesToNetworkDomainResponse moveDatabasesToNetworkDomainWithOptions(shared_ptr<MoveDatabasesToNetworkDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveDatabasesToNetworkDomainResponse moveDatabasesToNetworkDomain(shared_ptr<MoveDatabasesToNetworkDomainRequest> request);
  MoveHostsToNetworkDomainResponse moveHostsToNetworkDomainWithOptions(shared_ptr<MoveHostsToNetworkDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveHostsToNetworkDomainResponse moveHostsToNetworkDomain(shared_ptr<MoveHostsToNetworkDomainRequest> request);
  MoveResourceGroupResponse moveResourceGroupWithOptions(shared_ptr<MoveResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveResourceGroupResponse moveResourceGroup(shared_ptr<MoveResourceGroupRequest> request);
  RejectApproveCommandResponse rejectApproveCommandWithOptions(shared_ptr<RejectApproveCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RejectApproveCommandResponse rejectApproveCommand(shared_ptr<RejectApproveCommandRequest> request);
  RejectOperationTicketResponse rejectOperationTicketWithOptions(shared_ptr<RejectOperationTicketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RejectOperationTicketResponse rejectOperationTicket(shared_ptr<RejectOperationTicketRequest> request);
  RemoveDatabasesFromGroupResponse removeDatabasesFromGroupWithOptions(shared_ptr<RemoveDatabasesFromGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveDatabasesFromGroupResponse removeDatabasesFromGroup(shared_ptr<RemoveDatabasesFromGroupRequest> request);
  RemoveHostsFromGroupResponse removeHostsFromGroupWithOptions(shared_ptr<RemoveHostsFromGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveHostsFromGroupResponse removeHostsFromGroup(shared_ptr<RemoveHostsFromGroupRequest> request);
  RemoveUsersFromGroupResponse removeUsersFromGroupWithOptions(shared_ptr<RemoveUsersFromGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUsersFromGroupResponse removeUsersFromGroup(shared_ptr<RemoveUsersFromGroupRequest> request);
  RenewAssetOperationTokenResponse renewAssetOperationTokenWithOptions(shared_ptr<RenewAssetOperationTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewAssetOperationTokenResponse renewAssetOperationToken(shared_ptr<RenewAssetOperationTokenRequest> request);
  ResetHostAccountCredentialResponse resetHostAccountCredentialWithOptions(shared_ptr<ResetHostAccountCredentialRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetHostAccountCredentialResponse resetHostAccountCredential(shared_ptr<ResetHostAccountCredentialRequest> request);
  SetPolicyAccessTimeRangeConfigResponse setPolicyAccessTimeRangeConfigWithOptions(shared_ptr<SetPolicyAccessTimeRangeConfigRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPolicyAccessTimeRangeConfigResponse setPolicyAccessTimeRangeConfig(shared_ptr<SetPolicyAccessTimeRangeConfigRequest> request);
  SetPolicyApprovalConfigResponse setPolicyApprovalConfigWithOptions(shared_ptr<SetPolicyApprovalConfigRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPolicyApprovalConfigResponse setPolicyApprovalConfig(shared_ptr<SetPolicyApprovalConfigRequest> request);
  SetPolicyAssetScopeResponse setPolicyAssetScopeWithOptions(shared_ptr<SetPolicyAssetScopeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPolicyAssetScopeResponse setPolicyAssetScope(shared_ptr<SetPolicyAssetScopeRequest> request);
  SetPolicyCommandConfigResponse setPolicyCommandConfigWithOptions(shared_ptr<SetPolicyCommandConfigRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPolicyCommandConfigResponse setPolicyCommandConfig(shared_ptr<SetPolicyCommandConfigRequest> request);
  SetPolicyIPAclConfigResponse setPolicyIPAclConfigWithOptions(shared_ptr<SetPolicyIPAclConfigRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPolicyIPAclConfigResponse setPolicyIPAclConfig(shared_ptr<SetPolicyIPAclConfigRequest> request);
  SetPolicyProtocolConfigResponse setPolicyProtocolConfigWithOptions(shared_ptr<SetPolicyProtocolConfigRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPolicyProtocolConfigResponse setPolicyProtocolConfig(shared_ptr<SetPolicyProtocolConfigRequest> request);
  SetPolicyUserScopeResponse setPolicyUserScopeWithOptions(shared_ptr<SetPolicyUserScopeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPolicyUserScopeResponse setPolicyUserScope(shared_ptr<SetPolicyUserScopeRequest> request);
  StartInstanceResponse startInstanceWithOptions(shared_ptr<StartInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartInstanceResponse startInstance(shared_ptr<StartInstanceRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UnlockUsersResponse unlockUsersWithOptions(shared_ptr<UnlockUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnlockUsersResponse unlockUsers(shared_ptr<UnlockUsersRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  VerifyInstanceADAuthServerResponse verifyInstanceADAuthServerWithOptions(shared_ptr<VerifyInstanceADAuthServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyInstanceADAuthServerResponse verifyInstanceADAuthServer(shared_ptr<VerifyInstanceADAuthServerRequest> request);
  VerifyInstanceLDAPAuthServerResponse verifyInstanceLDAPAuthServerWithOptions(shared_ptr<VerifyInstanceLDAPAuthServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyInstanceLDAPAuthServerResponse verifyInstanceLDAPAuthServer(shared_ptr<VerifyInstanceLDAPAuthServerRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Yundun-bastionhost20191209

#endif
