// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DMS-ENTERPRISE20181101_H_
#define ALIBABACLOUD_DMS-ENTERPRISE20181101_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Dms-enterprise20181101 {
class AsyncTaskVO : public Darabonba::Model {
public:
  shared_ptr<string> datasetId{};
  shared_ptr<long> id{};
  shared_ptr<string> remark{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskStatus{};
  shared_ptr<long> taskType{};
  shared_ptr<long> userId{};

  AsyncTaskVO() {}

  explicit AsyncTaskVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~AsyncTaskVO() = default;
};
class ProjectDetailsLiteVO : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> projectName{};

  ProjectDetailsLiteVO() {}

  explicit ProjectDetailsLiteVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ProjectDetailsLiteVO() = default;
};
class DatasetItemVO : public Darabonba::Model {
public:
  shared_ptr<vector<AsyncTaskVO>> asyncTaskList{};
  shared_ptr<long> datasetStatus{};
  shared_ptr<long> datasetType{};
  shared_ptr<string> digest{};
  shared_ptr<string> fileSystem{};
  shared_ptr<string> id{};
  shared_ptr<string> keyName{};
  shared_ptr<string> moreInfo{};
  shared_ptr<string> path{};
  shared_ptr<vector<ProjectDetailsLiteVO>> projectsLinked{};
  shared_ptr<long> recentTaskStatus{};
  shared_ptr<string> remark{};
  shared_ptr<string> schema{};
  shared_ptr<string> tableName{};
  shared_ptr<string> url{};

  DatasetItemVO() {}

  explicit DatasetItemVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncTaskList) {
      vector<boost::any> temp1;
      for(auto item1:*asyncTaskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AsyncTaskList"] = boost::any(temp1);
    }
    if (datasetStatus) {
      res["DatasetStatus"] = boost::any(*datasetStatus);
    }
    if (datasetType) {
      res["DatasetType"] = boost::any(*datasetType);
    }
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (fileSystem) {
      res["FileSystem"] = boost::any(*fileSystem);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    if (moreInfo) {
      res["MoreInfo"] = boost::any(*moreInfo);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (projectsLinked) {
      vector<boost::any> temp1;
      for(auto item1:*projectsLinked){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectsLinked"] = boost::any(temp1);
    }
    if (recentTaskStatus) {
      res["RecentTaskStatus"] = boost::any(*recentTaskStatus);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncTaskList") != m.end() && !m["AsyncTaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["AsyncTaskList"].type()) {
        vector<AsyncTaskVO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AsyncTaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AsyncTaskVO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        asyncTaskList = make_shared<vector<AsyncTaskVO>>(expect1);
      }
    }
    if (m.find("DatasetStatus") != m.end() && !m["DatasetStatus"].empty()) {
      datasetStatus = make_shared<long>(boost::any_cast<long>(m["DatasetStatus"]));
    }
    if (m.find("DatasetType") != m.end() && !m["DatasetType"].empty()) {
      datasetType = make_shared<long>(boost::any_cast<long>(m["DatasetType"]));
    }
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("FileSystem") != m.end() && !m["FileSystem"].empty()) {
      fileSystem = make_shared<string>(boost::any_cast<string>(m["FileSystem"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
    if (m.find("MoreInfo") != m.end() && !m["MoreInfo"].empty()) {
      moreInfo = make_shared<string>(boost::any_cast<string>(m["MoreInfo"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProjectsLinked") != m.end() && !m["ProjectsLinked"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectsLinked"].type()) {
        vector<ProjectDetailsLiteVO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectsLinked"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ProjectDetailsLiteVO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectsLinked = make_shared<vector<ProjectDetailsLiteVO>>(expect1);
      }
    }
    if (m.find("RecentTaskStatus") != m.end() && !m["RecentTaskStatus"].empty()) {
      recentTaskStatus = make_shared<long>(boost::any_cast<long>(m["RecentTaskStatus"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DatasetItemVO() = default;
};
class GetTableDataKeyVO : public Darabonba::Model {
public:
  shared_ptr<string> colName{};
  shared_ptr<string> dbName{};
  shared_ptr<long> mekId{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> tblName{};
  shared_ptr<string> userName{};

  GetTableDataKeyVO() {}

  explicit GetTableDataKeyVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (colName) {
      res["ColName"] = boost::any(*colName);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (mekId) {
      res["MekId"] = boost::any(*mekId);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (tblName) {
      res["TblName"] = boost::any(*tblName);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColName") != m.end() && !m["ColName"].empty()) {
      colName = make_shared<string>(boost::any_cast<string>(m["ColName"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("MekId") != m.end() && !m["MekId"].empty()) {
      mekId = make_shared<long>(boost::any_cast<long>(m["MekId"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("TblName") != m.end() && !m["TblName"].empty()) {
      tblName = make_shared<string>(boost::any_cast<string>(m["TblName"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~GetTableDataKeyVO() = default;
};
class ImportMasterKeyVO : public Darabonba::Model {
public:
  shared_ptr<string> encryptMekDataBase64{};
  shared_ptr<long> mekId{};
  shared_ptr<vector<long>> projectId{};

  ImportMasterKeyVO() {}

  explicit ImportMasterKeyVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryptMekDataBase64) {
      res["EncryptMekDataBase64"] = boost::any(*encryptMekDataBase64);
    }
    if (mekId) {
      res["MekId"] = boost::any(*mekId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EncryptMekDataBase64") != m.end() && !m["EncryptMekDataBase64"].empty()) {
      encryptMekDataBase64 = make_shared<string>(boost::any_cast<string>(m["EncryptMekDataBase64"]));
    }
    if (m.find("MekId") != m.end() && !m["MekId"].empty()) {
      mekId = make_shared<long>(boost::any_cast<long>(m["MekId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ProjectId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProjectId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      projectId = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ImportMasterKeyVO() = default;
};
class StsApplyVO : public Darabonba::Model {
public:
  shared_ptr<string> aliyunId{};
  shared_ptr<long> duration{};

  StsApplyVO() {}

  explicit StsApplyVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunId) {
      res["AliyunId"] = boost::any(*aliyunId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunId") != m.end() && !m["AliyunId"].empty()) {
      aliyunId = make_shared<string>(boost::any_cast<string>(m["AliyunId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~StsApplyVO() = default;
};
class StsTokenVO : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> accessKeySecret{};
  shared_ptr<string> expiration{};
  shared_ptr<string> securityToken{};

  StsTokenVO() {}

  explicit StsTokenVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (accessKeySecret) {
      res["AccessKeySecret"] = boost::any(*accessKeySecret);
    }
    if (expiration) {
      res["Expiration"] = boost::any(*expiration);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("AccessKeySecret") != m.end() && !m["AccessKeySecret"].empty()) {
      accessKeySecret = make_shared<string>(boost::any_cast<string>(m["AccessKeySecret"]));
    }
    if (m.find("Expiration") != m.end() && !m["Expiration"].empty()) {
      expiration = make_shared<string>(boost::any_cast<string>(m["Expiration"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~StsTokenVO() = default;
};
class TeeEvidenceVO : public Darabonba::Model {
public:
  shared_ptr<string> cipherSuite{};
  shared_ptr<string> enclaveData{};
  shared_ptr<string> encryptPublicKeyPem{};
  shared_ptr<string> encryptPublicKeyType{};
  shared_ptr<string> modifiedDate{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> publicKeyRaBase64{};
  shared_ptr<string> publicKeyRaType{};
  shared_ptr<string> quoteReport{};
  shared_ptr<string> signPublicKeyPem{};
  shared_ptr<string> signPublicKeyType{};
  shared_ptr<vector<string>> trustedMrEnclave{};

  TeeEvidenceVO() {}

  explicit TeeEvidenceVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherSuite) {
      res["CipherSuite"] = boost::any(*cipherSuite);
    }
    if (enclaveData) {
      res["EnclaveData"] = boost::any(*enclaveData);
    }
    if (encryptPublicKeyPem) {
      res["EncryptPublicKeyPem"] = boost::any(*encryptPublicKeyPem);
    }
    if (encryptPublicKeyType) {
      res["EncryptPublicKeyType"] = boost::any(*encryptPublicKeyType);
    }
    if (modifiedDate) {
      res["ModifiedDate"] = boost::any(*modifiedDate);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (publicKeyRaBase64) {
      res["PublicKeyRaBase64"] = boost::any(*publicKeyRaBase64);
    }
    if (publicKeyRaType) {
      res["PublicKeyRaType"] = boost::any(*publicKeyRaType);
    }
    if (quoteReport) {
      res["QuoteReport"] = boost::any(*quoteReport);
    }
    if (signPublicKeyPem) {
      res["SignPublicKeyPem"] = boost::any(*signPublicKeyPem);
    }
    if (signPublicKeyType) {
      res["SignPublicKeyType"] = boost::any(*signPublicKeyType);
    }
    if (trustedMrEnclave) {
      res["TrustedMrEnclave"] = boost::any(*trustedMrEnclave);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CipherSuite") != m.end() && !m["CipherSuite"].empty()) {
      cipherSuite = make_shared<string>(boost::any_cast<string>(m["CipherSuite"]));
    }
    if (m.find("EnclaveData") != m.end() && !m["EnclaveData"].empty()) {
      enclaveData = make_shared<string>(boost::any_cast<string>(m["EnclaveData"]));
    }
    if (m.find("EncryptPublicKeyPem") != m.end() && !m["EncryptPublicKeyPem"].empty()) {
      encryptPublicKeyPem = make_shared<string>(boost::any_cast<string>(m["EncryptPublicKeyPem"]));
    }
    if (m.find("EncryptPublicKeyType") != m.end() && !m["EncryptPublicKeyType"].empty()) {
      encryptPublicKeyType = make_shared<string>(boost::any_cast<string>(m["EncryptPublicKeyType"]));
    }
    if (m.find("ModifiedDate") != m.end() && !m["ModifiedDate"].empty()) {
      modifiedDate = make_shared<string>(boost::any_cast<string>(m["ModifiedDate"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("PublicKeyRaBase64") != m.end() && !m["PublicKeyRaBase64"].empty()) {
      publicKeyRaBase64 = make_shared<string>(boost::any_cast<string>(m["PublicKeyRaBase64"]));
    }
    if (m.find("PublicKeyRaType") != m.end() && !m["PublicKeyRaType"].empty()) {
      publicKeyRaType = make_shared<string>(boost::any_cast<string>(m["PublicKeyRaType"]));
    }
    if (m.find("QuoteReport") != m.end() && !m["QuoteReport"].empty()) {
      quoteReport = make_shared<string>(boost::any_cast<string>(m["QuoteReport"]));
    }
    if (m.find("SignPublicKeyPem") != m.end() && !m["SignPublicKeyPem"].empty()) {
      signPublicKeyPem = make_shared<string>(boost::any_cast<string>(m["SignPublicKeyPem"]));
    }
    if (m.find("SignPublicKeyType") != m.end() && !m["SignPublicKeyType"].empty()) {
      signPublicKeyType = make_shared<string>(boost::any_cast<string>(m["SignPublicKeyType"]));
    }
    if (m.find("TrustedMrEnclave") != m.end() && !m["TrustedMrEnclave"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrustedMrEnclave"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrustedMrEnclave"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trustedMrEnclave = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~TeeEvidenceVO() = default;
};
class UsersDetailsVO : public Darabonba::Model {
public:
  shared_ptr<string> approvalSignatureBase64{};
  shared_ptr<string> approvalSqlTemplate{};
  shared_ptr<string> approvalStatus{};
  shared_ptr<long> creator{};
  shared_ptr<long> dataReady{};
  shared_ptr<long> id{};
  shared_ptr<long> mekid{};
  shared_ptr<string> pathPrefix{};
  shared_ptr<long> resultParty{};
  shared_ptr<string> uid{};
  shared_ptr<long> userConfirmed{};
  shared_ptr<string> userName{};
  shared_ptr<string> userPublicKeyPem{};

  UsersDetailsVO() {}

  explicit UsersDetailsVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalSignatureBase64) {
      res["ApprovalSignatureBase64"] = boost::any(*approvalSignatureBase64);
    }
    if (approvalSqlTemplate) {
      res["ApprovalSqlTemplate"] = boost::any(*approvalSqlTemplate);
    }
    if (approvalStatus) {
      res["ApprovalStatus"] = boost::any(*approvalStatus);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (dataReady) {
      res["DataReady"] = boost::any(*dataReady);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mekid) {
      res["Mekid"] = boost::any(*mekid);
    }
    if (pathPrefix) {
      res["PathPrefix"] = boost::any(*pathPrefix);
    }
    if (resultParty) {
      res["ResultParty"] = boost::any(*resultParty);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userConfirmed) {
      res["UserConfirmed"] = boost::any(*userConfirmed);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userPublicKeyPem) {
      res["UserPublicKeyPem"] = boost::any(*userPublicKeyPem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApprovalSignatureBase64") != m.end() && !m["ApprovalSignatureBase64"].empty()) {
      approvalSignatureBase64 = make_shared<string>(boost::any_cast<string>(m["ApprovalSignatureBase64"]));
    }
    if (m.find("ApprovalSqlTemplate") != m.end() && !m["ApprovalSqlTemplate"].empty()) {
      approvalSqlTemplate = make_shared<string>(boost::any_cast<string>(m["ApprovalSqlTemplate"]));
    }
    if (m.find("ApprovalStatus") != m.end() && !m["ApprovalStatus"].empty()) {
      approvalStatus = make_shared<string>(boost::any_cast<string>(m["ApprovalStatus"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<long>(boost::any_cast<long>(m["Creator"]));
    }
    if (m.find("DataReady") != m.end() && !m["DataReady"].empty()) {
      dataReady = make_shared<long>(boost::any_cast<long>(m["DataReady"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Mekid") != m.end() && !m["Mekid"].empty()) {
      mekid = make_shared<long>(boost::any_cast<long>(m["Mekid"]));
    }
    if (m.find("PathPrefix") != m.end() && !m["PathPrefix"].empty()) {
      pathPrefix = make_shared<string>(boost::any_cast<string>(m["PathPrefix"]));
    }
    if (m.find("ResultParty") != m.end() && !m["ResultParty"].empty()) {
      resultParty = make_shared<long>(boost::any_cast<long>(m["ResultParty"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("UserConfirmed") != m.end() && !m["UserConfirmed"].empty()) {
      userConfirmed = make_shared<long>(boost::any_cast<long>(m["UserConfirmed"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserPublicKeyPem") != m.end() && !m["UserPublicKeyPem"].empty()) {
      userPublicKeyPem = make_shared<string>(boost::any_cast<string>(m["UserPublicKeyPem"]));
    }
  }


  virtual ~UsersDetailsVO() = default;
};
class AddDesensitizationRuleRequest : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, string>>> functionParams{};
  shared_ptr<string> functionType{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleType{};
  shared_ptr<long> tid{};

  AddDesensitizationRuleRequest() {}

  explicit AddDesensitizationRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionParams) {
      res["FunctionParams"] = boost::any(*functionParams);
    }
    if (functionType) {
      res["FunctionType"] = boost::any(*functionType);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionParams") != m.end() && !m["FunctionParams"].empty()) {
      vector<map<string, string>> toVec1;
      if (typeid(vector<boost::any>) == m["FunctionParams"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FunctionParams"]);
        for (auto item:vec1) {
          map<string, string> map2 = boost::any_cast<map<string, string>>(item);
          map<string, string> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      functionParams = make_shared<vector<map<string, string>>>(toVec1);
    }
    if (m.find("FunctionType") != m.end() && !m["FunctionType"].empty()) {
      functionType = make_shared<string>(boost::any_cast<string>(m["FunctionType"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~AddDesensitizationRuleRequest() = default;
};
class AddDesensitizationRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> ruleId{};
  shared_ptr<bool> success{};

  AddDesensitizationRuleResponseBody() {}

  explicit AddDesensitizationRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddDesensitizationRuleResponseBody() = default;
};
class AddDesensitizationRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDesensitizationRuleResponseBody> body{};

  AddDesensitizationRuleResponse() {}

  explicit AddDesensitizationRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDesensitizationRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDesensitizationRuleResponseBody>(model1);
      }
    }
  }


  virtual ~AddDesensitizationRuleResponse() = default;
};
class AddInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataLinkName{};
  shared_ptr<string> databasePassword{};
  shared_ptr<string> databaseUser{};
  shared_ptr<long> dbaId{};
  shared_ptr<long> ddlOnline{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> ecsRegion{};
  shared_ptr<string> enableSellCommon{};
  shared_ptr<string> enableSellSitd{};
  shared_ptr<string> enableSellStable{};
  shared_ptr<string> enableSellTrust{};
  shared_ptr<string> envType{};
  shared_ptr<long> exportTimeout{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceAlias{};
  shared_ptr<string> instanceSource{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> networkType{};
  shared_ptr<long> port{};
  shared_ptr<long> queryTimeout{};
  shared_ptr<string> safeRule{};
  shared_ptr<string> sid{};
  shared_ptr<bool> skipTest{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<long> tid{};
  shared_ptr<long> useDsql{};
  shared_ptr<long> useSsl{};
  shared_ptr<string> vpcId{};

  AddInstanceRequest() {}

  explicit AddInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataLinkName) {
      res["DataLinkName"] = boost::any(*dataLinkName);
    }
    if (databasePassword) {
      res["DatabasePassword"] = boost::any(*databasePassword);
    }
    if (databaseUser) {
      res["DatabaseUser"] = boost::any(*databaseUser);
    }
    if (dbaId) {
      res["DbaId"] = boost::any(*dbaId);
    }
    if (ddlOnline) {
      res["DdlOnline"] = boost::any(*ddlOnline);
    }
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (ecsRegion) {
      res["EcsRegion"] = boost::any(*ecsRegion);
    }
    if (enableSellCommon) {
      res["EnableSellCommon"] = boost::any(*enableSellCommon);
    }
    if (enableSellSitd) {
      res["EnableSellSitd"] = boost::any(*enableSellSitd);
    }
    if (enableSellStable) {
      res["EnableSellStable"] = boost::any(*enableSellStable);
    }
    if (enableSellTrust) {
      res["EnableSellTrust"] = boost::any(*enableSellTrust);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (exportTimeout) {
      res["ExportTimeout"] = boost::any(*exportTimeout);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (instanceAlias) {
      res["InstanceAlias"] = boost::any(*instanceAlias);
    }
    if (instanceSource) {
      res["InstanceSource"] = boost::any(*instanceSource);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (queryTimeout) {
      res["QueryTimeout"] = boost::any(*queryTimeout);
    }
    if (safeRule) {
      res["SafeRule"] = boost::any(*safeRule);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (skipTest) {
      res["SkipTest"] = boost::any(*skipTest);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (useDsql) {
      res["UseDsql"] = boost::any(*useDsql);
    }
    if (useSsl) {
      res["UseSsl"] = boost::any(*useSsl);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataLinkName") != m.end() && !m["DataLinkName"].empty()) {
      dataLinkName = make_shared<string>(boost::any_cast<string>(m["DataLinkName"]));
    }
    if (m.find("DatabasePassword") != m.end() && !m["DatabasePassword"].empty()) {
      databasePassword = make_shared<string>(boost::any_cast<string>(m["DatabasePassword"]));
    }
    if (m.find("DatabaseUser") != m.end() && !m["DatabaseUser"].empty()) {
      databaseUser = make_shared<string>(boost::any_cast<string>(m["DatabaseUser"]));
    }
    if (m.find("DbaId") != m.end() && !m["DbaId"].empty()) {
      dbaId = make_shared<long>(boost::any_cast<long>(m["DbaId"]));
    }
    if (m.find("DdlOnline") != m.end() && !m["DdlOnline"].empty()) {
      ddlOnline = make_shared<long>(boost::any_cast<long>(m["DdlOnline"]));
    }
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("EcsRegion") != m.end() && !m["EcsRegion"].empty()) {
      ecsRegion = make_shared<string>(boost::any_cast<string>(m["EcsRegion"]));
    }
    if (m.find("EnableSellCommon") != m.end() && !m["EnableSellCommon"].empty()) {
      enableSellCommon = make_shared<string>(boost::any_cast<string>(m["EnableSellCommon"]));
    }
    if (m.find("EnableSellSitd") != m.end() && !m["EnableSellSitd"].empty()) {
      enableSellSitd = make_shared<string>(boost::any_cast<string>(m["EnableSellSitd"]));
    }
    if (m.find("EnableSellStable") != m.end() && !m["EnableSellStable"].empty()) {
      enableSellStable = make_shared<string>(boost::any_cast<string>(m["EnableSellStable"]));
    }
    if (m.find("EnableSellTrust") != m.end() && !m["EnableSellTrust"].empty()) {
      enableSellTrust = make_shared<string>(boost::any_cast<string>(m["EnableSellTrust"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ExportTimeout") != m.end() && !m["ExportTimeout"].empty()) {
      exportTimeout = make_shared<long>(boost::any_cast<long>(m["ExportTimeout"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("InstanceAlias") != m.end() && !m["InstanceAlias"].empty()) {
      instanceAlias = make_shared<string>(boost::any_cast<string>(m["InstanceAlias"]));
    }
    if (m.find("InstanceSource") != m.end() && !m["InstanceSource"].empty()) {
      instanceSource = make_shared<string>(boost::any_cast<string>(m["InstanceSource"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("QueryTimeout") != m.end() && !m["QueryTimeout"].empty()) {
      queryTimeout = make_shared<long>(boost::any_cast<long>(m["QueryTimeout"]));
    }
    if (m.find("SafeRule") != m.end() && !m["SafeRule"].empty()) {
      safeRule = make_shared<string>(boost::any_cast<string>(m["SafeRule"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("SkipTest") != m.end() && !m["SkipTest"].empty()) {
      skipTest = make_shared<bool>(boost::any_cast<bool>(m["SkipTest"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UseDsql") != m.end() && !m["UseDsql"].empty()) {
      useDsql = make_shared<long>(boost::any_cast<long>(m["UseDsql"]));
    }
    if (m.find("UseSsl") != m.end() && !m["UseSsl"].empty()) {
      useSsl = make_shared<long>(boost::any_cast<long>(m["UseSsl"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~AddInstanceRequest() = default;
};
class AddInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddInstanceResponseBody() {}

  explicit AddInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddInstanceResponseBody() = default;
};
class AddInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddInstanceResponseBody> body{};

  AddInstanceResponse() {}

  explicit AddInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~AddInstanceResponse() = default;
};
class AddLhMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> roles{};
  shared_ptr<long> userId{};

  AddLhMembersRequestMembers() {}

  explicit AddLhMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roles) {
      res["Roles"] = boost::any(*roles);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Roles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Roles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~AddLhMembersRequestMembers() = default;
};
class AddLhMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddLhMembersRequestMembers>> members{};
  shared_ptr<long> objectId{};
  shared_ptr<long> objectType{};
  shared_ptr<long> tid{};

  AddLhMembersRequest() {}

  explicit AddLhMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<AddLhMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddLhMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<AddLhMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<long>(boost::any_cast<long>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<long>(boost::any_cast<long>(m["ObjectType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~AddLhMembersRequest() = default;
};
class AddLhMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<long> objectId{};
  shared_ptr<long> objectType{};
  shared_ptr<long> tid{};

  AddLhMembersShrinkRequest() {}

  explicit AddLhMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<long>(boost::any_cast<long>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<long>(boost::any_cast<long>(m["ObjectType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~AddLhMembersShrinkRequest() = default;
};
class AddLhMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddLhMembersResponseBody() {}

  explicit AddLhMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddLhMembersResponseBody() = default;
};
class AddLhMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLhMembersResponseBody> body{};

  AddLhMembersResponse() {}

  explicit AddLhMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLhMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLhMembersResponseBody>(model1);
      }
    }
  }


  virtual ~AddLhMembersResponse() = default;
};
class AddLogicTableRouteConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> routeExpr{};
  shared_ptr<string> routeKey{};
  shared_ptr<long> tableId{};
  shared_ptr<long> tid{};

  AddLogicTableRouteConfigRequest() {}

  explicit AddLogicTableRouteConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeExpr) {
      res["RouteExpr"] = boost::any(*routeExpr);
    }
    if (routeKey) {
      res["RouteKey"] = boost::any(*routeKey);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteExpr") != m.end() && !m["RouteExpr"].empty()) {
      routeExpr = make_shared<string>(boost::any_cast<string>(m["RouteExpr"]));
    }
    if (m.find("RouteKey") != m.end() && !m["RouteKey"].empty()) {
      routeKey = make_shared<string>(boost::any_cast<string>(m["RouteKey"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<long>(boost::any_cast<long>(m["TableId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~AddLogicTableRouteConfigRequest() = default;
};
class AddLogicTableRouteConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddLogicTableRouteConfigResponseBody() {}

  explicit AddLogicTableRouteConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddLogicTableRouteConfigResponseBody() = default;
};
class AddLogicTableRouteConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddLogicTableRouteConfigResponseBody> body{};

  AddLogicTableRouteConfigResponse() {}

  explicit AddLogicTableRouteConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddLogicTableRouteConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddLogicTableRouteConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddLogicTableRouteConfigResponse() = default;
};
class AddTaskFlowEdgesRequestEdges : public Darabonba::Model {
public:
  shared_ptr<long> nodeEnd{};
  shared_ptr<long> nodeFrom{};

  AddTaskFlowEdgesRequestEdges() {}

  explicit AddTaskFlowEdgesRequestEdges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeEnd) {
      res["NodeEnd"] = boost::any(*nodeEnd);
    }
    if (nodeFrom) {
      res["NodeFrom"] = boost::any(*nodeFrom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeEnd") != m.end() && !m["NodeEnd"].empty()) {
      nodeEnd = make_shared<long>(boost::any_cast<long>(m["NodeEnd"]));
    }
    if (m.find("NodeFrom") != m.end() && !m["NodeFrom"].empty()) {
      nodeFrom = make_shared<long>(boost::any_cast<long>(m["NodeFrom"]));
    }
  }


  virtual ~AddTaskFlowEdgesRequestEdges() = default;
};
class AddTaskFlowEdgesRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<vector<AddTaskFlowEdgesRequestEdges>> edges{};
  shared_ptr<long> tid{};

  AddTaskFlowEdgesRequest() {}

  explicit AddTaskFlowEdgesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (edges) {
      vector<boost::any> temp1;
      for(auto item1:*edges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Edges"] = boost::any(temp1);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Edges") != m.end() && !m["Edges"].empty()) {
      if (typeid(vector<boost::any>) == m["Edges"].type()) {
        vector<AddTaskFlowEdgesRequestEdges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Edges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddTaskFlowEdgesRequestEdges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        edges = make_shared<vector<AddTaskFlowEdgesRequestEdges>>(expect1);
      }
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~AddTaskFlowEdgesRequest() = default;
};
class AddTaskFlowEdgesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> edgesShrink{};
  shared_ptr<long> tid{};

  AddTaskFlowEdgesShrinkRequest() {}

  explicit AddTaskFlowEdgesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (edgesShrink) {
      res["Edges"] = boost::any(*edgesShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Edges") != m.end() && !m["Edges"].empty()) {
      edgesShrink = make_shared<string>(boost::any_cast<string>(m["Edges"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~AddTaskFlowEdgesShrinkRequest() = default;
};
class AddTaskFlowEdgesResponseBodyEdgeIds : public Darabonba::Model {
public:
  shared_ptr<vector<long>> edgeId{};

  AddTaskFlowEdgesResponseBodyEdgeIds() {}

  explicit AddTaskFlowEdgesResponseBodyEdgeIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edgeId) {
      res["EdgeId"] = boost::any(*edgeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdgeId") != m.end() && !m["EdgeId"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["EdgeId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EdgeId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      edgeId = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~AddTaskFlowEdgesResponseBodyEdgeIds() = default;
};
class AddTaskFlowEdgesResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddTaskFlowEdgesResponseBodyEdgeIds> edgeIds{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddTaskFlowEdgesResponseBody() {}

  explicit AddTaskFlowEdgesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edgeIds) {
      res["EdgeIds"] = edgeIds ? boost::any(edgeIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdgeIds") != m.end() && !m["EdgeIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["EdgeIds"].type()) {
        AddTaskFlowEdgesResponseBodyEdgeIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EdgeIds"]));
        edgeIds = make_shared<AddTaskFlowEdgesResponseBodyEdgeIds>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddTaskFlowEdgesResponseBody() = default;
};
class AddTaskFlowEdgesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTaskFlowEdgesResponseBody> body{};

  AddTaskFlowEdgesResponse() {}

  explicit AddTaskFlowEdgesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTaskFlowEdgesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTaskFlowEdgesResponseBody>(model1);
      }
    }
  }


  virtual ~AddTaskFlowEdgesResponse() = default;
};
class AnalyzeSQLLineageRequest : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<string> sqlContent{};
  shared_ptr<long> tid{};

  AnalyzeSQLLineageRequest() {}

  explicit AnalyzeSQLLineageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (sqlContent) {
      res["SqlContent"] = boost::any(*sqlContent);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("SqlContent") != m.end() && !m["SqlContent"].empty()) {
      sqlContent = make_shared<string>(boost::any_cast<string>(m["SqlContent"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~AnalyzeSQLLineageRequest() = default;
};
class AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail : public Darabonba::Model {
public:
  shared_ptr<string> calWay{};
  shared_ptr<string> code{};

  AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail() {}

  explicit AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calWay) {
      res["CalWay"] = boost::any(*calWay);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalWay") != m.end() && !m["CalWay"].empty()) {
      calWay = make_shared<string>(boost::any_cast<string>(m["CalWay"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail() = default;
};
class AnalyzeSQLLineageResponseBodyLineageResultLineages : public Darabonba::Model {
public:
  shared_ptr<string> dst{};
  shared_ptr<string> lineageType{};
  shared_ptr<string> operType{};
  shared_ptr<AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail> processDetail{};
  shared_ptr<string> src{};

  AnalyzeSQLLineageResponseBodyLineageResultLineages() {}

  explicit AnalyzeSQLLineageResponseBodyLineageResultLineages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dst) {
      res["Dst"] = boost::any(*dst);
    }
    if (lineageType) {
      res["LineageType"] = boost::any(*lineageType);
    }
    if (operType) {
      res["OperType"] = boost::any(*operType);
    }
    if (processDetail) {
      res["ProcessDetail"] = processDetail ? boost::any(processDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (src) {
      res["Src"] = boost::any(*src);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dst") != m.end() && !m["Dst"].empty()) {
      dst = make_shared<string>(boost::any_cast<string>(m["Dst"]));
    }
    if (m.find("LineageType") != m.end() && !m["LineageType"].empty()) {
      lineageType = make_shared<string>(boost::any_cast<string>(m["LineageType"]));
    }
    if (m.find("OperType") != m.end() && !m["OperType"].empty()) {
      operType = make_shared<string>(boost::any_cast<string>(m["OperType"]));
    }
    if (m.find("ProcessDetail") != m.end() && !m["ProcessDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessDetail"].type()) {
        AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessDetail"]));
        processDetail = make_shared<AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail>(model1);
      }
    }
    if (m.find("Src") != m.end() && !m["Src"].empty()) {
      src = make_shared<string>(boost::any_cast<string>(m["Src"]));
    }
  }


  virtual ~AnalyzeSQLLineageResponseBodyLineageResultLineages() = default;
};
class AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields() {}

  explicit AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields() = default;
};
class AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata : public Darabonba::Model {
public:
  shared_ptr<vector<AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields>> fields{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};
  shared_ptr<string> type{};

  AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata() {}

  explicit AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Fields"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata() = default;
};
class AnalyzeSQLLineageResponseBodyLineageResult : public Darabonba::Model {
public:
  shared_ptr<vector<AnalyzeSQLLineageResponseBodyLineageResultLineages>> lineages{};
  shared_ptr<vector<AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata>> objectMetadata{};

  AnalyzeSQLLineageResponseBodyLineageResult() {}

  explicit AnalyzeSQLLineageResponseBodyLineageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lineages) {
      vector<boost::any> temp1;
      for(auto item1:*lineages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Lineages"] = boost::any(temp1);
    }
    if (objectMetadata) {
      vector<boost::any> temp1;
      for(auto item1:*objectMetadata){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ObjectMetadata"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lineages") != m.end() && !m["Lineages"].empty()) {
      if (typeid(vector<boost::any>) == m["Lineages"].type()) {
        vector<AnalyzeSQLLineageResponseBodyLineageResultLineages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Lineages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AnalyzeSQLLineageResponseBodyLineageResultLineages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lineages = make_shared<vector<AnalyzeSQLLineageResponseBodyLineageResultLineages>>(expect1);
      }
    }
    if (m.find("ObjectMetadata") != m.end() && !m["ObjectMetadata"].empty()) {
      if (typeid(vector<boost::any>) == m["ObjectMetadata"].type()) {
        vector<AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ObjectMetadata"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        objectMetadata = make_shared<vector<AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata>>(expect1);
      }
    }
  }


  virtual ~AnalyzeSQLLineageResponseBodyLineageResult() = default;
};
class AnalyzeSQLLineageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<AnalyzeSQLLineageResponseBodyLineageResult> lineageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AnalyzeSQLLineageResponseBody() {}

  explicit AnalyzeSQLLineageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (lineageResult) {
      res["LineageResult"] = lineageResult ? boost::any(lineageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("LineageResult") != m.end() && !m["LineageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["LineageResult"].type()) {
        AnalyzeSQLLineageResponseBodyLineageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LineageResult"]));
        lineageResult = make_shared<AnalyzeSQLLineageResponseBodyLineageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AnalyzeSQLLineageResponseBody() = default;
};
class AnalyzeSQLLineageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AnalyzeSQLLineageResponseBody> body{};

  AnalyzeSQLLineageResponse() {}

  explicit AnalyzeSQLLineageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AnalyzeSQLLineageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AnalyzeSQLLineageResponseBody>(model1);
      }
    }
  }


  virtual ~AnalyzeSQLLineageResponse() = default;
};
class ApproveOrderRequest : public Darabonba::Model {
public:
  shared_ptr<long> approvalNodeId{};
  shared_ptr<string> approvalNodePos{};
  shared_ptr<string> approvalType{};
  shared_ptr<string> comment{};
  shared_ptr<long> newApprover{};
  shared_ptr<long> oldApprover{};
  shared_ptr<long> tid{};
  shared_ptr<long> workflowInstanceId{};

  ApproveOrderRequest() {}

  explicit ApproveOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalNodeId) {
      res["ApprovalNodeId"] = boost::any(*approvalNodeId);
    }
    if (approvalNodePos) {
      res["ApprovalNodePos"] = boost::any(*approvalNodePos);
    }
    if (approvalType) {
      res["ApprovalType"] = boost::any(*approvalType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (newApprover) {
      res["NewApprover"] = boost::any(*newApprover);
    }
    if (oldApprover) {
      res["OldApprover"] = boost::any(*oldApprover);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApprovalNodeId") != m.end() && !m["ApprovalNodeId"].empty()) {
      approvalNodeId = make_shared<long>(boost::any_cast<long>(m["ApprovalNodeId"]));
    }
    if (m.find("ApprovalNodePos") != m.end() && !m["ApprovalNodePos"].empty()) {
      approvalNodePos = make_shared<string>(boost::any_cast<string>(m["ApprovalNodePos"]));
    }
    if (m.find("ApprovalType") != m.end() && !m["ApprovalType"].empty()) {
      approvalType = make_shared<string>(boost::any_cast<string>(m["ApprovalType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("NewApprover") != m.end() && !m["NewApprover"].empty()) {
      newApprover = make_shared<long>(boost::any_cast<long>(m["NewApprover"]));
    }
    if (m.find("OldApprover") != m.end() && !m["OldApprover"].empty()) {
      oldApprover = make_shared<long>(boost::any_cast<long>(m["OldApprover"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
  }


  virtual ~ApproveOrderRequest() = default;
};
class ApproveOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ApproveOrderResponseBody() {}

  explicit ApproveOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ApproveOrderResponseBody() = default;
};
class ApproveOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApproveOrderResponseBody> body{};

  ApproveOrderResponse() {}

  explicit ApproveOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApproveOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApproveOrderResponseBody>(model1);
      }
    }
  }


  virtual ~ApproveOrderResponse() = default;
};
class BackFillRequest : public Darabonba::Model {
public:
  shared_ptr<bool> asc{};
  shared_ptr<string> backFillDate{};
  shared_ptr<string> backFillDateBegin{};
  shared_ptr<string> backFillDateEnd{};
  shared_ptr<long> dagId{};
  shared_ptr<vector<long>> filterNodeIds{};
  shared_ptr<long> historyDagId{};
  shared_ptr<long> interval{};
  shared_ptr<bool> isTriggerSubTree{};
  shared_ptr<vector<long>> startNodeIds{};
  shared_ptr<long> tid{};

  BackFillRequest() {}

  explicit BackFillRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (backFillDate) {
      res["BackFillDate"] = boost::any(*backFillDate);
    }
    if (backFillDateBegin) {
      res["BackFillDateBegin"] = boost::any(*backFillDateBegin);
    }
    if (backFillDateEnd) {
      res["BackFillDateEnd"] = boost::any(*backFillDateEnd);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (filterNodeIds) {
      res["FilterNodeIds"] = boost::any(*filterNodeIds);
    }
    if (historyDagId) {
      res["HistoryDagId"] = boost::any(*historyDagId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (isTriggerSubTree) {
      res["IsTriggerSubTree"] = boost::any(*isTriggerSubTree);
    }
    if (startNodeIds) {
      res["StartNodeIds"] = boost::any(*startNodeIds);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<bool>(boost::any_cast<bool>(m["Asc"]));
    }
    if (m.find("BackFillDate") != m.end() && !m["BackFillDate"].empty()) {
      backFillDate = make_shared<string>(boost::any_cast<string>(m["BackFillDate"]));
    }
    if (m.find("BackFillDateBegin") != m.end() && !m["BackFillDateBegin"].empty()) {
      backFillDateBegin = make_shared<string>(boost::any_cast<string>(m["BackFillDateBegin"]));
    }
    if (m.find("BackFillDateEnd") != m.end() && !m["BackFillDateEnd"].empty()) {
      backFillDateEnd = make_shared<string>(boost::any_cast<string>(m["BackFillDateEnd"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("FilterNodeIds") != m.end() && !m["FilterNodeIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["FilterNodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterNodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      filterNodeIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("HistoryDagId") != m.end() && !m["HistoryDagId"].empty()) {
      historyDagId = make_shared<long>(boost::any_cast<long>(m["HistoryDagId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IsTriggerSubTree") != m.end() && !m["IsTriggerSubTree"].empty()) {
      isTriggerSubTree = make_shared<bool>(boost::any_cast<bool>(m["IsTriggerSubTree"]));
    }
    if (m.find("StartNodeIds") != m.end() && !m["StartNodeIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StartNodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StartNodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      startNodeIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~BackFillRequest() = default;
};
class BackFillShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> asc{};
  shared_ptr<string> backFillDate{};
  shared_ptr<string> backFillDateBegin{};
  shared_ptr<string> backFillDateEnd{};
  shared_ptr<long> dagId{};
  shared_ptr<string> filterNodeIdsShrink{};
  shared_ptr<long> historyDagId{};
  shared_ptr<long> interval{};
  shared_ptr<bool> isTriggerSubTree{};
  shared_ptr<string> startNodeIdsShrink{};
  shared_ptr<long> tid{};

  BackFillShrinkRequest() {}

  explicit BackFillShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asc) {
      res["Asc"] = boost::any(*asc);
    }
    if (backFillDate) {
      res["BackFillDate"] = boost::any(*backFillDate);
    }
    if (backFillDateBegin) {
      res["BackFillDateBegin"] = boost::any(*backFillDateBegin);
    }
    if (backFillDateEnd) {
      res["BackFillDateEnd"] = boost::any(*backFillDateEnd);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (filterNodeIdsShrink) {
      res["FilterNodeIds"] = boost::any(*filterNodeIdsShrink);
    }
    if (historyDagId) {
      res["HistoryDagId"] = boost::any(*historyDagId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (isTriggerSubTree) {
      res["IsTriggerSubTree"] = boost::any(*isTriggerSubTree);
    }
    if (startNodeIdsShrink) {
      res["StartNodeIds"] = boost::any(*startNodeIdsShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asc") != m.end() && !m["Asc"].empty()) {
      asc = make_shared<bool>(boost::any_cast<bool>(m["Asc"]));
    }
    if (m.find("BackFillDate") != m.end() && !m["BackFillDate"].empty()) {
      backFillDate = make_shared<string>(boost::any_cast<string>(m["BackFillDate"]));
    }
    if (m.find("BackFillDateBegin") != m.end() && !m["BackFillDateBegin"].empty()) {
      backFillDateBegin = make_shared<string>(boost::any_cast<string>(m["BackFillDateBegin"]));
    }
    if (m.find("BackFillDateEnd") != m.end() && !m["BackFillDateEnd"].empty()) {
      backFillDateEnd = make_shared<string>(boost::any_cast<string>(m["BackFillDateEnd"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("FilterNodeIds") != m.end() && !m["FilterNodeIds"].empty()) {
      filterNodeIdsShrink = make_shared<string>(boost::any_cast<string>(m["FilterNodeIds"]));
    }
    if (m.find("HistoryDagId") != m.end() && !m["HistoryDagId"].empty()) {
      historyDagId = make_shared<long>(boost::any_cast<long>(m["HistoryDagId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IsTriggerSubTree") != m.end() && !m["IsTriggerSubTree"].empty()) {
      isTriggerSubTree = make_shared<bool>(boost::any_cast<bool>(m["IsTriggerSubTree"]));
    }
    if (m.find("StartNodeIds") != m.end() && !m["StartNodeIds"].empty()) {
      startNodeIdsShrink = make_shared<string>(boost::any_cast<string>(m["StartNodeIds"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~BackFillShrinkRequest() = default;
};
class BackFillResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> dagInstanceId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BackFillResponseBody() {}

  explicit BackFillResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagInstanceId) {
      res["DagInstanceId"] = boost::any(*dagInstanceId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagInstanceId") != m.end() && !m["DagInstanceId"].empty()) {
      dagInstanceId = make_shared<long>(boost::any_cast<long>(m["DagInstanceId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BackFillResponseBody() = default;
};
class BackFillResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BackFillResponseBody> body{};

  BackFillResponse() {}

  explicit BackFillResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BackFillResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BackFillResponseBody>(model1);
      }
    }
  }


  virtual ~BackFillResponse() = default;
};
class BuyPayAsYouGoOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> commodityType{};
  shared_ptr<long> insNum{};
  shared_ptr<long> tid{};
  shared_ptr<string> versionType{};

  BuyPayAsYouGoOrderRequest() {}

  explicit BuyPayAsYouGoOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityType) {
      res["CommodityType"] = boost::any(*commodityType);
    }
    if (insNum) {
      res["InsNum"] = boost::any(*insNum);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityType") != m.end() && !m["CommodityType"].empty()) {
      commodityType = make_shared<string>(boost::any_cast<string>(m["CommodityType"]));
    }
    if (m.find("InsNum") != m.end() && !m["InsNum"].empty()) {
      insNum = make_shared<long>(boost::any_cast<long>(m["InsNum"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~BuyPayAsYouGoOrderRequest() = default;
};
class BuyPayAsYouGoOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BuyPayAsYouGoOrderResponseBody() {}

  explicit BuyPayAsYouGoOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BuyPayAsYouGoOrderResponseBody() = default;
};
class BuyPayAsYouGoOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BuyPayAsYouGoOrderResponseBody> body{};

  BuyPayAsYouGoOrderResponse() {}

  explicit BuyPayAsYouGoOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BuyPayAsYouGoOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BuyPayAsYouGoOrderResponseBody>(model1);
      }
    }
  }


  virtual ~BuyPayAsYouGoOrderResponse() = default;
};
class ChangeColumnSecLevelRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<long> dbId{};
  shared_ptr<bool> isLogic{};
  shared_ptr<string> newLevel{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> tid{};

  ChangeColumnSecLevelRequest() {}

  explicit ChangeColumnSecLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (isLogic) {
      res["IsLogic"] = boost::any(*isLogic);
    }
    if (newLevel) {
      res["NewLevel"] = boost::any(*newLevel);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("IsLogic") != m.end() && !m["IsLogic"].empty()) {
      isLogic = make_shared<bool>(boost::any_cast<bool>(m["IsLogic"]));
    }
    if (m.find("NewLevel") != m.end() && !m["NewLevel"].empty()) {
      newLevel = make_shared<string>(boost::any_cast<string>(m["NewLevel"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ChangeColumnSecLevelRequest() = default;
};
class ChangeColumnSecLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ChangeColumnSecLevelResponseBody() {}

  explicit ChangeColumnSecLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ChangeColumnSecLevelResponseBody() = default;
};
class ChangeColumnSecLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeColumnSecLevelResponseBody> body{};

  ChangeColumnSecLevelResponse() {}

  explicit ChangeColumnSecLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeColumnSecLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeColumnSecLevelResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeColumnSecLevelResponse() = default;
};
class ChangeColumnSecurityLevelRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<long> dbId{};
  shared_ptr<bool> isLogic{};
  shared_ptr<string> newSensitivityLevel{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> tid{};

  ChangeColumnSecurityLevelRequest() {}

  explicit ChangeColumnSecurityLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (isLogic) {
      res["IsLogic"] = boost::any(*isLogic);
    }
    if (newSensitivityLevel) {
      res["NewSensitivityLevel"] = boost::any(*newSensitivityLevel);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("IsLogic") != m.end() && !m["IsLogic"].empty()) {
      isLogic = make_shared<bool>(boost::any_cast<bool>(m["IsLogic"]));
    }
    if (m.find("NewSensitivityLevel") != m.end() && !m["NewSensitivityLevel"].empty()) {
      newSensitivityLevel = make_shared<string>(boost::any_cast<string>(m["NewSensitivityLevel"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ChangeColumnSecurityLevelRequest() = default;
};
class ChangeColumnSecurityLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ChangeColumnSecurityLevelResponseBody() {}

  explicit ChangeColumnSecurityLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ChangeColumnSecurityLevelResponseBody() = default;
};
class ChangeColumnSecurityLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeColumnSecurityLevelResponseBody> body{};

  ChangeColumnSecurityLevelResponse() {}

  explicit ChangeColumnSecurityLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeColumnSecurityLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeColumnSecurityLevelResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeColumnSecurityLevelResponse() = default;
};
class ChangeLhDagOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> ownerUserId{};
  shared_ptr<long> tid{};

  ChangeLhDagOwnerRequest() {}

  explicit ChangeLhDagOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<long>(boost::any_cast<long>(m["OwnerUserId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ChangeLhDagOwnerRequest() = default;
};
class ChangeLhDagOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ChangeLhDagOwnerResponseBody() {}

  explicit ChangeLhDagOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ChangeLhDagOwnerResponseBody() = default;
};
class ChangeLhDagOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeLhDagOwnerResponseBody> body{};

  ChangeLhDagOwnerResponse() {}

  explicit ChangeLhDagOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeLhDagOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeLhDagOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeLhDagOwnerResponse() = default;
};
class CloseOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> closeReason{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  CloseOrderRequest() {}

  explicit CloseOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (closeReason) {
      res["CloseReason"] = boost::any(*closeReason);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloseReason") != m.end() && !m["CloseReason"].empty()) {
      closeReason = make_shared<string>(boost::any_cast<string>(m["CloseReason"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CloseOrderRequest() = default;
};
class CloseOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CloseOrderResponseBody() {}

  explicit CloseOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CloseOrderResponseBody() = default;
};
class CloseOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseOrderResponseBody> body{};

  CloseOrderResponse() {}

  explicit CloseOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CloseOrderResponse() = default;
};
class CreateAuthorityTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> tid{};

  CreateAuthorityTemplateRequest() {}

  explicit CreateAuthorityTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateAuthorityTemplateRequest() = default;
};
class CreateAuthorityTemplateResponseBodyAuthorityTemplateView : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> templateId{};

  CreateAuthorityTemplateResponseBodyAuthorityTemplateView() {}

  explicit CreateAuthorityTemplateResponseBodyAuthorityTemplateView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~CreateAuthorityTemplateResponseBodyAuthorityTemplateView() = default;
};
class CreateAuthorityTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateAuthorityTemplateResponseBodyAuthorityTemplateView> authorityTemplateView{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> tid{};

  CreateAuthorityTemplateResponseBody() {}

  explicit CreateAuthorityTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorityTemplateView) {
      res["AuthorityTemplateView"] = authorityTemplateView ? boost::any(authorityTemplateView->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorityTemplateView") != m.end() && !m["AuthorityTemplateView"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorityTemplateView"].type()) {
        CreateAuthorityTemplateResponseBodyAuthorityTemplateView model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorityTemplateView"]));
        authorityTemplateView = make_shared<CreateAuthorityTemplateResponseBodyAuthorityTemplateView>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateAuthorityTemplateResponseBody() = default;
};
class CreateAuthorityTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAuthorityTemplateResponseBody> body{};

  CreateAuthorityTemplateResponse() {}

  explicit CreateAuthorityTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAuthorityTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAuthorityTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAuthorityTemplateResponse() = default;
};
class CreateDataArchiveOrderRequestParamTableIncludes : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> tableWhere{};

  CreateDataArchiveOrderRequestParamTableIncludes() {}

  explicit CreateDataArchiveOrderRequestParamTableIncludes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableWhere) {
      res["TableWhere"] = boost::any(*tableWhere);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableWhere") != m.end() && !m["TableWhere"].empty()) {
      tableWhere = make_shared<string>(boost::any_cast<string>(m["TableWhere"]));
    }
  }


  virtual ~CreateDataArchiveOrderRequestParamTableIncludes() = default;
};
class CreateDataArchiveOrderRequestParamVariables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> pattern{};

  CreateDataArchiveOrderRequestParamVariables() {}

  explicit CreateDataArchiveOrderRequestParamVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
  }


  virtual ~CreateDataArchiveOrderRequestParamVariables() = default;
};
class CreateDataArchiveOrderRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> archiveMethod{};
  shared_ptr<string> cronStr{};
  shared_ptr<bool> logic{};
  shared_ptr<vector<string>> orderAfter{};
  shared_ptr<string> runMethod{};
  shared_ptr<string> sourceCatalogName{};
  shared_ptr<string> sourceInstanceName{};
  shared_ptr<string> sourceSchemaName{};
  shared_ptr<vector<CreateDataArchiveOrderRequestParamTableIncludes>> tableIncludes{};
  shared_ptr<vector<string>> tableMapping{};
  shared_ptr<string> targetInstanceHost{};
  shared_ptr<vector<CreateDataArchiveOrderRequestParamVariables>> variables{};

  CreateDataArchiveOrderRequestParam() {}

  explicit CreateDataArchiveOrderRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archiveMethod) {
      res["ArchiveMethod"] = boost::any(*archiveMethod);
    }
    if (cronStr) {
      res["CronStr"] = boost::any(*cronStr);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (orderAfter) {
      res["OrderAfter"] = boost::any(*orderAfter);
    }
    if (runMethod) {
      res["RunMethod"] = boost::any(*runMethod);
    }
    if (sourceCatalogName) {
      res["SourceCatalogName"] = boost::any(*sourceCatalogName);
    }
    if (sourceInstanceName) {
      res["SourceInstanceName"] = boost::any(*sourceInstanceName);
    }
    if (sourceSchemaName) {
      res["SourceSchemaName"] = boost::any(*sourceSchemaName);
    }
    if (tableIncludes) {
      vector<boost::any> temp1;
      for(auto item1:*tableIncludes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableIncludes"] = boost::any(temp1);
    }
    if (tableMapping) {
      res["TableMapping"] = boost::any(*tableMapping);
    }
    if (targetInstanceHost) {
      res["TargetInstanceHost"] = boost::any(*targetInstanceHost);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchiveMethod") != m.end() && !m["ArchiveMethod"].empty()) {
      archiveMethod = make_shared<string>(boost::any_cast<string>(m["ArchiveMethod"]));
    }
    if (m.find("CronStr") != m.end() && !m["CronStr"].empty()) {
      cronStr = make_shared<string>(boost::any_cast<string>(m["CronStr"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("OrderAfter") != m.end() && !m["OrderAfter"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderAfter"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderAfter"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderAfter = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RunMethod") != m.end() && !m["RunMethod"].empty()) {
      runMethod = make_shared<string>(boost::any_cast<string>(m["RunMethod"]));
    }
    if (m.find("SourceCatalogName") != m.end() && !m["SourceCatalogName"].empty()) {
      sourceCatalogName = make_shared<string>(boost::any_cast<string>(m["SourceCatalogName"]));
    }
    if (m.find("SourceInstanceName") != m.end() && !m["SourceInstanceName"].empty()) {
      sourceInstanceName = make_shared<string>(boost::any_cast<string>(m["SourceInstanceName"]));
    }
    if (m.find("SourceSchemaName") != m.end() && !m["SourceSchemaName"].empty()) {
      sourceSchemaName = make_shared<string>(boost::any_cast<string>(m["SourceSchemaName"]));
    }
    if (m.find("TableIncludes") != m.end() && !m["TableIncludes"].empty()) {
      if (typeid(vector<boost::any>) == m["TableIncludes"].type()) {
        vector<CreateDataArchiveOrderRequestParamTableIncludes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableIncludes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataArchiveOrderRequestParamTableIncludes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableIncludes = make_shared<vector<CreateDataArchiveOrderRequestParamTableIncludes>>(expect1);
      }
    }
    if (m.find("TableMapping") != m.end() && !m["TableMapping"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableMapping"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableMapping"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableMapping = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetInstanceHost") != m.end() && !m["TargetInstanceHost"].empty()) {
      targetInstanceHost = make_shared<string>(boost::any_cast<string>(m["TargetInstanceHost"]));
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<CreateDataArchiveOrderRequestParamVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataArchiveOrderRequestParamVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<CreateDataArchiveOrderRequestParamVariables>>(expect1);
      }
    }
  }


  virtual ~CreateDataArchiveOrderRequestParam() = default;
};
class CreateDataArchiveOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<CreateDataArchiveOrderRequestParam> param{};
  shared_ptr<long> parentId{};
  shared_ptr<string> pluginType{};
  shared_ptr<vector<string>> relatedUserList{};
  shared_ptr<long> tid{};

  CreateDataArchiveOrderRequest() {}

  explicit CreateDataArchiveOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (param) {
      res["Param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(map<string, boost::any>) == m["Param"].type()) {
        CreateDataArchiveOrderRequestParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Param"]));
        param = make_shared<CreateDataArchiveOrderRequestParam>(model1);
      }
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relatedUserList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataArchiveOrderRequest() = default;
};
class CreateDataArchiveOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> paramShrink{};
  shared_ptr<long> parentId{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> relatedUserListShrink{};
  shared_ptr<long> tid{};

  CreateDataArchiveOrderShrinkRequest() {}

  explicit CreateDataArchiveOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (paramShrink) {
      res["Param"] = boost::any(*paramShrink);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (relatedUserListShrink) {
      res["RelatedUserList"] = boost::any(*relatedUserListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      paramShrink = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserListShrink = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataArchiveOrderShrinkRequest() = default;
};
class CreateDataArchiveOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataArchiveOrderResponseBody() {}

  explicit CreateDataArchiveOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = boost::any(*createOrderResult);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateOrderResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateOrderResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createOrderResult = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataArchiveOrderResponseBody() = default;
};
class CreateDataArchiveOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataArchiveOrderResponseBody> body{};

  CreateDataArchiveOrderResponse() {}

  explicit CreateDataArchiveOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataArchiveOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataArchiveOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataArchiveOrderResponse() = default;
};
class CreateDataCorrectOrderRequestParamDbItemList : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<bool> logic{};

  CreateDataCorrectOrderRequestParamDbItemList() {}

  explicit CreateDataCorrectOrderRequestParamDbItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
  }


  virtual ~CreateDataCorrectOrderRequestParamDbItemList() = default;
};
class CreateDataCorrectOrderRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> attachmentName{};
  shared_ptr<string> classify{};
  shared_ptr<vector<CreateDataCorrectOrderRequestParamDbItemList>> dbItemList{};
  shared_ptr<long> estimateAffectRows{};
  shared_ptr<string> execMode{};
  shared_ptr<string> execSQL{};
  shared_ptr<string> rollbackAttachmentName{};
  shared_ptr<string> rollbackSQL{};
  shared_ptr<string> rollbackSqlType{};
  shared_ptr<string> sqlType{};

  CreateDataCorrectOrderRequestParam() {}

  explicit CreateDataCorrectOrderRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentName) {
      res["AttachmentName"] = boost::any(*attachmentName);
    }
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (dbItemList) {
      vector<boost::any> temp1;
      for(auto item1:*dbItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DbItemList"] = boost::any(temp1);
    }
    if (estimateAffectRows) {
      res["EstimateAffectRows"] = boost::any(*estimateAffectRows);
    }
    if (execMode) {
      res["ExecMode"] = boost::any(*execMode);
    }
    if (execSQL) {
      res["ExecSQL"] = boost::any(*execSQL);
    }
    if (rollbackAttachmentName) {
      res["RollbackAttachmentName"] = boost::any(*rollbackAttachmentName);
    }
    if (rollbackSQL) {
      res["RollbackSQL"] = boost::any(*rollbackSQL);
    }
    if (rollbackSqlType) {
      res["RollbackSqlType"] = boost::any(*rollbackSqlType);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentName") != m.end() && !m["AttachmentName"].empty()) {
      attachmentName = make_shared<string>(boost::any_cast<string>(m["AttachmentName"]));
    }
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("DbItemList") != m.end() && !m["DbItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["DbItemList"].type()) {
        vector<CreateDataCorrectOrderRequestParamDbItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DbItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataCorrectOrderRequestParamDbItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dbItemList = make_shared<vector<CreateDataCorrectOrderRequestParamDbItemList>>(expect1);
      }
    }
    if (m.find("EstimateAffectRows") != m.end() && !m["EstimateAffectRows"].empty()) {
      estimateAffectRows = make_shared<long>(boost::any_cast<long>(m["EstimateAffectRows"]));
    }
    if (m.find("ExecMode") != m.end() && !m["ExecMode"].empty()) {
      execMode = make_shared<string>(boost::any_cast<string>(m["ExecMode"]));
    }
    if (m.find("ExecSQL") != m.end() && !m["ExecSQL"].empty()) {
      execSQL = make_shared<string>(boost::any_cast<string>(m["ExecSQL"]));
    }
    if (m.find("RollbackAttachmentName") != m.end() && !m["RollbackAttachmentName"].empty()) {
      rollbackAttachmentName = make_shared<string>(boost::any_cast<string>(m["RollbackAttachmentName"]));
    }
    if (m.find("RollbackSQL") != m.end() && !m["RollbackSQL"].empty()) {
      rollbackSQL = make_shared<string>(boost::any_cast<string>(m["RollbackSQL"]));
    }
    if (m.find("RollbackSqlType") != m.end() && !m["RollbackSqlType"].empty()) {
      rollbackSqlType = make_shared<string>(boost::any_cast<string>(m["RollbackSqlType"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
  }


  virtual ~CreateDataCorrectOrderRequestParam() = default;
};
class CreateDataCorrectOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<CreateDataCorrectOrderRequestParam> param{};
  shared_ptr<vector<long>> relatedUserList{};
  shared_ptr<long> tid{};

  CreateDataCorrectOrderRequest() {}

  explicit CreateDataCorrectOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (param) {
      res["Param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(map<string, boost::any>) == m["Param"].type()) {
        CreateDataCorrectOrderRequestParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Param"]));
        param = make_shared<CreateDataCorrectOrderRequestParam>(model1);
      }
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      relatedUserList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataCorrectOrderRequest() = default;
};
class CreateDataCorrectOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<string> paramShrink{};
  shared_ptr<string> relatedUserListShrink{};
  shared_ptr<long> tid{};

  CreateDataCorrectOrderShrinkRequest() {}

  explicit CreateDataCorrectOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (paramShrink) {
      res["Param"] = boost::any(*paramShrink);
    }
    if (relatedUserListShrink) {
      res["RelatedUserList"] = boost::any(*relatedUserListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      paramShrink = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserListShrink = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataCorrectOrderShrinkRequest() = default;
};
class CreateDataCorrectOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataCorrectOrderResponseBody() {}

  explicit CreateDataCorrectOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = boost::any(*createOrderResult);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateOrderResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateOrderResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createOrderResult = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataCorrectOrderResponseBody() = default;
};
class CreateDataCorrectOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataCorrectOrderResponseBody> body{};

  CreateDataCorrectOrderResponse() {}

  explicit CreateDataCorrectOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataCorrectOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataCorrectOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataCorrectOrderResponse() = default;
};
class CreateDataCronClearOrderRequestParamCronClearItemList : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> filterSQL{};
  shared_ptr<long> remainDays{};
  shared_ptr<string> tableName{};
  shared_ptr<string> timeUnit{};

  CreateDataCronClearOrderRequestParamCronClearItemList() {}

  explicit CreateDataCronClearOrderRequestParamCronClearItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (filterSQL) {
      res["FilterSQL"] = boost::any(*filterSQL);
    }
    if (remainDays) {
      res["RemainDays"] = boost::any(*remainDays);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (timeUnit) {
      res["TimeUnit"] = boost::any(*timeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("FilterSQL") != m.end() && !m["FilterSQL"].empty()) {
      filterSQL = make_shared<string>(boost::any_cast<string>(m["FilterSQL"]));
    }
    if (m.find("RemainDays") != m.end() && !m["RemainDays"].empty()) {
      remainDays = make_shared<long>(boost::any_cast<long>(m["RemainDays"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TimeUnit") != m.end() && !m["TimeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["TimeUnit"]));
    }
  }


  virtual ~CreateDataCronClearOrderRequestParamCronClearItemList() = default;
};
class CreateDataCronClearOrderRequestParamDbItemList : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<bool> logic{};

  CreateDataCronClearOrderRequestParamDbItemList() {}

  explicit CreateDataCronClearOrderRequestParamDbItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
  }


  virtual ~CreateDataCronClearOrderRequestParamDbItemList() = default;
};
class CreateDataCronClearOrderRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> classify{};
  shared_ptr<vector<CreateDataCronClearOrderRequestParamCronClearItemList>> cronClearItemList{};
  shared_ptr<string> cronFormat{};
  shared_ptr<vector<CreateDataCronClearOrderRequestParamDbItemList>> dbItemList{};
  shared_ptr<long> durationHour{};
  shared_ptr<bool> specifyDuration{};

  CreateDataCronClearOrderRequestParam() {}

  explicit CreateDataCronClearOrderRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (cronClearItemList) {
      vector<boost::any> temp1;
      for(auto item1:*cronClearItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CronClearItemList"] = boost::any(temp1);
    }
    if (cronFormat) {
      res["CronFormat"] = boost::any(*cronFormat);
    }
    if (dbItemList) {
      vector<boost::any> temp1;
      for(auto item1:*dbItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DbItemList"] = boost::any(temp1);
    }
    if (durationHour) {
      res["DurationHour"] = boost::any(*durationHour);
    }
    if (specifyDuration) {
      res["specifyDuration"] = boost::any(*specifyDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("CronClearItemList") != m.end() && !m["CronClearItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["CronClearItemList"].type()) {
        vector<CreateDataCronClearOrderRequestParamCronClearItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CronClearItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataCronClearOrderRequestParamCronClearItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cronClearItemList = make_shared<vector<CreateDataCronClearOrderRequestParamCronClearItemList>>(expect1);
      }
    }
    if (m.find("CronFormat") != m.end() && !m["CronFormat"].empty()) {
      cronFormat = make_shared<string>(boost::any_cast<string>(m["CronFormat"]));
    }
    if (m.find("DbItemList") != m.end() && !m["DbItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["DbItemList"].type()) {
        vector<CreateDataCronClearOrderRequestParamDbItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DbItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataCronClearOrderRequestParamDbItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dbItemList = make_shared<vector<CreateDataCronClearOrderRequestParamDbItemList>>(expect1);
      }
    }
    if (m.find("DurationHour") != m.end() && !m["DurationHour"].empty()) {
      durationHour = make_shared<long>(boost::any_cast<long>(m["DurationHour"]));
    }
    if (m.find("specifyDuration") != m.end() && !m["specifyDuration"].empty()) {
      specifyDuration = make_shared<bool>(boost::any_cast<bool>(m["specifyDuration"]));
    }
  }


  virtual ~CreateDataCronClearOrderRequestParam() = default;
};
class CreateDataCronClearOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<CreateDataCronClearOrderRequestParam> param{};
  shared_ptr<vector<long>> relatedUserList{};
  shared_ptr<long> tid{};

  CreateDataCronClearOrderRequest() {}

  explicit CreateDataCronClearOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (param) {
      res["Param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(map<string, boost::any>) == m["Param"].type()) {
        CreateDataCronClearOrderRequestParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Param"]));
        param = make_shared<CreateDataCronClearOrderRequestParam>(model1);
      }
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      relatedUserList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataCronClearOrderRequest() = default;
};
class CreateDataCronClearOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<string> paramShrink{};
  shared_ptr<string> relatedUserListShrink{};
  shared_ptr<long> tid{};

  CreateDataCronClearOrderShrinkRequest() {}

  explicit CreateDataCronClearOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (paramShrink) {
      res["Param"] = boost::any(*paramShrink);
    }
    if (relatedUserListShrink) {
      res["RelatedUserList"] = boost::any(*relatedUserListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      paramShrink = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserListShrink = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataCronClearOrderShrinkRequest() = default;
};
class CreateDataCronClearOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataCronClearOrderResponseBody() {}

  explicit CreateDataCronClearOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = boost::any(*createOrderResult);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateOrderResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateOrderResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createOrderResult = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataCronClearOrderResponseBody() = default;
};
class CreateDataCronClearOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataCronClearOrderResponseBody> body{};

  CreateDataCronClearOrderResponse() {}

  explicit CreateDataCronClearOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataCronClearOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataCronClearOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataCronClearOrderResponse() = default;
};
class CreateDataExportOrderRequestPluginParamWatermark : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> dataWatermark{};
  shared_ptr<string> fileWatermark{};
  shared_ptr<vector<string>> keys{};
  shared_ptr<vector<string>> watermarkTypes{};

  CreateDataExportOrderRequestPluginParamWatermark() {}

  explicit CreateDataExportOrderRequestPluginParamWatermark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dataWatermark) {
      res["DataWatermark"] = boost::any(*dataWatermark);
    }
    if (fileWatermark) {
      res["FileWatermark"] = boost::any(*fileWatermark);
    }
    if (keys) {
      res["Keys"] = boost::any(*keys);
    }
    if (watermarkTypes) {
      res["WatermarkTypes"] = boost::any(*watermarkTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DataWatermark") != m.end() && !m["DataWatermark"].empty()) {
      dataWatermark = make_shared<string>(boost::any_cast<string>(m["DataWatermark"]));
    }
    if (m.find("FileWatermark") != m.end() && !m["FileWatermark"].empty()) {
      fileWatermark = make_shared<string>(boost::any_cast<string>(m["FileWatermark"]));
    }
    if (m.find("Keys") != m.end() && !m["Keys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WatermarkTypes") != m.end() && !m["WatermarkTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WatermarkTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WatermarkTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      watermarkTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDataExportOrderRequestPluginParamWatermark() = default;
};
class CreateDataExportOrderRequestPluginParam : public Darabonba::Model {
public:
  shared_ptr<long> affectRows{};
  shared_ptr<string> classify{};
  shared_ptr<long> dbId{};
  shared_ptr<string> exeSQL{};
  shared_ptr<bool> ignoreAffectRows{};
  shared_ptr<string> ignoreAffectRowsReason{};
  shared_ptr<long> instanceId{};
  shared_ptr<bool> logic{};
  shared_ptr<CreateDataExportOrderRequestPluginParamWatermark> watermark{};

  CreateDataExportOrderRequestPluginParam() {}

  explicit CreateDataExportOrderRequestPluginParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectRows) {
      res["AffectRows"] = boost::any(*affectRows);
    }
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (exeSQL) {
      res["ExeSQL"] = boost::any(*exeSQL);
    }
    if (ignoreAffectRows) {
      res["IgnoreAffectRows"] = boost::any(*ignoreAffectRows);
    }
    if (ignoreAffectRowsReason) {
      res["IgnoreAffectRowsReason"] = boost::any(*ignoreAffectRowsReason);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (watermark) {
      res["Watermark"] = watermark ? boost::any(watermark->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectRows") != m.end() && !m["AffectRows"].empty()) {
      affectRows = make_shared<long>(boost::any_cast<long>(m["AffectRows"]));
    }
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("ExeSQL") != m.end() && !m["ExeSQL"].empty()) {
      exeSQL = make_shared<string>(boost::any_cast<string>(m["ExeSQL"]));
    }
    if (m.find("IgnoreAffectRows") != m.end() && !m["IgnoreAffectRows"].empty()) {
      ignoreAffectRows = make_shared<bool>(boost::any_cast<bool>(m["IgnoreAffectRows"]));
    }
    if (m.find("IgnoreAffectRowsReason") != m.end() && !m["IgnoreAffectRowsReason"].empty()) {
      ignoreAffectRowsReason = make_shared<string>(boost::any_cast<string>(m["IgnoreAffectRowsReason"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("Watermark") != m.end() && !m["Watermark"].empty()) {
      if (typeid(map<string, boost::any>) == m["Watermark"].type()) {
        CreateDataExportOrderRequestPluginParamWatermark model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Watermark"]));
        watermark = make_shared<CreateDataExportOrderRequestPluginParamWatermark>(model1);
      }
    }
  }


  virtual ~CreateDataExportOrderRequestPluginParam() = default;
};
class CreateDataExportOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<long> parentId{};
  shared_ptr<CreateDataExportOrderRequestPluginParam> pluginParam{};
  shared_ptr<vector<long>> relatedUserList{};
  shared_ptr<long> tid{};

  CreateDataExportOrderRequest() {}

  explicit CreateDataExportOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (pluginParam) {
      res["PluginParam"] = pluginParam ? boost::any(pluginParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("PluginParam") != m.end() && !m["PluginParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["PluginParam"].type()) {
        CreateDataExportOrderRequestPluginParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PluginParam"]));
        pluginParam = make_shared<CreateDataExportOrderRequestPluginParam>(model1);
      }
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      relatedUserList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataExportOrderRequest() = default;
};
class CreateDataExportOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<long> parentId{};
  shared_ptr<string> pluginParamShrink{};
  shared_ptr<string> relatedUserListShrink{};
  shared_ptr<long> tid{};

  CreateDataExportOrderShrinkRequest() {}

  explicit CreateDataExportOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (pluginParamShrink) {
      res["PluginParam"] = boost::any(*pluginParamShrink);
    }
    if (relatedUserListShrink) {
      res["RelatedUserList"] = boost::any(*relatedUserListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("PluginParam") != m.end() && !m["PluginParam"].empty()) {
      pluginParamShrink = make_shared<string>(boost::any_cast<string>(m["PluginParam"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserListShrink = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataExportOrderShrinkRequest() = default;
};
class CreateDataExportOrderResponseBodyCreateOrderResult : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createOrderResult{};

  CreateDataExportOrderResponseBodyCreateOrderResult() {}

  explicit CreateDataExportOrderResponseBodyCreateOrderResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = boost::any(*createOrderResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateOrderResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateOrderResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createOrderResult = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateDataExportOrderResponseBodyCreateOrderResult() = default;
};
class CreateDataExportOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateDataExportOrderResponseBodyCreateOrderResult> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataExportOrderResponseBody() {}

  explicit CreateDataExportOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = createOrderResult ? boost::any(createOrderResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateOrderResult"].type()) {
        CreateDataExportOrderResponseBodyCreateOrderResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateOrderResult"]));
        createOrderResult = make_shared<CreateDataExportOrderResponseBodyCreateOrderResult>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataExportOrderResponseBody() = default;
};
class CreateDataExportOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataExportOrderResponseBody> body{};

  CreateDataExportOrderResponse() {}

  explicit CreateDataExportOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataExportOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataExportOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataExportOrderResponse() = default;
};
class CreateDataImportOrderRequestParamDbItemList : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<bool> logic{};

  CreateDataImportOrderRequestParamDbItemList() {}

  explicit CreateDataImportOrderRequestParamDbItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
  }


  virtual ~CreateDataImportOrderRequestParamDbItemList() = default;
};
class CreateDataImportOrderRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> attachmentName{};
  shared_ptr<string> classify{};
  shared_ptr<bool> csvFirstRowIsColumnDef{};
  shared_ptr<vector<CreateDataImportOrderRequestParamDbItemList>> dbItemList{};
  shared_ptr<string> fileEncoding{};
  shared_ptr<string> fileType{};
  shared_ptr<bool> ignoreError{};
  shared_ptr<string> importMode{};
  shared_ptr<string> insertType{};
  shared_ptr<string> rollbackAttachmentName{};
  shared_ptr<string> rollbackSQL{};
  shared_ptr<string> rollbackSqlType{};
  shared_ptr<string> tableName{};

  CreateDataImportOrderRequestParam() {}

  explicit CreateDataImportOrderRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentName) {
      res["AttachmentName"] = boost::any(*attachmentName);
    }
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (csvFirstRowIsColumnDef) {
      res["CsvFirstRowIsColumnDef"] = boost::any(*csvFirstRowIsColumnDef);
    }
    if (dbItemList) {
      vector<boost::any> temp1;
      for(auto item1:*dbItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DbItemList"] = boost::any(temp1);
    }
    if (fileEncoding) {
      res["FileEncoding"] = boost::any(*fileEncoding);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (ignoreError) {
      res["IgnoreError"] = boost::any(*ignoreError);
    }
    if (importMode) {
      res["ImportMode"] = boost::any(*importMode);
    }
    if (insertType) {
      res["InsertType"] = boost::any(*insertType);
    }
    if (rollbackAttachmentName) {
      res["RollbackAttachmentName"] = boost::any(*rollbackAttachmentName);
    }
    if (rollbackSQL) {
      res["RollbackSQL"] = boost::any(*rollbackSQL);
    }
    if (rollbackSqlType) {
      res["RollbackSqlType"] = boost::any(*rollbackSqlType);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentName") != m.end() && !m["AttachmentName"].empty()) {
      attachmentName = make_shared<string>(boost::any_cast<string>(m["AttachmentName"]));
    }
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("CsvFirstRowIsColumnDef") != m.end() && !m["CsvFirstRowIsColumnDef"].empty()) {
      csvFirstRowIsColumnDef = make_shared<bool>(boost::any_cast<bool>(m["CsvFirstRowIsColumnDef"]));
    }
    if (m.find("DbItemList") != m.end() && !m["DbItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["DbItemList"].type()) {
        vector<CreateDataImportOrderRequestParamDbItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DbItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataImportOrderRequestParamDbItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dbItemList = make_shared<vector<CreateDataImportOrderRequestParamDbItemList>>(expect1);
      }
    }
    if (m.find("FileEncoding") != m.end() && !m["FileEncoding"].empty()) {
      fileEncoding = make_shared<string>(boost::any_cast<string>(m["FileEncoding"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("IgnoreError") != m.end() && !m["IgnoreError"].empty()) {
      ignoreError = make_shared<bool>(boost::any_cast<bool>(m["IgnoreError"]));
    }
    if (m.find("ImportMode") != m.end() && !m["ImportMode"].empty()) {
      importMode = make_shared<string>(boost::any_cast<string>(m["ImportMode"]));
    }
    if (m.find("InsertType") != m.end() && !m["InsertType"].empty()) {
      insertType = make_shared<string>(boost::any_cast<string>(m["InsertType"]));
    }
    if (m.find("RollbackAttachmentName") != m.end() && !m["RollbackAttachmentName"].empty()) {
      rollbackAttachmentName = make_shared<string>(boost::any_cast<string>(m["RollbackAttachmentName"]));
    }
    if (m.find("RollbackSQL") != m.end() && !m["RollbackSQL"].empty()) {
      rollbackSQL = make_shared<string>(boost::any_cast<string>(m["RollbackSQL"]));
    }
    if (m.find("RollbackSqlType") != m.end() && !m["RollbackSqlType"].empty()) {
      rollbackSqlType = make_shared<string>(boost::any_cast<string>(m["RollbackSqlType"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~CreateDataImportOrderRequestParam() = default;
};
class CreateDataImportOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<CreateDataImportOrderRequestParam> param{};
  shared_ptr<vector<long>> relatedUserList{};
  shared_ptr<long> tid{};

  CreateDataImportOrderRequest() {}

  explicit CreateDataImportOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (param) {
      res["Param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(map<string, boost::any>) == m["Param"].type()) {
        CreateDataImportOrderRequestParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Param"]));
        param = make_shared<CreateDataImportOrderRequestParam>(model1);
      }
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      relatedUserList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataImportOrderRequest() = default;
};
class CreateDataImportOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<string> paramShrink{};
  shared_ptr<string> relatedUserListShrink{};
  shared_ptr<long> tid{};

  CreateDataImportOrderShrinkRequest() {}

  explicit CreateDataImportOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (paramShrink) {
      res["Param"] = boost::any(*paramShrink);
    }
    if (relatedUserListShrink) {
      res["RelatedUserList"] = boost::any(*relatedUserListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      paramShrink = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserListShrink = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataImportOrderShrinkRequest() = default;
};
class CreateDataImportOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataImportOrderResponseBody() {}

  explicit CreateDataImportOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = boost::any(*createOrderResult);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateOrderResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateOrderResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createOrderResult = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataImportOrderResponseBody() = default;
};
class CreateDataImportOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataImportOrderResponseBody> body{};

  CreateDataImportOrderResponse() {}

  explicit CreateDataImportOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataImportOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataImportOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataImportOrderResponse() = default;
};
class CreateDataTrackOrderRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> dbId{};
  shared_ptr<string> jobEndTime{};
  shared_ptr<string> jobStartTime{};
  shared_ptr<vector<string>> tableNames{};
  shared_ptr<vector<string>> trackTypes{};

  CreateDataTrackOrderRequestParam() {}

  explicit CreateDataTrackOrderRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (jobEndTime) {
      res["JobEndTime"] = boost::any(*jobEndTime);
    }
    if (jobStartTime) {
      res["JobStartTime"] = boost::any(*jobStartTime);
    }
    if (tableNames) {
      res["TableNames"] = boost::any(*tableNames);
    }
    if (trackTypes) {
      res["TrackTypes"] = boost::any(*trackTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<string>(boost::any_cast<string>(m["DbId"]));
    }
    if (m.find("JobEndTime") != m.end() && !m["JobEndTime"].empty()) {
      jobEndTime = make_shared<string>(boost::any_cast<string>(m["JobEndTime"]));
    }
    if (m.find("JobStartTime") != m.end() && !m["JobStartTime"].empty()) {
      jobStartTime = make_shared<string>(boost::any_cast<string>(m["JobStartTime"]));
    }
    if (m.find("TableNames") != m.end() && !m["TableNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TrackTypes") != m.end() && !m["TrackTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrackTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrackTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trackTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDataTrackOrderRequestParam() = default;
};
class CreateDataTrackOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<CreateDataTrackOrderRequestParam> param{};
  shared_ptr<vector<string>> relatedUserList{};
  shared_ptr<long> tid{};

  CreateDataTrackOrderRequest() {}

  explicit CreateDataTrackOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (param) {
      res["Param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(map<string, boost::any>) == m["Param"].type()) {
        CreateDataTrackOrderRequestParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Param"]));
        param = make_shared<CreateDataTrackOrderRequestParam>(model1);
      }
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relatedUserList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataTrackOrderRequest() = default;
};
class CreateDataTrackOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> paramShrink{};
  shared_ptr<string> relatedUserListShrink{};
  shared_ptr<long> tid{};

  CreateDataTrackOrderShrinkRequest() {}

  explicit CreateDataTrackOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (paramShrink) {
      res["Param"] = boost::any(*paramShrink);
    }
    if (relatedUserListShrink) {
      res["RelatedUserList"] = boost::any(*relatedUserListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      paramShrink = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserListShrink = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDataTrackOrderShrinkRequest() = default;
};
class CreateDataTrackOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataTrackOrderResponseBody() {}

  explicit CreateDataTrackOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = boost::any(*createOrderResult);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateOrderResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateOrderResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createOrderResult = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataTrackOrderResponseBody() = default;
};
class CreateDataTrackOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataTrackOrderResponseBody> body{};

  CreateDataTrackOrderResponse() {}

  explicit CreateDataTrackOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataTrackOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataTrackOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataTrackOrderResponse() = default;
};
class CreateDatabaseExportOrderRequestPluginParamConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dataOption{};
  shared_ptr<string> exportContent{};
  shared_ptr<vector<string>> exportTypes{};
  shared_ptr<vector<string>> SQLExtOption{};
  shared_ptr<vector<string>> selectedTables{};
  shared_ptr<map<string, string>> tables{};
  shared_ptr<string> targetOption{};

  CreateDatabaseExportOrderRequestPluginParamConfig() {}

  explicit CreateDatabaseExportOrderRequestPluginParamConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataOption) {
      res["DataOption"] = boost::any(*dataOption);
    }
    if (exportContent) {
      res["ExportContent"] = boost::any(*exportContent);
    }
    if (exportTypes) {
      res["ExportTypes"] = boost::any(*exportTypes);
    }
    if (SQLExtOption) {
      res["SQLExtOption"] = boost::any(*SQLExtOption);
    }
    if (selectedTables) {
      res["SelectedTables"] = boost::any(*selectedTables);
    }
    if (tables) {
      res["Tables"] = boost::any(*tables);
    }
    if (targetOption) {
      res["TargetOption"] = boost::any(*targetOption);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataOption") != m.end() && !m["DataOption"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataOption"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataOption"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataOption = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExportContent") != m.end() && !m["ExportContent"].empty()) {
      exportContent = make_shared<string>(boost::any_cast<string>(m["ExportContent"]));
    }
    if (m.find("ExportTypes") != m.end() && !m["ExportTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExportTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExportTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      exportTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SQLExtOption") != m.end() && !m["SQLExtOption"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SQLExtOption"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SQLExtOption"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      SQLExtOption = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SelectedTables") != m.end() && !m["SelectedTables"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SelectedTables"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SelectedTables"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      selectedTables = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Tables"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tables = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("TargetOption") != m.end() && !m["TargetOption"].empty()) {
      targetOption = make_shared<string>(boost::any_cast<string>(m["TargetOption"]));
    }
  }


  virtual ~CreateDatabaseExportOrderRequestPluginParamConfig() = default;
};
class CreateDatabaseExportOrderRequestPluginParam : public Darabonba::Model {
public:
  shared_ptr<string> classify{};
  shared_ptr<CreateDatabaseExportOrderRequestPluginParamConfig> config{};
  shared_ptr<long> dbId{};
  shared_ptr<long> instanceId{};
  shared_ptr<bool> logic{};
  shared_ptr<string> searchName{};

  CreateDatabaseExportOrderRequestPluginParam() {}

  explicit CreateDatabaseExportOrderRequestPluginParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        CreateDatabaseExportOrderRequestPluginParamConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<CreateDatabaseExportOrderRequestPluginParamConfig>(model1);
      }
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~CreateDatabaseExportOrderRequestPluginParam() = default;
};
class CreateDatabaseExportOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<long> parentId{};
  shared_ptr<CreateDatabaseExportOrderRequestPluginParam> pluginParam{};
  shared_ptr<vector<long>> relatedUserList{};
  shared_ptr<long> tid{};

  CreateDatabaseExportOrderRequest() {}

  explicit CreateDatabaseExportOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (pluginParam) {
      res["PluginParam"] = pluginParam ? boost::any(pluginParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("PluginParam") != m.end() && !m["PluginParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["PluginParam"].type()) {
        CreateDatabaseExportOrderRequestPluginParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PluginParam"]));
        pluginParam = make_shared<CreateDatabaseExportOrderRequestPluginParam>(model1);
      }
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      relatedUserList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDatabaseExportOrderRequest() = default;
};
class CreateDatabaseExportOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<long> parentId{};
  shared_ptr<string> pluginParamShrink{};
  shared_ptr<string> relatedUserListShrink{};
  shared_ptr<long> tid{};

  CreateDatabaseExportOrderShrinkRequest() {}

  explicit CreateDatabaseExportOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (pluginParamShrink) {
      res["PluginParam"] = boost::any(*pluginParamShrink);
    }
    if (relatedUserListShrink) {
      res["RelatedUserList"] = boost::any(*relatedUserListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("PluginParam") != m.end() && !m["PluginParam"].empty()) {
      pluginParamShrink = make_shared<string>(boost::any_cast<string>(m["PluginParam"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserListShrink = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateDatabaseExportOrderShrinkRequest() = default;
};
class CreateDatabaseExportOrderResponseBodyCreateOrderResult : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createOrderResult{};

  CreateDatabaseExportOrderResponseBodyCreateOrderResult() {}

  explicit CreateDatabaseExportOrderResponseBodyCreateOrderResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = boost::any(*createOrderResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateOrderResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateOrderResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createOrderResult = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateDatabaseExportOrderResponseBodyCreateOrderResult() = default;
};
class CreateDatabaseExportOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateDatabaseExportOrderResponseBodyCreateOrderResult> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDatabaseExportOrderResponseBody() {}

  explicit CreateDatabaseExportOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = createOrderResult ? boost::any(createOrderResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateOrderResult"].type()) {
        CreateDatabaseExportOrderResponseBodyCreateOrderResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateOrderResult"]));
        createOrderResult = make_shared<CreateDatabaseExportOrderResponseBodyCreateOrderResult>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDatabaseExportOrderResponseBody() = default;
};
class CreateDatabaseExportOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDatabaseExportOrderResponseBody> body{};

  CreateDatabaseExportOrderResponse() {}

  explicit CreateDatabaseExportOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDatabaseExportOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDatabaseExportOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDatabaseExportOrderResponse() = default;
};
class CreateFreeLockCorrectOrderRequestParamDbItemList : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<bool> logic{};

  CreateFreeLockCorrectOrderRequestParamDbItemList() {}

  explicit CreateFreeLockCorrectOrderRequestParamDbItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
  }


  virtual ~CreateFreeLockCorrectOrderRequestParamDbItemList() = default;
};
class CreateFreeLockCorrectOrderRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> attachmentName{};
  shared_ptr<string> classify{};
  shared_ptr<vector<CreateFreeLockCorrectOrderRequestParamDbItemList>> dbItemList{};
  shared_ptr<string> execMode{};
  shared_ptr<string> execSQL{};
  shared_ptr<string> rollbackAttachmentName{};
  shared_ptr<string> rollbackSQL{};
  shared_ptr<string> rollbackSqlType{};
  shared_ptr<string> sqlType{};

  CreateFreeLockCorrectOrderRequestParam() {}

  explicit CreateFreeLockCorrectOrderRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentName) {
      res["AttachmentName"] = boost::any(*attachmentName);
    }
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (dbItemList) {
      vector<boost::any> temp1;
      for(auto item1:*dbItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DbItemList"] = boost::any(temp1);
    }
    if (execMode) {
      res["ExecMode"] = boost::any(*execMode);
    }
    if (execSQL) {
      res["ExecSQL"] = boost::any(*execSQL);
    }
    if (rollbackAttachmentName) {
      res["RollbackAttachmentName"] = boost::any(*rollbackAttachmentName);
    }
    if (rollbackSQL) {
      res["RollbackSQL"] = boost::any(*rollbackSQL);
    }
    if (rollbackSqlType) {
      res["RollbackSqlType"] = boost::any(*rollbackSqlType);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentName") != m.end() && !m["AttachmentName"].empty()) {
      attachmentName = make_shared<string>(boost::any_cast<string>(m["AttachmentName"]));
    }
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("DbItemList") != m.end() && !m["DbItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["DbItemList"].type()) {
        vector<CreateFreeLockCorrectOrderRequestParamDbItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DbItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFreeLockCorrectOrderRequestParamDbItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dbItemList = make_shared<vector<CreateFreeLockCorrectOrderRequestParamDbItemList>>(expect1);
      }
    }
    if (m.find("ExecMode") != m.end() && !m["ExecMode"].empty()) {
      execMode = make_shared<string>(boost::any_cast<string>(m["ExecMode"]));
    }
    if (m.find("ExecSQL") != m.end() && !m["ExecSQL"].empty()) {
      execSQL = make_shared<string>(boost::any_cast<string>(m["ExecSQL"]));
    }
    if (m.find("RollbackAttachmentName") != m.end() && !m["RollbackAttachmentName"].empty()) {
      rollbackAttachmentName = make_shared<string>(boost::any_cast<string>(m["RollbackAttachmentName"]));
    }
    if (m.find("RollbackSQL") != m.end() && !m["RollbackSQL"].empty()) {
      rollbackSQL = make_shared<string>(boost::any_cast<string>(m["RollbackSQL"]));
    }
    if (m.find("RollbackSqlType") != m.end() && !m["RollbackSqlType"].empty()) {
      rollbackSqlType = make_shared<string>(boost::any_cast<string>(m["RollbackSqlType"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
  }


  virtual ~CreateFreeLockCorrectOrderRequestParam() = default;
};
class CreateFreeLockCorrectOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<CreateFreeLockCorrectOrderRequestParam> param{};
  shared_ptr<vector<long>> relatedUserList{};
  shared_ptr<long> tid{};

  CreateFreeLockCorrectOrderRequest() {}

  explicit CreateFreeLockCorrectOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (param) {
      res["Param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(map<string, boost::any>) == m["Param"].type()) {
        CreateFreeLockCorrectOrderRequestParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Param"]));
        param = make_shared<CreateFreeLockCorrectOrderRequestParam>(model1);
      }
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      relatedUserList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateFreeLockCorrectOrderRequest() = default;
};
class CreateFreeLockCorrectOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<string> paramShrink{};
  shared_ptr<string> relatedUserListShrink{};
  shared_ptr<long> tid{};

  CreateFreeLockCorrectOrderShrinkRequest() {}

  explicit CreateFreeLockCorrectOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (paramShrink) {
      res["Param"] = boost::any(*paramShrink);
    }
    if (relatedUserListShrink) {
      res["RelatedUserList"] = boost::any(*relatedUserListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      paramShrink = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserListShrink = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateFreeLockCorrectOrderShrinkRequest() = default;
};
class CreateFreeLockCorrectOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateFreeLockCorrectOrderResponseBody() {}

  explicit CreateFreeLockCorrectOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = boost::any(*createOrderResult);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateOrderResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateOrderResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createOrderResult = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFreeLockCorrectOrderResponseBody() = default;
};
class CreateFreeLockCorrectOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFreeLockCorrectOrderResponseBody> body{};

  CreateFreeLockCorrectOrderResponse() {}

  explicit CreateFreeLockCorrectOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFreeLockCorrectOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFreeLockCorrectOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFreeLockCorrectOrderResponse() = default;
};
class CreateLakeHouseSpaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> devDbId{};
  shared_ptr<string> dwDbType{};
  shared_ptr<string> mode{};
  shared_ptr<string> prodDbId{};
  shared_ptr<string> spaceConfig{};
  shared_ptr<string> spaceName{};
  shared_ptr<long> tid{};

  CreateLakeHouseSpaceRequest() {}

  explicit CreateLakeHouseSpaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devDbId) {
      res["DevDbId"] = boost::any(*devDbId);
    }
    if (dwDbType) {
      res["DwDbType"] = boost::any(*dwDbType);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (prodDbId) {
      res["ProdDbId"] = boost::any(*prodDbId);
    }
    if (spaceConfig) {
      res["SpaceConfig"] = boost::any(*spaceConfig);
    }
    if (spaceName) {
      res["SpaceName"] = boost::any(*spaceName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevDbId") != m.end() && !m["DevDbId"].empty()) {
      devDbId = make_shared<string>(boost::any_cast<string>(m["DevDbId"]));
    }
    if (m.find("DwDbType") != m.end() && !m["DwDbType"].empty()) {
      dwDbType = make_shared<string>(boost::any_cast<string>(m["DwDbType"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("ProdDbId") != m.end() && !m["ProdDbId"].empty()) {
      prodDbId = make_shared<string>(boost::any_cast<string>(m["ProdDbId"]));
    }
    if (m.find("SpaceConfig") != m.end() && !m["SpaceConfig"].empty()) {
      spaceConfig = make_shared<string>(boost::any_cast<string>(m["SpaceConfig"]));
    }
    if (m.find("SpaceName") != m.end() && !m["SpaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["SpaceName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateLakeHouseSpaceRequest() = default;
};
class CreateLakeHouseSpaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> spaceId{};
  shared_ptr<bool> success{};

  CreateLakeHouseSpaceResponseBody() {}

  explicit CreateLakeHouseSpaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<long>(boost::any_cast<long>(m["SpaceId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateLakeHouseSpaceResponseBody() = default;
};
class CreateLakeHouseSpaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLakeHouseSpaceResponseBody> body{};

  CreateLakeHouseSpaceResponse() {}

  explicit CreateLakeHouseSpaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLakeHouseSpaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLakeHouseSpaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLakeHouseSpaceResponse() = default;
};
class CreateLogicDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<vector<long>> databaseIds{};
  shared_ptr<long> tid{};

  CreateLogicDatabaseRequest() {}

  explicit CreateLogicDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (databaseIds) {
      res["DatabaseIds"] = boost::any(*databaseIds);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("DatabaseIds") != m.end() && !m["DatabaseIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      databaseIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateLogicDatabaseRequest() = default;
};
class CreateLogicDatabaseShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> databaseIdsShrink{};
  shared_ptr<long> tid{};

  CreateLogicDatabaseShrinkRequest() {}

  explicit CreateLogicDatabaseShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (databaseIdsShrink) {
      res["DatabaseIds"] = boost::any(*databaseIdsShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("DatabaseIds") != m.end() && !m["DatabaseIds"].empty()) {
      databaseIdsShrink = make_shared<string>(boost::any_cast<string>(m["DatabaseIds"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateLogicDatabaseShrinkRequest() = default;
};
class CreateLogicDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> logicDbId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateLogicDatabaseResponseBody() {}

  explicit CreateLogicDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (logicDbId) {
      res["LogicDbId"] = boost::any(*logicDbId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("LogicDbId") != m.end() && !m["LogicDbId"].empty()) {
      logicDbId = make_shared<long>(boost::any_cast<long>(m["LogicDbId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateLogicDatabaseResponseBody() = default;
};
class CreateLogicDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLogicDatabaseResponseBody> body{};

  CreateLogicDatabaseResponse() {}

  explicit CreateLogicDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLogicDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLogicDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLogicDatabaseResponse() = default;
};
class CreateOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<map<string, boost::any>> pluginParam{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> relatedUserList{};
  shared_ptr<long> tid{};

  CreateOrderRequest() {}

  explicit CreateOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (pluginParam) {
      res["PluginParam"] = boost::any(*pluginParam);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("PluginParam") != m.end() && !m["PluginParam"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["PluginParam"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      pluginParam = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserList = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateOrderRequest() = default;
};
class CreateOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<string> pluginParamShrink{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> relatedUserList{};
  shared_ptr<long> tid{};

  CreateOrderShrinkRequest() {}

  explicit CreateOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (pluginParamShrink) {
      res["PluginParam"] = boost::any(*pluginParamShrink);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("PluginParam") != m.end() && !m["PluginParam"].empty()) {
      pluginParamShrink = make_shared<string>(boost::any_cast<string>(m["PluginParam"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserList = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateOrderShrinkRequest() = default;
};
class CreateOrderResponseBodyCreateOrderResult : public Darabonba::Model {
public:
  shared_ptr<vector<long>> orderIds{};

  CreateOrderResponseBodyCreateOrderResult() {}

  explicit CreateOrderResponseBodyCreateOrderResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      orderIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateOrderResponseBodyCreateOrderResult() = default;
};
class CreateOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrderResponseBodyCreateOrderResult> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateOrderResponseBody() {}

  explicit CreateOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = createOrderResult ? boost::any(createOrderResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateOrderResult"].type()) {
        CreateOrderResponseBodyCreateOrderResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateOrderResult"]));
        createOrderResult = make_shared<CreateOrderResponseBodyCreateOrderResult>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOrderResponseBody() = default;
};
class CreateOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrderResponseBody> body{};

  CreateOrderResponse() {}

  explicit CreateOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrderResponse() = default;
};
class CreateProcCorrectOrderRequestParamDbItemList : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<bool> logic{};

  CreateProcCorrectOrderRequestParamDbItemList() {}

  explicit CreateProcCorrectOrderRequestParamDbItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
  }


  virtual ~CreateProcCorrectOrderRequestParamDbItemList() = default;
};
class CreateProcCorrectOrderRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> classify{};
  shared_ptr<vector<CreateProcCorrectOrderRequestParamDbItemList>> dbItemList{};
  shared_ptr<string> execMode{};
  shared_ptr<string> execSQL{};
  shared_ptr<string> rollbackAttachmentName{};
  shared_ptr<string> rollbackSQL{};
  shared_ptr<string> rollbackSqlType{};

  CreateProcCorrectOrderRequestParam() {}

  explicit CreateProcCorrectOrderRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (dbItemList) {
      vector<boost::any> temp1;
      for(auto item1:*dbItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DbItemList"] = boost::any(temp1);
    }
    if (execMode) {
      res["ExecMode"] = boost::any(*execMode);
    }
    if (execSQL) {
      res["ExecSQL"] = boost::any(*execSQL);
    }
    if (rollbackAttachmentName) {
      res["RollbackAttachmentName"] = boost::any(*rollbackAttachmentName);
    }
    if (rollbackSQL) {
      res["RollbackSQL"] = boost::any(*rollbackSQL);
    }
    if (rollbackSqlType) {
      res["RollbackSqlType"] = boost::any(*rollbackSqlType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("DbItemList") != m.end() && !m["DbItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["DbItemList"].type()) {
        vector<CreateProcCorrectOrderRequestParamDbItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DbItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProcCorrectOrderRequestParamDbItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dbItemList = make_shared<vector<CreateProcCorrectOrderRequestParamDbItemList>>(expect1);
      }
    }
    if (m.find("ExecMode") != m.end() && !m["ExecMode"].empty()) {
      execMode = make_shared<string>(boost::any_cast<string>(m["ExecMode"]));
    }
    if (m.find("ExecSQL") != m.end() && !m["ExecSQL"].empty()) {
      execSQL = make_shared<string>(boost::any_cast<string>(m["ExecSQL"]));
    }
    if (m.find("RollbackAttachmentName") != m.end() && !m["RollbackAttachmentName"].empty()) {
      rollbackAttachmentName = make_shared<string>(boost::any_cast<string>(m["RollbackAttachmentName"]));
    }
    if (m.find("RollbackSQL") != m.end() && !m["RollbackSQL"].empty()) {
      rollbackSQL = make_shared<string>(boost::any_cast<string>(m["RollbackSQL"]));
    }
    if (m.find("RollbackSqlType") != m.end() && !m["RollbackSqlType"].empty()) {
      rollbackSqlType = make_shared<string>(boost::any_cast<string>(m["RollbackSqlType"]));
    }
  }


  virtual ~CreateProcCorrectOrderRequestParam() = default;
};
class CreateProcCorrectOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<CreateProcCorrectOrderRequestParam> param{};
  shared_ptr<vector<long>> relatedUserList{};
  shared_ptr<long> tid{};

  CreateProcCorrectOrderRequest() {}

  explicit CreateProcCorrectOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (param) {
      res["Param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(map<string, boost::any>) == m["Param"].type()) {
        CreateProcCorrectOrderRequestParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Param"]));
        param = make_shared<CreateProcCorrectOrderRequestParam>(model1);
      }
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      relatedUserList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateProcCorrectOrderRequest() = default;
};
class CreateProcCorrectOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<string> paramShrink{};
  shared_ptr<string> relatedUserListShrink{};
  shared_ptr<long> tid{};

  CreateProcCorrectOrderShrinkRequest() {}

  explicit CreateProcCorrectOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (paramShrink) {
      res["Param"] = boost::any(*paramShrink);
    }
    if (relatedUserListShrink) {
      res["RelatedUserList"] = boost::any(*relatedUserListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      paramShrink = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserListShrink = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateProcCorrectOrderShrinkRequest() = default;
};
class CreateProcCorrectOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateProcCorrectOrderResponseBody() {}

  explicit CreateProcCorrectOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = boost::any(*createOrderResult);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateOrderResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateOrderResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createOrderResult = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateProcCorrectOrderResponseBody() = default;
};
class CreateProcCorrectOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProcCorrectOrderResponseBody> body{};

  CreateProcCorrectOrderResponse() {}

  explicit CreateProcCorrectOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProcCorrectOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProcCorrectOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProcCorrectOrderResponse() = default;
};
class CreateProxyRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> password{};
  shared_ptr<long> tid{};
  shared_ptr<string> username{};

  CreateProxyRequest() {}

  explicit CreateProxyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~CreateProxyRequest() = default;
};
class CreateProxyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> proxyId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateProxyResponseBody() {}

  explicit CreateProxyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (proxyId) {
      res["ProxyId"] = boost::any(*proxyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProxyId") != m.end() && !m["ProxyId"].empty()) {
      proxyId = make_shared<long>(boost::any_cast<long>(m["ProxyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateProxyResponseBody() = default;
};
class CreateProxyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProxyResponseBody> body{};

  CreateProxyResponse() {}

  explicit CreateProxyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProxyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProxyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProxyResponse() = default;
};
class CreateProxyAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> indepAccount{};
  shared_ptr<string> indepPassword{};
  shared_ptr<long> proxyId{};
  shared_ptr<long> tid{};
  shared_ptr<long> userId{};

  CreateProxyAccessRequest() {}

  explicit CreateProxyAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indepAccount) {
      res["IndepAccount"] = boost::any(*indepAccount);
    }
    if (indepPassword) {
      res["IndepPassword"] = boost::any(*indepPassword);
    }
    if (proxyId) {
      res["ProxyId"] = boost::any(*proxyId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndepAccount") != m.end() && !m["IndepAccount"].empty()) {
      indepAccount = make_shared<string>(boost::any_cast<string>(m["IndepAccount"]));
    }
    if (m.find("IndepPassword") != m.end() && !m["IndepPassword"].empty()) {
      indepPassword = make_shared<string>(boost::any_cast<string>(m["IndepPassword"]));
    }
    if (m.find("ProxyId") != m.end() && !m["ProxyId"].empty()) {
      proxyId = make_shared<long>(boost::any_cast<long>(m["ProxyId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~CreateProxyAccessRequest() = default;
};
class CreateProxyAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> proxyAccessId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateProxyAccessResponseBody() {}

  explicit CreateProxyAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (proxyAccessId) {
      res["ProxyAccessId"] = boost::any(*proxyAccessId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProxyAccessId") != m.end() && !m["ProxyAccessId"].empty()) {
      proxyAccessId = make_shared<long>(boost::any_cast<long>(m["ProxyAccessId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateProxyAccessResponseBody() = default;
};
class CreateProxyAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProxyAccessResponseBody> body{};

  CreateProxyAccessResponse() {}

  explicit CreateProxyAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProxyAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProxyAccessResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProxyAccessResponse() = default;
};
class CreatePublishGroupTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<bool> logic{};
  shared_ptr<long> orderId{};
  shared_ptr<string> planTime{};
  shared_ptr<string> publishStrategy{};
  shared_ptr<long> tid{};

  CreatePublishGroupTaskRequest() {}

  explicit CreatePublishGroupTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (planTime) {
      res["PlanTime"] = boost::any(*planTime);
    }
    if (publishStrategy) {
      res["PublishStrategy"] = boost::any(*publishStrategy);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("PlanTime") != m.end() && !m["PlanTime"].empty()) {
      planTime = make_shared<string>(boost::any_cast<string>(m["PlanTime"]));
    }
    if (m.find("PublishStrategy") != m.end() && !m["PublishStrategy"].empty()) {
      publishStrategy = make_shared<string>(boost::any_cast<string>(m["PublishStrategy"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreatePublishGroupTaskRequest() = default;
};
class CreatePublishGroupTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> taskId{};

  CreatePublishGroupTaskResponseBody() {}

  explicit CreatePublishGroupTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~CreatePublishGroupTaskResponseBody() = default;
};
class CreatePublishGroupTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePublishGroupTaskResponseBody> body{};

  CreatePublishGroupTaskResponse() {}

  explicit CreatePublishGroupTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePublishGroupTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePublishGroupTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePublishGroupTaskResponse() = default;
};
class CreateSQLReviewOrderRequestParam : public Darabonba::Model {
public:
  shared_ptr<vector<string>> attachmentKeyList{};
  shared_ptr<long> dbId{};
  shared_ptr<string> projectName{};

  CreateSQLReviewOrderRequestParam() {}

  explicit CreateSQLReviewOrderRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKeyList) {
      res["AttachmentKeyList"] = boost::any(*attachmentKeyList);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKeyList") != m.end() && !m["AttachmentKeyList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AttachmentKeyList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AttachmentKeyList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attachmentKeyList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~CreateSQLReviewOrderRequestParam() = default;
};
class CreateSQLReviewOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<CreateSQLReviewOrderRequestParam> param{};
  shared_ptr<vector<long>> relatedUserList{};
  shared_ptr<long> tid{};

  CreateSQLReviewOrderRequest() {}

  explicit CreateSQLReviewOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (param) {
      res["Param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(map<string, boost::any>) == m["Param"].type()) {
        CreateSQLReviewOrderRequestParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Param"]));
        param = make_shared<CreateSQLReviewOrderRequestParam>(model1);
      }
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      relatedUserList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateSQLReviewOrderRequest() = default;
};
class CreateSQLReviewOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> paramShrink{};
  shared_ptr<string> relatedUserListShrink{};
  shared_ptr<long> tid{};

  CreateSQLReviewOrderShrinkRequest() {}

  explicit CreateSQLReviewOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (paramShrink) {
      res["Param"] = boost::any(*paramShrink);
    }
    if (relatedUserListShrink) {
      res["RelatedUserList"] = boost::any(*relatedUserListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      paramShrink = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserListShrink = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateSQLReviewOrderShrinkRequest() = default;
};
class CreateSQLReviewOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateSQLReviewOrderResponseBody() {}

  explicit CreateSQLReviewOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = boost::any(*createOrderResult);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateOrderResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateOrderResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createOrderResult = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSQLReviewOrderResponseBody() = default;
};
class CreateSQLReviewOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSQLReviewOrderResponseBody> body{};

  CreateSQLReviewOrderResponse() {}

  explicit CreateSQLReviewOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSQLReviewOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSQLReviewOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSQLReviewOrderResponse() = default;
};
class CreateScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> scenarioName{};
  shared_ptr<long> tid{};

  CreateScenarioRequest() {}

  explicit CreateScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (scenarioName) {
      res["ScenarioName"] = boost::any(*scenarioName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ScenarioName") != m.end() && !m["ScenarioName"].empty()) {
      scenarioName = make_shared<string>(boost::any_cast<string>(m["ScenarioName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateScenarioRequest() = default;
};
class CreateScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> scenarioId{};
  shared_ptr<bool> success{};

  CreateScenarioResponseBody() {}

  explicit CreateScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<long>(boost::any_cast<long>(m["ScenarioId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateScenarioResponseBody() = default;
};
class CreateScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScenarioResponseBody> body{};

  CreateScenarioResponse() {}

  explicit CreateScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScenarioResponse() = default;
};
class CreateStandardGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbType{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<long> tid{};

  CreateStandardGroupRequest() {}

  explicit CreateStandardGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateStandardGroupRequest() = default;
};
class CreateStandardGroupResponseBodyStandardGroup : public Darabonba::Model {
public:
  shared_ptr<string> dbType{};
  shared_ptr<string> description{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupMode{};
  shared_ptr<string> groupName{};
  shared_ptr<long> lastMenderId{};

  CreateStandardGroupResponseBodyStandardGroup() {}

  explicit CreateStandardGroupResponseBodyStandardGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupMode) {
      res["GroupMode"] = boost::any(*groupMode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lastMenderId) {
      res["LastMenderId"] = boost::any(*lastMenderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupMode") != m.end() && !m["GroupMode"].empty()) {
      groupMode = make_shared<string>(boost::any_cast<string>(m["GroupMode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LastMenderId") != m.end() && !m["LastMenderId"].empty()) {
      lastMenderId = make_shared<long>(boost::any_cast<long>(m["LastMenderId"]));
    }
  }


  virtual ~CreateStandardGroupResponseBodyStandardGroup() = default;
};
class CreateStandardGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateStandardGroupResponseBodyStandardGroup> standardGroup{};
  shared_ptr<bool> success{};

  CreateStandardGroupResponseBody() {}

  explicit CreateStandardGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (standardGroup) {
      res["StandardGroup"] = standardGroup ? boost::any(standardGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StandardGroup") != m.end() && !m["StandardGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["StandardGroup"].type()) {
        CreateStandardGroupResponseBodyStandardGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StandardGroup"]));
        standardGroup = make_shared<CreateStandardGroupResponseBodyStandardGroup>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateStandardGroupResponseBody() = default;
};
class CreateStandardGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateStandardGroupResponseBody> body{};

  CreateStandardGroupResponse() {}

  explicit CreateStandardGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateStandardGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateStandardGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateStandardGroupResponse() = default;
};
class CreateStructSyncOrderRequestParamSource : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<string> dbSearchName{};
  shared_ptr<bool> logic{};
  shared_ptr<string> versionId{};

  CreateStructSyncOrderRequestParamSource() {}

  explicit CreateStructSyncOrderRequestParamSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbSearchName) {
      res["DbSearchName"] = boost::any(*dbSearchName);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DbSearchName") != m.end() && !m["DbSearchName"].empty()) {
      dbSearchName = make_shared<string>(boost::any_cast<string>(m["DbSearchName"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~CreateStructSyncOrderRequestParamSource() = default;
};
class CreateStructSyncOrderRequestParamTableInfoList : public Darabonba::Model {
public:
  shared_ptr<string> sourceTableName{};
  shared_ptr<string> targetTableName{};

  CreateStructSyncOrderRequestParamTableInfoList() {}

  explicit CreateStructSyncOrderRequestParamTableInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    if (targetTableName) {
      res["TargetTableName"] = boost::any(*targetTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
    if (m.find("TargetTableName") != m.end() && !m["TargetTableName"].empty()) {
      targetTableName = make_shared<string>(boost::any_cast<string>(m["TargetTableName"]));
    }
  }


  virtual ~CreateStructSyncOrderRequestParamTableInfoList() = default;
};
class CreateStructSyncOrderRequestParamTarget : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<string> dbSearchName{};
  shared_ptr<bool> logic{};
  shared_ptr<string> versionId{};

  CreateStructSyncOrderRequestParamTarget() {}

  explicit CreateStructSyncOrderRequestParamTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbSearchName) {
      res["DbSearchName"] = boost::any(*dbSearchName);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DbSearchName") != m.end() && !m["DbSearchName"].empty()) {
      dbSearchName = make_shared<string>(boost::any_cast<string>(m["DbSearchName"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~CreateStructSyncOrderRequestParamTarget() = default;
};
class CreateStructSyncOrderRequestParam : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreError{};
  shared_ptr<CreateStructSyncOrderRequestParamSource> source{};
  shared_ptr<vector<CreateStructSyncOrderRequestParamTableInfoList>> tableInfoList{};
  shared_ptr<CreateStructSyncOrderRequestParamTarget> target{};

  CreateStructSyncOrderRequestParam() {}

  explicit CreateStructSyncOrderRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreError) {
      res["IgnoreError"] = boost::any(*ignoreError);
    }
    if (source) {
      res["Source"] = source ? boost::any(source->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*tableInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableInfoList"] = boost::any(temp1);
    }
    if (target) {
      res["Target"] = target ? boost::any(target->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreError") != m.end() && !m["IgnoreError"].empty()) {
      ignoreError = make_shared<bool>(boost::any_cast<bool>(m["IgnoreError"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(map<string, boost::any>) == m["Source"].type()) {
        CreateStructSyncOrderRequestParamSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Source"]));
        source = make_shared<CreateStructSyncOrderRequestParamSource>(model1);
      }
    }
    if (m.find("TableInfoList") != m.end() && !m["TableInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableInfoList"].type()) {
        vector<CreateStructSyncOrderRequestParamTableInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateStructSyncOrderRequestParamTableInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableInfoList = make_shared<vector<CreateStructSyncOrderRequestParamTableInfoList>>(expect1);
      }
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(map<string, boost::any>) == m["Target"].type()) {
        CreateStructSyncOrderRequestParamTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Target"]));
        target = make_shared<CreateStructSyncOrderRequestParamTarget>(model1);
      }
    }
  }


  virtual ~CreateStructSyncOrderRequestParam() = default;
};
class CreateStructSyncOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<CreateStructSyncOrderRequestParam> param{};
  shared_ptr<vector<long>> relatedUserList{};
  shared_ptr<long> tid{};

  CreateStructSyncOrderRequest() {}

  explicit CreateStructSyncOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (param) {
      res["Param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      if (typeid(map<string, boost::any>) == m["Param"].type()) {
        CreateStructSyncOrderRequestParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Param"]));
        param = make_shared<CreateStructSyncOrderRequestParam>(model1);
      }
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      relatedUserList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateStructSyncOrderRequest() = default;
};
class CreateStructSyncOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<string> paramShrink{};
  shared_ptr<string> relatedUserListShrink{};
  shared_ptr<long> tid{};

  CreateStructSyncOrderShrinkRequest() {}

  explicit CreateStructSyncOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (paramShrink) {
      res["Param"] = boost::any(*paramShrink);
    }
    if (relatedUserListShrink) {
      res["RelatedUserList"] = boost::any(*relatedUserListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      paramShrink = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      relatedUserListShrink = make_shared<string>(boost::any_cast<string>(m["RelatedUserList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateStructSyncOrderShrinkRequest() = default;
};
class CreateStructSyncOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createOrderResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateStructSyncOrderResponseBody() {}

  explicit CreateStructSyncOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createOrderResult) {
      res["CreateOrderResult"] = boost::any(*createOrderResult);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateOrderResult") != m.end() && !m["CreateOrderResult"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateOrderResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateOrderResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createOrderResult = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateStructSyncOrderResponseBody() = default;
};
class CreateStructSyncOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateStructSyncOrderResponseBody> body{};

  CreateStructSyncOrderResponse() {}

  explicit CreateStructSyncOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateStructSyncOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateStructSyncOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateStructSyncOrderResponse() = default;
};
class CreateTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> graphParam{};
  shared_ptr<string> nodeContent{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> nodeOutput{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> tid{};
  shared_ptr<string> timeVariables{};

  CreateTaskRequest() {}

  explicit CreateTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (graphParam) {
      res["GraphParam"] = boost::any(*graphParam);
    }
    if (nodeContent) {
      res["NodeContent"] = boost::any(*nodeContent);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeOutput) {
      res["NodeOutput"] = boost::any(*nodeOutput);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (timeVariables) {
      res["TimeVariables"] = boost::any(*timeVariables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("GraphParam") != m.end() && !m["GraphParam"].empty()) {
      graphParam = make_shared<string>(boost::any_cast<string>(m["GraphParam"]));
    }
    if (m.find("NodeContent") != m.end() && !m["NodeContent"].empty()) {
      nodeContent = make_shared<string>(boost::any_cast<string>(m["NodeContent"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeOutput") != m.end() && !m["NodeOutput"].empty()) {
      nodeOutput = make_shared<string>(boost::any_cast<string>(m["NodeOutput"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("TimeVariables") != m.end() && !m["TimeVariables"].empty()) {
      timeVariables = make_shared<string>(boost::any_cast<string>(m["TimeVariables"]));
    }
  }


  virtual ~CreateTaskRequest() = default;
};
class CreateTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateTaskResponseBody() {}

  explicit CreateTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateTaskResponseBody() = default;
};
class CreateTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTaskResponseBody> body{};

  CreateTaskResponse() {}

  explicit CreateTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTaskResponse() = default;
};
class CreateTaskFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> dagName{};
  shared_ptr<string> description{};
  shared_ptr<long> scenarioId{};
  shared_ptr<long> tid{};

  CreateTaskFlowRequest() {}

  explicit CreateTaskFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagName) {
      res["DagName"] = boost::any(*dagName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagName") != m.end() && !m["DagName"].empty()) {
      dagName = make_shared<string>(boost::any_cast<string>(m["DagName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<long>(boost::any_cast<long>(m["ScenarioId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~CreateTaskFlowRequest() = default;
};
class CreateTaskFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateTaskFlowResponseBody() {}

  explicit CreateTaskFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateTaskFlowResponseBody() = default;
};
class CreateTaskFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTaskFlowResponseBody> body{};

  CreateTaskFlowResponse() {}

  explicit CreateTaskFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTaskFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTaskFlowResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTaskFlowResponse() = default;
};
class CreateUploadFileJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSource{};
  shared_ptr<long> tid{};
  shared_ptr<string> uploadURL{};

  CreateUploadFileJobRequest() {}

  explicit CreateUploadFileJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSource) {
      res["FileSource"] = boost::any(*fileSource);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (uploadURL) {
      res["UploadURL"] = boost::any(*uploadURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSource") != m.end() && !m["FileSource"].empty()) {
      fileSource = make_shared<string>(boost::any_cast<string>(m["FileSource"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UploadURL") != m.end() && !m["UploadURL"].empty()) {
      uploadURL = make_shared<string>(boost::any_cast<string>(m["UploadURL"]));
    }
  }


  virtual ~CreateUploadFileJobRequest() = default;
};
class CreateUploadFileJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobKey{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateUploadFileJobResponseBody() {}

  explicit CreateUploadFileJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobKey) {
      res["JobKey"] = boost::any(*jobKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobKey") != m.end() && !m["JobKey"].empty()) {
      jobKey = make_shared<string>(boost::any_cast<string>(m["JobKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateUploadFileJobResponseBody() = default;
};
class CreateUploadFileJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUploadFileJobResponseBody> body{};

  CreateUploadFileJobResponse() {}

  explicit CreateUploadFileJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUploadFileJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUploadFileJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUploadFileJobResponse() = default;
};
class CreateUploadOSSFileJobRequestUploadTarget : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> objectName{};

  CreateUploadOSSFileJobRequestUploadTarget() {}

  explicit CreateUploadOSSFileJobRequestUploadTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
  }


  virtual ~CreateUploadOSSFileJobRequestUploadTarget() = default;
};
class CreateUploadOSSFileJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSource{};
  shared_ptr<long> tid{};
  shared_ptr<CreateUploadOSSFileJobRequestUploadTarget> uploadTarget{};

  CreateUploadOSSFileJobRequest() {}

  explicit CreateUploadOSSFileJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSource) {
      res["FileSource"] = boost::any(*fileSource);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (uploadTarget) {
      res["UploadTarget"] = uploadTarget ? boost::any(uploadTarget->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSource") != m.end() && !m["FileSource"].empty()) {
      fileSource = make_shared<string>(boost::any_cast<string>(m["FileSource"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UploadTarget") != m.end() && !m["UploadTarget"].empty()) {
      if (typeid(map<string, boost::any>) == m["UploadTarget"].type()) {
        CreateUploadOSSFileJobRequestUploadTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UploadTarget"]));
        uploadTarget = make_shared<CreateUploadOSSFileJobRequestUploadTarget>(model1);
      }
    }
  }


  virtual ~CreateUploadOSSFileJobRequest() = default;
};
class CreateUploadOSSFileJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSource{};
  shared_ptr<long> tid{};
  shared_ptr<string> uploadTargetShrink{};

  CreateUploadOSSFileJobShrinkRequest() {}

  explicit CreateUploadOSSFileJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSource) {
      res["FileSource"] = boost::any(*fileSource);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (uploadTargetShrink) {
      res["UploadTarget"] = boost::any(*uploadTargetShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSource") != m.end() && !m["FileSource"].empty()) {
      fileSource = make_shared<string>(boost::any_cast<string>(m["FileSource"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UploadTarget") != m.end() && !m["UploadTarget"].empty()) {
      uploadTargetShrink = make_shared<string>(boost::any_cast<string>(m["UploadTarget"]));
    }
  }


  virtual ~CreateUploadOSSFileJobShrinkRequest() = default;
};
class CreateUploadOSSFileJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobKey{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateUploadOSSFileJobResponseBody() {}

  explicit CreateUploadOSSFileJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobKey) {
      res["JobKey"] = boost::any(*jobKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobKey") != m.end() && !m["JobKey"].empty()) {
      jobKey = make_shared<string>(boost::any_cast<string>(m["JobKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateUploadOSSFileJobResponseBody() = default;
};
class CreateUploadOSSFileJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUploadOSSFileJobResponseBody> body{};

  CreateUploadOSSFileJobResponse() {}

  explicit CreateUploadOSSFileJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUploadOSSFileJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUploadOSSFileJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUploadOSSFileJobResponse() = default;
};
class DeleteAuthorityTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> templateId{};
  shared_ptr<long> tid{};

  DeleteAuthorityTemplateRequest() {}

  explicit DeleteAuthorityTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteAuthorityTemplateRequest() = default;
};
class DeleteAuthorityTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> tid{};

  DeleteAuthorityTemplateResponseBody() {}

  explicit DeleteAuthorityTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteAuthorityTemplateResponseBody() = default;
};
class DeleteAuthorityTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAuthorityTemplateResponseBody> body{};

  DeleteAuthorityTemplateResponse() {}

  explicit DeleteAuthorityTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAuthorityTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAuthorityTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAuthorityTemplateResponse() = default;
};
class DeleteInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};
  shared_ptr<string> sid{};
  shared_ptr<long> tid{};

  DeleteInstanceRequest() {}

  explicit DeleteInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteInstanceRequest() = default;
};
class DeleteInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteInstanceResponseBody() {}

  explicit DeleteInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteInstanceResponseBody() = default;
};
class DeleteInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInstanceResponseBody> body{};

  DeleteInstanceResponse() {}

  explicit DeleteInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstanceResponse() = default;
};
class DeleteLakeHouseSpaceRequest : public Darabonba::Model {
public:
  shared_ptr<long> spaceId{};
  shared_ptr<long> tid{};

  DeleteLakeHouseSpaceRequest() {}

  explicit DeleteLakeHouseSpaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<long>(boost::any_cast<long>(m["SpaceId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteLakeHouseSpaceRequest() = default;
};
class DeleteLakeHouseSpaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteLakeHouseSpaceResponseBody() {}

  explicit DeleteLakeHouseSpaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteLakeHouseSpaceResponseBody() = default;
};
class DeleteLakeHouseSpaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLakeHouseSpaceResponseBody> body{};

  DeleteLakeHouseSpaceResponse() {}

  explicit DeleteLakeHouseSpaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLakeHouseSpaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLakeHouseSpaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLakeHouseSpaceResponse() = default;
};
class DeleteLhMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> memberIds{};
  shared_ptr<long> objectId{};
  shared_ptr<long> objectType{};
  shared_ptr<long> tid{};

  DeleteLhMembersRequest() {}

  explicit DeleteLhMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberIds) {
      res["MemberIds"] = boost::any(*memberIds);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberIds") != m.end() && !m["MemberIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["MemberIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MemberIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      memberIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<long>(boost::any_cast<long>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<long>(boost::any_cast<long>(m["ObjectType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteLhMembersRequest() = default;
};
class DeleteLhMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> memberIdsShrink{};
  shared_ptr<long> objectId{};
  shared_ptr<long> objectType{};
  shared_ptr<long> tid{};

  DeleteLhMembersShrinkRequest() {}

  explicit DeleteLhMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberIdsShrink) {
      res["MemberIds"] = boost::any(*memberIdsShrink);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberIds") != m.end() && !m["MemberIds"].empty()) {
      memberIdsShrink = make_shared<string>(boost::any_cast<string>(m["MemberIds"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<long>(boost::any_cast<long>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<long>(boost::any_cast<long>(m["ObjectType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteLhMembersShrinkRequest() = default;
};
class DeleteLhMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteLhMembersResponseBody() {}

  explicit DeleteLhMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteLhMembersResponseBody() = default;
};
class DeleteLhMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLhMembersResponseBody> body{};

  DeleteLhMembersResponse() {}

  explicit DeleteLhMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLhMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLhMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLhMembersResponse() = default;
};
class DeleteLogicDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<long> logicDbId{};
  shared_ptr<long> tid{};

  DeleteLogicDatabaseRequest() {}

  explicit DeleteLogicDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicDbId) {
      res["LogicDbId"] = boost::any(*logicDbId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicDbId") != m.end() && !m["LogicDbId"].empty()) {
      logicDbId = make_shared<long>(boost::any_cast<long>(m["LogicDbId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteLogicDatabaseRequest() = default;
};
class DeleteLogicDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteLogicDatabaseResponseBody() {}

  explicit DeleteLogicDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteLogicDatabaseResponseBody() = default;
};
class DeleteLogicDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLogicDatabaseResponseBody> body{};

  DeleteLogicDatabaseResponse() {}

  explicit DeleteLogicDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLogicDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLogicDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLogicDatabaseResponse() = default;
};
class DeleteLogicTableRouteConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> routeKey{};
  shared_ptr<long> tableId{};
  shared_ptr<long> tid{};

  DeleteLogicTableRouteConfigRequest() {}

  explicit DeleteLogicTableRouteConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeKey) {
      res["RouteKey"] = boost::any(*routeKey);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteKey") != m.end() && !m["RouteKey"].empty()) {
      routeKey = make_shared<string>(boost::any_cast<string>(m["RouteKey"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<long>(boost::any_cast<long>(m["TableId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteLogicTableRouteConfigRequest() = default;
};
class DeleteLogicTableRouteConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteLogicTableRouteConfigResponseBody() {}

  explicit DeleteLogicTableRouteConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteLogicTableRouteConfigResponseBody() = default;
};
class DeleteLogicTableRouteConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLogicTableRouteConfigResponseBody> body{};

  DeleteLogicTableRouteConfigResponse() {}

  explicit DeleteLogicTableRouteConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLogicTableRouteConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLogicTableRouteConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLogicTableRouteConfigResponse() = default;
};
class DeleteProxyRequest : public Darabonba::Model {
public:
  shared_ptr<long> proxyId{};
  shared_ptr<long> tid{};

  DeleteProxyRequest() {}

  explicit DeleteProxyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxyId) {
      res["ProxyId"] = boost::any(*proxyId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxyId") != m.end() && !m["ProxyId"].empty()) {
      proxyId = make_shared<long>(boost::any_cast<long>(m["ProxyId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteProxyRequest() = default;
};
class DeleteProxyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteProxyResponseBody() {}

  explicit DeleteProxyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteProxyResponseBody() = default;
};
class DeleteProxyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProxyResponseBody> body{};

  DeleteProxyResponse() {}

  explicit DeleteProxyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProxyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProxyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProxyResponse() = default;
};
class DeleteProxyAccessRequest : public Darabonba::Model {
public:
  shared_ptr<long> proxyAccessId{};
  shared_ptr<long> tid{};

  DeleteProxyAccessRequest() {}

  explicit DeleteProxyAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxyAccessId) {
      res["ProxyAccessId"] = boost::any(*proxyAccessId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxyAccessId") != m.end() && !m["ProxyAccessId"].empty()) {
      proxyAccessId = make_shared<long>(boost::any_cast<long>(m["ProxyAccessId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteProxyAccessRequest() = default;
};
class DeleteProxyAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteProxyAccessResponseBody() {}

  explicit DeleteProxyAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteProxyAccessResponseBody() = default;
};
class DeleteProxyAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProxyAccessResponseBody> body{};

  DeleteProxyAccessResponse() {}

  explicit DeleteProxyAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProxyAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProxyAccessResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProxyAccessResponse() = default;
};
class DeleteScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<long> scenarioId{};
  shared_ptr<long> tid{};

  DeleteScenarioRequest() {}

  explicit DeleteScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<long>(boost::any_cast<long>(m["ScenarioId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteScenarioRequest() = default;
};
class DeleteScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteScenarioResponseBody() {}

  explicit DeleteScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteScenarioResponseBody() = default;
};
class DeleteScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScenarioResponseBody> body{};

  DeleteScenarioResponse() {}

  explicit DeleteScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScenarioResponse() = default;
};
class DeleteStandardGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<long> tid{};

  DeleteStandardGroupRequest() {}

  explicit DeleteStandardGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteStandardGroupRequest() = default;
};
class DeleteStandardGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteStandardGroupResponseBody() {}

  explicit DeleteStandardGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteStandardGroupResponseBody() = default;
};
class DeleteStandardGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteStandardGroupResponseBody> body{};

  DeleteStandardGroupResponse() {}

  explicit DeleteStandardGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStandardGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStandardGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStandardGroupResponse() = default;
};
class DeleteTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<long> tid{};

  DeleteTaskRequest() {}

  explicit DeleteTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteTaskRequest() = default;
};
class DeleteTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteTaskResponseBody() {}

  explicit DeleteTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTaskResponseBody() = default;
};
class DeleteTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTaskResponseBody> body{};

  DeleteTaskResponse() {}

  explicit DeleteTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTaskResponse() = default;
};
class DeleteTaskFlowRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  DeleteTaskFlowRequest() {}

  explicit DeleteTaskFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteTaskFlowRequest() = default;
};
class DeleteTaskFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteTaskFlowResponseBody() {}

  explicit DeleteTaskFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTaskFlowResponseBody() = default;
};
class DeleteTaskFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTaskFlowResponseBody> body{};

  DeleteTaskFlowResponse() {}

  explicit DeleteTaskFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTaskFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTaskFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTaskFlowResponse() = default;
};
class DeleteTaskFlowEdgesByConditionRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> id{};
  shared_ptr<long> nodeEnd{};
  shared_ptr<long> nodeFrom{};
  shared_ptr<long> tid{};

  DeleteTaskFlowEdgesByConditionRequest() {}

  explicit DeleteTaskFlowEdgesByConditionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nodeEnd) {
      res["NodeEnd"] = boost::any(*nodeEnd);
    }
    if (nodeFrom) {
      res["NodeFrom"] = boost::any(*nodeFrom);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NodeEnd") != m.end() && !m["NodeEnd"].empty()) {
      nodeEnd = make_shared<long>(boost::any_cast<long>(m["NodeEnd"]));
    }
    if (m.find("NodeFrom") != m.end() && !m["NodeFrom"].empty()) {
      nodeFrom = make_shared<long>(boost::any_cast<long>(m["NodeFrom"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DeleteTaskFlowEdgesByConditionRequest() = default;
};
class DeleteTaskFlowEdgesByConditionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteTaskFlowEdgesByConditionResponseBody() {}

  explicit DeleteTaskFlowEdgesByConditionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTaskFlowEdgesByConditionResponseBody() = default;
};
class DeleteTaskFlowEdgesByConditionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTaskFlowEdgesByConditionResponseBody> body{};

  DeleteTaskFlowEdgesByConditionResponse() {}

  explicit DeleteTaskFlowEdgesByConditionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTaskFlowEdgesByConditionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTaskFlowEdgesByConditionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTaskFlowEdgesByConditionResponse() = default;
};
class DeleteUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};
  shared_ptr<string> uid{};

  DeleteUserRequest() {}

  explicit DeleteUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
  }


  virtual ~DeleteUserRequest() = default;
};
class DeleteUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteUserResponseBody() {}

  explicit DeleteUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteUserResponseBody() = default;
};
class DeleteUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserResponseBody> body{};

  DeleteUserResponse() {}

  explicit DeleteUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserResponse() = default;
};
class DisableUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};
  shared_ptr<string> uid{};

  DisableUserRequest() {}

  explicit DisableUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
  }


  virtual ~DisableUserRequest() = default;
};
class DisableUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableUserResponseBody() {}

  explicit DisableUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableUserResponseBody() = default;
};
class DisableUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableUserResponseBody> body{};

  DisableUserResponse() {}

  explicit DisableUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableUserResponseBody>(model1);
      }
    }
  }


  virtual ~DisableUserResponse() = default;
};
class DownloadDataTrackResultRequestColumnFilter : public Darabonba::Model {
public:
  shared_ptr<string> betweenEnd{};
  shared_ptr<string> betweenStart{};
  shared_ptr<string> columnName{};
  shared_ptr<vector<string>> inList{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DownloadDataTrackResultRequestColumnFilter() {}

  explicit DownloadDataTrackResultRequestColumnFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (betweenEnd) {
      res["BetweenEnd"] = boost::any(*betweenEnd);
    }
    if (betweenStart) {
      res["BetweenStart"] = boost::any(*betweenStart);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (inList) {
      res["InList"] = boost::any(*inList);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BetweenEnd") != m.end() && !m["BetweenEnd"].empty()) {
      betweenEnd = make_shared<string>(boost::any_cast<string>(m["BetweenEnd"]));
    }
    if (m.find("BetweenStart") != m.end() && !m["BetweenStart"].empty()) {
      betweenStart = make_shared<string>(boost::any_cast<string>(m["BetweenStart"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("InList") != m.end() && !m["InList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      inList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DownloadDataTrackResultRequestColumnFilter() = default;
};
class DownloadDataTrackResultRequest : public Darabonba::Model {
public:
  shared_ptr<DownloadDataTrackResultRequestColumnFilter> columnFilter{};
  shared_ptr<vector<long>> eventIdList{};
  shared_ptr<string> filterEndTime{};
  shared_ptr<string> filterStartTime{};
  shared_ptr<vector<string>> filterTableList{};
  shared_ptr<vector<string>> filterTypeList{};
  shared_ptr<long> orderId{};
  shared_ptr<string> rollbackSQLType{};
  shared_ptr<long> tid{};

  DownloadDataTrackResultRequest() {}

  explicit DownloadDataTrackResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnFilter) {
      res["ColumnFilter"] = columnFilter ? boost::any(columnFilter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventIdList) {
      res["EventIdList"] = boost::any(*eventIdList);
    }
    if (filterEndTime) {
      res["FilterEndTime"] = boost::any(*filterEndTime);
    }
    if (filterStartTime) {
      res["FilterStartTime"] = boost::any(*filterStartTime);
    }
    if (filterTableList) {
      res["FilterTableList"] = boost::any(*filterTableList);
    }
    if (filterTypeList) {
      res["FilterTypeList"] = boost::any(*filterTypeList);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (rollbackSQLType) {
      res["RollbackSQLType"] = boost::any(*rollbackSQLType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnFilter") != m.end() && !m["ColumnFilter"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColumnFilter"].type()) {
        DownloadDataTrackResultRequestColumnFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColumnFilter"]));
        columnFilter = make_shared<DownloadDataTrackResultRequestColumnFilter>(model1);
      }
    }
    if (m.find("EventIdList") != m.end() && !m["EventIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["EventIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      eventIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("FilterEndTime") != m.end() && !m["FilterEndTime"].empty()) {
      filterEndTime = make_shared<string>(boost::any_cast<string>(m["FilterEndTime"]));
    }
    if (m.find("FilterStartTime") != m.end() && !m["FilterStartTime"].empty()) {
      filterStartTime = make_shared<string>(boost::any_cast<string>(m["FilterStartTime"]));
    }
    if (m.find("FilterTableList") != m.end() && !m["FilterTableList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterTableList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterTableList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterTableList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FilterTypeList") != m.end() && !m["FilterTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RollbackSQLType") != m.end() && !m["RollbackSQLType"].empty()) {
      rollbackSQLType = make_shared<string>(boost::any_cast<string>(m["RollbackSQLType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DownloadDataTrackResultRequest() = default;
};
class DownloadDataTrackResultShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnFilterShrink{};
  shared_ptr<string> eventIdListShrink{};
  shared_ptr<string> filterEndTime{};
  shared_ptr<string> filterStartTime{};
  shared_ptr<string> filterTableListShrink{};
  shared_ptr<string> filterTypeListShrink{};
  shared_ptr<long> orderId{};
  shared_ptr<string> rollbackSQLType{};
  shared_ptr<long> tid{};

  DownloadDataTrackResultShrinkRequest() {}

  explicit DownloadDataTrackResultShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnFilterShrink) {
      res["ColumnFilter"] = boost::any(*columnFilterShrink);
    }
    if (eventIdListShrink) {
      res["EventIdList"] = boost::any(*eventIdListShrink);
    }
    if (filterEndTime) {
      res["FilterEndTime"] = boost::any(*filterEndTime);
    }
    if (filterStartTime) {
      res["FilterStartTime"] = boost::any(*filterStartTime);
    }
    if (filterTableListShrink) {
      res["FilterTableList"] = boost::any(*filterTableListShrink);
    }
    if (filterTypeListShrink) {
      res["FilterTypeList"] = boost::any(*filterTypeListShrink);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (rollbackSQLType) {
      res["RollbackSQLType"] = boost::any(*rollbackSQLType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnFilter") != m.end() && !m["ColumnFilter"].empty()) {
      columnFilterShrink = make_shared<string>(boost::any_cast<string>(m["ColumnFilter"]));
    }
    if (m.find("EventIdList") != m.end() && !m["EventIdList"].empty()) {
      eventIdListShrink = make_shared<string>(boost::any_cast<string>(m["EventIdList"]));
    }
    if (m.find("FilterEndTime") != m.end() && !m["FilterEndTime"].empty()) {
      filterEndTime = make_shared<string>(boost::any_cast<string>(m["FilterEndTime"]));
    }
    if (m.find("FilterStartTime") != m.end() && !m["FilterStartTime"].empty()) {
      filterStartTime = make_shared<string>(boost::any_cast<string>(m["FilterStartTime"]));
    }
    if (m.find("FilterTableList") != m.end() && !m["FilterTableList"].empty()) {
      filterTableListShrink = make_shared<string>(boost::any_cast<string>(m["FilterTableList"]));
    }
    if (m.find("FilterTypeList") != m.end() && !m["FilterTypeList"].empty()) {
      filterTypeListShrink = make_shared<string>(boost::any_cast<string>(m["FilterTypeList"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("RollbackSQLType") != m.end() && !m["RollbackSQLType"].empty()) {
      rollbackSQLType = make_shared<string>(boost::any_cast<string>(m["RollbackSQLType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~DownloadDataTrackResultShrinkRequest() = default;
};
class DownloadDataTrackResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadKeyId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DownloadDataTrackResultResponseBody() {}

  explicit DownloadDataTrackResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadKeyId) {
      res["DownloadKeyId"] = boost::any(*downloadKeyId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadKeyId") != m.end() && !m["DownloadKeyId"].empty()) {
      downloadKeyId = make_shared<string>(boost::any_cast<string>(m["DownloadKeyId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadDataTrackResultResponseBody() = default;
};
class DownloadDataTrackResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadDataTrackResultResponseBody> body{};

  DownloadDataTrackResultResponse() {}

  explicit DownloadDataTrackResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadDataTrackResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadDataTrackResultResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadDataTrackResultResponse() = default;
};
class EditLogicDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<vector<long>> databaseIds{};
  shared_ptr<long> logicDbId{};
  shared_ptr<long> tid{};

  EditLogicDatabaseRequest() {}

  explicit EditLogicDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (databaseIds) {
      res["DatabaseIds"] = boost::any(*databaseIds);
    }
    if (logicDbId) {
      res["LogicDbId"] = boost::any(*logicDbId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("DatabaseIds") != m.end() && !m["DatabaseIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      databaseIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("LogicDbId") != m.end() && !m["LogicDbId"].empty()) {
      logicDbId = make_shared<long>(boost::any_cast<long>(m["LogicDbId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~EditLogicDatabaseRequest() = default;
};
class EditLogicDatabaseShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> databaseIdsShrink{};
  shared_ptr<long> logicDbId{};
  shared_ptr<long> tid{};

  EditLogicDatabaseShrinkRequest() {}

  explicit EditLogicDatabaseShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (databaseIdsShrink) {
      res["DatabaseIds"] = boost::any(*databaseIdsShrink);
    }
    if (logicDbId) {
      res["LogicDbId"] = boost::any(*logicDbId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("DatabaseIds") != m.end() && !m["DatabaseIds"].empty()) {
      databaseIdsShrink = make_shared<string>(boost::any_cast<string>(m["DatabaseIds"]));
    }
    if (m.find("LogicDbId") != m.end() && !m["LogicDbId"].empty()) {
      logicDbId = make_shared<long>(boost::any_cast<long>(m["LogicDbId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~EditLogicDatabaseShrinkRequest() = default;
};
class EditLogicDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EditLogicDatabaseResponseBody() {}

  explicit EditLogicDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EditLogicDatabaseResponseBody() = default;
};
class EditLogicDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EditLogicDatabaseResponseBody> body{};

  EditLogicDatabaseResponse() {}

  explicit EditLogicDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EditLogicDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EditLogicDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~EditLogicDatabaseResponse() = default;
};
class EnableUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};
  shared_ptr<string> uid{};

  EnableUserRequest() {}

  explicit EnableUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
  }


  virtual ~EnableUserRequest() = default;
};
class EnableUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableUserResponseBody() {}

  explicit EnableUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableUserResponseBody() = default;
};
class EnableUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableUserResponseBody> body{};

  EnableUserResponse() {}

  explicit EnableUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableUserResponseBody>(model1);
      }
    }
  }


  virtual ~EnableUserResponse() = default;
};
class ExecuteDataCorrectRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> actionDetail{};
  shared_ptr<long> orderId{};
  shared_ptr<string> tid{};

  ExecuteDataCorrectRequest() {}

  explicit ExecuteDataCorrectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionDetail) {
      res["ActionDetail"] = boost::any(*actionDetail);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionDetail") != m.end() && !m["ActionDetail"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ActionDetail"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      actionDetail = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<string>(boost::any_cast<string>(m["Tid"]));
    }
  }


  virtual ~ExecuteDataCorrectRequest() = default;
};
class ExecuteDataCorrectShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionDetailShrink{};
  shared_ptr<long> orderId{};
  shared_ptr<string> tid{};

  ExecuteDataCorrectShrinkRequest() {}

  explicit ExecuteDataCorrectShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionDetailShrink) {
      res["ActionDetail"] = boost::any(*actionDetailShrink);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionDetail") != m.end() && !m["ActionDetail"].empty()) {
      actionDetailShrink = make_shared<string>(boost::any_cast<string>(m["ActionDetail"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<string>(boost::any_cast<string>(m["Tid"]));
    }
  }


  virtual ~ExecuteDataCorrectShrinkRequest() = default;
};
class ExecuteDataCorrectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExecuteDataCorrectResponseBody() {}

  explicit ExecuteDataCorrectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExecuteDataCorrectResponseBody() = default;
};
class ExecuteDataCorrectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteDataCorrectResponseBody> body{};

  ExecuteDataCorrectResponse() {}

  explicit ExecuteDataCorrectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteDataCorrectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteDataCorrectResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteDataCorrectResponse() = default;
};
class ExecuteDataExportRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> actionDetail{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  ExecuteDataExportRequest() {}

  explicit ExecuteDataExportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionDetail) {
      res["ActionDetail"] = boost::any(*actionDetail);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionDetail") != m.end() && !m["ActionDetail"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ActionDetail"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      actionDetail = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ExecuteDataExportRequest() = default;
};
class ExecuteDataExportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionDetailShrink{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  ExecuteDataExportShrinkRequest() {}

  explicit ExecuteDataExportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionDetailShrink) {
      res["ActionDetail"] = boost::any(*actionDetailShrink);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionDetail") != m.end() && !m["ActionDetail"].empty()) {
      actionDetailShrink = make_shared<string>(boost::any_cast<string>(m["ActionDetail"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ExecuteDataExportShrinkRequest() = default;
};
class ExecuteDataExportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExecuteDataExportResponseBody() {}

  explicit ExecuteDataExportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExecuteDataExportResponseBody() = default;
};
class ExecuteDataExportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteDataExportResponseBody> body{};

  ExecuteDataExportResponse() {}

  explicit ExecuteDataExportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteDataExportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteDataExportResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteDataExportResponse() = default;
};
class ExecuteScriptRequest : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<bool> logic{};
  shared_ptr<string> script{};
  shared_ptr<long> tid{};

  ExecuteScriptRequest() {}

  explicit ExecuteScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ExecuteScriptRequest() = default;
};
class ExecuteScriptResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<vector<string>> columnNames{};
  shared_ptr<string> message{};
  shared_ptr<long> rowCount{};
  shared_ptr<vector<map<string, boost::any>>> rows{};
  shared_ptr<bool> success{};

  ExecuteScriptResponseBodyResults() {}

  explicit ExecuteScriptResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnNames) {
      res["ColumnNames"] = boost::any(*columnNames);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (rows) {
      res["Rows"] = boost::any(*rows);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnNames") != m.end() && !m["ColumnNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ColumnNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ColumnNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      columnNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("Rows") != m.end() && !m["Rows"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Rows"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Rows"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      rows = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExecuteScriptResponseBodyResults() = default;
};
class ExecuteScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ExecuteScriptResponseBodyResults>> results{};
  shared_ptr<bool> success{};

  ExecuteScriptResponseBody() {}

  explicit ExecuteScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<ExecuteScriptResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteScriptResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<ExecuteScriptResponseBodyResults>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExecuteScriptResponseBody() = default;
};
class ExecuteScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteScriptResponseBody> body{};

  ExecuteScriptResponse() {}

  explicit ExecuteScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteScriptResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteScriptResponse() = default;
};
class ExecuteStructSyncRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  ExecuteStructSyncRequest() {}

  explicit ExecuteStructSyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ExecuteStructSyncRequest() = default;
};
class ExecuteStructSyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExecuteStructSyncResponseBody() {}

  explicit ExecuteStructSyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExecuteStructSyncResponseBody() = default;
};
class ExecuteStructSyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteStructSyncResponseBody> body{};

  ExecuteStructSyncResponse() {}

  explicit ExecuteStructSyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteStructSyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteStructSyncResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteStructSyncResponse() = default;
};
class GetApprovalDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};
  shared_ptr<long> workflowInstanceId{};

  GetApprovalDetailRequest() {}

  explicit GetApprovalDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
  }


  virtual ~GetApprovalDetailRequest() = default;
};
class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> nickName{};

  GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler() {}

  explicit GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
  }


  virtual ~GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler() = default;
};
class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers : public Darabonba::Model {
public:
  shared_ptr<vector<GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler>> currentHandler{};

  GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers() {}

  explicit GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentHandler) {
      vector<boost::any> temp1;
      for(auto item1:*currentHandler){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CurrentHandler"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentHandler") != m.end() && !m["CurrentHandler"].empty()) {
      if (typeid(vector<boost::any>) == m["CurrentHandler"].type()) {
        vector<GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CurrentHandler"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        currentHandler = make_shared<vector<GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler>>(expect1);
      }
    }
  }


  virtual ~GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers() = default;
};
class GetApprovalDetailResponseBodyApprovalDetailReasonList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> reasons{};

  GetApprovalDetailResponseBodyApprovalDetailReasonList() {}

  explicit GetApprovalDetailResponseBodyApprovalDetailReasonList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reasons) {
      res["Reasons"] = boost::any(*reasons);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Reasons") != m.end() && !m["Reasons"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Reasons"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Reasons"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reasons = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetApprovalDetailResponseBodyApprovalDetailReasonList() = default;
};
class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> auditUserIds{};

  GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList() {}

  explicit GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditUserIds) {
      res["AuditUserIds"] = boost::any(*auditUserIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditUserIds") != m.end() && !m["AuditUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AuditUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AuditUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      auditUserIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList() = default;
};
class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode : public Darabonba::Model {
public:
  shared_ptr<GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList> auditUserIdList{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> operateComment{};
  shared_ptr<string> operateTime{};
  shared_ptr<long> operatorId{};
  shared_ptr<string> workflowInsCode{};

  GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode() {}

  explicit GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditUserIdList) {
      res["AuditUserIdList"] = auditUserIdList ? boost::any(auditUserIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (operateComment) {
      res["OperateComment"] = boost::any(*operateComment);
    }
    if (operateTime) {
      res["OperateTime"] = boost::any(*operateTime);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (workflowInsCode) {
      res["WorkflowInsCode"] = boost::any(*workflowInsCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditUserIdList") != m.end() && !m["AuditUserIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuditUserIdList"].type()) {
        GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuditUserIdList"]));
        auditUserIdList = make_shared<GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList>(model1);
      }
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("OperateComment") != m.end() && !m["OperateComment"].empty()) {
      operateComment = make_shared<string>(boost::any_cast<string>(m["OperateComment"]));
    }
    if (m.find("OperateTime") != m.end() && !m["OperateTime"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["OperateTime"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<long>(boost::any_cast<long>(m["OperatorId"]));
    }
    if (m.find("WorkflowInsCode") != m.end() && !m["WorkflowInsCode"].empty()) {
      workflowInsCode = make_shared<string>(boost::any_cast<string>(m["WorkflowInsCode"]));
    }
  }


  virtual ~GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode() = default;
};
class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes : public Darabonba::Model {
public:
  shared_ptr<vector<GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode>> workflowNode{};

  GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes() {}

  explicit GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workflowNode) {
      vector<boost::any> temp1;
      for(auto item1:*workflowNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkflowNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkflowNode") != m.end() && !m["WorkflowNode"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkflowNode"].type()) {
        vector<GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkflowNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workflowNode = make_shared<vector<GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode>>(expect1);
      }
    }
  }


  virtual ~GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes() = default;
};
class GetApprovalDetailResponseBodyApprovalDetail : public Darabonba::Model {
public:
  shared_ptr<long> auditId{};
  shared_ptr<string> createTime{};
  shared_ptr<GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers> currentHandlers{};
  shared_ptr<string> description{};
  shared_ptr<long> orderId{};
  shared_ptr<string> orderType{};
  shared_ptr<GetApprovalDetailResponseBodyApprovalDetailReasonList> reasonList{};
  shared_ptr<long> templateId{};
  shared_ptr<string> title{};
  shared_ptr<string> workflowInsCode{};
  shared_ptr<GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes> workflowNodes{};

  GetApprovalDetailResponseBodyApprovalDetail() {}

  explicit GetApprovalDetailResponseBodyApprovalDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditId) {
      res["AuditId"] = boost::any(*auditId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (currentHandlers) {
      res["CurrentHandlers"] = currentHandlers ? boost::any(currentHandlers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (reasonList) {
      res["ReasonList"] = reasonList ? boost::any(reasonList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (workflowInsCode) {
      res["WorkflowInsCode"] = boost::any(*workflowInsCode);
    }
    if (workflowNodes) {
      res["WorkflowNodes"] = workflowNodes ? boost::any(workflowNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditId") != m.end() && !m["AuditId"].empty()) {
      auditId = make_shared<long>(boost::any_cast<long>(m["AuditId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CurrentHandlers") != m.end() && !m["CurrentHandlers"].empty()) {
      if (typeid(map<string, boost::any>) == m["CurrentHandlers"].type()) {
        GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CurrentHandlers"]));
        currentHandlers = make_shared<GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("ReasonList") != m.end() && !m["ReasonList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReasonList"].type()) {
        GetApprovalDetailResponseBodyApprovalDetailReasonList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReasonList"]));
        reasonList = make_shared<GetApprovalDetailResponseBodyApprovalDetailReasonList>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("WorkflowInsCode") != m.end() && !m["WorkflowInsCode"].empty()) {
      workflowInsCode = make_shared<string>(boost::any_cast<string>(m["WorkflowInsCode"]));
    }
    if (m.find("WorkflowNodes") != m.end() && !m["WorkflowNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkflowNodes"].type()) {
        GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkflowNodes"]));
        workflowNodes = make_shared<GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes>(model1);
      }
    }
  }


  virtual ~GetApprovalDetailResponseBodyApprovalDetail() = default;
};
class GetApprovalDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetApprovalDetailResponseBodyApprovalDetail> approvalDetail{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetApprovalDetailResponseBody() {}

  explicit GetApprovalDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalDetail) {
      res["ApprovalDetail"] = approvalDetail ? boost::any(approvalDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApprovalDetail") != m.end() && !m["ApprovalDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApprovalDetail"].type()) {
        GetApprovalDetailResponseBodyApprovalDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApprovalDetail"]));
        approvalDetail = make_shared<GetApprovalDetailResponseBodyApprovalDetail>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetApprovalDetailResponseBody() = default;
};
class GetApprovalDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApprovalDetailResponseBody> body{};

  GetApprovalDetailResponse() {}

  explicit GetApprovalDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApprovalDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApprovalDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetApprovalDetailResponse() = default;
};
class GetAuthorityTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> templateId{};
  shared_ptr<long> tid{};

  GetAuthorityTemplateRequest() {}

  explicit GetAuthorityTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetAuthorityTemplateRequest() = default;
};
class GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem : public Darabonba::Model {
public:
  shared_ptr<string> attribute{};
  shared_ptr<long> dbId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> itemId{};
  shared_ptr<long> modifierId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tableName{};
  shared_ptr<long> templateId{};

  GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem() {}

  explicit GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attribute) {
      res["Attribute"] = boost::any(*attribute);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attribute") != m.end() && !m["Attribute"].empty()) {
      attribute = make_shared<string>(boost::any_cast<string>(m["Attribute"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<long>(boost::any_cast<long>(m["ModifierId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem() = default;
};
class GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList : public Darabonba::Model {
public:
  shared_ptr<vector<GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem>> authorityTemplateItem{};

  GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList() {}

  explicit GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorityTemplateItem) {
      vector<boost::any> temp1;
      for(auto item1:*authorityTemplateItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorityTemplateItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorityTemplateItem") != m.end() && !m["AuthorityTemplateItem"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorityTemplateItem"].type()) {
        vector<GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorityTemplateItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorityTemplateItem = make_shared<vector<GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem>>(expect1);
      }
    }
  }


  virtual ~GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList() = default;
};
class GetAuthorityTemplateResponseBodyAuthorityTemplateView : public Darabonba::Model {
public:
  shared_ptr<GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList> authorityTemplateItemList{};
  shared_ptr<string> createTime{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> templateId{};

  GetAuthorityTemplateResponseBodyAuthorityTemplateView() {}

  explicit GetAuthorityTemplateResponseBodyAuthorityTemplateView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorityTemplateItemList) {
      res["AuthorityTemplateItemList"] = authorityTemplateItemList ? boost::any(authorityTemplateItemList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorityTemplateItemList") != m.end() && !m["AuthorityTemplateItemList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorityTemplateItemList"].type()) {
        GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorityTemplateItemList"]));
        authorityTemplateItemList = make_shared<GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~GetAuthorityTemplateResponseBodyAuthorityTemplateView() = default;
};
class GetAuthorityTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAuthorityTemplateResponseBodyAuthorityTemplateView> authorityTemplateView{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> tid{};

  GetAuthorityTemplateResponseBody() {}

  explicit GetAuthorityTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorityTemplateView) {
      res["AuthorityTemplateView"] = authorityTemplateView ? boost::any(authorityTemplateView->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorityTemplateView") != m.end() && !m["AuthorityTemplateView"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorityTemplateView"].type()) {
        GetAuthorityTemplateResponseBodyAuthorityTemplateView model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorityTemplateView"]));
        authorityTemplateView = make_shared<GetAuthorityTemplateResponseBodyAuthorityTemplateView>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetAuthorityTemplateResponseBody() = default;
};
class GetAuthorityTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAuthorityTemplateResponseBody> body{};

  GetAuthorityTemplateResponse() {}

  explicit GetAuthorityTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAuthorityTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAuthorityTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetAuthorityTemplateResponse() = default;
};
class GetAuthorityTemplateItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> templateId{};
  shared_ptr<long> tid{};

  GetAuthorityTemplateItemRequest() {}

  explicit GetAuthorityTemplateItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetAuthorityTemplateItemRequest() = default;
};
class GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem : public Darabonba::Model {
public:
  shared_ptr<string> attribute{};
  shared_ptr<long> dbId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> itemId{};
  shared_ptr<long> modifierId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tableName{};
  shared_ptr<long> templateId{};

  GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem() {}

  explicit GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attribute) {
      res["Attribute"] = boost::any(*attribute);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attribute") != m.end() && !m["Attribute"].empty()) {
      attribute = make_shared<string>(boost::any_cast<string>(m["Attribute"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<long>(boost::any_cast<long>(m["ModifierId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem() = default;
};
class GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList : public Darabonba::Model {
public:
  shared_ptr<vector<GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem>> authorityTemplateItem{};

  GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList() {}

  explicit GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorityTemplateItem) {
      vector<boost::any> temp1;
      for(auto item1:*authorityTemplateItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorityTemplateItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorityTemplateItem") != m.end() && !m["AuthorityTemplateItem"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorityTemplateItem"].type()) {
        vector<GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorityTemplateItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorityTemplateItem = make_shared<vector<GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem>>(expect1);
      }
    }
  }


  virtual ~GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList() = default;
};
class GetAuthorityTemplateItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList> authorityTemplateItemList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> tid{};

  GetAuthorityTemplateItemResponseBody() {}

  explicit GetAuthorityTemplateItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorityTemplateItemList) {
      res["AuthorityTemplateItemList"] = authorityTemplateItemList ? boost::any(authorityTemplateItemList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorityTemplateItemList") != m.end() && !m["AuthorityTemplateItemList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorityTemplateItemList"].type()) {
        GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorityTemplateItemList"]));
        authorityTemplateItemList = make_shared<GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetAuthorityTemplateItemResponseBody() = default;
};
class GetAuthorityTemplateItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAuthorityTemplateItemResponseBody> body{};

  GetAuthorityTemplateItemResponse() {}

  explicit GetAuthorityTemplateItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAuthorityTemplateItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAuthorityTemplateItemResponseBody>(model1);
      }
    }
  }


  virtual ~GetAuthorityTemplateItemResponse() = default;
};
class GetClassificationTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<long> tid{};

  GetClassificationTemplateRequest() {}

  explicit GetClassificationTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetClassificationTemplateRequest() = default;
};
class GetClassificationTemplateResponseBodyClassificationResourceTemplateMap : public Darabonba::Model {
public:
  shared_ptr<long> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateType{};

  GetClassificationTemplateResponseBodyClassificationResourceTemplateMap() {}

  explicit GetClassificationTemplateResponseBodyClassificationResourceTemplateMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<long>(boost::any_cast<long>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~GetClassificationTemplateResponseBodyClassificationResourceTemplateMap() = default;
};
class GetClassificationTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetClassificationTemplateResponseBodyClassificationResourceTemplateMap> classificationResourceTemplateMap{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetClassificationTemplateResponseBody() {}

  explicit GetClassificationTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classificationResourceTemplateMap) {
      res["ClassificationResourceTemplateMap"] = classificationResourceTemplateMap ? boost::any(classificationResourceTemplateMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassificationResourceTemplateMap") != m.end() && !m["ClassificationResourceTemplateMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClassificationResourceTemplateMap"].type()) {
        GetClassificationTemplateResponseBodyClassificationResourceTemplateMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClassificationResourceTemplateMap"]));
        classificationResourceTemplateMap = make_shared<GetClassificationTemplateResponseBodyClassificationResourceTemplateMap>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetClassificationTemplateResponseBody() = default;
};
class GetClassificationTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClassificationTemplateResponseBody> body{};

  GetClassificationTemplateResponse() {}

  explicit GetClassificationTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClassificationTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClassificationTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetClassificationTemplateResponse() = default;
};
class GetDBTaskSQLJobLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> jobId{};
  shared_ptr<long> tid{};

  GetDBTaskSQLJobLogRequest() {}

  explicit GetDBTaskSQLJobLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<long>(boost::any_cast<long>(m["JobId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDBTaskSQLJobLogRequest() = default;
};
class GetDBTaskSQLJobLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> log{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDBTaskSQLJobLogResponseBody() {}

  explicit GetDBTaskSQLJobLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (log) {
      res["Log"] = boost::any(*log);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      log = make_shared<string>(boost::any_cast<string>(m["Log"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDBTaskSQLJobLogResponseBody() = default;
};
class GetDBTaskSQLJobLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDBTaskSQLJobLogResponseBody> body{};

  GetDBTaskSQLJobLogResponse() {}

  explicit GetDBTaskSQLJobLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDBTaskSQLJobLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDBTaskSQLJobLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetDBTaskSQLJobLogResponse() = default;
};
class GetDBTopologyRequest : public Darabonba::Model {
public:
  shared_ptr<long> logicDbId{};
  shared_ptr<long> tid{};

  GetDBTopologyRequest() {}

  explicit GetDBTopologyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicDbId) {
      res["LogicDbId"] = boost::any(*logicDbId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicDbId") != m.end() && !m["LogicDbId"].empty()) {
      logicDbId = make_shared<long>(boost::any_cast<long>(m["LogicDbId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDBTopologyRequest() = default;
};
class GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList : public Darabonba::Model {
public:
  shared_ptr<string> catalogName{};
  shared_ptr<long> dbId{};
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceResourceId{};
  shared_ptr<string> instanceSource{};
  shared_ptr<string> regionId{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> searchName{};

  GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList() {}

  explicit GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (catalogName) {
      res["CatalogName"] = boost::any(*catalogName);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceResourceId) {
      res["InstanceResourceId"] = boost::any(*instanceResourceId);
    }
    if (instanceSource) {
      res["InstanceSource"] = boost::any(*instanceSource);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CatalogName") != m.end() && !m["CatalogName"].empty()) {
      catalogName = make_shared<string>(boost::any_cast<string>(m["CatalogName"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceResourceId") != m.end() && !m["InstanceResourceId"].empty()) {
      instanceResourceId = make_shared<string>(boost::any_cast<string>(m["InstanceResourceId"]));
    }
    if (m.find("InstanceSource") != m.end() && !m["InstanceSource"].empty()) {
      instanceSource = make_shared<string>(boost::any_cast<string>(m["InstanceSource"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList() = default;
};
class GetDBTopologyResponseBodyDBTopology : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<vector<GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList>> DBTopologyInfoList{};
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<long> logicDbId{};
  shared_ptr<string> logicDbName{};
  shared_ptr<string> searchName{};

  GetDBTopologyResponseBodyDBTopology() {}

  explicit GetDBTopologyResponseBodyDBTopology(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (DBTopologyInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*DBTopologyInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBTopologyInfoList"] = boost::any(temp1);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (logicDbId) {
      res["LogicDbId"] = boost::any(*logicDbId);
    }
    if (logicDbName) {
      res["LogicDbName"] = boost::any(*logicDbName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("DBTopologyInfoList") != m.end() && !m["DBTopologyInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["DBTopologyInfoList"].type()) {
        vector<GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBTopologyInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBTopologyInfoList = make_shared<vector<GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList>>(expect1);
      }
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("LogicDbId") != m.end() && !m["LogicDbId"].empty()) {
      logicDbId = make_shared<long>(boost::any_cast<long>(m["LogicDbId"]));
    }
    if (m.find("LogicDbName") != m.end() && !m["LogicDbName"].empty()) {
      logicDbName = make_shared<string>(boost::any_cast<string>(m["LogicDbName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~GetDBTopologyResponseBodyDBTopology() = default;
};
class GetDBTopologyResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDBTopologyResponseBodyDBTopology> DBTopology{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDBTopologyResponseBody() {}

  explicit GetDBTopologyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBTopology) {
      res["DBTopology"] = DBTopology ? boost::any(DBTopology->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBTopology") != m.end() && !m["DBTopology"].empty()) {
      if (typeid(map<string, boost::any>) == m["DBTopology"].type()) {
        GetDBTopologyResponseBodyDBTopology model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DBTopology"]));
        DBTopology = make_shared<GetDBTopologyResponseBodyDBTopology>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDBTopologyResponseBody() = default;
};
class GetDBTopologyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDBTopologyResponseBody> body{};

  GetDBTopologyResponse() {}

  explicit GetDBTopologyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDBTopologyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDBTopologyResponseBody>(model1);
      }
    }
  }


  virtual ~GetDBTopologyResponse() = default;
};
class GetDataArchiveCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderResultType{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> searchDateType{};
  shared_ptr<long> tid{};

  GetDataArchiveCountRequest() {}

  explicit GetDataArchiveCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderResultType) {
      res["OrderResultType"] = boost::any(*orderResultType);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (searchDateType) {
      res["SearchDateType"] = boost::any(*searchDateType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderResultType") != m.end() && !m["OrderResultType"].empty()) {
      orderResultType = make_shared<string>(boost::any_cast<string>(m["OrderResultType"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("SearchDateType") != m.end() && !m["SearchDateType"].empty()) {
      searchDateType = make_shared<string>(boost::any_cast<string>(m["SearchDateType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataArchiveCountRequest() = default;
};
class GetDataArchiveCountResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> failCount{};
  shared_ptr<long> processingCount{};
  shared_ptr<long> successCount{};
  shared_ptr<long> totalCount{};

  GetDataArchiveCountResponseBodyData() {}

  explicit GetDataArchiveCountResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (processingCount) {
      res["ProcessingCount"] = boost::any(*processingCount);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("ProcessingCount") != m.end() && !m["ProcessingCount"].empty()) {
      processingCount = make_shared<long>(boost::any_cast<long>(m["ProcessingCount"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetDataArchiveCountResponseBodyData() = default;
};
class GetDataArchiveCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataArchiveCountResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataArchiveCountResponseBody() {}

  explicit GetDataArchiveCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataArchiveCountResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataArchiveCountResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataArchiveCountResponseBody() = default;
};
class GetDataArchiveCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataArchiveCountResponseBody> body{};

  GetDataArchiveCountResponse() {}

  explicit GetDataArchiveCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataArchiveCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataArchiveCountResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataArchiveCountResponse() = default;
};
class GetDataArchiveOrderDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataArchiveOrderDetailRequest() {}

  explicit GetDataArchiveOrderDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataArchiveOrderDetailRequest() = default;
};
class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo : public Darabonba::Model {
public:
  shared_ptr<string> creatorId{};
  shared_ptr<string> cronBeginDate{};
  shared_ptr<string> cronEndDate{};
  shared_ptr<bool> cronTrigger{};
  shared_ptr<bool> DWDevelop{};
  shared_ptr<string> dagName{};
  shared_ptr<string> dagOwnerId{};
  shared_ptr<long> deployId{};
  shared_ptr<string> description{};
  shared_ptr<long> editDagId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> isPublic{};
  shared_ptr<bool> legacy{};
  shared_ptr<bool> system{};
  shared_ptr<string> tenantId{};
  shared_ptr<bool> triggerOnce{};

  GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo() {}

  explicit GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (cronBeginDate) {
      res["CronBeginDate"] = boost::any(*cronBeginDate);
    }
    if (cronEndDate) {
      res["CronEndDate"] = boost::any(*cronEndDate);
    }
    if (cronTrigger) {
      res["CronTrigger"] = boost::any(*cronTrigger);
    }
    if (DWDevelop) {
      res["DWDevelop"] = boost::any(*DWDevelop);
    }
    if (dagName) {
      res["DagName"] = boost::any(*dagName);
    }
    if (dagOwnerId) {
      res["DagOwnerId"] = boost::any(*dagOwnerId);
    }
    if (deployId) {
      res["DeployId"] = boost::any(*deployId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (editDagId) {
      res["EditDagId"] = boost::any(*editDagId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isPublic) {
      res["IsPublic"] = boost::any(*isPublic);
    }
    if (legacy) {
      res["Legacy"] = boost::any(*legacy);
    }
    if (system) {
      res["System"] = boost::any(*system);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (triggerOnce) {
      res["TriggerOnce"] = boost::any(*triggerOnce);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CronBeginDate") != m.end() && !m["CronBeginDate"].empty()) {
      cronBeginDate = make_shared<string>(boost::any_cast<string>(m["CronBeginDate"]));
    }
    if (m.find("CronEndDate") != m.end() && !m["CronEndDate"].empty()) {
      cronEndDate = make_shared<string>(boost::any_cast<string>(m["CronEndDate"]));
    }
    if (m.find("CronTrigger") != m.end() && !m["CronTrigger"].empty()) {
      cronTrigger = make_shared<bool>(boost::any_cast<bool>(m["CronTrigger"]));
    }
    if (m.find("DWDevelop") != m.end() && !m["DWDevelop"].empty()) {
      DWDevelop = make_shared<bool>(boost::any_cast<bool>(m["DWDevelop"]));
    }
    if (m.find("DagName") != m.end() && !m["DagName"].empty()) {
      dagName = make_shared<string>(boost::any_cast<string>(m["DagName"]));
    }
    if (m.find("DagOwnerId") != m.end() && !m["DagOwnerId"].empty()) {
      dagOwnerId = make_shared<string>(boost::any_cast<string>(m["DagOwnerId"]));
    }
    if (m.find("DeployId") != m.end() && !m["DeployId"].empty()) {
      deployId = make_shared<long>(boost::any_cast<long>(m["DeployId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EditDagId") != m.end() && !m["EditDagId"].empty()) {
      editDagId = make_shared<long>(boost::any_cast<long>(m["EditDagId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsPublic") != m.end() && !m["IsPublic"].empty()) {
      isPublic = make_shared<long>(boost::any_cast<long>(m["IsPublic"]));
    }
    if (m.find("Legacy") != m.end() && !m["Legacy"].empty()) {
      legacy = make_shared<bool>(boost::any_cast<bool>(m["Legacy"]));
    }
    if (m.find("System") != m.end() && !m["System"].empty()) {
      system = make_shared<bool>(boost::any_cast<bool>(m["System"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TriggerOnce") != m.end() && !m["TriggerOnce"].empty()) {
      triggerOnce = make_shared<bool>(boost::any_cast<bool>(m["TriggerOnce"]));
    }
  }


  virtual ~GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo() = default;
};
class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup : public Darabonba::Model {
public:
  shared_ptr<string> dbType{};
  shared_ptr<string> description{};
  shared_ptr<bool> freeOrStable{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> groupMode{};
  shared_ptr<string> groupName{};
  shared_ptr<long> id{};
  shared_ptr<long> lastMenderId{};

  GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup() {}

  explicit GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (freeOrStable) {
      res["FreeOrStable"] = boost::any(*freeOrStable);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groupMode) {
      res["GroupMode"] = boost::any(*groupMode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastMenderId) {
      res["LastMenderId"] = boost::any(*lastMenderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FreeOrStable") != m.end() && !m["FreeOrStable"].empty()) {
      freeOrStable = make_shared<bool>(boost::any_cast<bool>(m["FreeOrStable"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GroupMode") != m.end() && !m["GroupMode"].empty()) {
      groupMode = make_shared<string>(boost::any_cast<string>(m["GroupMode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastMenderId") != m.end() && !m["LastMenderId"].empty()) {
      lastMenderId = make_shared<long>(boost::any_cast<long>(m["LastMenderId"]));
    }
  }


  virtual ~GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup() = default;
};
class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<long> alterTimeout{};
  shared_ptr<bool> assetControl{};
  shared_ptr<string> catalogName{};
  shared_ptr<string> clusterNode{};
  shared_ptr<long> dbId{};
  shared_ptr<string> dbType{};
  shared_ptr<long> dbaId{};
  shared_ptr<string> dbaName{};
  shared_ptr<string> description{};
  shared_ptr<string> encoding{};
  shared_ptr<string> envType{};
  shared_ptr<bool> follow{};
  shared_ptr<string> host{};
  shared_ptr<string> idc{};
  shared_ptr<string> idcTitle{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceSource{};
  shared_ptr<string> lastSyncTime{};
  shared_ptr<string> level{};
  shared_ptr<bool> logic{};
  shared_ptr<vector<long>> ownerIds{};
  shared_ptr<vector<string>> ownerNames{};
  shared_ptr<long> port{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> searchName{};
  shared_ptr<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup> standardGroup{};
  shared_ptr<string> state{};
  shared_ptr<long> tableCount{};
  shared_ptr<string> tnsName{};
  shared_ptr<string> unitType{};

  GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo() {}

  explicit GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (alterTimeout) {
      res["AlterTimeout"] = boost::any(*alterTimeout);
    }
    if (assetControl) {
      res["AssetControl"] = boost::any(*assetControl);
    }
    if (catalogName) {
      res["CatalogName"] = boost::any(*catalogName);
    }
    if (clusterNode) {
      res["ClusterNode"] = boost::any(*clusterNode);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (dbaId) {
      res["DbaId"] = boost::any(*dbaId);
    }
    if (dbaName) {
      res["DbaName"] = boost::any(*dbaName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (follow) {
      res["Follow"] = boost::any(*follow);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (idc) {
      res["Idc"] = boost::any(*idc);
    }
    if (idcTitle) {
      res["IdcTitle"] = boost::any(*idcTitle);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceSource) {
      res["InstanceSource"] = boost::any(*instanceSource);
    }
    if (lastSyncTime) {
      res["LastSyncTime"] = boost::any(*lastSyncTime);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (standardGroup) {
      res["StandardGroup"] = standardGroup ? boost::any(standardGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tableCount) {
      res["TableCount"] = boost::any(*tableCount);
    }
    if (tnsName) {
      res["TnsName"] = boost::any(*tnsName);
    }
    if (unitType) {
      res["UnitType"] = boost::any(*unitType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("AlterTimeout") != m.end() && !m["AlterTimeout"].empty()) {
      alterTimeout = make_shared<long>(boost::any_cast<long>(m["AlterTimeout"]));
    }
    if (m.find("AssetControl") != m.end() && !m["AssetControl"].empty()) {
      assetControl = make_shared<bool>(boost::any_cast<bool>(m["AssetControl"]));
    }
    if (m.find("CatalogName") != m.end() && !m["CatalogName"].empty()) {
      catalogName = make_shared<string>(boost::any_cast<string>(m["CatalogName"]));
    }
    if (m.find("ClusterNode") != m.end() && !m["ClusterNode"].empty()) {
      clusterNode = make_shared<string>(boost::any_cast<string>(m["ClusterNode"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("DbaId") != m.end() && !m["DbaId"].empty()) {
      dbaId = make_shared<long>(boost::any_cast<long>(m["DbaId"]));
    }
    if (m.find("DbaName") != m.end() && !m["DbaName"].empty()) {
      dbaName = make_shared<string>(boost::any_cast<string>(m["DbaName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Follow") != m.end() && !m["Follow"].empty()) {
      follow = make_shared<bool>(boost::any_cast<bool>(m["Follow"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Idc") != m.end() && !m["Idc"].empty()) {
      idc = make_shared<string>(boost::any_cast<string>(m["Idc"]));
    }
    if (m.find("IdcTitle") != m.end() && !m["IdcTitle"].empty()) {
      idcTitle = make_shared<string>(boost::any_cast<string>(m["IdcTitle"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceSource") != m.end() && !m["InstanceSource"].empty()) {
      instanceSource = make_shared<string>(boost::any_cast<string>(m["InstanceSource"]));
    }
    if (m.find("LastSyncTime") != m.end() && !m["LastSyncTime"].empty()) {
      lastSyncTime = make_shared<string>(boost::any_cast<string>(m["LastSyncTime"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ownerIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("StandardGroup") != m.end() && !m["StandardGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["StandardGroup"].type()) {
        GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StandardGroup"]));
        standardGroup = make_shared<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TableCount") != m.end() && !m["TableCount"].empty()) {
      tableCount = make_shared<long>(boost::any_cast<long>(m["TableCount"]));
    }
    if (m.find("TnsName") != m.end() && !m["TnsName"].empty()) {
      tnsName = make_shared<string>(boost::any_cast<string>(m["TnsName"]));
    }
    if (m.find("UnitType") != m.end() && !m["UnitType"].empty()) {
      unitType = make_shared<string>(boost::any_cast<string>(m["UnitType"]));
    }
  }


  virtual ~GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo() = default;
};
class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances : public Darabonba::Model {
public:
  shared_ptr<string> businessTime{};
  shared_ptr<long> dagId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> historyDagId{};
  shared_ptr<long> id{};
  shared_ptr<string> lastRunningContext{};
  shared_ptr<string> msg{};
  shared_ptr<long> status{};
  shared_ptr<string> tenantId{};
  shared_ptr<long> triggerType{};
  shared_ptr<string> version{};

  GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances() {}

  explicit GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessTime) {
      res["BusinessTime"] = boost::any(*businessTime);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (historyDagId) {
      res["HistoryDagId"] = boost::any(*historyDagId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastRunningContext) {
      res["LastRunningContext"] = boost::any(*lastRunningContext);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessTime") != m.end() && !m["BusinessTime"].empty()) {
      businessTime = make_shared<string>(boost::any_cast<string>(m["BusinessTime"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HistoryDagId") != m.end() && !m["HistoryDagId"].empty()) {
      historyDagId = make_shared<long>(boost::any_cast<long>(m["HistoryDagId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastRunningContext") != m.end() && !m["LastRunningContext"].empty()) {
      lastRunningContext = make_shared<string>(boost::any_cast<string>(m["LastRunningContext"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<long>(boost::any_cast<long>(m["TriggerType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances() = default;
};
class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult : public Darabonba::Model {
public:
  shared_ptr<string> cronFireType{};

  GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult() {}

  explicit GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronFireType) {
      res["CronFireType"] = boost::any(*cronFireType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CronFireType") != m.end() && !m["CronFireType"].empty()) {
      cronFireType = make_shared<string>(boost::any_cast<string>(m["CronFireType"]));
    }
  }


  virtual ~GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult() = default;
};
class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData : public Darabonba::Model {
public:
  shared_ptr<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo> dagInfo{};
  shared_ptr<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo> dbBaseInfo{};
  shared_ptr<long> instanceTotal{};
  shared_ptr<vector<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances>> instances{};
  shared_ptr<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult> nextFireTimeResult{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<map<string, boost::any>> tempTableNameMap{};

  GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData() {}

  explicit GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagInfo) {
      res["DagInfo"] = dagInfo ? boost::any(dagInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dbBaseInfo) {
      res["DbBaseInfo"] = dbBaseInfo ? boost::any(dbBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceTotal) {
      res["InstanceTotal"] = boost::any(*instanceTotal);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (nextFireTimeResult) {
      res["NextFireTimeResult"] = nextFireTimeResult ? boost::any(nextFireTimeResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tempTableNameMap) {
      res["TempTableNameMap"] = boost::any(*tempTableNameMap);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagInfo") != m.end() && !m["DagInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DagInfo"].type()) {
        GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DagInfo"]));
        dagInfo = make_shared<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo>(model1);
      }
    }
    if (m.find("DbBaseInfo") != m.end() && !m["DbBaseInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DbBaseInfo"].type()) {
        GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DbBaseInfo"]));
        dbBaseInfo = make_shared<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo>(model1);
      }
    }
    if (m.find("InstanceTotal") != m.end() && !m["InstanceTotal"].empty()) {
      instanceTotal = make_shared<long>(boost::any_cast<long>(m["InstanceTotal"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances>>(expect1);
      }
    }
    if (m.find("NextFireTimeResult") != m.end() && !m["NextFireTimeResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["NextFireTimeResult"].type()) {
        GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NextFireTimeResult"]));
        nextFireTimeResult = make_shared<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult>(model1);
      }
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TempTableNameMap") != m.end() && !m["TempTableNameMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["TempTableNameMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tempTableNameMap = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData() = default;
};
class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> tableWhere{};

  GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes() {}

  explicit GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableWhere) {
      res["TableWhere"] = boost::any(*tableWhere);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableWhere") != m.end() && !m["TableWhere"].empty()) {
      tableWhere = make_shared<string>(boost::any_cast<string>(m["TableWhere"]));
    }
  }


  virtual ~GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes() = default;
};
class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam : public Darabonba::Model {
public:
  shared_ptr<string> archiveMethod{};
  shared_ptr<string> dbSchema{};
  shared_ptr<bool> logic{};
  shared_ptr<vector<string>> orderAfter{};
  shared_ptr<string> runMethod{};
  shared_ptr<long> sourceDatabaseId{};
  shared_ptr<vector<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes>> tableIncludes{};
  shared_ptr<vector<string>> tableMapping{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<vector<string>> variables{};

  GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam() {}

  explicit GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (archiveMethod) {
      res["ArchiveMethod"] = boost::any(*archiveMethod);
    }
    if (dbSchema) {
      res["DbSchema"] = boost::any(*dbSchema);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (orderAfter) {
      res["OrderAfter"] = boost::any(*orderAfter);
    }
    if (runMethod) {
      res["RunMethod"] = boost::any(*runMethod);
    }
    if (sourceDatabaseId) {
      res["SourceDatabaseId"] = boost::any(*sourceDatabaseId);
    }
    if (tableIncludes) {
      vector<boost::any> temp1;
      for(auto item1:*tableIncludes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableIncludes"] = boost::any(temp1);
    }
    if (tableMapping) {
      res["TableMapping"] = boost::any(*tableMapping);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (variables) {
      res["Variables"] = boost::any(*variables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArchiveMethod") != m.end() && !m["ArchiveMethod"].empty()) {
      archiveMethod = make_shared<string>(boost::any_cast<string>(m["ArchiveMethod"]));
    }
    if (m.find("DbSchema") != m.end() && !m["DbSchema"].empty()) {
      dbSchema = make_shared<string>(boost::any_cast<string>(m["DbSchema"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("OrderAfter") != m.end() && !m["OrderAfter"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderAfter"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderAfter"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderAfter = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RunMethod") != m.end() && !m["RunMethod"].empty()) {
      runMethod = make_shared<string>(boost::any_cast<string>(m["RunMethod"]));
    }
    if (m.find("SourceDatabaseId") != m.end() && !m["SourceDatabaseId"].empty()) {
      sourceDatabaseId = make_shared<long>(boost::any_cast<long>(m["SourceDatabaseId"]));
    }
    if (m.find("TableIncludes") != m.end() && !m["TableIncludes"].empty()) {
      if (typeid(vector<boost::any>) == m["TableIncludes"].type()) {
        vector<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableIncludes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableIncludes = make_shared<vector<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes>>(expect1);
      }
    }
    if (m.find("TableMapping") != m.end() && !m["TableMapping"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableMapping"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableMapping"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableMapping = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Variables"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      variables = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam() = default;
};
class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> committer{};
  shared_ptr<long> committerId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData> pluginExtraData{};
  shared_ptr<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam> pluginParam{};
  shared_ptr<string> pluginType{};
  shared_ptr<vector<long>> relatedUserList{};
  shared_ptr<vector<string>> relatedUserNickList{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> statusDesc{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowStatusDesc{};

  GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail() {}

  explicit GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (committer) {
      res["Committer"] = boost::any(*committer);
    }
    if (committerId) {
      res["CommitterId"] = boost::any(*committerId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pluginExtraData) {
      res["PluginExtraData"] = pluginExtraData ? boost::any(pluginExtraData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pluginParam) {
      res["PluginParam"] = pluginParam ? boost::any(pluginParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (relatedUserList) {
      res["RelatedUserList"] = boost::any(*relatedUserList);
    }
    if (relatedUserNickList) {
      res["RelatedUserNickList"] = boost::any(*relatedUserNickList);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowStatusDesc) {
      res["WorkflowStatusDesc"] = boost::any(*workflowStatusDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Committer") != m.end() && !m["Committer"].empty()) {
      committer = make_shared<string>(boost::any_cast<string>(m["Committer"]));
    }
    if (m.find("CommitterId") != m.end() && !m["CommitterId"].empty()) {
      committerId = make_shared<long>(boost::any_cast<long>(m["CommitterId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PluginExtraData") != m.end() && !m["PluginExtraData"].empty()) {
      if (typeid(map<string, boost::any>) == m["PluginExtraData"].type()) {
        GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PluginExtraData"]));
        pluginExtraData = make_shared<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData>(model1);
      }
    }
    if (m.find("PluginParam") != m.end() && !m["PluginParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["PluginParam"].type()) {
        GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PluginParam"]));
        pluginParam = make_shared<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam>(model1);
      }
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      relatedUserList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RelatedUserNickList") != m.end() && !m["RelatedUserNickList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelatedUserNickList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelatedUserNickList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relatedUserNickList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowStatusDesc") != m.end() && !m["WorkflowStatusDesc"].empty()) {
      workflowStatusDesc = make_shared<string>(boost::any_cast<string>(m["WorkflowStatusDesc"]));
    }
  }


  virtual ~GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail() = default;
};
class GetDataArchiveOrderDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail> dataArchiveOrderDetail{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  GetDataArchiveOrderDetailResponseBody() {}

  explicit GetDataArchiveOrderDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataArchiveOrderDetail) {
      res["DataArchiveOrderDetail"] = dataArchiveOrderDetail ? boost::any(dataArchiveOrderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataArchiveOrderDetail") != m.end() && !m["DataArchiveOrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataArchiveOrderDetail"].type()) {
        GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataArchiveOrderDetail"]));
        dataArchiveOrderDetail = make_shared<GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~GetDataArchiveOrderDetailResponseBody() = default;
};
class GetDataArchiveOrderDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataArchiveOrderDetailResponseBody> body{};

  GetDataArchiveOrderDetailResponse() {}

  explicit GetDataArchiveOrderDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataArchiveOrderDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataArchiveOrderDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataArchiveOrderDetailResponse() = default;
};
class GetDataCorrectBackupFilesRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> actionDetail{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataCorrectBackupFilesRequest() {}

  explicit GetDataCorrectBackupFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionDetail) {
      res["ActionDetail"] = boost::any(*actionDetail);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionDetail") != m.end() && !m["ActionDetail"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ActionDetail"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      actionDetail = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataCorrectBackupFilesRequest() = default;
};
class GetDataCorrectBackupFilesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionDetailShrink{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataCorrectBackupFilesShrinkRequest() {}

  explicit GetDataCorrectBackupFilesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionDetailShrink) {
      res["ActionDetail"] = boost::any(*actionDetailShrink);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionDetail") != m.end() && !m["ActionDetail"].empty()) {
      actionDetailShrink = make_shared<string>(boost::any_cast<string>(m["ActionDetail"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataCorrectBackupFilesShrinkRequest() = default;
};
class GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fileUrl{};

  GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles() {}

  explicit GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileUrl = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles() = default;
};
class GetDataCorrectBackupFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles> dataCorrectBackupFiles{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataCorrectBackupFilesResponseBody() {}

  explicit GetDataCorrectBackupFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataCorrectBackupFiles) {
      res["DataCorrectBackupFiles"] = dataCorrectBackupFiles ? boost::any(dataCorrectBackupFiles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataCorrectBackupFiles") != m.end() && !m["DataCorrectBackupFiles"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataCorrectBackupFiles"].type()) {
        GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataCorrectBackupFiles"]));
        dataCorrectBackupFiles = make_shared<GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataCorrectBackupFilesResponseBody() = default;
};
class GetDataCorrectBackupFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataCorrectBackupFilesResponseBody> body{};

  GetDataCorrectBackupFilesResponse() {}

  explicit GetDataCorrectBackupFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataCorrectBackupFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataCorrectBackupFilesResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataCorrectBackupFilesResponse() = default;
};
class GetDataCorrectOrderDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataCorrectOrderDetailRequest() {}

  explicit GetDataCorrectOrderDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataCorrectOrderDetailRequest() = default;
};
class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<bool> logic{};
  shared_ptr<string> searchName{};

  GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase() {}

  explicit GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase() = default;
};
class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase>> database{};

  GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList() {}

  explicit GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      vector<boost::any> temp1;
      for(auto item1:*database){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Database"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      if (typeid(vector<boost::any>) == m["Database"].type()) {
        vector<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Database"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        database = make_shared<vector<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase>>(expect1);
      }
    }
  }


  virtual ~GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList() = default;
};
class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail : public Darabonba::Model {
public:
  shared_ptr<long> actualAffectRows{};
  shared_ptr<string> attachmentName{};
  shared_ptr<string> classify{};
  shared_ptr<long> estimateAffectRows{};
  shared_ptr<string> exeSQL{};
  shared_ptr<bool> ignoreAffectRows{};
  shared_ptr<string> ignoreAffectRowsReason{};
  shared_ptr<string> rbAttachmentName{};
  shared_ptr<string> rbSQL{};
  shared_ptr<string> rbSQLType{};
  shared_ptr<string> sqlType{};

  GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail() {}

  explicit GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualAffectRows) {
      res["ActualAffectRows"] = boost::any(*actualAffectRows);
    }
    if (attachmentName) {
      res["AttachmentName"] = boost::any(*attachmentName);
    }
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (estimateAffectRows) {
      res["EstimateAffectRows"] = boost::any(*estimateAffectRows);
    }
    if (exeSQL) {
      res["ExeSQL"] = boost::any(*exeSQL);
    }
    if (ignoreAffectRows) {
      res["IgnoreAffectRows"] = boost::any(*ignoreAffectRows);
    }
    if (ignoreAffectRowsReason) {
      res["IgnoreAffectRowsReason"] = boost::any(*ignoreAffectRowsReason);
    }
    if (rbAttachmentName) {
      res["RbAttachmentName"] = boost::any(*rbAttachmentName);
    }
    if (rbSQL) {
      res["RbSQL"] = boost::any(*rbSQL);
    }
    if (rbSQLType) {
      res["RbSQLType"] = boost::any(*rbSQLType);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualAffectRows") != m.end() && !m["ActualAffectRows"].empty()) {
      actualAffectRows = make_shared<long>(boost::any_cast<long>(m["ActualAffectRows"]));
    }
    if (m.find("AttachmentName") != m.end() && !m["AttachmentName"].empty()) {
      attachmentName = make_shared<string>(boost::any_cast<string>(m["AttachmentName"]));
    }
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("EstimateAffectRows") != m.end() && !m["EstimateAffectRows"].empty()) {
      estimateAffectRows = make_shared<long>(boost::any_cast<long>(m["EstimateAffectRows"]));
    }
    if (m.find("ExeSQL") != m.end() && !m["ExeSQL"].empty()) {
      exeSQL = make_shared<string>(boost::any_cast<string>(m["ExeSQL"]));
    }
    if (m.find("IgnoreAffectRows") != m.end() && !m["IgnoreAffectRows"].empty()) {
      ignoreAffectRows = make_shared<bool>(boost::any_cast<bool>(m["IgnoreAffectRows"]));
    }
    if (m.find("IgnoreAffectRowsReason") != m.end() && !m["IgnoreAffectRowsReason"].empty()) {
      ignoreAffectRowsReason = make_shared<string>(boost::any_cast<string>(m["IgnoreAffectRowsReason"]));
    }
    if (m.find("RbAttachmentName") != m.end() && !m["RbAttachmentName"].empty()) {
      rbAttachmentName = make_shared<string>(boost::any_cast<string>(m["RbAttachmentName"]));
    }
    if (m.find("RbSQL") != m.end() && !m["RbSQL"].empty()) {
      rbSQL = make_shared<string>(boost::any_cast<string>(m["RbSQL"]));
    }
    if (m.find("RbSQLType") != m.end() && !m["RbSQLType"].empty()) {
      rbSQLType = make_shared<string>(boost::any_cast<string>(m["RbSQLType"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
  }


  virtual ~GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail() = default;
};
class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO : public Darabonba::Model {
public:
  shared_ptr<string> checkStatus{};
  shared_ptr<string> checkStep{};
  shared_ptr<string> userTip{};

  GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO() {}

  explicit GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStatus) {
      res["CheckStatus"] = boost::any(*checkStatus);
    }
    if (checkStep) {
      res["CheckStep"] = boost::any(*checkStep);
    }
    if (userTip) {
      res["UserTip"] = boost::any(*userTip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckStatus") != m.end() && !m["CheckStatus"].empty()) {
      checkStatus = make_shared<string>(boost::any_cast<string>(m["CheckStatus"]));
    }
    if (m.find("CheckStep") != m.end() && !m["CheckStep"].empty()) {
      checkStep = make_shared<string>(boost::any_cast<string>(m["CheckStep"]));
    }
    if (m.find("UserTip") != m.end() && !m["UserTip"].empty()) {
      userTip = make_shared<string>(boost::any_cast<string>(m["UserTip"]));
    }
  }


  virtual ~GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO() = default;
};
class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO>> taskCheckDO{};

  GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail() {}

  explicit GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskCheckDO) {
      vector<boost::any> temp1;
      for(auto item1:*taskCheckDO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskCheckDO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskCheckDO") != m.end() && !m["TaskCheckDO"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskCheckDO"].type()) {
        vector<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskCheckDO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskCheckDO = make_shared<vector<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO>>(expect1);
      }
    }
  }


  virtual ~GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail() = default;
};
class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail : public Darabonba::Model {
public:
  shared_ptr<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList> databaseList{};
  shared_ptr<string> execMode{};
  shared_ptr<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail> orderDetail{};
  shared_ptr<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail> preCheckDetail{};
  shared_ptr<string> status{};

  GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail() {}

  explicit GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseList) {
      res["DatabaseList"] = databaseList ? boost::any(databaseList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (execMode) {
      res["ExecMode"] = boost::any(*execMode);
    }
    if (orderDetail) {
      res["OrderDetail"] = orderDetail ? boost::any(orderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (preCheckDetail) {
      res["PreCheckDetail"] = preCheckDetail ? boost::any(preCheckDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseList") != m.end() && !m["DatabaseList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatabaseList"].type()) {
        GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatabaseList"]));
        databaseList = make_shared<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList>(model1);
      }
    }
    if (m.find("ExecMode") != m.end() && !m["ExecMode"].empty()) {
      execMode = make_shared<string>(boost::any_cast<string>(m["ExecMode"]));
    }
    if (m.find("OrderDetail") != m.end() && !m["OrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderDetail"].type()) {
        GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderDetail"]));
        orderDetail = make_shared<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail>(model1);
      }
    }
    if (m.find("PreCheckDetail") != m.end() && !m["PreCheckDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["PreCheckDetail"].type()) {
        GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PreCheckDetail"]));
        preCheckDetail = make_shared<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail() = default;
};
class GetDataCorrectOrderDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail> dataCorrectOrderDetail{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataCorrectOrderDetailResponseBody() {}

  explicit GetDataCorrectOrderDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataCorrectOrderDetail) {
      res["DataCorrectOrderDetail"] = dataCorrectOrderDetail ? boost::any(dataCorrectOrderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataCorrectOrderDetail") != m.end() && !m["DataCorrectOrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataCorrectOrderDetail"].type()) {
        GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataCorrectOrderDetail"]));
        dataCorrectOrderDetail = make_shared<GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataCorrectOrderDetailResponseBody() = default;
};
class GetDataCorrectOrderDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataCorrectOrderDetailResponseBody> body{};

  GetDataCorrectOrderDetailResponse() {}

  explicit GetDataCorrectOrderDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataCorrectOrderDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataCorrectOrderDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataCorrectOrderDetailResponse() = default;
};
class GetDataCorrectRollbackFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataCorrectRollbackFileRequest() {}

  explicit GetDataCorrectRollbackFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataCorrectRollbackFileRequest() = default;
};
class GetDataCorrectRollbackFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataCorrectRollbackFileResponseBody() {}

  explicit GetDataCorrectRollbackFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataCorrectRollbackFileResponseBody() = default;
};
class GetDataCorrectRollbackFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataCorrectRollbackFileResponseBody> body{};

  GetDataCorrectRollbackFileResponse() {}

  explicit GetDataCorrectRollbackFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataCorrectRollbackFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataCorrectRollbackFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataCorrectRollbackFileResponse() = default;
};
class GetDataCorrectSQLFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataCorrectSQLFileRequest() {}

  explicit GetDataCorrectSQLFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataCorrectSQLFileRequest() = default;
};
class GetDataCorrectSQLFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataCorrectSQLFileResponseBody() {}

  explicit GetDataCorrectSQLFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataCorrectSQLFileResponseBody() = default;
};
class GetDataCorrectSQLFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataCorrectSQLFileResponseBody> body{};

  GetDataCorrectSQLFileResponse() {}

  explicit GetDataCorrectSQLFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataCorrectSQLFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataCorrectSQLFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataCorrectSQLFileResponse() = default;
};
class GetDataCorrectTaskDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataCorrectTaskDetailRequest() {}

  explicit GetDataCorrectTaskDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataCorrectTaskDetailRequest() = default;
};
class GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail : public Darabonba::Model {
public:
  shared_ptr<long> actualAffectRows{};
  shared_ptr<string> createTime{};
  shared_ptr<long> DBTaskGroupId{};
  shared_ptr<string> jobStatus{};

  GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail() {}

  explicit GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualAffectRows) {
      res["ActualAffectRows"] = boost::any(*actualAffectRows);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (DBTaskGroupId) {
      res["DBTaskGroupId"] = boost::any(*DBTaskGroupId);
    }
    if (jobStatus) {
      res["jobStatus"] = boost::any(*jobStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualAffectRows") != m.end() && !m["ActualAffectRows"].empty()) {
      actualAffectRows = make_shared<long>(boost::any_cast<long>(m["ActualAffectRows"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DBTaskGroupId") != m.end() && !m["DBTaskGroupId"].empty()) {
      DBTaskGroupId = make_shared<long>(boost::any_cast<long>(m["DBTaskGroupId"]));
    }
    if (m.find("jobStatus") != m.end() && !m["jobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["jobStatus"]));
    }
  }


  virtual ~GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail() = default;
};
class GetDataCorrectTaskDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail> dataCorrectTaskDetail{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataCorrectTaskDetailResponseBody() {}

  explicit GetDataCorrectTaskDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataCorrectTaskDetail) {
      res["DataCorrectTaskDetail"] = dataCorrectTaskDetail ? boost::any(dataCorrectTaskDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataCorrectTaskDetail") != m.end() && !m["DataCorrectTaskDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataCorrectTaskDetail"].type()) {
        GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataCorrectTaskDetail"]));
        dataCorrectTaskDetail = make_shared<GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataCorrectTaskDetailResponseBody() = default;
};
class GetDataCorrectTaskDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataCorrectTaskDetailResponseBody> body{};

  GetDataCorrectTaskDetailResponse() {}

  explicit GetDataCorrectTaskDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataCorrectTaskDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataCorrectTaskDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataCorrectTaskDetailResponse() = default;
};
class GetDataCronClearConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataCronClearConfigRequest() {}

  explicit GetDataCronClearConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataCronClearConfigRequest() = default;
};
class GetDataCronClearConfigResponseBodyDataCronClearConfig : public Darabonba::Model {
public:
  shared_ptr<string> cronCallTimes{};
  shared_ptr<string> cronFormat{};
  shared_ptr<string> cronLastCallStartTime{};
  shared_ptr<string> cronNextCallTime{};
  shared_ptr<string> cronStatus{};
  shared_ptr<long> currentClearTaskCount{};
  shared_ptr<string> duration{};
  shared_ptr<long> optimizeTableAfterEveryClearTimes{};

  GetDataCronClearConfigResponseBodyDataCronClearConfig() {}

  explicit GetDataCronClearConfigResponseBodyDataCronClearConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronCallTimes) {
      res["CronCallTimes"] = boost::any(*cronCallTimes);
    }
    if (cronFormat) {
      res["CronFormat"] = boost::any(*cronFormat);
    }
    if (cronLastCallStartTime) {
      res["CronLastCallStartTime"] = boost::any(*cronLastCallStartTime);
    }
    if (cronNextCallTime) {
      res["CronNextCallTime"] = boost::any(*cronNextCallTime);
    }
    if (cronStatus) {
      res["CronStatus"] = boost::any(*cronStatus);
    }
    if (currentClearTaskCount) {
      res["CurrentClearTaskCount"] = boost::any(*currentClearTaskCount);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (optimizeTableAfterEveryClearTimes) {
      res["OptimizeTableAfterEveryClearTimes"] = boost::any(*optimizeTableAfterEveryClearTimes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CronCallTimes") != m.end() && !m["CronCallTimes"].empty()) {
      cronCallTimes = make_shared<string>(boost::any_cast<string>(m["CronCallTimes"]));
    }
    if (m.find("CronFormat") != m.end() && !m["CronFormat"].empty()) {
      cronFormat = make_shared<string>(boost::any_cast<string>(m["CronFormat"]));
    }
    if (m.find("CronLastCallStartTime") != m.end() && !m["CronLastCallStartTime"].empty()) {
      cronLastCallStartTime = make_shared<string>(boost::any_cast<string>(m["CronLastCallStartTime"]));
    }
    if (m.find("CronNextCallTime") != m.end() && !m["CronNextCallTime"].empty()) {
      cronNextCallTime = make_shared<string>(boost::any_cast<string>(m["CronNextCallTime"]));
    }
    if (m.find("CronStatus") != m.end() && !m["CronStatus"].empty()) {
      cronStatus = make_shared<string>(boost::any_cast<string>(m["CronStatus"]));
    }
    if (m.find("CurrentClearTaskCount") != m.end() && !m["CurrentClearTaskCount"].empty()) {
      currentClearTaskCount = make_shared<long>(boost::any_cast<long>(m["CurrentClearTaskCount"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("OptimizeTableAfterEveryClearTimes") != m.end() && !m["OptimizeTableAfterEveryClearTimes"].empty()) {
      optimizeTableAfterEveryClearTimes = make_shared<long>(boost::any_cast<long>(m["OptimizeTableAfterEveryClearTimes"]));
    }
  }


  virtual ~GetDataCronClearConfigResponseBodyDataCronClearConfig() = default;
};
class GetDataCronClearConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataCronClearConfigResponseBodyDataCronClearConfig> dataCronClearConfig{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataCronClearConfigResponseBody() {}

  explicit GetDataCronClearConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataCronClearConfig) {
      res["DataCronClearConfig"] = dataCronClearConfig ? boost::any(dataCronClearConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataCronClearConfig") != m.end() && !m["DataCronClearConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataCronClearConfig"].type()) {
        GetDataCronClearConfigResponseBodyDataCronClearConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataCronClearConfig"]));
        dataCronClearConfig = make_shared<GetDataCronClearConfigResponseBodyDataCronClearConfig>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataCronClearConfigResponseBody() = default;
};
class GetDataCronClearConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataCronClearConfigResponseBody> body{};

  GetDataCronClearConfigResponse() {}

  explicit GetDataCronClearConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataCronClearConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataCronClearConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataCronClearConfigResponse() = default;
};
class GetDataCronClearTaskDetailListRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tid{};

  GetDataCronClearTaskDetailListRequest() {}

  explicit GetDataCronClearTaskDetailListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataCronClearTaskDetailListRequest() = default;
};
class GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList : public Darabonba::Model {
public:
  shared_ptr<long> actualAffectRows{};
  shared_ptr<string> createTime{};
  shared_ptr<long> DBTaskGroupId{};
  shared_ptr<string> jobStatus{};

  GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList() {}

  explicit GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualAffectRows) {
      res["ActualAffectRows"] = boost::any(*actualAffectRows);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (DBTaskGroupId) {
      res["DBTaskGroupId"] = boost::any(*DBTaskGroupId);
    }
    if (jobStatus) {
      res["jobStatus"] = boost::any(*jobStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualAffectRows") != m.end() && !m["ActualAffectRows"].empty()) {
      actualAffectRows = make_shared<long>(boost::any_cast<long>(m["ActualAffectRows"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DBTaskGroupId") != m.end() && !m["DBTaskGroupId"].empty()) {
      DBTaskGroupId = make_shared<long>(boost::any_cast<long>(m["DBTaskGroupId"]));
    }
    if (m.find("jobStatus") != m.end() && !m["jobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["jobStatus"]));
    }
  }


  virtual ~GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList() = default;
};
class GetDataCronClearTaskDetailListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList>> dataCronClearTaskDetailList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  GetDataCronClearTaskDetailListResponseBody() {}

  explicit GetDataCronClearTaskDetailListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataCronClearTaskDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*dataCronClearTaskDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataCronClearTaskDetailList"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataCronClearTaskDetailList") != m.end() && !m["DataCronClearTaskDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataCronClearTaskDetailList"].type()) {
        vector<GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataCronClearTaskDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataCronClearTaskDetailList = make_shared<vector<GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetDataCronClearTaskDetailListResponseBody() = default;
};
class GetDataCronClearTaskDetailListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataCronClearTaskDetailListResponseBody> body{};

  GetDataCronClearTaskDetailListResponse() {}

  explicit GetDataCronClearTaskDetailListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataCronClearTaskDetailListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataCronClearTaskDetailListResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataCronClearTaskDetailListResponse() = default;
};
class GetDataExportDownloadURLRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataExportDownloadURLRequest() {}

  explicit GetDataExportDownloadURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataExportDownloadURLRequest() = default;
};
class GetDataExportDownloadURLResponseBodyDownloadURLResult : public Darabonba::Model {
public:
  shared_ptr<bool> hasResult{};
  shared_ptr<string> tipMessage{};
  shared_ptr<string> URL{};

  GetDataExportDownloadURLResponseBodyDownloadURLResult() {}

  explicit GetDataExportDownloadURLResponseBodyDownloadURLResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasResult) {
      res["HasResult"] = boost::any(*hasResult);
    }
    if (tipMessage) {
      res["TipMessage"] = boost::any(*tipMessage);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasResult") != m.end() && !m["HasResult"].empty()) {
      hasResult = make_shared<bool>(boost::any_cast<bool>(m["HasResult"]));
    }
    if (m.find("TipMessage") != m.end() && !m["TipMessage"].empty()) {
      tipMessage = make_shared<string>(boost::any_cast<string>(m["TipMessage"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~GetDataExportDownloadURLResponseBodyDownloadURLResult() = default;
};
class GetDataExportDownloadURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataExportDownloadURLResponseBodyDownloadURLResult> downloadURLResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataExportDownloadURLResponseBody() {}

  explicit GetDataExportDownloadURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadURLResult) {
      res["DownloadURLResult"] = downloadURLResult ? boost::any(downloadURLResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadURLResult") != m.end() && !m["DownloadURLResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadURLResult"].type()) {
        GetDataExportDownloadURLResponseBodyDownloadURLResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadURLResult"]));
        downloadURLResult = make_shared<GetDataExportDownloadURLResponseBodyDownloadURLResult>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataExportDownloadURLResponseBody() = default;
};
class GetDataExportDownloadURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataExportDownloadURLResponseBody> body{};

  GetDataExportDownloadURLResponse() {}

  explicit GetDataExportDownloadURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataExportDownloadURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataExportDownloadURLResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataExportDownloadURLResponse() = default;
};
class GetDataExportOrderDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataExportOrderDetailRequest() {}

  explicit GetDataExportOrderDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataExportOrderDetailRequest() = default;
};
class GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo : public Darabonba::Model {
public:
  shared_ptr<string> jobStatus{};
  shared_ptr<long> preCheckId{};

  GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo() {}

  explicit GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (preCheckId) {
      res["PreCheckId"] = boost::any(*preCheckId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("PreCheckId") != m.end() && !m["PreCheckId"].empty()) {
      preCheckId = make_shared<long>(boost::any_cast<long>(m["PreCheckId"]));
    }
  }


  virtual ~GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo() = default;
};
class GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail : public Darabonba::Model {
public:
  shared_ptr<long> actualAffectRows{};
  shared_ptr<string> classify{};
  shared_ptr<string> database{};
  shared_ptr<long> dbId{};
  shared_ptr<string> envType{};
  shared_ptr<string> exeSQL{};
  shared_ptr<bool> ignoreAffectRows{};
  shared_ptr<string> ignoreAffectRowsReason{};
  shared_ptr<bool> logic{};

  GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail() {}

  explicit GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualAffectRows) {
      res["ActualAffectRows"] = boost::any(*actualAffectRows);
    }
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (exeSQL) {
      res["ExeSQL"] = boost::any(*exeSQL);
    }
    if (ignoreAffectRows) {
      res["IgnoreAffectRows"] = boost::any(*ignoreAffectRows);
    }
    if (ignoreAffectRowsReason) {
      res["IgnoreAffectRowsReason"] = boost::any(*ignoreAffectRowsReason);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualAffectRows") != m.end() && !m["ActualAffectRows"].empty()) {
      actualAffectRows = make_shared<long>(boost::any_cast<long>(m["ActualAffectRows"]));
    }
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ExeSQL") != m.end() && !m["ExeSQL"].empty()) {
      exeSQL = make_shared<string>(boost::any_cast<string>(m["ExeSQL"]));
    }
    if (m.find("IgnoreAffectRows") != m.end() && !m["IgnoreAffectRows"].empty()) {
      ignoreAffectRows = make_shared<bool>(boost::any_cast<bool>(m["IgnoreAffectRows"]));
    }
    if (m.find("IgnoreAffectRowsReason") != m.end() && !m["IgnoreAffectRowsReason"].empty()) {
      ignoreAffectRowsReason = make_shared<string>(boost::any_cast<string>(m["IgnoreAffectRowsReason"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
  }


  virtual ~GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail() = default;
};
class GetDataExportOrderDetailResponseBodyDataExportOrderDetail : public Darabonba::Model {
public:
  shared_ptr<GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo> keyInfo{};
  shared_ptr<GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail> orderDetail{};

  GetDataExportOrderDetailResponseBodyDataExportOrderDetail() {}

  explicit GetDataExportOrderDetailResponseBodyDataExportOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyInfo) {
      res["KeyInfo"] = keyInfo ? boost::any(keyInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderDetail) {
      res["OrderDetail"] = orderDetail ? boost::any(orderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyInfo") != m.end() && !m["KeyInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeyInfo"].type()) {
        GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeyInfo"]));
        keyInfo = make_shared<GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo>(model1);
      }
    }
    if (m.find("OrderDetail") != m.end() && !m["OrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderDetail"].type()) {
        GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderDetail"]));
        orderDetail = make_shared<GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail>(model1);
      }
    }
  }


  virtual ~GetDataExportOrderDetailResponseBodyDataExportOrderDetail() = default;
};
class GetDataExportOrderDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataExportOrderDetailResponseBodyDataExportOrderDetail> dataExportOrderDetail{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataExportOrderDetailResponseBody() {}

  explicit GetDataExportOrderDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataExportOrderDetail) {
      res["DataExportOrderDetail"] = dataExportOrderDetail ? boost::any(dataExportOrderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataExportOrderDetail") != m.end() && !m["DataExportOrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataExportOrderDetail"].type()) {
        GetDataExportOrderDetailResponseBodyDataExportOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataExportOrderDetail"]));
        dataExportOrderDetail = make_shared<GetDataExportOrderDetailResponseBodyDataExportOrderDetail>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataExportOrderDetailResponseBody() = default;
};
class GetDataExportOrderDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataExportOrderDetailResponseBody> body{};

  GetDataExportOrderDetailResponse() {}

  explicit GetDataExportOrderDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataExportOrderDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataExportOrderDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataExportOrderDetailResponse() = default;
};
class GetDataExportPreCheckDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataExportPreCheckDetailRequest() {}

  explicit GetDataExportPreCheckDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataExportPreCheckDetailRequest() = default;
};
class GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList : public Darabonba::Model {
public:
  shared_ptr<long> affectRows{};
  shared_ptr<string> SQL{};

  GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList() {}

  explicit GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectRows) {
      res["AffectRows"] = boost::any(*affectRows);
    }
    if (SQL) {
      res["SQL"] = boost::any(*SQL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectRows") != m.end() && !m["AffectRows"].empty()) {
      affectRows = make_shared<long>(boost::any_cast<long>(m["AffectRows"]));
    }
    if (m.find("SQL") != m.end() && !m["SQL"].empty()) {
      SQL = make_shared<string>(boost::any_cast<string>(m["SQL"]));
    }
  }


  virtual ~GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList() = default;
};
class GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList>> preCheckDetailList{};

  GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList() {}

  explicit GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preCheckDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*preCheckDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PreCheckDetailList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreCheckDetailList") != m.end() && !m["PreCheckDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["PreCheckDetailList"].type()) {
        vector<GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PreCheckDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preCheckDetailList = make_shared<vector<GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList>>(expect1);
      }
    }
  }


  virtual ~GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList() = default;
};
class GetDataExportPreCheckDetailResponseBodyPreCheckResult : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreAffectRows{};
  shared_ptr<GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList> preCheckDetailList{};

  GetDataExportPreCheckDetailResponseBodyPreCheckResult() {}

  explicit GetDataExportPreCheckDetailResponseBodyPreCheckResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreAffectRows) {
      res["IgnoreAffectRows"] = boost::any(*ignoreAffectRows);
    }
    if (preCheckDetailList) {
      res["PreCheckDetailList"] = preCheckDetailList ? boost::any(preCheckDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreAffectRows") != m.end() && !m["IgnoreAffectRows"].empty()) {
      ignoreAffectRows = make_shared<bool>(boost::any_cast<bool>(m["IgnoreAffectRows"]));
    }
    if (m.find("PreCheckDetailList") != m.end() && !m["PreCheckDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PreCheckDetailList"].type()) {
        GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PreCheckDetailList"]));
        preCheckDetailList = make_shared<GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList>(model1);
      }
    }
  }


  virtual ~GetDataExportPreCheckDetailResponseBodyPreCheckResult() = default;
};
class GetDataExportPreCheckDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetDataExportPreCheckDetailResponseBodyPreCheckResult> preCheckResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataExportPreCheckDetailResponseBody() {}

  explicit GetDataExportPreCheckDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (preCheckResult) {
      res["PreCheckResult"] = preCheckResult ? boost::any(preCheckResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PreCheckResult") != m.end() && !m["PreCheckResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PreCheckResult"].type()) {
        GetDataExportPreCheckDetailResponseBodyPreCheckResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PreCheckResult"]));
        preCheckResult = make_shared<GetDataExportPreCheckDetailResponseBodyPreCheckResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataExportPreCheckDetailResponseBody() = default;
};
class GetDataExportPreCheckDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataExportPreCheckDetailResponseBody> body{};

  GetDataExportPreCheckDetailResponse() {}

  explicit GetDataExportPreCheckDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataExportPreCheckDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataExportPreCheckDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataExportPreCheckDetailResponse() = default;
};
class GetDataImportSQLRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> sqlId{};
  shared_ptr<long> tid{};

  GetDataImportSQLRequest() {}

  explicit GetDataImportSQLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<long>(boost::any_cast<long>(m["SqlId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataImportSQLRequest() = default;
};
class GetDataImportSQLResponseBodySQLDetail : public Darabonba::Model {
public:
  shared_ptr<string> execSql{};

  GetDataImportSQLResponseBodySQLDetail() {}

  explicit GetDataImportSQLResponseBodySQLDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (execSql) {
      res["ExecSql"] = boost::any(*execSql);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecSql") != m.end() && !m["ExecSql"].empty()) {
      execSql = make_shared<string>(boost::any_cast<string>(m["ExecSql"]));
    }
  }


  virtual ~GetDataImportSQLResponseBodySQLDetail() = default;
};
class GetDataImportSQLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetDataImportSQLResponseBodySQLDetail> SQLDetail{};
  shared_ptr<bool> success{};

  GetDataImportSQLResponseBody() {}

  explicit GetDataImportSQLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (SQLDetail) {
      res["SQLDetail"] = SQLDetail ? boost::any(SQLDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SQLDetail") != m.end() && !m["SQLDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["SQLDetail"].type()) {
        GetDataImportSQLResponseBodySQLDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SQLDetail"]));
        SQLDetail = make_shared<GetDataImportSQLResponseBodySQLDetail>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataImportSQLResponseBody() = default;
};
class GetDataImportSQLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataImportSQLResponseBody> body{};

  GetDataImportSQLResponse() {}

  explicit GetDataImportSQLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataImportSQLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataImportSQLResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataImportSQLResponse() = default;
};
class GetDataTrackJobDegreeRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataTrackJobDegreeRequest() {}

  explicit GetDataTrackJobDegreeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataTrackJobDegreeRequest() = default;
};
class GetDataTrackJobDegreeResponseBodyJobDegree : public Darabonba::Model {
public:
  shared_ptr<double> downloadCompletionDegree{};
  shared_ptr<double> filterCompletionDegree{};
  shared_ptr<string> jobStatus{};
  shared_ptr<double> listCompletionDegree{};
  shared_ptr<string> statusDesc{};

  GetDataTrackJobDegreeResponseBodyJobDegree() {}

  explicit GetDataTrackJobDegreeResponseBodyJobDegree(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadCompletionDegree) {
      res["DownloadCompletionDegree"] = boost::any(*downloadCompletionDegree);
    }
    if (filterCompletionDegree) {
      res["FilterCompletionDegree"] = boost::any(*filterCompletionDegree);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (listCompletionDegree) {
      res["ListCompletionDegree"] = boost::any(*listCompletionDegree);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadCompletionDegree") != m.end() && !m["DownloadCompletionDegree"].empty()) {
      downloadCompletionDegree = make_shared<double>(boost::any_cast<double>(m["DownloadCompletionDegree"]));
    }
    if (m.find("FilterCompletionDegree") != m.end() && !m["FilterCompletionDegree"].empty()) {
      filterCompletionDegree = make_shared<double>(boost::any_cast<double>(m["FilterCompletionDegree"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("ListCompletionDegree") != m.end() && !m["ListCompletionDegree"].empty()) {
      listCompletionDegree = make_shared<double>(boost::any_cast<double>(m["ListCompletionDegree"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
  }


  virtual ~GetDataTrackJobDegreeResponseBodyJobDegree() = default;
};
class GetDataTrackJobDegreeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetDataTrackJobDegreeResponseBodyJobDegree> jobDegree{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataTrackJobDegreeResponseBody() {}

  explicit GetDataTrackJobDegreeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobDegree) {
      res["JobDegree"] = jobDegree ? boost::any(jobDegree->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobDegree") != m.end() && !m["JobDegree"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobDegree"].type()) {
        GetDataTrackJobDegreeResponseBodyJobDegree model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobDegree"]));
        jobDegree = make_shared<GetDataTrackJobDegreeResponseBodyJobDegree>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataTrackJobDegreeResponseBody() = default;
};
class GetDataTrackJobDegreeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataTrackJobDegreeResponseBody> body{};

  GetDataTrackJobDegreeResponse() {}

  explicit GetDataTrackJobDegreeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataTrackJobDegreeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataTrackJobDegreeResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataTrackJobDegreeResponse() = default;
};
class GetDataTrackJobTableMetaRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataTrackJobTableMetaRequest() {}

  explicit GetDataTrackJobTableMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataTrackJobTableMetaRequest() = default;
};
class GetDataTrackJobTableMetaResponseBodyTableMetaListColumns : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<string> columnName{};
  shared_ptr<long> columnPosition{};
  shared_ptr<string> columnType{};
  shared_ptr<bool> fictive{};

  GetDataTrackJobTableMetaResponseBodyTableMetaListColumns() {}

  explicit GetDataTrackJobTableMetaResponseBodyTableMetaListColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnPosition) {
      res["ColumnPosition"] = boost::any(*columnPosition);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (fictive) {
      res["Fictive"] = boost::any(*fictive);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnPosition") != m.end() && !m["ColumnPosition"].empty()) {
      columnPosition = make_shared<long>(boost::any_cast<long>(m["ColumnPosition"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("Fictive") != m.end() && !m["Fictive"].empty()) {
      fictive = make_shared<bool>(boost::any_cast<bool>(m["Fictive"]));
    }
  }


  virtual ~GetDataTrackJobTableMetaResponseBodyTableMetaListColumns() = default;
};
class GetDataTrackJobTableMetaResponseBodyTableMetaList : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataTrackJobTableMetaResponseBodyTableMetaListColumns>> columns{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> tableName{};

  GetDataTrackJobTableMetaResponseBodyTableMetaList() {}

  explicit GetDataTrackJobTableMetaResponseBodyTableMetaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<GetDataTrackJobTableMetaResponseBodyTableMetaListColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataTrackJobTableMetaResponseBodyTableMetaListColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<GetDataTrackJobTableMetaResponseBodyTableMetaListColumns>>(expect1);
      }
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetDataTrackJobTableMetaResponseBodyTableMetaList() = default;
};
class GetDataTrackJobTableMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<GetDataTrackJobTableMetaResponseBodyTableMetaList>> tableMetaList{};

  GetDataTrackJobTableMetaResponseBody() {}

  explicit GetDataTrackJobTableMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tableMetaList) {
      vector<boost::any> temp1;
      for(auto item1:*tableMetaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableMetaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TableMetaList") != m.end() && !m["TableMetaList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableMetaList"].type()) {
        vector<GetDataTrackJobTableMetaResponseBodyTableMetaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableMetaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataTrackJobTableMetaResponseBodyTableMetaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableMetaList = make_shared<vector<GetDataTrackJobTableMetaResponseBodyTableMetaList>>(expect1);
      }
    }
  }


  virtual ~GetDataTrackJobTableMetaResponseBody() = default;
};
class GetDataTrackJobTableMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataTrackJobTableMetaResponseBody> body{};

  GetDataTrackJobTableMetaResponse() {}

  explicit GetDataTrackJobTableMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataTrackJobTableMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataTrackJobTableMetaResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataTrackJobTableMetaResponse() = default;
};
class GetDataTrackOrderDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDataTrackOrderDetailRequest() {}

  explicit GetDataTrackOrderDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDataTrackOrderDetailRequest() = default;
};
class GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail : public Darabonba::Model {
public:
  shared_ptr<string> databaseSearchName{};
  shared_ptr<long> dbId{};
  shared_ptr<string> jobEndTime{};
  shared_ptr<string> jobStartTime{};
  shared_ptr<string> jobStatus{};
  shared_ptr<bool> logic{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> statusDesc{};
  shared_ptr<vector<string>> tableNames{};
  shared_ptr<vector<string>> trackTypes{};

  GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail() {}

  explicit GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseSearchName) {
      res["DatabaseSearchName"] = boost::any(*databaseSearchName);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (jobEndTime) {
      res["JobEndTime"] = boost::any(*jobEndTime);
    }
    if (jobStartTime) {
      res["JobStartTime"] = boost::any(*jobStartTime);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (tableNames) {
      res["TableNames"] = boost::any(*tableNames);
    }
    if (trackTypes) {
      res["TrackTypes"] = boost::any(*trackTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseSearchName") != m.end() && !m["DatabaseSearchName"].empty()) {
      databaseSearchName = make_shared<string>(boost::any_cast<string>(m["DatabaseSearchName"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("JobEndTime") != m.end() && !m["JobEndTime"].empty()) {
      jobEndTime = make_shared<string>(boost::any_cast<string>(m["JobEndTime"]));
    }
    if (m.find("JobStartTime") != m.end() && !m["JobStartTime"].empty()) {
      jobStartTime = make_shared<string>(boost::any_cast<string>(m["JobStartTime"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("TableNames") != m.end() && !m["TableNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TrackTypes") != m.end() && !m["TrackTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrackTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrackTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trackTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail() = default;
};
class GetDataTrackOrderDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail> dataTrackOrderDetail{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataTrackOrderDetailResponseBody() {}

  explicit GetDataTrackOrderDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataTrackOrderDetail) {
      res["DataTrackOrderDetail"] = dataTrackOrderDetail ? boost::any(dataTrackOrderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataTrackOrderDetail") != m.end() && !m["DataTrackOrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataTrackOrderDetail"].type()) {
        GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataTrackOrderDetail"]));
        dataTrackOrderDetail = make_shared<GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataTrackOrderDetailResponseBody() = default;
};
class GetDataTrackOrderDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataTrackOrderDetailResponseBody> body{};

  GetDataTrackOrderDetailResponse() {}

  explicit GetDataTrackOrderDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataTrackOrderDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataTrackOrderDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataTrackOrderDetailResponse() = default;
};
class GetDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> sid{};
  shared_ptr<long> tid{};

  GetDatabaseRequest() {}

  explicit GetDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDatabaseRequest() = default;
};
class GetDatabaseResponseBodyDatabaseOwnerIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerIds{};

  GetDatabaseResponseBodyDatabaseOwnerIdList() {}

  explicit GetDatabaseResponseBodyDatabaseOwnerIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDatabaseResponseBodyDatabaseOwnerIdList() = default;
};
class GetDatabaseResponseBodyDatabaseOwnerNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerNames{};

  GetDatabaseResponseBodyDatabaseOwnerNameList() {}

  explicit GetDatabaseResponseBodyDatabaseOwnerNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDatabaseResponseBodyDatabaseOwnerNameList() = default;
};
class GetDatabaseResponseBodyDatabase : public Darabonba::Model {
public:
  shared_ptr<string> catalogName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> dbType{};
  shared_ptr<string> dbaId{};
  shared_ptr<string> dbaName{};
  shared_ptr<string> encoding{};
  shared_ptr<string> envType{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceAlias{};
  shared_ptr<string> instanceId{};
  shared_ptr<GetDatabaseResponseBodyDatabaseOwnerIdList> ownerIdList{};
  shared_ptr<GetDatabaseResponseBodyDatabaseOwnerNameList> ownerNameList{};
  shared_ptr<long> port{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> searchName{};
  shared_ptr<string> sid{};
  shared_ptr<string> state{};

  GetDatabaseResponseBodyDatabase() {}

  explicit GetDatabaseResponseBodyDatabase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (catalogName) {
      res["CatalogName"] = boost::any(*catalogName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (dbaId) {
      res["DbaId"] = boost::any(*dbaId);
    }
    if (dbaName) {
      res["DbaName"] = boost::any(*dbaName);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (instanceAlias) {
      res["InstanceAlias"] = boost::any(*instanceAlias);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerIdList) {
      res["OwnerIdList"] = ownerIdList ? boost::any(ownerIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerNameList) {
      res["OwnerNameList"] = ownerNameList ? boost::any(ownerNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CatalogName") != m.end() && !m["CatalogName"].empty()) {
      catalogName = make_shared<string>(boost::any_cast<string>(m["CatalogName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("DbaId") != m.end() && !m["DbaId"].empty()) {
      dbaId = make_shared<string>(boost::any_cast<string>(m["DbaId"]));
    }
    if (m.find("DbaName") != m.end() && !m["DbaName"].empty()) {
      dbaName = make_shared<string>(boost::any_cast<string>(m["DbaName"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("InstanceAlias") != m.end() && !m["InstanceAlias"].empty()) {
      instanceAlias = make_shared<string>(boost::any_cast<string>(m["InstanceAlias"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerIdList") != m.end() && !m["OwnerIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerIdList"].type()) {
        GetDatabaseResponseBodyDatabaseOwnerIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerIdList"]));
        ownerIdList = make_shared<GetDatabaseResponseBodyDatabaseOwnerIdList>(model1);
      }
    }
    if (m.find("OwnerNameList") != m.end() && !m["OwnerNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerNameList"].type()) {
        GetDatabaseResponseBodyDatabaseOwnerNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerNameList"]));
        ownerNameList = make_shared<GetDatabaseResponseBodyDatabaseOwnerNameList>(model1);
      }
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~GetDatabaseResponseBodyDatabase() = default;
};
class GetDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDatabaseResponseBodyDatabase> database{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDatabaseResponseBody() {}

  explicit GetDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = database ? boost::any(database->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      if (typeid(map<string, boost::any>) == m["Database"].type()) {
        GetDatabaseResponseBodyDatabase model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Database"]));
        database = make_shared<GetDatabaseResponseBodyDatabase>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDatabaseResponseBody() = default;
};
class GetDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDatabaseResponseBody> body{};

  GetDatabaseResponse() {}

  explicit GetDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~GetDatabaseResponse() = default;
};
class GetDatabaseExportOrderDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDatabaseExportOrderDetailRequest() {}

  explicit GetDatabaseExportOrderDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDatabaseExportOrderDetailRequest() = default;
};
class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> exportTypes{};

  GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes() {}

  explicit GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportTypes) {
      res["ExportTypes"] = boost::any(*exportTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportTypes") != m.end() && !m["ExportTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExportTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExportTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      exportTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes() = default;
};
class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption : public Darabonba::Model {
public:
  shared_ptr<vector<string>> SQLExtOption{};

  GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption() {}

  explicit GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLExtOption) {
      res["SQLExtOption"] = boost::any(*SQLExtOption);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLExtOption") != m.end() && !m["SQLExtOption"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SQLExtOption"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SQLExtOption"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      SQLExtOption = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption() = default;
};
class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables : public Darabonba::Model {
public:
  shared_ptr<vector<string>> selectedTables{};

  GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables() {}

  explicit GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (selectedTables) {
      res["SelectedTables"] = boost::any(*selectedTables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SelectedTables") != m.end() && !m["SelectedTables"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SelectedTables"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SelectedTables"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      selectedTables = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables() = default;
};
class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<string> exportContent{};
  shared_ptr<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes> exportTypes{};
  shared_ptr<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption> SQLExtOption{};
  shared_ptr<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables> selectedTables{};
  shared_ptr<string> targetOption{};

  GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig() {}

  explicit GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (exportContent) {
      res["ExportContent"] = boost::any(*exportContent);
    }
    if (exportTypes) {
      res["ExportTypes"] = exportTypes ? boost::any(exportTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (SQLExtOption) {
      res["SQLExtOption"] = SQLExtOption ? boost::any(SQLExtOption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (selectedTables) {
      res["SelectedTables"] = selectedTables ? boost::any(selectedTables->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetOption) {
      res["TargetOption"] = boost::any(*targetOption);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("ExportContent") != m.end() && !m["ExportContent"].empty()) {
      exportContent = make_shared<string>(boost::any_cast<string>(m["ExportContent"]));
    }
    if (m.find("ExportTypes") != m.end() && !m["ExportTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExportTypes"].type()) {
        GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExportTypes"]));
        exportTypes = make_shared<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes>(model1);
      }
    }
    if (m.find("SQLExtOption") != m.end() && !m["SQLExtOption"].empty()) {
      if (typeid(map<string, boost::any>) == m["SQLExtOption"].type()) {
        GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SQLExtOption"]));
        SQLExtOption = make_shared<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption>(model1);
      }
    }
    if (m.find("SelectedTables") != m.end() && !m["SelectedTables"].empty()) {
      if (typeid(map<string, boost::any>) == m["SelectedTables"].type()) {
        GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SelectedTables"]));
        selectedTables = make_shared<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables>(model1);
      }
    }
    if (m.find("TargetOption") != m.end() && !m["TargetOption"].empty()) {
      targetOption = make_shared<string>(boost::any_cast<string>(m["TargetOption"]));
    }
  }


  virtual ~GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig() = default;
};
class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo : public Darabonba::Model {
public:
  shared_ptr<string> auditDate{};
  shared_ptr<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig> config{};
  shared_ptr<long> dbId{};
  shared_ptr<string> downloadURL{};

  GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo() {}

  explicit GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditDate) {
      res["AuditDate"] = boost::any(*auditDate);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (downloadURL) {
      res["DownloadURL"] = boost::any(*downloadURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditDate") != m.end() && !m["AuditDate"].empty()) {
      auditDate = make_shared<string>(boost::any_cast<string>(m["AuditDate"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig>(model1);
      }
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DownloadURL") != m.end() && !m["DownloadURL"].empty()) {
      downloadURL = make_shared<string>(boost::any_cast<string>(m["DownloadURL"]));
    }
  }


  virtual ~GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo() = default;
};
class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> committer{};
  shared_ptr<string> committerId{};
  shared_ptr<long> id{};
  shared_ptr<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo> keyInfo{};
  shared_ptr<string> log{};
  shared_ptr<string> searchName{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> workflowStatusDesc{};

  GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail() {}

  explicit GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (committer) {
      res["Committer"] = boost::any(*committer);
    }
    if (committerId) {
      res["CommitterId"] = boost::any(*committerId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keyInfo) {
      res["KeyInfo"] = keyInfo ? boost::any(keyInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (log) {
      res["Log"] = boost::any(*log);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (workflowStatusDesc) {
      res["WorkflowStatusDesc"] = boost::any(*workflowStatusDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Committer") != m.end() && !m["Committer"].empty()) {
      committer = make_shared<string>(boost::any_cast<string>(m["Committer"]));
    }
    if (m.find("CommitterId") != m.end() && !m["CommitterId"].empty()) {
      committerId = make_shared<string>(boost::any_cast<string>(m["CommitterId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("KeyInfo") != m.end() && !m["KeyInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeyInfo"].type()) {
        GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeyInfo"]));
        keyInfo = make_shared<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo>(model1);
      }
    }
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      log = make_shared<string>(boost::any_cast<string>(m["Log"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("WorkflowStatusDesc") != m.end() && !m["WorkflowStatusDesc"].empty()) {
      workflowStatusDesc = make_shared<string>(boost::any_cast<string>(m["WorkflowStatusDesc"]));
    }
  }


  virtual ~GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail() = default;
};
class GetDatabaseExportOrderDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail> databaseExportOrderDetail{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDatabaseExportOrderDetailResponseBody() {}

  explicit GetDatabaseExportOrderDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseExportOrderDetail) {
      res["DatabaseExportOrderDetail"] = databaseExportOrderDetail ? boost::any(databaseExportOrderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseExportOrderDetail") != m.end() && !m["DatabaseExportOrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatabaseExportOrderDetail"].type()) {
        GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatabaseExportOrderDetail"]));
        databaseExportOrderDetail = make_shared<GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDatabaseExportOrderDetailResponseBody() = default;
};
class GetDatabaseExportOrderDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDatabaseExportOrderDetailResponseBody> body{};

  GetDatabaseExportOrderDetailResponse() {}

  explicit GetDatabaseExportOrderDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDatabaseExportOrderDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDatabaseExportOrderDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetDatabaseExportOrderDetailResponse() = default;
};
class GetDbExportDownloadURLRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetDbExportDownloadURLRequest() {}

  explicit GetDbExportDownloadURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetDbExportDownloadURLRequest() = default;
};
class GetDbExportDownloadURLResponseBodyDownloadURLResult : public Darabonba::Model {
public:
  shared_ptr<bool> hasResult{};
  shared_ptr<string> tipMessage{};
  shared_ptr<string> URL{};

  GetDbExportDownloadURLResponseBodyDownloadURLResult() {}

  explicit GetDbExportDownloadURLResponseBodyDownloadURLResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasResult) {
      res["HasResult"] = boost::any(*hasResult);
    }
    if (tipMessage) {
      res["TipMessage"] = boost::any(*tipMessage);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasResult") != m.end() && !m["HasResult"].empty()) {
      hasResult = make_shared<bool>(boost::any_cast<bool>(m["HasResult"]));
    }
    if (m.find("TipMessage") != m.end() && !m["TipMessage"].empty()) {
      tipMessage = make_shared<string>(boost::any_cast<string>(m["TipMessage"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~GetDbExportDownloadURLResponseBodyDownloadURLResult() = default;
};
class GetDbExportDownloadURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDbExportDownloadURLResponseBodyDownloadURLResult> downloadURLResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDbExportDownloadURLResponseBody() {}

  explicit GetDbExportDownloadURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadURLResult) {
      res["DownloadURLResult"] = downloadURLResult ? boost::any(downloadURLResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadURLResult") != m.end() && !m["DownloadURLResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadURLResult"].type()) {
        GetDbExportDownloadURLResponseBodyDownloadURLResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadURLResult"]));
        downloadURLResult = make_shared<GetDbExportDownloadURLResponseBodyDownloadURLResult>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDbExportDownloadURLResponseBody() = default;
};
class GetDbExportDownloadURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDbExportDownloadURLResponseBody> body{};

  GetDbExportDownloadURLResponse() {}

  explicit GetDbExportDownloadURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDbExportDownloadURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDbExportDownloadURLResponseBody>(model1);
      }
    }
  }


  virtual ~GetDbExportDownloadURLResponse() = default;
};
class GetInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};
  shared_ptr<string> sid{};
  shared_ptr<long> tid{};

  GetInstanceRequest() {}

  explicit GetInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetInstanceRequest() = default;
};
class GetInstanceResponseBodyInstanceOwnerIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerIds{};

  GetInstanceResponseBodyInstanceOwnerIdList() {}

  explicit GetInstanceResponseBodyInstanceOwnerIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetInstanceResponseBodyInstanceOwnerIdList() = default;
};
class GetInstanceResponseBodyInstanceOwnerNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerNames{};

  GetInstanceResponseBodyInstanceOwnerNameList() {}

  explicit GetInstanceResponseBodyInstanceOwnerNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetInstanceResponseBodyInstanceOwnerNameList() = default;
};
class GetInstanceResponseBodyInstanceStandardGroup : public Darabonba::Model {
public:
  shared_ptr<string> groupMode{};
  shared_ptr<string> groupName{};

  GetInstanceResponseBodyInstanceStandardGroup() {}

  explicit GetInstanceResponseBodyInstanceStandardGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupMode) {
      res["GroupMode"] = boost::any(*groupMode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupMode") != m.end() && !m["GroupMode"].empty()) {
      groupMode = make_shared<string>(boost::any_cast<string>(m["GroupMode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~GetInstanceResponseBodyInstanceStandardGroup() = default;
};
class GetInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<string> dataLinkName{};
  shared_ptr<string> databasePassword{};
  shared_ptr<string> databaseUser{};
  shared_ptr<string> dbaId{};
  shared_ptr<string> dbaNickName{};
  shared_ptr<long> ddlOnline{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> ecsRegion{};
  shared_ptr<string> envType{};
  shared_ptr<long> exportTimeout{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceAlias{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceSource{};
  shared_ptr<string> instanceType{};
  shared_ptr<GetInstanceResponseBodyInstanceOwnerIdList> ownerIdList{};
  shared_ptr<GetInstanceResponseBodyInstanceOwnerNameList> ownerNameList{};
  shared_ptr<long> port{};
  shared_ptr<long> queryTimeout{};
  shared_ptr<string> safeRuleId{};
  shared_ptr<string> sellSitd{};
  shared_ptr<string> sid{};
  shared_ptr<GetInstanceResponseBodyInstanceStandardGroup> standardGroup{};
  shared_ptr<string> state{};
  shared_ptr<long> useDsql{};
  shared_ptr<string> vpcId{};

  GetInstanceResponseBodyInstance() {}

  explicit GetInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataLinkName) {
      res["DataLinkName"] = boost::any(*dataLinkName);
    }
    if (databasePassword) {
      res["DatabasePassword"] = boost::any(*databasePassword);
    }
    if (databaseUser) {
      res["DatabaseUser"] = boost::any(*databaseUser);
    }
    if (dbaId) {
      res["DbaId"] = boost::any(*dbaId);
    }
    if (dbaNickName) {
      res["DbaNickName"] = boost::any(*dbaNickName);
    }
    if (ddlOnline) {
      res["DdlOnline"] = boost::any(*ddlOnline);
    }
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (ecsRegion) {
      res["EcsRegion"] = boost::any(*ecsRegion);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (exportTimeout) {
      res["ExportTimeout"] = boost::any(*exportTimeout);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (instanceAlias) {
      res["InstanceAlias"] = boost::any(*instanceAlias);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceSource) {
      res["InstanceSource"] = boost::any(*instanceSource);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerIdList) {
      res["OwnerIdList"] = ownerIdList ? boost::any(ownerIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerNameList) {
      res["OwnerNameList"] = ownerNameList ? boost::any(ownerNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (queryTimeout) {
      res["QueryTimeout"] = boost::any(*queryTimeout);
    }
    if (safeRuleId) {
      res["SafeRuleId"] = boost::any(*safeRuleId);
    }
    if (sellSitd) {
      res["SellSitd"] = boost::any(*sellSitd);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (standardGroup) {
      res["StandardGroup"] = standardGroup ? boost::any(standardGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (useDsql) {
      res["UseDsql"] = boost::any(*useDsql);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataLinkName") != m.end() && !m["DataLinkName"].empty()) {
      dataLinkName = make_shared<string>(boost::any_cast<string>(m["DataLinkName"]));
    }
    if (m.find("DatabasePassword") != m.end() && !m["DatabasePassword"].empty()) {
      databasePassword = make_shared<string>(boost::any_cast<string>(m["DatabasePassword"]));
    }
    if (m.find("DatabaseUser") != m.end() && !m["DatabaseUser"].empty()) {
      databaseUser = make_shared<string>(boost::any_cast<string>(m["DatabaseUser"]));
    }
    if (m.find("DbaId") != m.end() && !m["DbaId"].empty()) {
      dbaId = make_shared<string>(boost::any_cast<string>(m["DbaId"]));
    }
    if (m.find("DbaNickName") != m.end() && !m["DbaNickName"].empty()) {
      dbaNickName = make_shared<string>(boost::any_cast<string>(m["DbaNickName"]));
    }
    if (m.find("DdlOnline") != m.end() && !m["DdlOnline"].empty()) {
      ddlOnline = make_shared<long>(boost::any_cast<long>(m["DdlOnline"]));
    }
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("EcsRegion") != m.end() && !m["EcsRegion"].empty()) {
      ecsRegion = make_shared<string>(boost::any_cast<string>(m["EcsRegion"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ExportTimeout") != m.end() && !m["ExportTimeout"].empty()) {
      exportTimeout = make_shared<long>(boost::any_cast<long>(m["ExportTimeout"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("InstanceAlias") != m.end() && !m["InstanceAlias"].empty()) {
      instanceAlias = make_shared<string>(boost::any_cast<string>(m["InstanceAlias"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceSource") != m.end() && !m["InstanceSource"].empty()) {
      instanceSource = make_shared<string>(boost::any_cast<string>(m["InstanceSource"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerIdList") != m.end() && !m["OwnerIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerIdList"].type()) {
        GetInstanceResponseBodyInstanceOwnerIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerIdList"]));
        ownerIdList = make_shared<GetInstanceResponseBodyInstanceOwnerIdList>(model1);
      }
    }
    if (m.find("OwnerNameList") != m.end() && !m["OwnerNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerNameList"].type()) {
        GetInstanceResponseBodyInstanceOwnerNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerNameList"]));
        ownerNameList = make_shared<GetInstanceResponseBodyInstanceOwnerNameList>(model1);
      }
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("QueryTimeout") != m.end() && !m["QueryTimeout"].empty()) {
      queryTimeout = make_shared<long>(boost::any_cast<long>(m["QueryTimeout"]));
    }
    if (m.find("SafeRuleId") != m.end() && !m["SafeRuleId"].empty()) {
      safeRuleId = make_shared<string>(boost::any_cast<string>(m["SafeRuleId"]));
    }
    if (m.find("SellSitd") != m.end() && !m["SellSitd"].empty()) {
      sellSitd = make_shared<string>(boost::any_cast<string>(m["SellSitd"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("StandardGroup") != m.end() && !m["StandardGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["StandardGroup"].type()) {
        GetInstanceResponseBodyInstanceStandardGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StandardGroup"]));
        standardGroup = make_shared<GetInstanceResponseBodyInstanceStandardGroup>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UseDsql") != m.end() && !m["UseDsql"].empty()) {
      useDsql = make_shared<long>(boost::any_cast<long>(m["UseDsql"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetInstanceResponseBodyInstance() = default;
};
class GetInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetInstanceResponseBodyInstance> instance{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetInstanceResponseBody() {}

  explicit GetInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        GetInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<GetInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInstanceResponseBody() = default;
};
class GetInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceResponseBody> body{};

  GetInstanceResponse() {}

  explicit GetInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceResponse() = default;
};
class GetIntervalLimitOfSLARequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  GetIntervalLimitOfSLARequest() {}

  explicit GetIntervalLimitOfSLARequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetIntervalLimitOfSLARequest() = default;
};
class GetIntervalLimitOfSLAResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> intervalLimit{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetIntervalLimitOfSLAResponseBody() {}

  explicit GetIntervalLimitOfSLAResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (intervalLimit) {
      res["IntervalLimit"] = boost::any(*intervalLimit);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("IntervalLimit") != m.end() && !m["IntervalLimit"].empty()) {
      intervalLimit = make_shared<long>(boost::any_cast<long>(m["IntervalLimit"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetIntervalLimitOfSLAResponseBody() = default;
};
class GetIntervalLimitOfSLAResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIntervalLimitOfSLAResponseBody> body{};

  GetIntervalLimitOfSLAResponse() {}

  explicit GetIntervalLimitOfSLAResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIntervalLimitOfSLAResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIntervalLimitOfSLAResponseBody>(model1);
      }
    }
  }


  virtual ~GetIntervalLimitOfSLAResponse() = default;
};
class GetLhSpaceByNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> spaceName{};
  shared_ptr<long> tid{};

  GetLhSpaceByNameRequest() {}

  explicit GetLhSpaceByNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spaceName) {
      res["SpaceName"] = boost::any(*spaceName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpaceName") != m.end() && !m["SpaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["SpaceName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetLhSpaceByNameRequest() = default;
};
class GetLhSpaceByNameResponseBodyLakehouseSpace : public Darabonba::Model {
public:
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<long> devDbId{};
  shared_ptr<string> dwDbType{};
  shared_ptr<long> id{};
  shared_ptr<bool> isDeleted{};
  shared_ptr<long> mode{};
  shared_ptr<long> prodDbId{};
  shared_ptr<string> spaceConfig{};
  shared_ptr<string> spaceName{};
  shared_ptr<string> tenantId{};

  GetLhSpaceByNameResponseBodyLakehouseSpace() {}

  explicit GetLhSpaceByNameResponseBodyLakehouseSpace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devDbId) {
      res["DevDbId"] = boost::any(*devDbId);
    }
    if (dwDbType) {
      res["DwDbType"] = boost::any(*dwDbType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isDeleted) {
      res["IsDeleted"] = boost::any(*isDeleted);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (prodDbId) {
      res["ProdDbId"] = boost::any(*prodDbId);
    }
    if (spaceConfig) {
      res["SpaceConfig"] = boost::any(*spaceConfig);
    }
    if (spaceName) {
      res["SpaceName"] = boost::any(*spaceName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevDbId") != m.end() && !m["DevDbId"].empty()) {
      devDbId = make_shared<long>(boost::any_cast<long>(m["DevDbId"]));
    }
    if (m.find("DwDbType") != m.end() && !m["DwDbType"].empty()) {
      dwDbType = make_shared<string>(boost::any_cast<string>(m["DwDbType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsDeleted") != m.end() && !m["IsDeleted"].empty()) {
      isDeleted = make_shared<bool>(boost::any_cast<bool>(m["IsDeleted"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("ProdDbId") != m.end() && !m["ProdDbId"].empty()) {
      prodDbId = make_shared<long>(boost::any_cast<long>(m["ProdDbId"]));
    }
    if (m.find("SpaceConfig") != m.end() && !m["SpaceConfig"].empty()) {
      spaceConfig = make_shared<string>(boost::any_cast<string>(m["SpaceConfig"]));
    }
    if (m.find("SpaceName") != m.end() && !m["SpaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["SpaceName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~GetLhSpaceByNameResponseBodyLakehouseSpace() = default;
};
class GetLhSpaceByNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetLhSpaceByNameResponseBodyLakehouseSpace> lakehouseSpace{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetLhSpaceByNameResponseBody() {}

  explicit GetLhSpaceByNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (lakehouseSpace) {
      res["LakehouseSpace"] = lakehouseSpace ? boost::any(lakehouseSpace->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("LakehouseSpace") != m.end() && !m["LakehouseSpace"].empty()) {
      if (typeid(map<string, boost::any>) == m["LakehouseSpace"].type()) {
        GetLhSpaceByNameResponseBodyLakehouseSpace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LakehouseSpace"]));
        lakehouseSpace = make_shared<GetLhSpaceByNameResponseBodyLakehouseSpace>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetLhSpaceByNameResponseBody() = default;
};
class GetLhSpaceByNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLhSpaceByNameResponseBody> body{};

  GetLhSpaceByNameResponse() {}

  explicit GetLhSpaceByNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLhSpaceByNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLhSpaceByNameResponseBody>(model1);
      }
    }
  }


  virtual ~GetLhSpaceByNameResponse() = default;
};
class GetLogicDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbId{};
  shared_ptr<long> tid{};

  GetLogicDatabaseRequest() {}

  explicit GetLogicDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<string>(boost::any_cast<string>(m["DbId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetLogicDatabaseRequest() = default;
};
class GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds : public Darabonba::Model {
public:
  shared_ptr<vector<long>> databaseIds{};

  GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds() {}

  explicit GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseIds) {
      res["DatabaseIds"] = boost::any(*databaseIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseIds") != m.end() && !m["DatabaseIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      databaseIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds() = default;
};
class GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerIds{};

  GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList() {}

  explicit GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList() = default;
};
class GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerNames{};

  GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList() {}

  explicit GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList() = default;
};
class GetLogicDatabaseResponseBodyLogicDatabase : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> databaseId{};
  shared_ptr<GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds> databaseIds{};
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<bool> logic{};
  shared_ptr<GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList> ownerIdList{};
  shared_ptr<GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList> ownerNameList{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> searchName{};

  GetLogicDatabaseResponseBodyLogicDatabase() {}

  explicit GetLogicDatabaseResponseBodyLogicDatabase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (databaseIds) {
      res["DatabaseIds"] = databaseIds ? boost::any(databaseIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (ownerIdList) {
      res["OwnerIdList"] = ownerIdList ? boost::any(ownerIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerNameList) {
      res["OwnerNameList"] = ownerNameList ? boost::any(ownerNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatabaseIds") != m.end() && !m["DatabaseIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatabaseIds"].type()) {
        GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatabaseIds"]));
        databaseIds = make_shared<GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds>(model1);
      }
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("OwnerIdList") != m.end() && !m["OwnerIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerIdList"].type()) {
        GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerIdList"]));
        ownerIdList = make_shared<GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList>(model1);
      }
    }
    if (m.find("OwnerNameList") != m.end() && !m["OwnerNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerNameList"].type()) {
        GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerNameList"]));
        ownerNameList = make_shared<GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList>(model1);
      }
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~GetLogicDatabaseResponseBodyLogicDatabase() = default;
};
class GetLogicDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetLogicDatabaseResponseBodyLogicDatabase> logicDatabase{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetLogicDatabaseResponseBody() {}

  explicit GetLogicDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (logicDatabase) {
      res["LogicDatabase"] = logicDatabase ? boost::any(logicDatabase->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("LogicDatabase") != m.end() && !m["LogicDatabase"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogicDatabase"].type()) {
        GetLogicDatabaseResponseBodyLogicDatabase model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogicDatabase"]));
        logicDatabase = make_shared<GetLogicDatabaseResponseBodyLogicDatabase>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetLogicDatabaseResponseBody() = default;
};
class GetLogicDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLogicDatabaseResponseBody> body{};

  GetLogicDatabaseResponse() {}

  explicit GetLogicDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLogicDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLogicDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~GetLogicDatabaseResponse() = default;
};
class GetMetaTableColumnRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<long> tid{};

  GetMetaTableColumnRequest() {}

  explicit GetMetaTableColumnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetMetaTableColumnRequest() = default;
};
class GetMetaTableColumnResponseBodyColumnList : public Darabonba::Model {
public:
  shared_ptr<bool> autoIncrement{};
  shared_ptr<string> columnId{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};
  shared_ptr<long> dataLength{};
  shared_ptr<long> dataPrecision{};
  shared_ptr<long> dataScale{};
  shared_ptr<string> description{};
  shared_ptr<bool> nullable{};
  shared_ptr<long> position{};
  shared_ptr<string> primaryKey{};
  shared_ptr<string> securityLevel{};

  GetMetaTableColumnResponseBodyColumnList() {}

  explicit GetMetaTableColumnResponseBodyColumnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoIncrement) {
      res["AutoIncrement"] = boost::any(*autoIncrement);
    }
    if (columnId) {
      res["ColumnId"] = boost::any(*columnId);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (dataLength) {
      res["DataLength"] = boost::any(*dataLength);
    }
    if (dataPrecision) {
      res["DataPrecision"] = boost::any(*dataPrecision);
    }
    if (dataScale) {
      res["DataScale"] = boost::any(*dataScale);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nullable) {
      res["Nullable"] = boost::any(*nullable);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (securityLevel) {
      res["SecurityLevel"] = boost::any(*securityLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoIncrement") != m.end() && !m["AutoIncrement"].empty()) {
      autoIncrement = make_shared<bool>(boost::any_cast<bool>(m["AutoIncrement"]));
    }
    if (m.find("ColumnId") != m.end() && !m["ColumnId"].empty()) {
      columnId = make_shared<string>(boost::any_cast<string>(m["ColumnId"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("DataLength") != m.end() && !m["DataLength"].empty()) {
      dataLength = make_shared<long>(boost::any_cast<long>(m["DataLength"]));
    }
    if (m.find("DataPrecision") != m.end() && !m["DataPrecision"].empty()) {
      dataPrecision = make_shared<long>(boost::any_cast<long>(m["DataPrecision"]));
    }
    if (m.find("DataScale") != m.end() && !m["DataScale"].empty()) {
      dataScale = make_shared<long>(boost::any_cast<long>(m["DataScale"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Nullable") != m.end() && !m["Nullable"].empty()) {
      nullable = make_shared<bool>(boost::any_cast<bool>(m["Nullable"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("SecurityLevel") != m.end() && !m["SecurityLevel"].empty()) {
      securityLevel = make_shared<string>(boost::any_cast<string>(m["SecurityLevel"]));
    }
  }


  virtual ~GetMetaTableColumnResponseBodyColumnList() = default;
};
class GetMetaTableColumnResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetMetaTableColumnResponseBodyColumnList>> columnList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetMetaTableColumnResponseBody() {}

  explicit GetMetaTableColumnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnList) {
      vector<boost::any> temp1;
      for(auto item1:*columnList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnList"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnList") != m.end() && !m["ColumnList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnList"].type()) {
        vector<GetMetaTableColumnResponseBodyColumnList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableColumnResponseBodyColumnList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnList = make_shared<vector<GetMetaTableColumnResponseBodyColumnList>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMetaTableColumnResponseBody() = default;
};
class GetMetaTableColumnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMetaTableColumnResponseBody> body{};

  GetMetaTableColumnResponse() {}

  explicit GetMetaTableColumnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTableColumnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTableColumnResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTableColumnResponse() = default;
};
class GetMetaTableDetailInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<long> tid{};

  GetMetaTableDetailInfoRequest() {}

  explicit GetMetaTableDetailInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetMetaTableDetailInfoRequest() = default;
};
class GetMetaTableDetailInfoResponseBodyDetailInfoColumnList : public Darabonba::Model {
public:
  shared_ptr<bool> autoIncrement{};
  shared_ptr<string> columnId{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};
  shared_ptr<long> dataLength{};
  shared_ptr<long> dataPrecision{};
  shared_ptr<long> dataScale{};
  shared_ptr<string> description{};
  shared_ptr<bool> nullable{};
  shared_ptr<string> position{};

  GetMetaTableDetailInfoResponseBodyDetailInfoColumnList() {}

  explicit GetMetaTableDetailInfoResponseBodyDetailInfoColumnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoIncrement) {
      res["AutoIncrement"] = boost::any(*autoIncrement);
    }
    if (columnId) {
      res["ColumnId"] = boost::any(*columnId);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (dataLength) {
      res["DataLength"] = boost::any(*dataLength);
    }
    if (dataPrecision) {
      res["DataPrecision"] = boost::any(*dataPrecision);
    }
    if (dataScale) {
      res["DataScale"] = boost::any(*dataScale);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nullable) {
      res["Nullable"] = boost::any(*nullable);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoIncrement") != m.end() && !m["AutoIncrement"].empty()) {
      autoIncrement = make_shared<bool>(boost::any_cast<bool>(m["AutoIncrement"]));
    }
    if (m.find("ColumnId") != m.end() && !m["ColumnId"].empty()) {
      columnId = make_shared<string>(boost::any_cast<string>(m["ColumnId"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("DataLength") != m.end() && !m["DataLength"].empty()) {
      dataLength = make_shared<long>(boost::any_cast<long>(m["DataLength"]));
    }
    if (m.find("DataPrecision") != m.end() && !m["DataPrecision"].empty()) {
      dataPrecision = make_shared<long>(boost::any_cast<long>(m["DataPrecision"]));
    }
    if (m.find("DataScale") != m.end() && !m["DataScale"].empty()) {
      dataScale = make_shared<long>(boost::any_cast<long>(m["DataScale"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Nullable") != m.end() && !m["Nullable"].empty()) {
      nullable = make_shared<bool>(boost::any_cast<bool>(m["Nullable"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["Position"]));
    }
  }


  virtual ~GetMetaTableDetailInfoResponseBodyDetailInfoColumnList() = default;
};
class GetMetaTableDetailInfoResponseBodyDetailInfoIndexList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> indexColumns{};
  shared_ptr<string> indexId{};
  shared_ptr<string> indexName{};
  shared_ptr<string> indexType{};
  shared_ptr<bool> unique{};

  GetMetaTableDetailInfoResponseBodyDetailInfoIndexList() {}

  explicit GetMetaTableDetailInfoResponseBodyDetailInfoIndexList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexColumns) {
      res["IndexColumns"] = boost::any(*indexColumns);
    }
    if (indexId) {
      res["IndexId"] = boost::any(*indexId);
    }
    if (indexName) {
      res["IndexName"] = boost::any(*indexName);
    }
    if (indexType) {
      res["IndexType"] = boost::any(*indexType);
    }
    if (unique) {
      res["Unique"] = boost::any(*unique);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexColumns") != m.end() && !m["IndexColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IndexColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IndexColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      indexColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IndexId") != m.end() && !m["IndexId"].empty()) {
      indexId = make_shared<string>(boost::any_cast<string>(m["IndexId"]));
    }
    if (m.find("IndexName") != m.end() && !m["IndexName"].empty()) {
      indexName = make_shared<string>(boost::any_cast<string>(m["IndexName"]));
    }
    if (m.find("IndexType") != m.end() && !m["IndexType"].empty()) {
      indexType = make_shared<string>(boost::any_cast<string>(m["IndexType"]));
    }
    if (m.find("Unique") != m.end() && !m["Unique"].empty()) {
      unique = make_shared<bool>(boost::any_cast<bool>(m["Unique"]));
    }
  }


  virtual ~GetMetaTableDetailInfoResponseBodyDetailInfoIndexList() = default;
};
class GetMetaTableDetailInfoResponseBodyDetailInfo : public Darabonba::Model {
public:
  shared_ptr<vector<GetMetaTableDetailInfoResponseBodyDetailInfoColumnList>> columnList{};
  shared_ptr<vector<GetMetaTableDetailInfoResponseBodyDetailInfoIndexList>> indexList{};

  GetMetaTableDetailInfoResponseBodyDetailInfo() {}

  explicit GetMetaTableDetailInfoResponseBodyDetailInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnList) {
      vector<boost::any> temp1;
      for(auto item1:*columnList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnList"] = boost::any(temp1);
    }
    if (indexList) {
      vector<boost::any> temp1;
      for(auto item1:*indexList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IndexList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnList") != m.end() && !m["ColumnList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnList"].type()) {
        vector<GetMetaTableDetailInfoResponseBodyDetailInfoColumnList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableDetailInfoResponseBodyDetailInfoColumnList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnList = make_shared<vector<GetMetaTableDetailInfoResponseBodyDetailInfoColumnList>>(expect1);
      }
    }
    if (m.find("IndexList") != m.end() && !m["IndexList"].empty()) {
      if (typeid(vector<boost::any>) == m["IndexList"].type()) {
        vector<GetMetaTableDetailInfoResponseBodyDetailInfoIndexList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IndexList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableDetailInfoResponseBodyDetailInfoIndexList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        indexList = make_shared<vector<GetMetaTableDetailInfoResponseBodyDetailInfoIndexList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableDetailInfoResponseBodyDetailInfo() = default;
};
class GetMetaTableDetailInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMetaTableDetailInfoResponseBodyDetailInfo> detailInfo{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetMetaTableDetailInfoResponseBody() {}

  explicit GetMetaTableDetailInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detailInfo) {
      res["DetailInfo"] = detailInfo ? boost::any(detailInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DetailInfo") != m.end() && !m["DetailInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DetailInfo"].type()) {
        GetMetaTableDetailInfoResponseBodyDetailInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DetailInfo"]));
        detailInfo = make_shared<GetMetaTableDetailInfoResponseBodyDetailInfo>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMetaTableDetailInfoResponseBody() = default;
};
class GetMetaTableDetailInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMetaTableDetailInfoResponseBody> body{};

  GetMetaTableDetailInfoResponse() {}

  explicit GetMetaTableDetailInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTableDetailInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTableDetailInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTableDetailInfoResponse() = default;
};
class GetOnlineDDLProgressRequest : public Darabonba::Model {
public:
  shared_ptr<long> jobDetailId{};
  shared_ptr<long> tid{};

  GetOnlineDDLProgressRequest() {}

  explicit GetOnlineDDLProgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobDetailId) {
      res["JobDetailId"] = boost::any(*jobDetailId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobDetailId") != m.end() && !m["JobDetailId"].empty()) {
      jobDetailId = make_shared<long>(boost::any_cast<long>(m["JobDetailId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetOnlineDDLProgressRequest() = default;
};
class GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail : public Darabonba::Model {
public:
  shared_ptr<string> cleanStrategy{};
  shared_ptr<string> copyChunkMode{};
  shared_ptr<long> copyChunkSize{};
  shared_ptr<long> copyCount{};
  shared_ptr<long> copyTotal{};
  shared_ptr<long> cutoverFailRetryTimes{};
  shared_ptr<long> cutoverLockTimeSeconds{};
  shared_ptr<string> cutoverWindowEndTime{};
  shared_ptr<string> cutoverWindowStartTime{};
  shared_ptr<long> delaySeconds{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> progressRatio{};
  shared_ptr<string> statusDesc{};

  GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail() {}

  explicit GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cleanStrategy) {
      res["CleanStrategy"] = boost::any(*cleanStrategy);
    }
    if (copyChunkMode) {
      res["CopyChunkMode"] = boost::any(*copyChunkMode);
    }
    if (copyChunkSize) {
      res["CopyChunkSize"] = boost::any(*copyChunkSize);
    }
    if (copyCount) {
      res["CopyCount"] = boost::any(*copyCount);
    }
    if (copyTotal) {
      res["CopyTotal"] = boost::any(*copyTotal);
    }
    if (cutoverFailRetryTimes) {
      res["CutoverFailRetryTimes"] = boost::any(*cutoverFailRetryTimes);
    }
    if (cutoverLockTimeSeconds) {
      res["CutoverLockTimeSeconds"] = boost::any(*cutoverLockTimeSeconds);
    }
    if (cutoverWindowEndTime) {
      res["CutoverWindowEndTime"] = boost::any(*cutoverWindowEndTime);
    }
    if (cutoverWindowStartTime) {
      res["CutoverWindowStartTime"] = boost::any(*cutoverWindowStartTime);
    }
    if (delaySeconds) {
      res["DelaySeconds"] = boost::any(*delaySeconds);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (progressRatio) {
      res["ProgressRatio"] = boost::any(*progressRatio);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CleanStrategy") != m.end() && !m["CleanStrategy"].empty()) {
      cleanStrategy = make_shared<string>(boost::any_cast<string>(m["CleanStrategy"]));
    }
    if (m.find("CopyChunkMode") != m.end() && !m["CopyChunkMode"].empty()) {
      copyChunkMode = make_shared<string>(boost::any_cast<string>(m["CopyChunkMode"]));
    }
    if (m.find("CopyChunkSize") != m.end() && !m["CopyChunkSize"].empty()) {
      copyChunkSize = make_shared<long>(boost::any_cast<long>(m["CopyChunkSize"]));
    }
    if (m.find("CopyCount") != m.end() && !m["CopyCount"].empty()) {
      copyCount = make_shared<long>(boost::any_cast<long>(m["CopyCount"]));
    }
    if (m.find("CopyTotal") != m.end() && !m["CopyTotal"].empty()) {
      copyTotal = make_shared<long>(boost::any_cast<long>(m["CopyTotal"]));
    }
    if (m.find("CutoverFailRetryTimes") != m.end() && !m["CutoverFailRetryTimes"].empty()) {
      cutoverFailRetryTimes = make_shared<long>(boost::any_cast<long>(m["CutoverFailRetryTimes"]));
    }
    if (m.find("CutoverLockTimeSeconds") != m.end() && !m["CutoverLockTimeSeconds"].empty()) {
      cutoverLockTimeSeconds = make_shared<long>(boost::any_cast<long>(m["CutoverLockTimeSeconds"]));
    }
    if (m.find("CutoverWindowEndTime") != m.end() && !m["CutoverWindowEndTime"].empty()) {
      cutoverWindowEndTime = make_shared<string>(boost::any_cast<string>(m["CutoverWindowEndTime"]));
    }
    if (m.find("CutoverWindowStartTime") != m.end() && !m["CutoverWindowStartTime"].empty()) {
      cutoverWindowStartTime = make_shared<string>(boost::any_cast<string>(m["CutoverWindowStartTime"]));
    }
    if (m.find("DelaySeconds") != m.end() && !m["DelaySeconds"].empty()) {
      delaySeconds = make_shared<long>(boost::any_cast<long>(m["DelaySeconds"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("ProgressRatio") != m.end() && !m["ProgressRatio"].empty()) {
      progressRatio = make_shared<string>(boost::any_cast<string>(m["ProgressRatio"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
  }


  virtual ~GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail() = default;
};
class GetOnlineDDLProgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail> onlineDDLTaskDetail{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetOnlineDDLProgressResponseBody() {}

  explicit GetOnlineDDLProgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (onlineDDLTaskDetail) {
      res["OnlineDDLTaskDetail"] = onlineDDLTaskDetail ? boost::any(onlineDDLTaskDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("OnlineDDLTaskDetail") != m.end() && !m["OnlineDDLTaskDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineDDLTaskDetail"].type()) {
        GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineDDLTaskDetail"]));
        onlineDDLTaskDetail = make_shared<GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetOnlineDDLProgressResponseBody() = default;
};
class GetOnlineDDLProgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOnlineDDLProgressResponseBody> body{};

  GetOnlineDDLProgressResponse() {}

  explicit GetOnlineDDLProgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOnlineDDLProgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOnlineDDLProgressResponseBody>(model1);
      }
    }
  }


  virtual ~GetOnlineDDLProgressResponse() = default;
};
class GetOpLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> module{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<long> tid{};
  shared_ptr<string> userNick{};

  GetOpLogRequest() {}

  explicit GetOpLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (userNick) {
      res["UserNick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UserNick") != m.end() && !m["UserNick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["UserNick"]));
    }
  }


  virtual ~GetOpLogRequest() = default;
};
class GetOpLogResponseBodyOpLogDetailsOpLogDetail : public Darabonba::Model {
public:
  shared_ptr<string> database{};
  shared_ptr<string> module{};
  shared_ptr<string> opContent{};
  shared_ptr<string> opTime{};
  shared_ptr<long> opUserId{};
  shared_ptr<long> orderId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userNick{};

  GetOpLogResponseBodyOpLogDetailsOpLogDetail() {}

  explicit GetOpLogResponseBodyOpLogDetailsOpLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    if (opContent) {
      res["OpContent"] = boost::any(*opContent);
    }
    if (opTime) {
      res["OpTime"] = boost::any(*opTime);
    }
    if (opUserId) {
      res["OpUserId"] = boost::any(*opUserId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userNick) {
      res["UserNick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
    if (m.find("OpContent") != m.end() && !m["OpContent"].empty()) {
      opContent = make_shared<string>(boost::any_cast<string>(m["OpContent"]));
    }
    if (m.find("OpTime") != m.end() && !m["OpTime"].empty()) {
      opTime = make_shared<string>(boost::any_cast<string>(m["OpTime"]));
    }
    if (m.find("OpUserId") != m.end() && !m["OpUserId"].empty()) {
      opUserId = make_shared<long>(boost::any_cast<long>(m["OpUserId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserNick") != m.end() && !m["UserNick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["UserNick"]));
    }
  }


  virtual ~GetOpLogResponseBodyOpLogDetailsOpLogDetail() = default;
};
class GetOpLogResponseBodyOpLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<GetOpLogResponseBodyOpLogDetailsOpLogDetail>> opLogDetail{};

  GetOpLogResponseBodyOpLogDetails() {}

  explicit GetOpLogResponseBodyOpLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*opLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OpLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpLogDetail") != m.end() && !m["OpLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["OpLogDetail"].type()) {
        vector<GetOpLogResponseBodyOpLogDetailsOpLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OpLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOpLogResponseBodyOpLogDetailsOpLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        opLogDetail = make_shared<vector<GetOpLogResponseBodyOpLogDetailsOpLogDetail>>(expect1);
      }
    }
  }


  virtual ~GetOpLogResponseBodyOpLogDetails() = default;
};
class GetOpLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetOpLogResponseBodyOpLogDetails> opLogDetails{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  GetOpLogResponseBody() {}

  explicit GetOpLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (opLogDetails) {
      res["OpLogDetails"] = opLogDetails ? boost::any(opLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("OpLogDetails") != m.end() && !m["OpLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpLogDetails"].type()) {
        GetOpLogResponseBodyOpLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpLogDetails"]));
        opLogDetails = make_shared<GetOpLogResponseBodyOpLogDetails>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetOpLogResponseBody() = default;
};
class GetOpLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOpLogResponseBody> body{};

  GetOpLogResponse() {}

  explicit GetOpLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOpLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOpLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetOpLogResponse() = default;
};
class GetOrderAttachmentFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetOrderAttachmentFileRequest() {}

  explicit GetOrderAttachmentFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetOrderAttachmentFileRequest() = default;
};
class GetOrderAttachmentFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetOrderAttachmentFileResponseBody() {}

  explicit GetOrderAttachmentFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetOrderAttachmentFileResponseBody() = default;
};
class GetOrderAttachmentFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOrderAttachmentFileResponseBody> body{};

  GetOrderAttachmentFileResponse() {}

  explicit GetOrderAttachmentFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOrderAttachmentFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOrderAttachmentFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetOrderAttachmentFileResponse() = default;
};
class GetOrderBaseInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetOrderBaseInfoRequest() {}

  explicit GetOrderBaseInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetOrderBaseInfoRequest() = default;
};
class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> userIds{};

  GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList() {}

  explicit GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList() = default;
};
class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> userNicks{};

  GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList() {}

  explicit GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userNicks) {
      res["UserNicks"] = boost::any(*userNicks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserNicks") != m.end() && !m["UserNicks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserNicks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserNicks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userNicks = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList() = default;
};
class GetOrderBaseInfoResponseBodyOrderBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> comment{};
  shared_ptr<string> committer{};
  shared_ptr<long> committerId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModifyTime{};
  shared_ptr<long> orderId{};
  shared_ptr<string> originAttachmentName{};
  shared_ptr<string> pluginType{};
  shared_ptr<GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList> relatedUserList{};
  shared_ptr<GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList> relatedUserNickList{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> statusDesc{};
  shared_ptr<long> workflowInstanceId{};
  shared_ptr<string> workflowStatusDesc{};

  GetOrderBaseInfoResponseBodyOrderBaseInfo() {}

  explicit GetOrderBaseInfoResponseBodyOrderBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (committer) {
      res["Committer"] = boost::any(*committer);
    }
    if (committerId) {
      res["CommitterId"] = boost::any(*committerId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModifyTime) {
      res["LastModifyTime"] = boost::any(*lastModifyTime);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (originAttachmentName) {
      res["OriginAttachmentName"] = boost::any(*originAttachmentName);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (relatedUserList) {
      res["RelatedUserList"] = relatedUserList ? boost::any(relatedUserList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relatedUserNickList) {
      res["RelatedUserNickList"] = relatedUserNickList ? boost::any(relatedUserNickList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    if (workflowStatusDesc) {
      res["WorkflowStatusDesc"] = boost::any(*workflowStatusDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Committer") != m.end() && !m["Committer"].empty()) {
      committer = make_shared<string>(boost::any_cast<string>(m["Committer"]));
    }
    if (m.find("CommitterId") != m.end() && !m["CommitterId"].empty()) {
      committerId = make_shared<long>(boost::any_cast<long>(m["CommitterId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModifyTime") != m.end() && !m["LastModifyTime"].empty()) {
      lastModifyTime = make_shared<string>(boost::any_cast<string>(m["LastModifyTime"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("OriginAttachmentName") != m.end() && !m["OriginAttachmentName"].empty()) {
      originAttachmentName = make_shared<string>(boost::any_cast<string>(m["OriginAttachmentName"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("RelatedUserList") != m.end() && !m["RelatedUserList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelatedUserList"].type()) {
        GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelatedUserList"]));
        relatedUserList = make_shared<GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList>(model1);
      }
    }
    if (m.find("RelatedUserNickList") != m.end() && !m["RelatedUserNickList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelatedUserNickList"].type()) {
        GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelatedUserNickList"]));
        relatedUserNickList = make_shared<GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList>(model1);
      }
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
    if (m.find("WorkflowStatusDesc") != m.end() && !m["WorkflowStatusDesc"].empty()) {
      workflowStatusDesc = make_shared<string>(boost::any_cast<string>(m["WorkflowStatusDesc"]));
    }
  }


  virtual ~GetOrderBaseInfoResponseBodyOrderBaseInfo() = default;
};
class GetOrderBaseInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetOrderBaseInfoResponseBodyOrderBaseInfo> orderBaseInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetOrderBaseInfoResponseBody() {}

  explicit GetOrderBaseInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (orderBaseInfo) {
      res["OrderBaseInfo"] = orderBaseInfo ? boost::any(orderBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("OrderBaseInfo") != m.end() && !m["OrderBaseInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderBaseInfo"].type()) {
        GetOrderBaseInfoResponseBodyOrderBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderBaseInfo"]));
        orderBaseInfo = make_shared<GetOrderBaseInfoResponseBodyOrderBaseInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetOrderBaseInfoResponseBody() = default;
};
class GetOrderBaseInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOrderBaseInfoResponseBody> body{};

  GetOrderBaseInfoResponse() {}

  explicit GetOrderBaseInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOrderBaseInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOrderBaseInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetOrderBaseInfoResponse() = default;
};
class GetOwnerApplyOrderDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetOwnerApplyOrderDetailRequest() {}

  explicit GetOwnerApplyOrderDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetOwnerApplyOrderDetailRequest() = default;
};
class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail : public Darabonba::Model {
public:
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<vector<long>> ownerIds{};
  shared_ptr<vector<string>> ownerNickNames{};
  shared_ptr<string> searchName{};
  shared_ptr<string> tableName{};

  GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail() {}

  explicit GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    if (ownerNickNames) {
      res["OwnerNickNames"] = boost::any(*ownerNickNames);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ownerIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("OwnerNickNames") != m.end() && !m["OwnerNickNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNickNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNickNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNickNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail() = default;
};
class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources : public Darabonba::Model {
public:
  shared_ptr<bool> logic{};
  shared_ptr<GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail> resourceDetail{};
  shared_ptr<string> targetId{};

  GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources() {}

  explicit GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (resourceDetail) {
      res["ResourceDetail"] = resourceDetail ? boost::any(resourceDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("ResourceDetail") != m.end() && !m["ResourceDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceDetail"].type()) {
        GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceDetail"]));
        resourceDetail = make_shared<GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail>(model1);
      }
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
  }


  virtual ~GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources() = default;
};
class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail : public Darabonba::Model {
public:
  shared_ptr<string> applyType{};
  shared_ptr<vector<GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources>> resources{};

  GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail() {}

  explicit GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyType) {
      res["ApplyType"] = boost::any(*applyType);
    }
    if (resources) {
      vector<boost::any> temp1;
      for(auto item1:*resources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyType") != m.end() && !m["ApplyType"].empty()) {
      applyType = make_shared<string>(boost::any_cast<string>(m["ApplyType"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resources = make_shared<vector<GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources>>(expect1);
      }
    }
  }


  virtual ~GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail() = default;
};
class GetOwnerApplyOrderDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail> ownerApplyOrderDetail{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetOwnerApplyOrderDetailResponseBody() {}

  explicit GetOwnerApplyOrderDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (ownerApplyOrderDetail) {
      res["OwnerApplyOrderDetail"] = ownerApplyOrderDetail ? boost::any(ownerApplyOrderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("OwnerApplyOrderDetail") != m.end() && !m["OwnerApplyOrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerApplyOrderDetail"].type()) {
        GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerApplyOrderDetail"]));
        ownerApplyOrderDetail = make_shared<GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetOwnerApplyOrderDetailResponseBody() = default;
};
class GetOwnerApplyOrderDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOwnerApplyOrderDetailResponseBody> body{};

  GetOwnerApplyOrderDetailResponse() {}

  explicit GetOwnerApplyOrderDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOwnerApplyOrderDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOwnerApplyOrderDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetOwnerApplyOrderDetailResponse() = default;
};
class GetPagedInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetPagedInstanceRequest() {}

  explicit GetPagedInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetPagedInstanceRequest() = default;
};
class GetPagedInstanceResponseBodyDataInstance : public Darabonba::Model {
public:
  shared_ptr<string> businessTime{};
  shared_ptr<long> checkStatus{};
  shared_ptr<long> dagId{};
  shared_ptr<string> delete_{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> historyDagId{};
  shared_ptr<long> id{};
  shared_ptr<string> lastRunningContext{};
  shared_ptr<string> msg{};
  shared_ptr<long> status{};
  shared_ptr<long> taskType{};
  shared_ptr<string> tenantId{};
  shared_ptr<long> triggerType{};
  shared_ptr<string> version{};

  GetPagedInstanceResponseBodyDataInstance() {}

  explicit GetPagedInstanceResponseBodyDataInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessTime) {
      res["BusinessTime"] = boost::any(*businessTime);
    }
    if (checkStatus) {
      res["CheckStatus"] = boost::any(*checkStatus);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (historyDagId) {
      res["HistoryDagId"] = boost::any(*historyDagId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastRunningContext) {
      res["LastRunningContext"] = boost::any(*lastRunningContext);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessTime") != m.end() && !m["BusinessTime"].empty()) {
      businessTime = make_shared<string>(boost::any_cast<string>(m["BusinessTime"]));
    }
    if (m.find("CheckStatus") != m.end() && !m["CheckStatus"].empty()) {
      checkStatus = make_shared<long>(boost::any_cast<long>(m["CheckStatus"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<string>(boost::any_cast<string>(m["Delete"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HistoryDagId") != m.end() && !m["HistoryDagId"].empty()) {
      historyDagId = make_shared<long>(boost::any_cast<long>(m["HistoryDagId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastRunningContext") != m.end() && !m["LastRunningContext"].empty()) {
      lastRunningContext = make_shared<string>(boost::any_cast<string>(m["LastRunningContext"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<long>(boost::any_cast<long>(m["TriggerType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetPagedInstanceResponseBodyDataInstance() = default;
};
class GetPagedInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetPagedInstanceResponseBodyDataInstance>> instance{};

  GetPagedInstanceResponseBodyData() {}

  explicit GetPagedInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<GetPagedInstanceResponseBodyDataInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPagedInstanceResponseBodyDataInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<GetPagedInstanceResponseBodyDataInstance>>(expect1);
      }
    }
  }


  virtual ~GetPagedInstanceResponseBodyData() = default;
};
class GetPagedInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPagedInstanceResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};
  shared_ptr<string> traceId{};

  GetPagedInstanceResponseBody() {}

  explicit GetPagedInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPagedInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPagedInstanceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~GetPagedInstanceResponseBody() = default;
};
class GetPagedInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPagedInstanceResponseBody> body{};

  GetPagedInstanceResponse() {}

  explicit GetPagedInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPagedInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPagedInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetPagedInstanceResponse() = default;
};
class GetPermApplyOrderDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetPermApplyOrderDetailRequest() {}

  explicit GetPermApplyOrderDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetPermApplyOrderDetailRequest() = default;
};
class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> tableName{};

  GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo() {}

  explicit GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo() = default;
};
class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<bool> logic{};
  shared_ptr<vector<long>> ownerIds{};
  shared_ptr<vector<string>> ownerNickNames{};
  shared_ptr<string> searchName{};

  GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo() {}

  explicit GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    if (ownerNickNames) {
      res["OwnerNickNames"] = boost::any(*ownerNickNames);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ownerIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("OwnerNickNames") != m.end() && !m["OwnerNickNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNickNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNickNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNickNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo() = default;
};
class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo : public Darabonba::Model {
public:
  shared_ptr<string> dbType{};
  shared_ptr<long> dbaId{};
  shared_ptr<string> dbaNickName{};
  shared_ptr<string> envType{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<long>> ownerIds{};
  shared_ptr<vector<string>> ownerNickName{};
  shared_ptr<long> port{};
  shared_ptr<string> searchName{};

  GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo() {}

  explicit GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (dbaId) {
      res["DbaId"] = boost::any(*dbaId);
    }
    if (dbaNickName) {
      res["DbaNickName"] = boost::any(*dbaNickName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    if (ownerNickName) {
      res["OwnerNickName"] = boost::any(*ownerNickName);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("DbaId") != m.end() && !m["DbaId"].empty()) {
      dbaId = make_shared<long>(boost::any_cast<long>(m["DbaId"]));
    }
    if (m.find("DbaNickName") != m.end() && !m["DbaNickName"].empty()) {
      dbaNickName = make_shared<string>(boost::any_cast<string>(m["DbaNickName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ownerIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("OwnerNickName") != m.end() && !m["OwnerNickName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNickName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNickName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNickName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo() = default;
};
class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};

  GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo() {}

  explicit GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo() = default;
};
class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources : public Darabonba::Model {
public:
  shared_ptr<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo> columnInfo{};
  shared_ptr<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo> databaseInfo{};
  shared_ptr<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo> instanceInfo{};
  shared_ptr<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo> tableInfo{};

  GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources() {}

  explicit GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnInfo) {
      res["ColumnInfo"] = columnInfo ? boost::any(columnInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (databaseInfo) {
      res["DatabaseInfo"] = databaseInfo ? boost::any(databaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceInfo) {
      res["InstanceInfo"] = instanceInfo ? boost::any(instanceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableInfo) {
      res["TableInfo"] = tableInfo ? boost::any(tableInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnInfo") != m.end() && !m["ColumnInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColumnInfo"].type()) {
        GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColumnInfo"]));
        columnInfo = make_shared<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo>(model1);
      }
    }
    if (m.find("DatabaseInfo") != m.end() && !m["DatabaseInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatabaseInfo"].type()) {
        GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatabaseInfo"]));
        databaseInfo = make_shared<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo>(model1);
      }
    }
    if (m.find("InstanceInfo") != m.end() && !m["InstanceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceInfo"].type()) {
        GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceInfo"]));
        instanceInfo = make_shared<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo>(model1);
      }
    }
    if (m.find("TableInfo") != m.end() && !m["TableInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableInfo"].type()) {
        GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableInfo"]));
        tableInfo = make_shared<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo>(model1);
      }
    }
  }


  virtual ~GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources() = default;
};
class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail : public Darabonba::Model {
public:
  shared_ptr<string> applyType{};
  shared_ptr<long> permType{};
  shared_ptr<vector<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources>> resources{};
  shared_ptr<long> seconds{};

  GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail() {}

  explicit GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyType) {
      res["ApplyType"] = boost::any(*applyType);
    }
    if (permType) {
      res["PermType"] = boost::any(*permType);
    }
    if (resources) {
      vector<boost::any> temp1;
      for(auto item1:*resources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resources"] = boost::any(temp1);
    }
    if (seconds) {
      res["Seconds"] = boost::any(*seconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyType") != m.end() && !m["ApplyType"].empty()) {
      applyType = make_shared<string>(boost::any_cast<string>(m["ApplyType"]));
    }
    if (m.find("PermType") != m.end() && !m["PermType"].empty()) {
      permType = make_shared<long>(boost::any_cast<long>(m["PermType"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resources = make_shared<vector<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources>>(expect1);
      }
    }
    if (m.find("Seconds") != m.end() && !m["Seconds"].empty()) {
      seconds = make_shared<long>(boost::any_cast<long>(m["Seconds"]));
    }
  }


  virtual ~GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail() = default;
};
class GetPermApplyOrderDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail> permApplyOrderDetail{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPermApplyOrderDetailResponseBody() {}

  explicit GetPermApplyOrderDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (permApplyOrderDetail) {
      res["PermApplyOrderDetail"] = permApplyOrderDetail ? boost::any(permApplyOrderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PermApplyOrderDetail") != m.end() && !m["PermApplyOrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["PermApplyOrderDetail"].type()) {
        GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PermApplyOrderDetail"]));
        permApplyOrderDetail = make_shared<GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPermApplyOrderDetailResponseBody() = default;
};
class GetPermApplyOrderDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPermApplyOrderDetailResponseBody> body{};

  GetPermApplyOrderDetailResponse() {}

  explicit GetPermApplyOrderDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPermApplyOrderDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPermApplyOrderDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetPermApplyOrderDetailResponse() = default;
};
class GetPhysicalDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<long> tid{};

  GetPhysicalDatabaseRequest() {}

  explicit GetPhysicalDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetPhysicalDatabaseRequest() = default;
};
class GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerIds{};

  GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList() {}

  explicit GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList() = default;
};
class GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerNames{};

  GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList() {}

  explicit GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList() = default;
};
class GetPhysicalDatabaseResponseBodyDatabase : public Darabonba::Model {
public:
  shared_ptr<string> catalogName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> dbType{};
  shared_ptr<string> dbaId{};
  shared_ptr<string> dbaName{};
  shared_ptr<string> encoding{};
  shared_ptr<string> envType{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceAlias{};
  shared_ptr<string> instanceId{};
  shared_ptr<GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList> ownerIdList{};
  shared_ptr<GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList> ownerNameList{};
  shared_ptr<long> port{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> searchName{};
  shared_ptr<string> sid{};
  shared_ptr<string> state{};

  GetPhysicalDatabaseResponseBodyDatabase() {}

  explicit GetPhysicalDatabaseResponseBodyDatabase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (catalogName) {
      res["CatalogName"] = boost::any(*catalogName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (dbaId) {
      res["DbaId"] = boost::any(*dbaId);
    }
    if (dbaName) {
      res["DbaName"] = boost::any(*dbaName);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (instanceAlias) {
      res["InstanceAlias"] = boost::any(*instanceAlias);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerIdList) {
      res["OwnerIdList"] = ownerIdList ? boost::any(ownerIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerNameList) {
      res["OwnerNameList"] = ownerNameList ? boost::any(ownerNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CatalogName") != m.end() && !m["CatalogName"].empty()) {
      catalogName = make_shared<string>(boost::any_cast<string>(m["CatalogName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("DbaId") != m.end() && !m["DbaId"].empty()) {
      dbaId = make_shared<string>(boost::any_cast<string>(m["DbaId"]));
    }
    if (m.find("DbaName") != m.end() && !m["DbaName"].empty()) {
      dbaName = make_shared<string>(boost::any_cast<string>(m["DbaName"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("InstanceAlias") != m.end() && !m["InstanceAlias"].empty()) {
      instanceAlias = make_shared<string>(boost::any_cast<string>(m["InstanceAlias"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerIdList") != m.end() && !m["OwnerIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerIdList"].type()) {
        GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerIdList"]));
        ownerIdList = make_shared<GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList>(model1);
      }
    }
    if (m.find("OwnerNameList") != m.end() && !m["OwnerNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerNameList"].type()) {
        GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerNameList"]));
        ownerNameList = make_shared<GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList>(model1);
      }
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~GetPhysicalDatabaseResponseBodyDatabase() = default;
};
class GetPhysicalDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPhysicalDatabaseResponseBodyDatabase> database{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPhysicalDatabaseResponseBody() {}

  explicit GetPhysicalDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = database ? boost::any(database->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      if (typeid(map<string, boost::any>) == m["Database"].type()) {
        GetPhysicalDatabaseResponseBodyDatabase model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Database"]));
        database = make_shared<GetPhysicalDatabaseResponseBodyDatabase>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPhysicalDatabaseResponseBody() = default;
};
class GetPhysicalDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPhysicalDatabaseResponseBody> body{};

  GetPhysicalDatabaseResponse() {}

  explicit GetPhysicalDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPhysicalDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPhysicalDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~GetPhysicalDatabaseResponse() = default;
};
class GetProxyRequest : public Darabonba::Model {
public:
  shared_ptr<long> proxyId{};
  shared_ptr<long> tid{};

  GetProxyRequest() {}

  explicit GetProxyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxyId) {
      res["ProxyId"] = boost::any(*proxyId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxyId") != m.end() && !m["ProxyId"].empty()) {
      proxyId = make_shared<long>(boost::any_cast<long>(m["ProxyId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetProxyRequest() = default;
};
class GetProxyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> httpsPort{};
  shared_ptr<long> instanceId{};
  shared_ptr<bool> privateEnable{};
  shared_ptr<string> privateHost{};
  shared_ptr<long> protocolPort{};
  shared_ptr<string> protocolType{};
  shared_ptr<long> proxyId{};
  shared_ptr<bool> publicEnable{};
  shared_ptr<string> publicHost{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetProxyResponseBody() {}

  explicit GetProxyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (httpsPort) {
      res["HttpsPort"] = boost::any(*httpsPort);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (privateEnable) {
      res["PrivateEnable"] = boost::any(*privateEnable);
    }
    if (privateHost) {
      res["PrivateHost"] = boost::any(*privateHost);
    }
    if (protocolPort) {
      res["ProtocolPort"] = boost::any(*protocolPort);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (proxyId) {
      res["ProxyId"] = boost::any(*proxyId);
    }
    if (publicEnable) {
      res["PublicEnable"] = boost::any(*publicEnable);
    }
    if (publicHost) {
      res["PublicHost"] = boost::any(*publicHost);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HttpsPort") != m.end() && !m["HttpsPort"].empty()) {
      httpsPort = make_shared<long>(boost::any_cast<long>(m["HttpsPort"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("PrivateEnable") != m.end() && !m["PrivateEnable"].empty()) {
      privateEnable = make_shared<bool>(boost::any_cast<bool>(m["PrivateEnable"]));
    }
    if (m.find("PrivateHost") != m.end() && !m["PrivateHost"].empty()) {
      privateHost = make_shared<string>(boost::any_cast<string>(m["PrivateHost"]));
    }
    if (m.find("ProtocolPort") != m.end() && !m["ProtocolPort"].empty()) {
      protocolPort = make_shared<long>(boost::any_cast<long>(m["ProtocolPort"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("ProxyId") != m.end() && !m["ProxyId"].empty()) {
      proxyId = make_shared<long>(boost::any_cast<long>(m["ProxyId"]));
    }
    if (m.find("PublicEnable") != m.end() && !m["PublicEnable"].empty()) {
      publicEnable = make_shared<bool>(boost::any_cast<bool>(m["PublicEnable"]));
    }
    if (m.find("PublicHost") != m.end() && !m["PublicHost"].empty()) {
      publicHost = make_shared<string>(boost::any_cast<string>(m["PublicHost"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetProxyResponseBody() = default;
};
class GetProxyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProxyResponseBody> body{};

  GetProxyResponse() {}

  explicit GetProxyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProxyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProxyResponseBody>(model1);
      }
    }
  }


  virtual ~GetProxyResponse() = default;
};
class GetProxyAccessRequest : public Darabonba::Model {
public:
  shared_ptr<long> proxyAccessId{};
  shared_ptr<long> tid{};

  GetProxyAccessRequest() {}

  explicit GetProxyAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxyAccessId) {
      res["ProxyAccessId"] = boost::any(*proxyAccessId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxyAccessId") != m.end() && !m["ProxyAccessId"].empty()) {
      proxyAccessId = make_shared<long>(boost::any_cast<long>(m["ProxyAccessId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetProxyAccessRequest() = default;
};
class GetProxyAccessResponseBodyProxyAccess : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> indepAccount{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> originInfo{};
  shared_ptr<long> proxyAccessId{};
  shared_ptr<long> proxyId{};
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userUid{};

  GetProxyAccessResponseBodyProxyAccess() {}

  explicit GetProxyAccessResponseBodyProxyAccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (indepAccount) {
      res["IndepAccount"] = boost::any(*indepAccount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (originInfo) {
      res["OriginInfo"] = boost::any(*originInfo);
    }
    if (proxyAccessId) {
      res["ProxyAccessId"] = boost::any(*proxyAccessId);
    }
    if (proxyId) {
      res["ProxyId"] = boost::any(*proxyId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userUid) {
      res["UserUid"] = boost::any(*userUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("IndepAccount") != m.end() && !m["IndepAccount"].empty()) {
      indepAccount = make_shared<string>(boost::any_cast<string>(m["IndepAccount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("OriginInfo") != m.end() && !m["OriginInfo"].empty()) {
      originInfo = make_shared<string>(boost::any_cast<string>(m["OriginInfo"]));
    }
    if (m.find("ProxyAccessId") != m.end() && !m["ProxyAccessId"].empty()) {
      proxyAccessId = make_shared<long>(boost::any_cast<long>(m["ProxyAccessId"]));
    }
    if (m.find("ProxyId") != m.end() && !m["ProxyId"].empty()) {
      proxyId = make_shared<long>(boost::any_cast<long>(m["ProxyId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserUid") != m.end() && !m["UserUid"].empty()) {
      userUid = make_shared<string>(boost::any_cast<string>(m["UserUid"]));
    }
  }


  virtual ~GetProxyAccessResponseBodyProxyAccess() = default;
};
class GetProxyAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetProxyAccessResponseBodyProxyAccess> proxyAccess{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetProxyAccessResponseBody() {}

  explicit GetProxyAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (proxyAccess) {
      res["ProxyAccess"] = proxyAccess ? boost::any(proxyAccess->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProxyAccess") != m.end() && !m["ProxyAccess"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProxyAccess"].type()) {
        GetProxyAccessResponseBodyProxyAccess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProxyAccess"]));
        proxyAccess = make_shared<GetProxyAccessResponseBodyProxyAccess>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetProxyAccessResponseBody() = default;
};
class GetProxyAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProxyAccessResponseBody> body{};

  GetProxyAccessResponse() {}

  explicit GetProxyAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProxyAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProxyAccessResponseBody>(model1);
      }
    }
  }


  virtual ~GetProxyAccessResponse() = default;
};
class GetRuleNumLimitOfSLARequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  GetRuleNumLimitOfSLARequest() {}

  explicit GetRuleNumLimitOfSLARequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetRuleNumLimitOfSLARequest() = default;
};
class GetRuleNumLimitOfSLAResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> ruleNumLimit{};
  shared_ptr<bool> success{};

  GetRuleNumLimitOfSLAResponseBody() {}

  explicit GetRuleNumLimitOfSLAResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleNumLimit) {
      res["RuleNumLimit"] = boost::any(*ruleNumLimit);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleNumLimit") != m.end() && !m["RuleNumLimit"].empty()) {
      ruleNumLimit = make_shared<long>(boost::any_cast<long>(m["RuleNumLimit"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRuleNumLimitOfSLAResponseBody() = default;
};
class GetRuleNumLimitOfSLAResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRuleNumLimitOfSLAResponseBody> body{};

  GetRuleNumLimitOfSLAResponse() {}

  explicit GetRuleNumLimitOfSLAResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRuleNumLimitOfSLAResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRuleNumLimitOfSLAResponseBody>(model1);
      }
    }
  }


  virtual ~GetRuleNumLimitOfSLAResponse() = default;
};
class GetSQLReviewCheckResultStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetSQLReviewCheckResultStatusRequest() {}

  explicit GetSQLReviewCheckResultStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetSQLReviewCheckResultStatusRequest() = default;
};
class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult : public Darabonba::Model {
public:
  shared_ptr<long> checkNotPass{};
  shared_ptr<long> checkPass{};
  shared_ptr<long> forceNotPass{};
  shared_ptr<long> forcePass{};
  shared_ptr<long> new_{};
  shared_ptr<long> unknown{};

  GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult() {}

  explicit GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkNotPass) {
      res["CheckNotPass"] = boost::any(*checkNotPass);
    }
    if (checkPass) {
      res["CheckPass"] = boost::any(*checkPass);
    }
    if (forceNotPass) {
      res["ForceNotPass"] = boost::any(*forceNotPass);
    }
    if (forcePass) {
      res["ForcePass"] = boost::any(*forcePass);
    }
    if (new_) {
      res["New"] = boost::any(*new_);
    }
    if (unknown) {
      res["Unknown"] = boost::any(*unknown);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckNotPass") != m.end() && !m["CheckNotPass"].empty()) {
      checkNotPass = make_shared<long>(boost::any_cast<long>(m["CheckNotPass"]));
    }
    if (m.find("CheckPass") != m.end() && !m["CheckPass"].empty()) {
      checkPass = make_shared<long>(boost::any_cast<long>(m["CheckPass"]));
    }
    if (m.find("ForceNotPass") != m.end() && !m["ForceNotPass"].empty()) {
      forceNotPass = make_shared<long>(boost::any_cast<long>(m["ForceNotPass"]));
    }
    if (m.find("ForcePass") != m.end() && !m["ForcePass"].empty()) {
      forcePass = make_shared<long>(boost::any_cast<long>(m["ForcePass"]));
    }
    if (m.find("New") != m.end() && !m["New"].empty()) {
      new_ = make_shared<long>(boost::any_cast<long>(m["New"]));
    }
    if (m.find("Unknown") != m.end() && !m["Unknown"].empty()) {
      unknown = make_shared<long>(boost::any_cast<long>(m["Unknown"]));
    }
  }


  virtual ~GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult() = default;
};
class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult : public Darabonba::Model {
public:
  shared_ptr<long> mustImprove{};
  shared_ptr<long> potentialIssue{};
  shared_ptr<long> suggestImprove{};
  shared_ptr<long> tableIndexSuggest{};
  shared_ptr<long> useDmsDmlUnlock{};
  shared_ptr<long> useDmsToolkit{};

  GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult() {}

  explicit GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mustImprove) {
      res["MustImprove"] = boost::any(*mustImprove);
    }
    if (potentialIssue) {
      res["PotentialIssue"] = boost::any(*potentialIssue);
    }
    if (suggestImprove) {
      res["SuggestImprove"] = boost::any(*suggestImprove);
    }
    if (tableIndexSuggest) {
      res["TableIndexSuggest"] = boost::any(*tableIndexSuggest);
    }
    if (useDmsDmlUnlock) {
      res["UseDmsDmlUnlock"] = boost::any(*useDmsDmlUnlock);
    }
    if (useDmsToolkit) {
      res["UseDmsToolkit"] = boost::any(*useDmsToolkit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MustImprove") != m.end() && !m["MustImprove"].empty()) {
      mustImprove = make_shared<long>(boost::any_cast<long>(m["MustImprove"]));
    }
    if (m.find("PotentialIssue") != m.end() && !m["PotentialIssue"].empty()) {
      potentialIssue = make_shared<long>(boost::any_cast<long>(m["PotentialIssue"]));
    }
    if (m.find("SuggestImprove") != m.end() && !m["SuggestImprove"].empty()) {
      suggestImprove = make_shared<long>(boost::any_cast<long>(m["SuggestImprove"]));
    }
    if (m.find("TableIndexSuggest") != m.end() && !m["TableIndexSuggest"].empty()) {
      tableIndexSuggest = make_shared<long>(boost::any_cast<long>(m["TableIndexSuggest"]));
    }
    if (m.find("UseDmsDmlUnlock") != m.end() && !m["UseDmsDmlUnlock"].empty()) {
      useDmsDmlUnlock = make_shared<long>(boost::any_cast<long>(m["UseDmsDmlUnlock"]));
    }
    if (m.find("UseDmsToolkit") != m.end() && !m["UseDmsToolkit"].empty()) {
      useDmsToolkit = make_shared<long>(boost::any_cast<long>(m["UseDmsToolkit"]));
    }
  }


  virtual ~GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult() = default;
};
class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus : public Darabonba::Model {
public:
  shared_ptr<GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult> checkStatusResult{};
  shared_ptr<long> checkedCount{};
  shared_ptr<GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult> SQLReviewResult{};
  shared_ptr<long> totalSQLCount{};

  GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus() {}

  explicit GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStatusResult) {
      res["CheckStatusResult"] = checkStatusResult ? boost::any(checkStatusResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (checkedCount) {
      res["CheckedCount"] = boost::any(*checkedCount);
    }
    if (SQLReviewResult) {
      res["SQLReviewResult"] = SQLReviewResult ? boost::any(SQLReviewResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalSQLCount) {
      res["TotalSQLCount"] = boost::any(*totalSQLCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckStatusResult") != m.end() && !m["CheckStatusResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckStatusResult"].type()) {
        GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckStatusResult"]));
        checkStatusResult = make_shared<GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult>(model1);
      }
    }
    if (m.find("CheckedCount") != m.end() && !m["CheckedCount"].empty()) {
      checkedCount = make_shared<long>(boost::any_cast<long>(m["CheckedCount"]));
    }
    if (m.find("SQLReviewResult") != m.end() && !m["SQLReviewResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["SQLReviewResult"].type()) {
        GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SQLReviewResult"]));
        SQLReviewResult = make_shared<GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult>(model1);
      }
    }
    if (m.find("TotalSQLCount") != m.end() && !m["TotalSQLCount"].empty()) {
      totalSQLCount = make_shared<long>(boost::any_cast<long>(m["TotalSQLCount"]));
    }
  }


  virtual ~GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus() = default;
};
class GetSQLReviewCheckResultStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus> checkResultStatus{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSQLReviewCheckResultStatusResponseBody() {}

  explicit GetSQLReviewCheckResultStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkResultStatus) {
      res["CheckResultStatus"] = checkResultStatus ? boost::any(checkResultStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckResultStatus") != m.end() && !m["CheckResultStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckResultStatus"].type()) {
        GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckResultStatus"]));
        checkResultStatus = make_shared<GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSQLReviewCheckResultStatusResponseBody() = default;
};
class GetSQLReviewCheckResultStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSQLReviewCheckResultStatusResponseBody> body{};

  GetSQLReviewCheckResultStatusResponse() {}

  explicit GetSQLReviewCheckResultStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSQLReviewCheckResultStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSQLReviewCheckResultStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetSQLReviewCheckResultStatusResponse() = default;
};
class GetSQLReviewOptimizeDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> SQLReviewQueryKey{};
  shared_ptr<long> tid{};

  GetSQLReviewOptimizeDetailRequest() {}

  explicit GetSQLReviewOptimizeDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLReviewQueryKey) {
      res["SQLReviewQueryKey"] = boost::any(*SQLReviewQueryKey);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLReviewQueryKey") != m.end() && !m["SQLReviewQueryKey"].empty()) {
      SQLReviewQueryKey = make_shared<string>(boost::any_cast<string>(m["SQLReviewQueryKey"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetSQLReviewOptimizeDetailRequest() = default;
};
class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> opType{};
  shared_ptr<string> tableName{};

  GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts() {}

  explicit GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts() = default;
};
class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults : public Darabonba::Model {
public:
  shared_ptr<string> comments{};
  shared_ptr<string> feedback{};
  shared_ptr<vector<string>> messages{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleType{};
  shared_ptr<vector<GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts>> scripts{};

  GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults() {}

  explicit GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comments) {
      res["Comments"] = boost::any(*comments);
    }
    if (feedback) {
      res["Feedback"] = boost::any(*feedback);
    }
    if (messages) {
      res["Messages"] = boost::any(*messages);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (scripts) {
      vector<boost::any> temp1;
      for(auto item1:*scripts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Scripts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comments") != m.end() && !m["Comments"].empty()) {
      comments = make_shared<string>(boost::any_cast<string>(m["Comments"]));
    }
    if (m.find("Feedback") != m.end() && !m["Feedback"].empty()) {
      feedback = make_shared<string>(boost::any_cast<string>(m["Feedback"]));
    }
    if (m.find("Messages") != m.end() && !m["Messages"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Messages"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Messages"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      messages = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("Scripts") != m.end() && !m["Scripts"].empty()) {
      if (typeid(vector<boost::any>) == m["Scripts"].type()) {
        vector<GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Scripts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scripts = make_shared<vector<GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts>>(expect1);
      }
    }
  }


  virtual ~GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults() = default;
};
class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> occurError{};
  shared_ptr<vector<GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults>> results{};

  GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult() {}

  explicit GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (occurError) {
      res["OccurError"] = boost::any(*occurError);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("OccurError") != m.end() && !m["OccurError"].empty()) {
      occurError = make_shared<bool>(boost::any_cast<bool>(m["OccurError"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults>>(expect1);
      }
    }
  }


  virtual ~GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult() = default;
};
class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<long> instanceId{};
  shared_ptr<GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult> qualityResult{};
  shared_ptr<string> queryKey{};
  shared_ptr<string> sqlType{};

  GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail() {}

  explicit GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (qualityResult) {
      res["QualityResult"] = qualityResult ? boost::any(qualityResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queryKey) {
      res["QueryKey"] = boost::any(*queryKey);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("QualityResult") != m.end() && !m["QualityResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["QualityResult"].type()) {
        GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QualityResult"]));
        qualityResult = make_shared<GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult>(model1);
      }
    }
    if (m.find("QueryKey") != m.end() && !m["QueryKey"].empty()) {
      queryKey = make_shared<string>(boost::any_cast<string>(m["QueryKey"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
  }


  virtual ~GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail() = default;
};
class GetSQLReviewOptimizeDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail> optimizeDetail{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSQLReviewOptimizeDetailResponseBody() {}

  explicit GetSQLReviewOptimizeDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (optimizeDetail) {
      res["OptimizeDetail"] = optimizeDetail ? boost::any(optimizeDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("OptimizeDetail") != m.end() && !m["OptimizeDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["OptimizeDetail"].type()) {
        GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OptimizeDetail"]));
        optimizeDetail = make_shared<GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSQLReviewOptimizeDetailResponseBody() = default;
};
class GetSQLReviewOptimizeDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSQLReviewOptimizeDetailResponseBody> body{};

  GetSQLReviewOptimizeDetailResponse() {}

  explicit GetSQLReviewOptimizeDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSQLReviewOptimizeDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSQLReviewOptimizeDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetSQLReviewOptimizeDetailResponse() = default;
};
class GetStandardGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<long> tid{};

  GetStandardGroupRequest() {}

  explicit GetStandardGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetStandardGroupRequest() = default;
};
class GetStandardGroupResponseBodyStandardGroup : public Darabonba::Model {
public:
  shared_ptr<string> dbType{};
  shared_ptr<string> description{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupMode{};
  shared_ptr<string> groupName{};
  shared_ptr<long> lastMenderId{};

  GetStandardGroupResponseBodyStandardGroup() {}

  explicit GetStandardGroupResponseBodyStandardGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupMode) {
      res["GroupMode"] = boost::any(*groupMode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lastMenderId) {
      res["LastMenderId"] = boost::any(*lastMenderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupMode") != m.end() && !m["GroupMode"].empty()) {
      groupMode = make_shared<string>(boost::any_cast<string>(m["GroupMode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LastMenderId") != m.end() && !m["LastMenderId"].empty()) {
      lastMenderId = make_shared<long>(boost::any_cast<long>(m["LastMenderId"]));
    }
  }


  virtual ~GetStandardGroupResponseBodyStandardGroup() = default;
};
class GetStandardGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetStandardGroupResponseBodyStandardGroup> standardGroup{};
  shared_ptr<bool> success{};

  GetStandardGroupResponseBody() {}

  explicit GetStandardGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (standardGroup) {
      res["StandardGroup"] = standardGroup ? boost::any(standardGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StandardGroup") != m.end() && !m["StandardGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["StandardGroup"].type()) {
        GetStandardGroupResponseBodyStandardGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StandardGroup"]));
        standardGroup = make_shared<GetStandardGroupResponseBodyStandardGroup>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetStandardGroupResponseBody() = default;
};
class GetStandardGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetStandardGroupResponseBody> body{};

  GetStandardGroupResponse() {}

  explicit GetStandardGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetStandardGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetStandardGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetStandardGroupResponse() = default;
};
class GetStructSyncExecSqlDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tid{};

  GetStructSyncExecSqlDetailRequest() {}

  explicit GetStructSyncExecSqlDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetStructSyncExecSqlDetailRequest() = default;
};
class GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail : public Darabonba::Model {
public:
  shared_ptr<string> execSql{};
  shared_ptr<long> totalSqlCount{};

  GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail() {}

  explicit GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (execSql) {
      res["ExecSql"] = boost::any(*execSql);
    }
    if (totalSqlCount) {
      res["TotalSqlCount"] = boost::any(*totalSqlCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecSql") != m.end() && !m["ExecSql"].empty()) {
      execSql = make_shared<string>(boost::any_cast<string>(m["ExecSql"]));
    }
    if (m.find("TotalSqlCount") != m.end() && !m["TotalSqlCount"].empty()) {
      totalSqlCount = make_shared<long>(boost::any_cast<long>(m["TotalSqlCount"]));
    }
  }


  virtual ~GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail() = default;
};
class GetStructSyncExecSqlDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail> structSyncExecSqlDetail{};
  shared_ptr<bool> success{};

  GetStructSyncExecSqlDetailResponseBody() {}

  explicit GetStructSyncExecSqlDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (structSyncExecSqlDetail) {
      res["StructSyncExecSqlDetail"] = structSyncExecSqlDetail ? boost::any(structSyncExecSqlDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StructSyncExecSqlDetail") != m.end() && !m["StructSyncExecSqlDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructSyncExecSqlDetail"].type()) {
        GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructSyncExecSqlDetail"]));
        structSyncExecSqlDetail = make_shared<GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetStructSyncExecSqlDetailResponseBody() = default;
};
class GetStructSyncExecSqlDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetStructSyncExecSqlDetailResponseBody> body{};

  GetStructSyncExecSqlDetailResponse() {}

  explicit GetStructSyncExecSqlDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetStructSyncExecSqlDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetStructSyncExecSqlDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetStructSyncExecSqlDetailResponse() = default;
};
class GetStructSyncJobAnalyzeResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> compareType{};
  shared_ptr<long> orderId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tid{};

  GetStructSyncJobAnalyzeResultRequest() {}

  explicit GetStructSyncJobAnalyzeResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compareType) {
      res["CompareType"] = boost::any(*compareType);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompareType") != m.end() && !m["CompareType"].empty()) {
      compareType = make_shared<string>(boost::any_cast<string>(m["CompareType"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetStructSyncJobAnalyzeResultRequest() = default;
};
class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList : public Darabonba::Model {
public:
  shared_ptr<string> script{};
  shared_ptr<string> sourceTableName{};
  shared_ptr<string> targetTableName{};

  GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList() {}

  explicit GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    if (targetTableName) {
      res["TargetTableName"] = boost::any(*targetTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
    if (m.find("TargetTableName") != m.end() && !m["TargetTableName"].empty()) {
      targetTableName = make_shared<string>(boost::any_cast<string>(m["TargetTableName"]));
    }
  }


  virtual ~GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList() = default;
};
class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList : public Darabonba::Model {
public:
  shared_ptr<string> compareType{};
  shared_ptr<long> count{};

  GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList() {}

  explicit GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compareType) {
      res["CompareType"] = boost::any(*compareType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompareType") != m.end() && !m["CompareType"].empty()) {
      compareType = make_shared<string>(boost::any_cast<string>(m["CompareType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList() = default;
};
class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList>> resultList{};
  shared_ptr<vector<GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList>> summaryList{};

  GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult() {}

  explicit GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultList) {
      vector<boost::any> temp1;
      for(auto item1:*resultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResultList"] = boost::any(temp1);
    }
    if (summaryList) {
      vector<boost::any> temp1;
      for(auto item1:*summaryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SummaryList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultList") != m.end() && !m["ResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResultList"].type()) {
        vector<GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultList = make_shared<vector<GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList>>(expect1);
      }
    }
    if (m.find("SummaryList") != m.end() && !m["SummaryList"].empty()) {
      if (typeid(vector<boost::any>) == m["SummaryList"].type()) {
        vector<GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SummaryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summaryList = make_shared<vector<GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList>>(expect1);
      }
    }
  }


  virtual ~GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult() = default;
};
class GetStructSyncJobAnalyzeResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult> structSyncJobAnalyzeResult{};
  shared_ptr<bool> success{};

  GetStructSyncJobAnalyzeResultResponseBody() {}

  explicit GetStructSyncJobAnalyzeResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (structSyncJobAnalyzeResult) {
      res["StructSyncJobAnalyzeResult"] = structSyncJobAnalyzeResult ? boost::any(structSyncJobAnalyzeResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StructSyncJobAnalyzeResult") != m.end() && !m["StructSyncJobAnalyzeResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructSyncJobAnalyzeResult"].type()) {
        GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructSyncJobAnalyzeResult"]));
        structSyncJobAnalyzeResult = make_shared<GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetStructSyncJobAnalyzeResultResponseBody() = default;
};
class GetStructSyncJobAnalyzeResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetStructSyncJobAnalyzeResultResponseBody> body{};

  GetStructSyncJobAnalyzeResultResponse() {}

  explicit GetStructSyncJobAnalyzeResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetStructSyncJobAnalyzeResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetStructSyncJobAnalyzeResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetStructSyncJobAnalyzeResultResponse() = default;
};
class GetStructSyncJobDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetStructSyncJobDetailRequest() {}

  explicit GetStructSyncJobDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetStructSyncJobDetailRequest() = default;
};
class GetStructSyncJobDetailResponseBodyStructSyncJobDetail : public Darabonba::Model {
public:
  shared_ptr<long> DBTaskGroupId{};
  shared_ptr<long> executeCount{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> message{};
  shared_ptr<string> securityRule{};
  shared_ptr<long> sqlCount{};
  shared_ptr<long> tableAnalyzed{};
  shared_ptr<long> tableCount{};

  GetStructSyncJobDetailResponseBodyStructSyncJobDetail() {}

  explicit GetStructSyncJobDetailResponseBodyStructSyncJobDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBTaskGroupId) {
      res["DBTaskGroupId"] = boost::any(*DBTaskGroupId);
    }
    if (executeCount) {
      res["ExecuteCount"] = boost::any(*executeCount);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (securityRule) {
      res["SecurityRule"] = boost::any(*securityRule);
    }
    if (sqlCount) {
      res["SqlCount"] = boost::any(*sqlCount);
    }
    if (tableAnalyzed) {
      res["TableAnalyzed"] = boost::any(*tableAnalyzed);
    }
    if (tableCount) {
      res["TableCount"] = boost::any(*tableCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBTaskGroupId") != m.end() && !m["DBTaskGroupId"].empty()) {
      DBTaskGroupId = make_shared<long>(boost::any_cast<long>(m["DBTaskGroupId"]));
    }
    if (m.find("ExecuteCount") != m.end() && !m["ExecuteCount"].empty()) {
      executeCount = make_shared<long>(boost::any_cast<long>(m["ExecuteCount"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("SecurityRule") != m.end() && !m["SecurityRule"].empty()) {
      securityRule = make_shared<string>(boost::any_cast<string>(m["SecurityRule"]));
    }
    if (m.find("SqlCount") != m.end() && !m["SqlCount"].empty()) {
      sqlCount = make_shared<long>(boost::any_cast<long>(m["SqlCount"]));
    }
    if (m.find("TableAnalyzed") != m.end() && !m["TableAnalyzed"].empty()) {
      tableAnalyzed = make_shared<long>(boost::any_cast<long>(m["TableAnalyzed"]));
    }
    if (m.find("TableCount") != m.end() && !m["TableCount"].empty()) {
      tableCount = make_shared<long>(boost::any_cast<long>(m["TableCount"]));
    }
  }


  virtual ~GetStructSyncJobDetailResponseBodyStructSyncJobDetail() = default;
};
class GetStructSyncJobDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetStructSyncJobDetailResponseBodyStructSyncJobDetail> structSyncJobDetail{};
  shared_ptr<bool> success{};

  GetStructSyncJobDetailResponseBody() {}

  explicit GetStructSyncJobDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (structSyncJobDetail) {
      res["StructSyncJobDetail"] = structSyncJobDetail ? boost::any(structSyncJobDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StructSyncJobDetail") != m.end() && !m["StructSyncJobDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructSyncJobDetail"].type()) {
        GetStructSyncJobDetailResponseBodyStructSyncJobDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructSyncJobDetail"]));
        structSyncJobDetail = make_shared<GetStructSyncJobDetailResponseBodyStructSyncJobDetail>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetStructSyncJobDetailResponseBody() = default;
};
class GetStructSyncJobDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetStructSyncJobDetailResponseBody> body{};

  GetStructSyncJobDetailResponse() {}

  explicit GetStructSyncJobDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetStructSyncJobDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetStructSyncJobDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetStructSyncJobDetailResponse() = default;
};
class GetStructSyncOrderDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  GetStructSyncOrderDetailRequest() {}

  explicit GetStructSyncOrderDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetStructSyncOrderDetailRequest() = default;
};
class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<bool> logic{};
  shared_ptr<string> searchName{};

  GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo() {}

  explicit GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo() = default;
};
class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo : public Darabonba::Model {
public:
  shared_ptr<string> versionId{};

  GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo() {}

  explicit GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo() = default;
};
class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList : public Darabonba::Model {
public:
  shared_ptr<string> sourceTableName{};
  shared_ptr<string> targetTableName{};

  GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList() {}

  explicit GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    if (targetTableName) {
      res["TargetTableName"] = boost::any(*targetTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
    if (m.find("TargetTableName") != m.end() && !m["TargetTableName"].empty()) {
      targetTableName = make_shared<string>(boost::any_cast<string>(m["TargetTableName"]));
    }
  }


  virtual ~GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList() = default;
};
class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<bool> logic{};
  shared_ptr<string> searchName{};

  GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo() {}

  explicit GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo() = default;
};
class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo : public Darabonba::Model {
public:
  shared_ptr<string> versionId{};

  GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo() {}

  explicit GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo() = default;
};
class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreError{};
  shared_ptr<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo> sourceDatabaseInfo{};
  shared_ptr<string> sourceType{};
  shared_ptr<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo> sourceVersionInfo{};
  shared_ptr<vector<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList>> tableInfoList{};
  shared_ptr<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo> targetDatabaseInfo{};
  shared_ptr<string> targetType{};
  shared_ptr<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo> targetVersionInfo{};

  GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail() {}

  explicit GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreError) {
      res["IgnoreError"] = boost::any(*ignoreError);
    }
    if (sourceDatabaseInfo) {
      res["SourceDatabaseInfo"] = sourceDatabaseInfo ? boost::any(sourceDatabaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceVersionInfo) {
      res["SourceVersionInfo"] = sourceVersionInfo ? boost::any(sourceVersionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*tableInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableInfoList"] = boost::any(temp1);
    }
    if (targetDatabaseInfo) {
      res["TargetDatabaseInfo"] = targetDatabaseInfo ? boost::any(targetDatabaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (targetVersionInfo) {
      res["TargetVersionInfo"] = targetVersionInfo ? boost::any(targetVersionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreError") != m.end() && !m["IgnoreError"].empty()) {
      ignoreError = make_shared<bool>(boost::any_cast<bool>(m["IgnoreError"]));
    }
    if (m.find("SourceDatabaseInfo") != m.end() && !m["SourceDatabaseInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceDatabaseInfo"].type()) {
        GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceDatabaseInfo"]));
        sourceDatabaseInfo = make_shared<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo>(model1);
      }
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceVersionInfo") != m.end() && !m["SourceVersionInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceVersionInfo"].type()) {
        GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceVersionInfo"]));
        sourceVersionInfo = make_shared<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo>(model1);
      }
    }
    if (m.find("TableInfoList") != m.end() && !m["TableInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableInfoList"].type()) {
        vector<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableInfoList = make_shared<vector<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList>>(expect1);
      }
    }
    if (m.find("TargetDatabaseInfo") != m.end() && !m["TargetDatabaseInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetDatabaseInfo"].type()) {
        GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetDatabaseInfo"]));
        targetDatabaseInfo = make_shared<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo>(model1);
      }
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TargetVersionInfo") != m.end() && !m["TargetVersionInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetVersionInfo"].type()) {
        GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetVersionInfo"]));
        targetVersionInfo = make_shared<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo>(model1);
      }
    }
  }


  virtual ~GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail() = default;
};
class GetStructSyncOrderDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail> structSyncOrderDetail{};
  shared_ptr<bool> success{};

  GetStructSyncOrderDetailResponseBody() {}

  explicit GetStructSyncOrderDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (structSyncOrderDetail) {
      res["StructSyncOrderDetail"] = structSyncOrderDetail ? boost::any(structSyncOrderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StructSyncOrderDetail") != m.end() && !m["StructSyncOrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructSyncOrderDetail"].type()) {
        GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructSyncOrderDetail"]));
        structSyncOrderDetail = make_shared<GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetStructSyncOrderDetailResponseBody() = default;
};
class GetStructSyncOrderDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetStructSyncOrderDetailResponseBody> body{};

  GetStructSyncOrderDetailResponse() {}

  explicit GetStructSyncOrderDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetStructSyncOrderDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetStructSyncOrderDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetStructSyncOrderDetailResponse() = default;
};
class GetTableDBTopologyRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<long> tid{};

  GetTableDBTopologyRequest() {}

  explicit GetTableDBTopologyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetTableDBTopologyRequest() = default;
};
class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList : public Darabonba::Model {
public:
  shared_ptr<string> tableId{};
  shared_ptr<string> tableName{};
  shared_ptr<string> tableType{};

  GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList() {}

  explicit GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableType) {
      res["TableType"] = boost::any(*tableType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableType") != m.end() && !m["TableType"].empty()) {
      tableType = make_shared<string>(boost::any_cast<string>(m["TableType"]));
    }
  }


  virtual ~GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList() = default;
};
class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList : public Darabonba::Model {
public:
  shared_ptr<string> dbId{};
  shared_ptr<string> dbName{};
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<vector<GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList>> tableList{};

  GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList() {}

  explicit GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (tableList) {
      vector<boost::any> temp1;
      for(auto item1:*tableList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<string>(boost::any_cast<string>(m["DbId"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("TableList") != m.end() && !m["TableList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableList"].type()) {
        vector<GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableList = make_shared<vector<GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList>>(expect1);
      }
    }
  }


  virtual ~GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList() = default;
};
class GetTableDBTopologyResponseBodyDBTopologyDataSourceList : public Darabonba::Model {
public:
  shared_ptr<vector<GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList>> databaseList{};
  shared_ptr<string> dbType{};
  shared_ptr<string> host{};
  shared_ptr<long> port{};
  shared_ptr<string> sid{};

  GetTableDBTopologyResponseBodyDBTopologyDataSourceList() {}

  explicit GetTableDBTopologyResponseBodyDBTopologyDataSourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseList) {
      vector<boost::any> temp1;
      for(auto item1:*databaseList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseList"] = boost::any(temp1);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseList") != m.end() && !m["DatabaseList"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseList"].type()) {
        vector<GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseList = make_shared<vector<GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList>>(expect1);
      }
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
  }


  virtual ~GetTableDBTopologyResponseBodyDBTopologyDataSourceList() = default;
};
class GetTableDBTopologyResponseBodyDBTopology : public Darabonba::Model {
public:
  shared_ptr<vector<GetTableDBTopologyResponseBodyDBTopologyDataSourceList>> dataSourceList{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> tableName{};

  GetTableDBTopologyResponseBodyDBTopology() {}

  explicit GetTableDBTopologyResponseBodyDBTopology(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceList) {
      vector<boost::any> temp1;
      for(auto item1:*dataSourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSourceList"] = boost::any(temp1);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceList") != m.end() && !m["DataSourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSourceList"].type()) {
        vector<GetTableDBTopologyResponseBodyDBTopologyDataSourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTableDBTopologyResponseBodyDBTopologyDataSourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSourceList = make_shared<vector<GetTableDBTopologyResponseBodyDBTopologyDataSourceList>>(expect1);
      }
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~GetTableDBTopologyResponseBodyDBTopology() = default;
};
class GetTableDBTopologyResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetTableDBTopologyResponseBodyDBTopology> DBTopology{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetTableDBTopologyResponseBody() {}

  explicit GetTableDBTopologyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBTopology) {
      res["DBTopology"] = DBTopology ? boost::any(DBTopology->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBTopology") != m.end() && !m["DBTopology"].empty()) {
      if (typeid(map<string, boost::any>) == m["DBTopology"].type()) {
        GetTableDBTopologyResponseBodyDBTopology model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DBTopology"]));
        DBTopology = make_shared<GetTableDBTopologyResponseBodyDBTopology>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetTableDBTopologyResponseBody() = default;
};
class GetTableDBTopologyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTableDBTopologyResponseBody> body{};

  GetTableDBTopologyResponse() {}

  explicit GetTableDBTopologyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTableDBTopologyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTableDBTopologyResponseBody>(model1);
      }
    }
  }


  virtual ~GetTableDBTopologyResponse() = default;
};
class GetTableTopologyRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<long> tid{};

  GetTableTopologyRequest() {}

  explicit GetTableTopologyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetTableTopologyRequest() = default;
};
class GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<string> dbName{};
  shared_ptr<string> dbSearchName{};
  shared_ptr<string> dbType{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceResourceId{};
  shared_ptr<string> instanceSource{};
  shared_ptr<string> regionId{};
  shared_ptr<long> tableCount{};
  shared_ptr<string> tableNameExpr{};
  shared_ptr<string> tableNameList{};

  GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList() {}

  explicit GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (dbSearchName) {
      res["DbSearchName"] = boost::any(*dbSearchName);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceResourceId) {
      res["InstanceResourceId"] = boost::any(*instanceResourceId);
    }
    if (instanceSource) {
      res["InstanceSource"] = boost::any(*instanceSource);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tableCount) {
      res["TableCount"] = boost::any(*tableCount);
    }
    if (tableNameExpr) {
      res["TableNameExpr"] = boost::any(*tableNameExpr);
    }
    if (tableNameList) {
      res["TableNameList"] = boost::any(*tableNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DbSearchName") != m.end() && !m["DbSearchName"].empty()) {
      dbSearchName = make_shared<string>(boost::any_cast<string>(m["DbSearchName"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceResourceId") != m.end() && !m["InstanceResourceId"].empty()) {
      instanceResourceId = make_shared<string>(boost::any_cast<string>(m["InstanceResourceId"]));
    }
    if (m.find("InstanceSource") != m.end() && !m["InstanceSource"].empty()) {
      instanceSource = make_shared<string>(boost::any_cast<string>(m["InstanceSource"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TableCount") != m.end() && !m["TableCount"].empty()) {
      tableCount = make_shared<long>(boost::any_cast<long>(m["TableCount"]));
    }
    if (m.find("TableNameExpr") != m.end() && !m["TableNameExpr"].empty()) {
      tableNameExpr = make_shared<string>(boost::any_cast<string>(m["TableNameExpr"]));
    }
    if (m.find("TableNameList") != m.end() && !m["TableNameList"].empty()) {
      tableNameList = make_shared<string>(boost::any_cast<string>(m["TableNameList"]));
    }
  }


  virtual ~GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList() = default;
};
class GetTableTopologyResponseBodyTableTopology : public Darabonba::Model {
public:
  shared_ptr<bool> logic{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> tableName{};
  shared_ptr<vector<GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList>> tableTopologyInfoList{};

  GetTableTopologyResponseBodyTableTopology() {}

  explicit GetTableTopologyResponseBodyTableTopology(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableTopologyInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*tableTopologyInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableTopologyInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableTopologyInfoList") != m.end() && !m["TableTopologyInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableTopologyInfoList"].type()) {
        vector<GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableTopologyInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableTopologyInfoList = make_shared<vector<GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList>>(expect1);
      }
    }
  }


  virtual ~GetTableTopologyResponseBodyTableTopology() = default;
};
class GetTableTopologyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetTableTopologyResponseBodyTableTopology> tableTopology{};

  GetTableTopologyResponseBody() {}

  explicit GetTableTopologyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tableTopology) {
      res["TableTopology"] = tableTopology ? boost::any(tableTopology->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TableTopology") != m.end() && !m["TableTopology"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableTopology"].type()) {
        GetTableTopologyResponseBodyTableTopology model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableTopology"]));
        tableTopology = make_shared<GetTableTopologyResponseBodyTableTopology>(model1);
      }
    }
  }


  virtual ~GetTableTopologyResponseBody() = default;
};
class GetTableTopologyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTableTopologyResponseBody> body{};

  GetTableTopologyResponse() {}

  explicit GetTableTopologyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTableTopologyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTableTopologyResponseBody>(model1);
      }
    }
  }


  virtual ~GetTableTopologyResponse() = default;
};
class GetTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<long> tid{};

  GetTaskRequest() {}

  explicit GetTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetTaskRequest() = default;
};
class GetTaskResponseBodyTask : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> graphParam{};
  shared_ptr<string> nodeConfig{};
  shared_ptr<string> nodeContent{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> nodeOutput{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> timeVariables{};

  GetTaskResponseBodyTask() {}

  explicit GetTaskResponseBodyTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (graphParam) {
      res["GraphParam"] = boost::any(*graphParam);
    }
    if (nodeConfig) {
      res["NodeConfig"] = boost::any(*nodeConfig);
    }
    if (nodeContent) {
      res["NodeContent"] = boost::any(*nodeContent);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeOutput) {
      res["NodeOutput"] = boost::any(*nodeOutput);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (timeVariables) {
      res["TimeVariables"] = boost::any(*timeVariables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("GraphParam") != m.end() && !m["GraphParam"].empty()) {
      graphParam = make_shared<string>(boost::any_cast<string>(m["GraphParam"]));
    }
    if (m.find("NodeConfig") != m.end() && !m["NodeConfig"].empty()) {
      nodeConfig = make_shared<string>(boost::any_cast<string>(m["NodeConfig"]));
    }
    if (m.find("NodeContent") != m.end() && !m["NodeContent"].empty()) {
      nodeContent = make_shared<string>(boost::any_cast<string>(m["NodeContent"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeOutput") != m.end() && !m["NodeOutput"].empty()) {
      nodeOutput = make_shared<string>(boost::any_cast<string>(m["NodeOutput"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("TimeVariables") != m.end() && !m["TimeVariables"].empty()) {
      timeVariables = make_shared<string>(boost::any_cast<string>(m["TimeVariables"]));
    }
  }


  virtual ~GetTaskResponseBodyTask() = default;
};
class GetTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetTaskResponseBodyTask> task{};

  GetTaskResponseBody() {}

  explicit GetTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        GetTaskResponseBodyTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<GetTaskResponseBodyTask>(model1);
      }
    }
  }


  virtual ~GetTaskResponseBody() = default;
};
class GetTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskResponseBody> body{};

  GetTaskResponse() {}

  explicit GetTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskResponse() = default;
};
class GetTaskFlowGraphRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  GetTaskFlowGraphRequest() {}

  explicit GetTaskFlowGraphRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetTaskFlowGraphRequest() = default;
};
class GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> id{};
  shared_ptr<long> nodeEnd{};
  shared_ptr<long> nodeFrom{};

  GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge() {}

  explicit GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nodeEnd) {
      res["NodeEnd"] = boost::any(*nodeEnd);
    }
    if (nodeFrom) {
      res["NodeFrom"] = boost::any(*nodeFrom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NodeEnd") != m.end() && !m["NodeEnd"].empty()) {
      nodeEnd = make_shared<long>(boost::any_cast<long>(m["NodeEnd"]));
    }
    if (m.find("NodeFrom") != m.end() && !m["NodeFrom"].empty()) {
      nodeFrom = make_shared<long>(boost::any_cast<long>(m["NodeFrom"]));
    }
  }


  virtual ~GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge() = default;
};
class GetTaskFlowGraphResponseBodyTaskFlowGraphEdges : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge>> edge{};

  GetTaskFlowGraphResponseBodyTaskFlowGraphEdges() {}

  explicit GetTaskFlowGraphResponseBodyTaskFlowGraphEdges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edge) {
      vector<boost::any> temp1;
      for(auto item1:*edge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Edge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edge") != m.end() && !m["Edge"].empty()) {
      if (typeid(vector<boost::any>) == m["Edge"].type()) {
        vector<GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Edge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        edge = make_shared<vector<GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge>>(expect1);
      }
    }
  }


  virtual ~GetTaskFlowGraphResponseBodyTaskFlowGraphEdges() = default;
};
class GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> graphParam{};
  shared_ptr<string> nodeConfig{};
  shared_ptr<string> nodeContent{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> nodeType{};
  shared_ptr<string> timeVariables{};

  GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode() {}

  explicit GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (graphParam) {
      res["GraphParam"] = boost::any(*graphParam);
    }
    if (nodeConfig) {
      res["NodeConfig"] = boost::any(*nodeConfig);
    }
    if (nodeContent) {
      res["NodeContent"] = boost::any(*nodeContent);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (timeVariables) {
      res["TimeVariables"] = boost::any(*timeVariables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("GraphParam") != m.end() && !m["GraphParam"].empty()) {
      graphParam = make_shared<string>(boost::any_cast<string>(m["GraphParam"]));
    }
    if (m.find("NodeConfig") != m.end() && !m["NodeConfig"].empty()) {
      nodeConfig = make_shared<string>(boost::any_cast<string>(m["NodeConfig"]));
    }
    if (m.find("NodeContent") != m.end() && !m["NodeContent"].empty()) {
      nodeContent = make_shared<string>(boost::any_cast<string>(m["NodeContent"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("TimeVariables") != m.end() && !m["TimeVariables"].empty()) {
      timeVariables = make_shared<string>(boost::any_cast<string>(m["TimeVariables"]));
    }
  }


  virtual ~GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode() = default;
};
class GetTaskFlowGraphResponseBodyTaskFlowGraphNodes : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode>> node{};

  GetTaskFlowGraphResponseBodyTaskFlowGraphNodes() {}

  explicit GetTaskFlowGraphResponseBodyTaskFlowGraphNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (node) {
      vector<boost::any> temp1;
      for(auto item1:*node){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Node"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(vector<boost::any>) == m["Node"].type()) {
        vector<GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Node"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        node = make_shared<vector<GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode>>(expect1);
      }
    }
  }


  virtual ~GetTaskFlowGraphResponseBodyTaskFlowGraphNodes() = default;
};
class GetTaskFlowGraphResponseBodyTaskFlowGraph : public Darabonba::Model {
public:
  shared_ptr<bool> canEdit{};
  shared_ptr<string> dagName{};
  shared_ptr<GetTaskFlowGraphResponseBodyTaskFlowGraphEdges> edges{};
  shared_ptr<GetTaskFlowGraphResponseBodyTaskFlowGraphNodes> nodes{};
  shared_ptr<long> status{};

  GetTaskFlowGraphResponseBodyTaskFlowGraph() {}

  explicit GetTaskFlowGraphResponseBodyTaskFlowGraph(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canEdit) {
      res["CanEdit"] = boost::any(*canEdit);
    }
    if (dagName) {
      res["DagName"] = boost::any(*dagName);
    }
    if (edges) {
      res["Edges"] = edges ? boost::any(edges->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodes) {
      res["Nodes"] = nodes ? boost::any(nodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanEdit") != m.end() && !m["CanEdit"].empty()) {
      canEdit = make_shared<bool>(boost::any_cast<bool>(m["CanEdit"]));
    }
    if (m.find("DagName") != m.end() && !m["DagName"].empty()) {
      dagName = make_shared<string>(boost::any_cast<string>(m["DagName"]));
    }
    if (m.find("Edges") != m.end() && !m["Edges"].empty()) {
      if (typeid(map<string, boost::any>) == m["Edges"].type()) {
        GetTaskFlowGraphResponseBodyTaskFlowGraphEdges model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Edges"]));
        edges = make_shared<GetTaskFlowGraphResponseBodyTaskFlowGraphEdges>(model1);
      }
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Nodes"].type()) {
        GetTaskFlowGraphResponseBodyTaskFlowGraphNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Nodes"]));
        nodes = make_shared<GetTaskFlowGraphResponseBodyTaskFlowGraphNodes>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetTaskFlowGraphResponseBodyTaskFlowGraph() = default;
};
class GetTaskFlowGraphResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetTaskFlowGraphResponseBodyTaskFlowGraph> taskFlowGraph{};

  GetTaskFlowGraphResponseBody() {}

  explicit GetTaskFlowGraphResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskFlowGraph) {
      res["TaskFlowGraph"] = taskFlowGraph ? boost::any(taskFlowGraph->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskFlowGraph") != m.end() && !m["TaskFlowGraph"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskFlowGraph"].type()) {
        GetTaskFlowGraphResponseBodyTaskFlowGraph model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskFlowGraph"]));
        taskFlowGraph = make_shared<GetTaskFlowGraphResponseBodyTaskFlowGraph>(model1);
      }
    }
  }


  virtual ~GetTaskFlowGraphResponseBody() = default;
};
class GetTaskFlowGraphResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskFlowGraphResponseBody> body{};

  GetTaskFlowGraphResponse() {}

  explicit GetTaskFlowGraphResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskFlowGraphResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskFlowGraphResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskFlowGraphResponse() = default;
};
class GetTaskFlowNotificationRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  GetTaskFlowNotificationRequest() {}

  explicit GetTaskFlowNotificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetTaskFlowNotificationRequest() = default;
};
class GetTaskFlowNotificationResponseBodyNotification : public Darabonba::Model {
public:
  shared_ptr<bool> dagNotificationFail{};
  shared_ptr<bool> dagNotificationSla{};
  shared_ptr<bool> dagNotificationSuccess{};

  GetTaskFlowNotificationResponseBodyNotification() {}

  explicit GetTaskFlowNotificationResponseBodyNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagNotificationFail) {
      res["DagNotificationFail"] = boost::any(*dagNotificationFail);
    }
    if (dagNotificationSla) {
      res["DagNotificationSla"] = boost::any(*dagNotificationSla);
    }
    if (dagNotificationSuccess) {
      res["DagNotificationSuccess"] = boost::any(*dagNotificationSuccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagNotificationFail") != m.end() && !m["DagNotificationFail"].empty()) {
      dagNotificationFail = make_shared<bool>(boost::any_cast<bool>(m["DagNotificationFail"]));
    }
    if (m.find("DagNotificationSla") != m.end() && !m["DagNotificationSla"].empty()) {
      dagNotificationSla = make_shared<bool>(boost::any_cast<bool>(m["DagNotificationSla"]));
    }
    if (m.find("DagNotificationSuccess") != m.end() && !m["DagNotificationSuccess"].empty()) {
      dagNotificationSuccess = make_shared<bool>(boost::any_cast<bool>(m["DagNotificationSuccess"]));
    }
  }


  virtual ~GetTaskFlowNotificationResponseBodyNotification() = default;
};
class GetTaskFlowNotificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetTaskFlowNotificationResponseBodyNotification> notification{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetTaskFlowNotificationResponseBody() {}

  explicit GetTaskFlowNotificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        GetTaskFlowNotificationResponseBodyNotification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<GetTaskFlowNotificationResponseBodyNotification>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetTaskFlowNotificationResponseBody() = default;
};
class GetTaskFlowNotificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskFlowNotificationResponseBody> body{};

  GetTaskFlowNotificationResponse() {}

  explicit GetTaskFlowNotificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskFlowNotificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskFlowNotificationResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskFlowNotificationResponse() = default;
};
class GetTaskInstanceRelationRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> dagInstanceId{};
  shared_ptr<long> tid{};

  GetTaskInstanceRelationRequest() {}

  explicit GetTaskInstanceRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagInstanceId) {
      res["DagInstanceId"] = boost::any(*dagInstanceId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagInstanceId") != m.end() && !m["DagInstanceId"].empty()) {
      dagInstanceId = make_shared<long>(boost::any_cast<long>(m["DagInstanceId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetTaskInstanceRelationRequest() = default;
};
class GetTaskInstanceRelationResponseBodyNodeListNode : public Darabonba::Model {
public:
  shared_ptr<string> businessTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> executeTime{};
  shared_ptr<long> id{};
  shared_ptr<string> message{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> nodeType{};
  shared_ptr<long> status{};

  GetTaskInstanceRelationResponseBodyNodeListNode() {}

  explicit GetTaskInstanceRelationResponseBodyNodeListNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessTime) {
      res["BusinessTime"] = boost::any(*businessTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessTime") != m.end() && !m["BusinessTime"].empty()) {
      businessTime = make_shared<string>(boost::any_cast<string>(m["BusinessTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<long>(boost::any_cast<long>(m["ExecuteTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetTaskInstanceRelationResponseBodyNodeListNode() = default;
};
class GetTaskInstanceRelationResponseBodyNodeList : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskInstanceRelationResponseBodyNodeListNode>> node{};

  GetTaskInstanceRelationResponseBodyNodeList() {}

  explicit GetTaskInstanceRelationResponseBodyNodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (node) {
      vector<boost::any> temp1;
      for(auto item1:*node){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Node"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(vector<boost::any>) == m["Node"].type()) {
        vector<GetTaskInstanceRelationResponseBodyNodeListNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Node"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskInstanceRelationResponseBodyNodeListNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        node = make_shared<vector<GetTaskInstanceRelationResponseBodyNodeListNode>>(expect1);
      }
    }
  }


  virtual ~GetTaskInstanceRelationResponseBodyNodeList() = default;
};
class GetTaskInstanceRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetTaskInstanceRelationResponseBodyNodeList> nodeList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetTaskInstanceRelationResponseBody() {}

  explicit GetTaskInstanceRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nodeList) {
      res["NodeList"] = nodeList ? boost::any(nodeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NodeList") != m.end() && !m["NodeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeList"].type()) {
        GetTaskInstanceRelationResponseBodyNodeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeList"]));
        nodeList = make_shared<GetTaskInstanceRelationResponseBodyNodeList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetTaskInstanceRelationResponseBody() = default;
};
class GetTaskInstanceRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskInstanceRelationResponseBody> body{};

  GetTaskInstanceRelationResponse() {}

  explicit GetTaskInstanceRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskInstanceRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskInstanceRelationResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskInstanceRelationResponse() = default;
};
class GetUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};
  shared_ptr<string> uid{};
  shared_ptr<string> userId{};

  GetUserRequest() {}

  explicit GetUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetUserRequest() = default;
};
class GetUserResponseBodyUserRoleIdList : public Darabonba::Model {
public:
  shared_ptr<vector<long>> roleIds{};

  GetUserResponseBodyUserRoleIdList() {}

  explicit GetUserResponseBodyUserRoleIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleIds) {
      res["RoleIds"] = boost::any(*roleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleIds") != m.end() && !m["RoleIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RoleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      roleIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~GetUserResponseBodyUserRoleIdList() = default;
};
class GetUserResponseBodyUserRoleNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> roleNames{};

  GetUserResponseBodyUserRoleNameList() {}

  explicit GetUserResponseBodyUserRoleNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleNames) {
      res["RoleNames"] = boost::any(*roleNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleNames") != m.end() && !m["RoleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetUserResponseBodyUserRoleNameList() = default;
};
class GetUserResponseBodyUser : public Darabonba::Model {
public:
  shared_ptr<long> curExecuteCount{};
  shared_ptr<long> curResultCount{};
  shared_ptr<string> dingRobot{};
  shared_ptr<string> email{};
  shared_ptr<string> lastLoginTime{};
  shared_ptr<long> maxExecuteCount{};
  shared_ptr<long> maxResultCount{};
  shared_ptr<string> mobile{};
  shared_ptr<string> nickName{};
  shared_ptr<string> notificationMode{};
  shared_ptr<long> parentUid{};
  shared_ptr<GetUserResponseBodyUserRoleIdList> roleIdList{};
  shared_ptr<GetUserResponseBodyUserRoleNameList> roleNameList{};
  shared_ptr<string> signatureMethod{};
  shared_ptr<string> state{};
  shared_ptr<string> uid{};
  shared_ptr<string> userId{};
  shared_ptr<string> webhook{};

  GetUserResponseBodyUser() {}

  explicit GetUserResponseBodyUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (curExecuteCount) {
      res["CurExecuteCount"] = boost::any(*curExecuteCount);
    }
    if (curResultCount) {
      res["CurResultCount"] = boost::any(*curResultCount);
    }
    if (dingRobot) {
      res["DingRobot"] = boost::any(*dingRobot);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (lastLoginTime) {
      res["LastLoginTime"] = boost::any(*lastLoginTime);
    }
    if (maxExecuteCount) {
      res["MaxExecuteCount"] = boost::any(*maxExecuteCount);
    }
    if (maxResultCount) {
      res["MaxResultCount"] = boost::any(*maxResultCount);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (notificationMode) {
      res["NotificationMode"] = boost::any(*notificationMode);
    }
    if (parentUid) {
      res["ParentUid"] = boost::any(*parentUid);
    }
    if (roleIdList) {
      res["RoleIdList"] = roleIdList ? boost::any(roleIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roleNameList) {
      res["RoleNameList"] = roleNameList ? boost::any(roleNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signatureMethod) {
      res["SignatureMethod"] = boost::any(*signatureMethod);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurExecuteCount") != m.end() && !m["CurExecuteCount"].empty()) {
      curExecuteCount = make_shared<long>(boost::any_cast<long>(m["CurExecuteCount"]));
    }
    if (m.find("CurResultCount") != m.end() && !m["CurResultCount"].empty()) {
      curResultCount = make_shared<long>(boost::any_cast<long>(m["CurResultCount"]));
    }
    if (m.find("DingRobot") != m.end() && !m["DingRobot"].empty()) {
      dingRobot = make_shared<string>(boost::any_cast<string>(m["DingRobot"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LastLoginTime") != m.end() && !m["LastLoginTime"].empty()) {
      lastLoginTime = make_shared<string>(boost::any_cast<string>(m["LastLoginTime"]));
    }
    if (m.find("MaxExecuteCount") != m.end() && !m["MaxExecuteCount"].empty()) {
      maxExecuteCount = make_shared<long>(boost::any_cast<long>(m["MaxExecuteCount"]));
    }
    if (m.find("MaxResultCount") != m.end() && !m["MaxResultCount"].empty()) {
      maxResultCount = make_shared<long>(boost::any_cast<long>(m["MaxResultCount"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("NotificationMode") != m.end() && !m["NotificationMode"].empty()) {
      notificationMode = make_shared<string>(boost::any_cast<string>(m["NotificationMode"]));
    }
    if (m.find("ParentUid") != m.end() && !m["ParentUid"].empty()) {
      parentUid = make_shared<long>(boost::any_cast<long>(m["ParentUid"]));
    }
    if (m.find("RoleIdList") != m.end() && !m["RoleIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoleIdList"].type()) {
        GetUserResponseBodyUserRoleIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoleIdList"]));
        roleIdList = make_shared<GetUserResponseBodyUserRoleIdList>(model1);
      }
    }
    if (m.find("RoleNameList") != m.end() && !m["RoleNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoleNameList"].type()) {
        GetUserResponseBodyUserRoleNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoleNameList"]));
        roleNameList = make_shared<GetUserResponseBodyUserRoleNameList>(model1);
      }
    }
    if (m.find("SignatureMethod") != m.end() && !m["SignatureMethod"].empty()) {
      signatureMethod = make_shared<string>(boost::any_cast<string>(m["SignatureMethod"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~GetUserResponseBodyUser() = default;
};
class GetUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetUserResponseBodyUser> user{};

  GetUserResponseBody() {}

  explicit GetUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (user) {
      res["User"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(map<string, boost::any>) == m["User"].type()) {
        GetUserResponseBodyUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["User"]));
        user = make_shared<GetUserResponseBodyUser>(model1);
      }
    }
  }


  virtual ~GetUserResponseBody() = default;
};
class GetUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserResponseBody> body{};

  GetUserResponse() {}

  explicit GetUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserResponse() = default;
};
class GetUserActiveTenantRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};

  GetUserActiveTenantRequest() {}

  explicit GetUserActiveTenantRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetUserActiveTenantRequest() = default;
};
class GetUserActiveTenantResponseBodyTenant : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> tenantName{};
  shared_ptr<long> tid{};

  GetUserActiveTenantResponseBodyTenant() {}

  explicit GetUserActiveTenantResponseBodyTenant(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetUserActiveTenantResponseBodyTenant() = default;
};
class GetUserActiveTenantResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetUserActiveTenantResponseBodyTenant> tenant{};

  GetUserActiveTenantResponseBody() {}

  explicit GetUserActiveTenantResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tenant) {
      res["Tenant"] = tenant ? boost::any(tenant->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Tenant") != m.end() && !m["Tenant"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tenant"].type()) {
        GetUserActiveTenantResponseBodyTenant model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tenant"]));
        tenant = make_shared<GetUserActiveTenantResponseBodyTenant>(model1);
      }
    }
  }


  virtual ~GetUserActiveTenantResponseBody() = default;
};
class GetUserActiveTenantResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserActiveTenantResponseBody> body{};

  GetUserActiveTenantResponse() {}

  explicit GetUserActiveTenantResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserActiveTenantResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserActiveTenantResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserActiveTenantResponse() = default;
};
class GetUserUploadFileJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobKey{};
  shared_ptr<long> tid{};

  GetUserUploadFileJobRequest() {}

  explicit GetUserUploadFileJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobKey) {
      res["JobKey"] = boost::any(*jobKey);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobKey") != m.end() && !m["JobKey"].empty()) {
      jobKey = make_shared<string>(boost::any_cast<string>(m["JobKey"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~GetUserUploadFileJobRequest() = default;
};
class GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> objectName{};

  GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam() {}

  explicit GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
  }


  virtual ~GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam() = default;
};
class GetUserUploadFileJobResponseBodyUploadFileJobDetail : public Darabonba::Model {
public:
  shared_ptr<string> attachmentKey{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> fileSource{};
  shared_ptr<string> jobKey{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobStatusDesc{};
  shared_ptr<GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam> uploadOSSParam{};
  shared_ptr<string> uploadType{};
  shared_ptr<string> uploadURL{};
  shared_ptr<long> uploadedSize{};

  GetUserUploadFileJobResponseBodyUploadFileJobDetail() {}

  explicit GetUserUploadFileJobResponseBodyUploadFileJobDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachmentKey) {
      res["AttachmentKey"] = boost::any(*attachmentKey);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileSource) {
      res["FileSource"] = boost::any(*fileSource);
    }
    if (jobKey) {
      res["JobKey"] = boost::any(*jobKey);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobStatusDesc) {
      res["JobStatusDesc"] = boost::any(*jobStatusDesc);
    }
    if (uploadOSSParam) {
      res["UploadOSSParam"] = uploadOSSParam ? boost::any(uploadOSSParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (uploadType) {
      res["UploadType"] = boost::any(*uploadType);
    }
    if (uploadURL) {
      res["UploadURL"] = boost::any(*uploadURL);
    }
    if (uploadedSize) {
      res["UploadedSize"] = boost::any(*uploadedSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachmentKey") != m.end() && !m["AttachmentKey"].empty()) {
      attachmentKey = make_shared<string>(boost::any_cast<string>(m["AttachmentKey"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
    if (m.find("FileSource") != m.end() && !m["FileSource"].empty()) {
      fileSource = make_shared<string>(boost::any_cast<string>(m["FileSource"]));
    }
    if (m.find("JobKey") != m.end() && !m["JobKey"].empty()) {
      jobKey = make_shared<string>(boost::any_cast<string>(m["JobKey"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobStatusDesc") != m.end() && !m["JobStatusDesc"].empty()) {
      jobStatusDesc = make_shared<string>(boost::any_cast<string>(m["JobStatusDesc"]));
    }
    if (m.find("UploadOSSParam") != m.end() && !m["UploadOSSParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["UploadOSSParam"].type()) {
        GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UploadOSSParam"]));
        uploadOSSParam = make_shared<GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam>(model1);
      }
    }
    if (m.find("UploadType") != m.end() && !m["UploadType"].empty()) {
      uploadType = make_shared<string>(boost::any_cast<string>(m["UploadType"]));
    }
    if (m.find("UploadURL") != m.end() && !m["UploadURL"].empty()) {
      uploadURL = make_shared<string>(boost::any_cast<string>(m["UploadURL"]));
    }
    if (m.find("UploadedSize") != m.end() && !m["UploadedSize"].empty()) {
      uploadedSize = make_shared<long>(boost::any_cast<long>(m["UploadedSize"]));
    }
  }


  virtual ~GetUserUploadFileJobResponseBodyUploadFileJobDetail() = default;
};
class GetUserUploadFileJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetUserUploadFileJobResponseBodyUploadFileJobDetail> uploadFileJobDetail{};

  GetUserUploadFileJobResponseBody() {}

  explicit GetUserUploadFileJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (uploadFileJobDetail) {
      res["UploadFileJobDetail"] = uploadFileJobDetail ? boost::any(uploadFileJobDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UploadFileJobDetail") != m.end() && !m["UploadFileJobDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["UploadFileJobDetail"].type()) {
        GetUserUploadFileJobResponseBodyUploadFileJobDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UploadFileJobDetail"]));
        uploadFileJobDetail = make_shared<GetUserUploadFileJobResponseBodyUploadFileJobDetail>(model1);
      }
    }
  }


  virtual ~GetUserUploadFileJobResponseBody() = default;
};
class GetUserUploadFileJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserUploadFileJobResponseBody> body{};

  GetUserUploadFileJobResponse() {}

  explicit GetUserUploadFileJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserUploadFileJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserUploadFileJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserUploadFileJobResponse() = default;
};
class GrantTemplateAuthorityRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> expireDate{};
  shared_ptr<long> templateId{};
  shared_ptr<long> tid{};
  shared_ptr<string> userIds{};

  GrantTemplateAuthorityRequest() {}

  explicit GrantTemplateAuthorityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (expireDate) {
      res["ExpireDate"] = boost::any(*expireDate);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ExpireDate") != m.end() && !m["ExpireDate"].empty()) {
      expireDate = make_shared<string>(boost::any_cast<string>(m["ExpireDate"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIds = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~GrantTemplateAuthorityRequest() = default;
};
class GrantTemplateAuthorityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  GrantTemplateAuthorityResponseBody() {}

  explicit GrantTemplateAuthorityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GrantTemplateAuthorityResponseBody() = default;
};
class GrantTemplateAuthorityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GrantTemplateAuthorityResponseBody> body{};

  GrantTemplateAuthorityResponse() {}

  explicit GrantTemplateAuthorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantTemplateAuthorityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantTemplateAuthorityResponseBody>(model1);
      }
    }
  }


  virtual ~GrantTemplateAuthorityResponse() = default;
};
class GrantUserPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbId{};
  shared_ptr<string> dsType{};
  shared_ptr<string> expireDate{};
  shared_ptr<long> instanceId{};
  shared_ptr<bool> logic{};
  shared_ptr<string> permTypes{};
  shared_ptr<string> tableId{};
  shared_ptr<string> tableName{};
  shared_ptr<long> tid{};
  shared_ptr<string> userId{};

  GrantUserPermissionRequest() {}

  explicit GrantUserPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dsType) {
      res["DsType"] = boost::any(*dsType);
    }
    if (expireDate) {
      res["ExpireDate"] = boost::any(*expireDate);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (permTypes) {
      res["PermTypes"] = boost::any(*permTypes);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<string>(boost::any_cast<string>(m["DbId"]));
    }
    if (m.find("DsType") != m.end() && !m["DsType"].empty()) {
      dsType = make_shared<string>(boost::any_cast<string>(m["DsType"]));
    }
    if (m.find("ExpireDate") != m.end() && !m["ExpireDate"].empty()) {
      expireDate = make_shared<string>(boost::any_cast<string>(m["ExpireDate"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("PermTypes") != m.end() && !m["PermTypes"].empty()) {
      permTypes = make_shared<string>(boost::any_cast<string>(m["PermTypes"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GrantUserPermissionRequest() = default;
};
class GrantUserPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GrantUserPermissionResponseBody() {}

  explicit GrantUserPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GrantUserPermissionResponseBody() = default;
};
class GrantUserPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GrantUserPermissionResponseBody> body{};

  GrantUserPermissionResponse() {}

  explicit GrantUserPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantUserPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantUserPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~GrantUserPermissionResponse() = default;
};
class InspectProxyAccessSecretRequest : public Darabonba::Model {
public:
  shared_ptr<long> proxyAccessId{};
  shared_ptr<long> tid{};

  InspectProxyAccessSecretRequest() {}

  explicit InspectProxyAccessSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxyAccessId) {
      res["ProxyAccessId"] = boost::any(*proxyAccessId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxyAccessId") != m.end() && !m["ProxyAccessId"].empty()) {
      proxyAccessId = make_shared<long>(boost::any_cast<long>(m["ProxyAccessId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~InspectProxyAccessSecretRequest() = default;
};
class InspectProxyAccessSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessSecret{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InspectProxyAccessSecretResponseBody() {}

  explicit InspectProxyAccessSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessSecret) {
      res["AccessSecret"] = boost::any(*accessSecret);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessSecret") != m.end() && !m["AccessSecret"].empty()) {
      accessSecret = make_shared<string>(boost::any_cast<string>(m["AccessSecret"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InspectProxyAccessSecretResponseBody() = default;
};
class InspectProxyAccessSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InspectProxyAccessSecretResponseBody> body{};

  InspectProxyAccessSecretResponse() {}

  explicit InspectProxyAccessSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InspectProxyAccessSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InspectProxyAccessSecretResponseBody>(model1);
      }
    }
  }


  virtual ~InspectProxyAccessSecretResponse() = default;
};
class ListAuthorityTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<long> tid{};

  ListAuthorityTemplateRequest() {}

  explicit ListAuthorityTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListAuthorityTemplateRequest() = default;
};
class ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> templateId{};

  ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView() {}

  explicit ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView() = default;
};
class ListAuthorityTemplateResponseBodyAuthorityTemplateViewList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView>> authorityTemplateView{};

  ListAuthorityTemplateResponseBodyAuthorityTemplateViewList() {}

  explicit ListAuthorityTemplateResponseBodyAuthorityTemplateViewList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorityTemplateView) {
      vector<boost::any> temp1;
      for(auto item1:*authorityTemplateView){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorityTemplateView"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorityTemplateView") != m.end() && !m["AuthorityTemplateView"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorityTemplateView"].type()) {
        vector<ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorityTemplateView"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorityTemplateView = make_shared<vector<ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView>>(expect1);
      }
    }
  }


  virtual ~ListAuthorityTemplateResponseBodyAuthorityTemplateViewList() = default;
};
class ListAuthorityTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAuthorityTemplateResponseBodyAuthorityTemplateViewList> authorityTemplateViewList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> tid{};
  shared_ptr<long> totalCount{};

  ListAuthorityTemplateResponseBody() {}

  explicit ListAuthorityTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorityTemplateViewList) {
      res["AuthorityTemplateViewList"] = authorityTemplateViewList ? boost::any(authorityTemplateViewList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorityTemplateViewList") != m.end() && !m["AuthorityTemplateViewList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorityTemplateViewList"].type()) {
        ListAuthorityTemplateResponseBodyAuthorityTemplateViewList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorityTemplateViewList"]));
        authorityTemplateViewList = make_shared<ListAuthorityTemplateResponseBodyAuthorityTemplateViewList>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAuthorityTemplateResponseBody() = default;
};
class ListAuthorityTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAuthorityTemplateResponseBody> body{};

  ListAuthorityTemplateResponse() {}

  explicit ListAuthorityTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAuthorityTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAuthorityTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ListAuthorityTemplateResponse() = default;
};
class ListClassificationTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};

  ListClassificationTemplatesRequest() {}

  explicit ListClassificationTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListClassificationTemplatesRequest() = default;
};
class ListClassificationTemplatesResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateType{};

  ListClassificationTemplatesResponseBodyTemplateList() {}

  explicit ListClassificationTemplatesResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~ListClassificationTemplatesResponseBodyTemplateList() = default;
};
class ListClassificationTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListClassificationTemplatesResponseBodyTemplateList>> templateList{};

  ListClassificationTemplatesResponseBody() {}

  explicit ListClassificationTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (templateList) {
      vector<boost::any> temp1;
      for(auto item1:*templateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateList"].type()) {
        vector<ListClassificationTemplatesResponseBodyTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClassificationTemplatesResponseBodyTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateList = make_shared<vector<ListClassificationTemplatesResponseBodyTemplateList>>(expect1);
      }
    }
  }


  virtual ~ListClassificationTemplatesResponseBody() = default;
};
class ListClassificationTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClassificationTemplatesResponseBody> body{};

  ListClassificationTemplatesResponse() {}

  explicit ListClassificationTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClassificationTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClassificationTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClassificationTemplatesResponse() = default;
};
class ListColumnsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> logic{};
  shared_ptr<string> tableId{};
  shared_ptr<long> tid{};

  ListColumnsRequest() {}

  explicit ListColumnsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListColumnsRequest() = default;
};
class ListColumnsResponseBodyColumnListColumn : public Darabonba::Model {
public:
  shared_ptr<bool> autoIncrement{};
  shared_ptr<string> columnId{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};
  shared_ptr<long> dataLength{};
  shared_ptr<long> dataPrecision{};
  shared_ptr<long> dataScale{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<string> functionType{};
  shared_ptr<bool> nullable{};
  shared_ptr<string> securityLevel{};
  shared_ptr<bool> sensitive{};

  ListColumnsResponseBodyColumnListColumn() {}

  explicit ListColumnsResponseBodyColumnListColumn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoIncrement) {
      res["AutoIncrement"] = boost::any(*autoIncrement);
    }
    if (columnId) {
      res["ColumnId"] = boost::any(*columnId);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (dataLength) {
      res["DataLength"] = boost::any(*dataLength);
    }
    if (dataPrecision) {
      res["DataPrecision"] = boost::any(*dataPrecision);
    }
    if (dataScale) {
      res["DataScale"] = boost::any(*dataScale);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (functionType) {
      res["FunctionType"] = boost::any(*functionType);
    }
    if (nullable) {
      res["Nullable"] = boost::any(*nullable);
    }
    if (securityLevel) {
      res["SecurityLevel"] = boost::any(*securityLevel);
    }
    if (sensitive) {
      res["Sensitive"] = boost::any(*sensitive);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoIncrement") != m.end() && !m["AutoIncrement"].empty()) {
      autoIncrement = make_shared<bool>(boost::any_cast<bool>(m["AutoIncrement"]));
    }
    if (m.find("ColumnId") != m.end() && !m["ColumnId"].empty()) {
      columnId = make_shared<string>(boost::any_cast<string>(m["ColumnId"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("DataLength") != m.end() && !m["DataLength"].empty()) {
      dataLength = make_shared<long>(boost::any_cast<long>(m["DataLength"]));
    }
    if (m.find("DataPrecision") != m.end() && !m["DataPrecision"].empty()) {
      dataPrecision = make_shared<long>(boost::any_cast<long>(m["DataPrecision"]));
    }
    if (m.find("DataScale") != m.end() && !m["DataScale"].empty()) {
      dataScale = make_shared<long>(boost::any_cast<long>(m["DataScale"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FunctionType") != m.end() && !m["FunctionType"].empty()) {
      functionType = make_shared<string>(boost::any_cast<string>(m["FunctionType"]));
    }
    if (m.find("Nullable") != m.end() && !m["Nullable"].empty()) {
      nullable = make_shared<bool>(boost::any_cast<bool>(m["Nullable"]));
    }
    if (m.find("SecurityLevel") != m.end() && !m["SecurityLevel"].empty()) {
      securityLevel = make_shared<string>(boost::any_cast<string>(m["SecurityLevel"]));
    }
    if (m.find("Sensitive") != m.end() && !m["Sensitive"].empty()) {
      sensitive = make_shared<bool>(boost::any_cast<bool>(m["Sensitive"]));
    }
  }


  virtual ~ListColumnsResponseBodyColumnListColumn() = default;
};
class ListColumnsResponseBodyColumnList : public Darabonba::Model {
public:
  shared_ptr<vector<ListColumnsResponseBodyColumnListColumn>> column{};

  ListColumnsResponseBodyColumnList() {}

  explicit ListColumnsResponseBodyColumnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      vector<boost::any> temp1;
      for(auto item1:*column){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Column"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      if (typeid(vector<boost::any>) == m["Column"].type()) {
        vector<ListColumnsResponseBodyColumnListColumn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Column"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListColumnsResponseBodyColumnListColumn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        column = make_shared<vector<ListColumnsResponseBodyColumnListColumn>>(expect1);
      }
    }
  }


  virtual ~ListColumnsResponseBodyColumnList() = default;
};
class ListColumnsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListColumnsResponseBodyColumnList> columnList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListColumnsResponseBody() {}

  explicit ListColumnsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnList) {
      res["ColumnList"] = columnList ? boost::any(columnList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnList") != m.end() && !m["ColumnList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColumnList"].type()) {
        ListColumnsResponseBodyColumnList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColumnList"]));
        columnList = make_shared<ListColumnsResponseBodyColumnList>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListColumnsResponseBody() = default;
};
class ListColumnsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListColumnsResponseBody> body{};

  ListColumnsResponse() {}

  explicit ListColumnsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListColumnsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListColumnsResponseBody>(model1);
      }
    }
  }


  virtual ~ListColumnsResponse() = default;
};
class ListDAGVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tid{};

  ListDAGVersionsRequest() {}

  explicit ListDAGVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListDAGVersionsRequest() = default;
};
class ListDAGVersionsResponseBodyDagVersionListDagVersion : public Darabonba::Model {
public:
  shared_ptr<string> dagName{};
  shared_ptr<string> dagOwnerId{};
  shared_ptr<string> dagOwnerNickName{};
  shared_ptr<long> lastVersionId{};
  shared_ptr<string> versionComments{};
  shared_ptr<long> versionId{};

  ListDAGVersionsResponseBodyDagVersionListDagVersion() {}

  explicit ListDAGVersionsResponseBodyDagVersionListDagVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagName) {
      res["DagName"] = boost::any(*dagName);
    }
    if (dagOwnerId) {
      res["DagOwnerId"] = boost::any(*dagOwnerId);
    }
    if (dagOwnerNickName) {
      res["DagOwnerNickName"] = boost::any(*dagOwnerNickName);
    }
    if (lastVersionId) {
      res["LastVersionId"] = boost::any(*lastVersionId);
    }
    if (versionComments) {
      res["VersionComments"] = boost::any(*versionComments);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagName") != m.end() && !m["DagName"].empty()) {
      dagName = make_shared<string>(boost::any_cast<string>(m["DagName"]));
    }
    if (m.find("DagOwnerId") != m.end() && !m["DagOwnerId"].empty()) {
      dagOwnerId = make_shared<string>(boost::any_cast<string>(m["DagOwnerId"]));
    }
    if (m.find("DagOwnerNickName") != m.end() && !m["DagOwnerNickName"].empty()) {
      dagOwnerNickName = make_shared<string>(boost::any_cast<string>(m["DagOwnerNickName"]));
    }
    if (m.find("LastVersionId") != m.end() && !m["LastVersionId"].empty()) {
      lastVersionId = make_shared<long>(boost::any_cast<long>(m["LastVersionId"]));
    }
    if (m.find("VersionComments") != m.end() && !m["VersionComments"].empty()) {
      versionComments = make_shared<string>(boost::any_cast<string>(m["VersionComments"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<long>(boost::any_cast<long>(m["VersionId"]));
    }
  }


  virtual ~ListDAGVersionsResponseBodyDagVersionListDagVersion() = default;
};
class ListDAGVersionsResponseBodyDagVersionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListDAGVersionsResponseBodyDagVersionListDagVersion>> dagVersion{};

  ListDAGVersionsResponseBodyDagVersionList() {}

  explicit ListDAGVersionsResponseBodyDagVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagVersion) {
      vector<boost::any> temp1;
      for(auto item1:*dagVersion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DagVersion"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagVersion") != m.end() && !m["DagVersion"].empty()) {
      if (typeid(vector<boost::any>) == m["DagVersion"].type()) {
        vector<ListDAGVersionsResponseBodyDagVersionListDagVersion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DagVersion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDAGVersionsResponseBodyDagVersionListDagVersion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dagVersion = make_shared<vector<ListDAGVersionsResponseBodyDagVersionListDagVersion>>(expect1);
      }
    }
  }


  virtual ~ListDAGVersionsResponseBodyDagVersionList() = default;
};
class ListDAGVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDAGVersionsResponseBodyDagVersionList> dagVersionList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListDAGVersionsResponseBody() {}

  explicit ListDAGVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagVersionList) {
      res["DagVersionList"] = dagVersionList ? boost::any(dagVersionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagVersionList") != m.end() && !m["DagVersionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DagVersionList"].type()) {
        ListDAGVersionsResponseBodyDagVersionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DagVersionList"]));
        dagVersionList = make_shared<ListDAGVersionsResponseBodyDagVersionList>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDAGVersionsResponseBody() = default;
};
class ListDAGVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDAGVersionsResponseBody> body{};

  ListDAGVersionsResponse() {}

  explicit ListDAGVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDAGVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDAGVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDAGVersionsResponse() = default;
};
class ListDBTaskSQLJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> DBTaskGroupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tid{};

  ListDBTaskSQLJobRequest() {}

  explicit ListDBTaskSQLJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBTaskGroupId) {
      res["DBTaskGroupId"] = boost::any(*DBTaskGroupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBTaskGroupId") != m.end() && !m["DBTaskGroupId"].empty()) {
      DBTaskGroupId = make_shared<long>(boost::any_cast<long>(m["DBTaskGroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListDBTaskSQLJobRequest() = default;
};
class ListDBTaskSQLJobResponseBodyDBTaskSQLJobList : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> createTime{};
  shared_ptr<long> dbId{};
  shared_ptr<string> dbSearchName{};
  shared_ptr<long> dbTaskGroupId{};
  shared_ptr<long> jobId{};
  shared_ptr<string> jobType{};
  shared_ptr<string> lastExecTime{};
  shared_ptr<bool> logic{};
  shared_ptr<string> status{};
  shared_ptr<bool> transactional{};

  ListDBTaskSQLJobResponseBodyDBTaskSQLJobList() {}

  explicit ListDBTaskSQLJobResponseBodyDBTaskSQLJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbSearchName) {
      res["DbSearchName"] = boost::any(*dbSearchName);
    }
    if (dbTaskGroupId) {
      res["DbTaskGroupId"] = boost::any(*dbTaskGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (lastExecTime) {
      res["LastExecTime"] = boost::any(*lastExecTime);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (transactional) {
      res["Transactional"] = boost::any(*transactional);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DbSearchName") != m.end() && !m["DbSearchName"].empty()) {
      dbSearchName = make_shared<string>(boost::any_cast<string>(m["DbSearchName"]));
    }
    if (m.find("DbTaskGroupId") != m.end() && !m["DbTaskGroupId"].empty()) {
      dbTaskGroupId = make_shared<long>(boost::any_cast<long>(m["DbTaskGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<long>(boost::any_cast<long>(m["JobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("LastExecTime") != m.end() && !m["LastExecTime"].empty()) {
      lastExecTime = make_shared<string>(boost::any_cast<string>(m["LastExecTime"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Transactional") != m.end() && !m["Transactional"].empty()) {
      transactional = make_shared<bool>(boost::any_cast<bool>(m["Transactional"]));
    }
  }


  virtual ~ListDBTaskSQLJobResponseBodyDBTaskSQLJobList() = default;
};
class ListDBTaskSQLJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDBTaskSQLJobResponseBodyDBTaskSQLJobList>> DBTaskSQLJobList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListDBTaskSQLJobResponseBody() {}

  explicit ListDBTaskSQLJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBTaskSQLJobList) {
      vector<boost::any> temp1;
      for(auto item1:*DBTaskSQLJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBTaskSQLJobList"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBTaskSQLJobList") != m.end() && !m["DBTaskSQLJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["DBTaskSQLJobList"].type()) {
        vector<ListDBTaskSQLJobResponseBodyDBTaskSQLJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBTaskSQLJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDBTaskSQLJobResponseBodyDBTaskSQLJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBTaskSQLJobList = make_shared<vector<ListDBTaskSQLJobResponseBodyDBTaskSQLJobList>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDBTaskSQLJobResponseBody() = default;
};
class ListDBTaskSQLJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDBTaskSQLJobResponseBody> body{};

  ListDBTaskSQLJobResponse() {}

  explicit ListDBTaskSQLJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDBTaskSQLJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDBTaskSQLJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListDBTaskSQLJobResponse() = default;
};
class ListDBTaskSQLJobDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> jobId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tid{};

  ListDBTaskSQLJobDetailRequest() {}

  explicit ListDBTaskSQLJobDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<long>(boost::any_cast<long>(m["JobId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListDBTaskSQLJobDetailRequest() = default;
};
class ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList : public Darabonba::Model {
public:
  shared_ptr<long> affectRows{};
  shared_ptr<string> currentSql{};
  shared_ptr<long> dbId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> executeCount{};
  shared_ptr<long> jobDetailId{};
  shared_ptr<long> jobId{};
  shared_ptr<string> log{};
  shared_ptr<bool> logic{};
  shared_ptr<bool> skip{};
  shared_ptr<string> sqlType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> timeDelay{};

  ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList() {}

  explicit ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectRows) {
      res["AffectRows"] = boost::any(*affectRows);
    }
    if (currentSql) {
      res["CurrentSql"] = boost::any(*currentSql);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (executeCount) {
      res["ExecuteCount"] = boost::any(*executeCount);
    }
    if (jobDetailId) {
      res["JobDetailId"] = boost::any(*jobDetailId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (log) {
      res["Log"] = boost::any(*log);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeDelay) {
      res["TimeDelay"] = boost::any(*timeDelay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectRows") != m.end() && !m["AffectRows"].empty()) {
      affectRows = make_shared<long>(boost::any_cast<long>(m["AffectRows"]));
    }
    if (m.find("CurrentSql") != m.end() && !m["CurrentSql"].empty()) {
      currentSql = make_shared<string>(boost::any_cast<string>(m["CurrentSql"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExecuteCount") != m.end() && !m["ExecuteCount"].empty()) {
      executeCount = make_shared<long>(boost::any_cast<long>(m["ExecuteCount"]));
    }
    if (m.find("JobDetailId") != m.end() && !m["JobDetailId"].empty()) {
      jobDetailId = make_shared<long>(boost::any_cast<long>(m["JobDetailId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<long>(boost::any_cast<long>(m["JobId"]));
    }
    if (m.find("Log") != m.end() && !m["Log"].empty()) {
      log = make_shared<string>(boost::any_cast<string>(m["Log"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<bool>(boost::any_cast<bool>(m["Skip"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimeDelay") != m.end() && !m["TimeDelay"].empty()) {
      timeDelay = make_shared<long>(boost::any_cast<long>(m["TimeDelay"]));
    }
  }


  virtual ~ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList() = default;
};
class ListDBTaskSQLJobDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList>> DBTaskSQLJobDetailList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListDBTaskSQLJobDetailResponseBody() {}

  explicit ListDBTaskSQLJobDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBTaskSQLJobDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*DBTaskSQLJobDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBTaskSQLJobDetailList"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBTaskSQLJobDetailList") != m.end() && !m["DBTaskSQLJobDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["DBTaskSQLJobDetailList"].type()) {
        vector<ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBTaskSQLJobDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBTaskSQLJobDetailList = make_shared<vector<ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDBTaskSQLJobDetailResponseBody() = default;
};
class ListDBTaskSQLJobDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDBTaskSQLJobDetailResponseBody> body{};

  ListDBTaskSQLJobDetailResponse() {}

  explicit ListDBTaskSQLJobDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDBTaskSQLJobDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDBTaskSQLJobDetailResponseBody>(model1);
      }
    }
  }


  virtual ~ListDBTaskSQLJobDetailResponse() = default;
};
class ListDDLPublishRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  ListDDLPublishRecordsRequest() {}

  explicit ListDDLPublishRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListDDLPublishRecordsRequest() = default;
};
class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList : public Darabonba::Model {
public:
  shared_ptr<long> DBTaskGroupId{};
  shared_ptr<long> executeCount{};
  shared_ptr<string> scripts{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> tableName{};
  shared_ptr<string> taskJobStatus{};

  ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList() {}

  explicit ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBTaskGroupId) {
      res["DBTaskGroupId"] = boost::any(*DBTaskGroupId);
    }
    if (executeCount) {
      res["ExecuteCount"] = boost::any(*executeCount);
    }
    if (scripts) {
      res["Scripts"] = boost::any(*scripts);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (taskJobStatus) {
      res["TaskJobStatus"] = boost::any(*taskJobStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBTaskGroupId") != m.end() && !m["DBTaskGroupId"].empty()) {
      DBTaskGroupId = make_shared<long>(boost::any_cast<long>(m["DBTaskGroupId"]));
    }
    if (m.find("ExecuteCount") != m.end() && !m["ExecuteCount"].empty()) {
      executeCount = make_shared<long>(boost::any_cast<long>(m["ExecuteCount"]));
    }
    if (m.find("Scripts") != m.end() && !m["Scripts"].empty()) {
      scripts = make_shared<string>(boost::any_cast<string>(m["Scripts"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TaskJobStatus") != m.end() && !m["TaskJobStatus"].empty()) {
      taskJobStatus = make_shared<string>(boost::any_cast<string>(m["TaskJobStatus"]));
    }
  }


  virtual ~ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList() = default;
};
class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<bool> logic{};
  shared_ptr<string> planTime{};
  shared_ptr<vector<ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList>> publishJobList{};
  shared_ptr<string> publishStrategy{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> taskJobStatus{};

  ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList() {}

  explicit ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (planTime) {
      res["PlanTime"] = boost::any(*planTime);
    }
    if (publishJobList) {
      vector<boost::any> temp1;
      for(auto item1:*publishJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublishJobList"] = boost::any(temp1);
    }
    if (publishStrategy) {
      res["PublishStrategy"] = boost::any(*publishStrategy);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (taskJobStatus) {
      res["TaskJobStatus"] = boost::any(*taskJobStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("PlanTime") != m.end() && !m["PlanTime"].empty()) {
      planTime = make_shared<string>(boost::any_cast<string>(m["PlanTime"]));
    }
    if (m.find("PublishJobList") != m.end() && !m["PublishJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["PublishJobList"].type()) {
        vector<ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublishJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publishJobList = make_shared<vector<ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList>>(expect1);
      }
    }
    if (m.find("PublishStrategy") != m.end() && !m["PublishStrategy"].empty()) {
      publishStrategy = make_shared<string>(boost::any_cast<string>(m["PublishStrategy"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("TaskJobStatus") != m.end() && !m["TaskJobStatus"].empty()) {
      taskJobStatus = make_shared<string>(boost::any_cast<string>(m["TaskJobStatus"]));
    }
  }


  virtual ~ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList() = default;
};
class ListDDLPublishRecordsResponseBodyDDLPublishRecordList : public Darabonba::Model {
public:
  shared_ptr<string> auditExpireTime{};
  shared_ptr<string> auditStatus{};
  shared_ptr<string> comment{};
  shared_ptr<long> creatorId{};
  shared_ptr<bool> finality{};
  shared_ptr<string> finalityReason{};
  shared_ptr<string> publishStatus{};
  shared_ptr<vector<ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList>> publishTaskInfoList{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> statusDesc{};
  shared_ptr<long> workflowInstanceId{};

  ListDDLPublishRecordsResponseBodyDDLPublishRecordList() {}

  explicit ListDDLPublishRecordsResponseBodyDDLPublishRecordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditExpireTime) {
      res["AuditExpireTime"] = boost::any(*auditExpireTime);
    }
    if (auditStatus) {
      res["AuditStatus"] = boost::any(*auditStatus);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (finality) {
      res["Finality"] = boost::any(*finality);
    }
    if (finalityReason) {
      res["FinalityReason"] = boost::any(*finalityReason);
    }
    if (publishStatus) {
      res["PublishStatus"] = boost::any(*publishStatus);
    }
    if (publishTaskInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*publishTaskInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublishTaskInfoList"] = boost::any(temp1);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditExpireTime") != m.end() && !m["AuditExpireTime"].empty()) {
      auditExpireTime = make_shared<string>(boost::any_cast<string>(m["AuditExpireTime"]));
    }
    if (m.find("AuditStatus") != m.end() && !m["AuditStatus"].empty()) {
      auditStatus = make_shared<string>(boost::any_cast<string>(m["AuditStatus"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["CreatorId"]));
    }
    if (m.find("Finality") != m.end() && !m["Finality"].empty()) {
      finality = make_shared<bool>(boost::any_cast<bool>(m["Finality"]));
    }
    if (m.find("FinalityReason") != m.end() && !m["FinalityReason"].empty()) {
      finalityReason = make_shared<string>(boost::any_cast<string>(m["FinalityReason"]));
    }
    if (m.find("PublishStatus") != m.end() && !m["PublishStatus"].empty()) {
      publishStatus = make_shared<string>(boost::any_cast<string>(m["PublishStatus"]));
    }
    if (m.find("PublishTaskInfoList") != m.end() && !m["PublishTaskInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["PublishTaskInfoList"].type()) {
        vector<ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublishTaskInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publishTaskInfoList = make_shared<vector<ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList>>(expect1);
      }
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
  }


  virtual ~ListDDLPublishRecordsResponseBodyDDLPublishRecordList() = default;
};
class ListDDLPublishRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDDLPublishRecordsResponseBodyDDLPublishRecordList>> DDLPublishRecordList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListDDLPublishRecordsResponseBody() {}

  explicit ListDDLPublishRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DDLPublishRecordList) {
      vector<boost::any> temp1;
      for(auto item1:*DDLPublishRecordList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DDLPublishRecordList"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DDLPublishRecordList") != m.end() && !m["DDLPublishRecordList"].empty()) {
      if (typeid(vector<boost::any>) == m["DDLPublishRecordList"].type()) {
        vector<ListDDLPublishRecordsResponseBodyDDLPublishRecordList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DDLPublishRecordList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDDLPublishRecordsResponseBodyDDLPublishRecordList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DDLPublishRecordList = make_shared<vector<ListDDLPublishRecordsResponseBodyDDLPublishRecordList>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDDLPublishRecordsResponseBody() = default;
};
class ListDDLPublishRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDDLPublishRecordsResponseBody> body{};

  ListDDLPublishRecordsResponse() {}

  explicit ListDDLPublishRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDDLPublishRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDDLPublishRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDDLPublishRecordsResponse() = default;
};
class ListDataCorrectPreCheckDBRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tid{};

  ListDataCorrectPreCheckDBRequest() {}

  explicit ListDataCorrectPreCheckDBRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListDataCorrectPreCheckDBRequest() = default;
};
class ListDataCorrectPreCheckDBResponseBodyPreCheckDBList : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<string> searchName{};
  shared_ptr<long> sqlNum{};

  ListDataCorrectPreCheckDBResponseBodyPreCheckDBList() {}

  explicit ListDataCorrectPreCheckDBResponseBodyPreCheckDBList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (sqlNum) {
      res["SqlNum"] = boost::any(*sqlNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("SqlNum") != m.end() && !m["SqlNum"].empty()) {
      sqlNum = make_shared<long>(boost::any_cast<long>(m["SqlNum"]));
    }
  }


  virtual ~ListDataCorrectPreCheckDBResponseBodyPreCheckDBList() = default;
};
class ListDataCorrectPreCheckDBResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListDataCorrectPreCheckDBResponseBodyPreCheckDBList>> preCheckDBList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListDataCorrectPreCheckDBResponseBody() {}

  explicit ListDataCorrectPreCheckDBResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (preCheckDBList) {
      vector<boost::any> temp1;
      for(auto item1:*preCheckDBList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PreCheckDBList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PreCheckDBList") != m.end() && !m["PreCheckDBList"].empty()) {
      if (typeid(vector<boost::any>) == m["PreCheckDBList"].type()) {
        vector<ListDataCorrectPreCheckDBResponseBodyPreCheckDBList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PreCheckDBList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataCorrectPreCheckDBResponseBodyPreCheckDBList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preCheckDBList = make_shared<vector<ListDataCorrectPreCheckDBResponseBodyPreCheckDBList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDataCorrectPreCheckDBResponseBody() = default;
};
class ListDataCorrectPreCheckDBResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataCorrectPreCheckDBResponseBody> body{};

  ListDataCorrectPreCheckDBResponse() {}

  explicit ListDataCorrectPreCheckDBResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataCorrectPreCheckDBResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataCorrectPreCheckDBResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataCorrectPreCheckDBResponse() = default;
};
class ListDataCorrectPreCheckSQLRequest : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tid{};

  ListDataCorrectPreCheckSQLRequest() {}

  explicit ListDataCorrectPreCheckSQLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListDataCorrectPreCheckSQLRequest() = default;
};
class ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList : public Darabonba::Model {
public:
  shared_ptr<long> affectRows{};
  shared_ptr<string> checkSQL{};
  shared_ptr<long> dbId{};
  shared_ptr<string> SQLReviewQueryKey{};
  shared_ptr<string> sqlReviewStatus{};
  shared_ptr<string> sqlType{};
  shared_ptr<string> tableNames{};

  ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList() {}

  explicit ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectRows) {
      res["AffectRows"] = boost::any(*affectRows);
    }
    if (checkSQL) {
      res["CheckSQL"] = boost::any(*checkSQL);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (SQLReviewQueryKey) {
      res["SQLReviewQueryKey"] = boost::any(*SQLReviewQueryKey);
    }
    if (sqlReviewStatus) {
      res["SqlReviewStatus"] = boost::any(*sqlReviewStatus);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (tableNames) {
      res["TableNames"] = boost::any(*tableNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectRows") != m.end() && !m["AffectRows"].empty()) {
      affectRows = make_shared<long>(boost::any_cast<long>(m["AffectRows"]));
    }
    if (m.find("CheckSQL") != m.end() && !m["CheckSQL"].empty()) {
      checkSQL = make_shared<string>(boost::any_cast<string>(m["CheckSQL"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("SQLReviewQueryKey") != m.end() && !m["SQLReviewQueryKey"].empty()) {
      SQLReviewQueryKey = make_shared<string>(boost::any_cast<string>(m["SQLReviewQueryKey"]));
    }
    if (m.find("SqlReviewStatus") != m.end() && !m["SqlReviewStatus"].empty()) {
      sqlReviewStatus = make_shared<string>(boost::any_cast<string>(m["SqlReviewStatus"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("TableNames") != m.end() && !m["TableNames"].empty()) {
      tableNames = make_shared<string>(boost::any_cast<string>(m["TableNames"]));
    }
  }


  virtual ~ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList() = default;
};
class ListDataCorrectPreCheckSQLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList>> preCheckSQLList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListDataCorrectPreCheckSQLResponseBody() {}

  explicit ListDataCorrectPreCheckSQLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (preCheckSQLList) {
      vector<boost::any> temp1;
      for(auto item1:*preCheckSQLList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PreCheckSQLList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PreCheckSQLList") != m.end() && !m["PreCheckSQLList"].empty()) {
      if (typeid(vector<boost::any>) == m["PreCheckSQLList"].type()) {
        vector<ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PreCheckSQLList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preCheckSQLList = make_shared<vector<ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDataCorrectPreCheckSQLResponseBody() = default;
};
class ListDataCorrectPreCheckSQLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataCorrectPreCheckSQLResponseBody> body{};

  ListDataCorrectPreCheckSQLResponse() {}

  explicit ListDataCorrectPreCheckSQLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataCorrectPreCheckSQLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataCorrectPreCheckSQLResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataCorrectPreCheckSQLResponse() = default;
};
class ListDataImportSQLPreCheckDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> pageNumer{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sqlType{};
  shared_ptr<string> statusCode{};
  shared_ptr<long> tid{};

  ListDataImportSQLPreCheckDetailRequest() {}

  explicit ListDataImportSQLPreCheckDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (pageNumer) {
      res["PageNumer"] = boost::any(*pageNumer);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("PageNumer") != m.end() && !m["PageNumer"].empty()) {
      pageNumer = make_shared<long>(boost::any_cast<long>(m["PageNumer"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListDataImportSQLPreCheckDetailRequest() = default;
};
class ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList : public Darabonba::Model {
public:
  shared_ptr<bool> skip{};
  shared_ptr<long> sqlId{};
  shared_ptr<string> sqlType{};
  shared_ptr<string> statusCode{};

  ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList() {}

  explicit ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<bool>(boost::any_cast<bool>(m["Skip"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<long>(boost::any_cast<long>(m["SqlId"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
  }


  virtual ~ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList() = default;
};
class ListDataImportSQLPreCheckDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList>> preCheckSQLDetailList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListDataImportSQLPreCheckDetailResponseBody() {}

  explicit ListDataImportSQLPreCheckDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (preCheckSQLDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*preCheckSQLDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PreCheckSQLDetailList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PreCheckSQLDetailList") != m.end() && !m["PreCheckSQLDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["PreCheckSQLDetailList"].type()) {
        vector<ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PreCheckSQLDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preCheckSQLDetailList = make_shared<vector<ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataImportSQLPreCheckDetailResponseBody() = default;
};
class ListDataImportSQLPreCheckDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataImportSQLPreCheckDetailResponseBody> body{};

  ListDataImportSQLPreCheckDetailResponse() {}

  explicit ListDataImportSQLPreCheckDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataImportSQLPreCheckDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataImportSQLPreCheckDetailResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataImportSQLPreCheckDetailResponse() = default;
};
class ListDataImportSQLTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  ListDataImportSQLTypeRequest() {}

  explicit ListDataImportSQLTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListDataImportSQLTypeRequest() = default;
};
class ListDataImportSQLTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> sqlTypeResult{};
  shared_ptr<bool> success{};

  ListDataImportSQLTypeResponseBody() {}

  explicit ListDataImportSQLTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sqlTypeResult) {
      res["SqlTypeResult"] = boost::any(*sqlTypeResult);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SqlTypeResult") != m.end() && !m["SqlTypeResult"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SqlTypeResult"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SqlTypeResult"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sqlTypeResult = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDataImportSQLTypeResponseBody() = default;
};
class ListDataImportSQLTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataImportSQLTypeResponseBody> body{};

  ListDataImportSQLTypeResponse() {}

  explicit ListDataImportSQLTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataImportSQLTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataImportSQLTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataImportSQLTypeResponse() = default;
};
class ListDatabaseUserPermssionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbId{};
  shared_ptr<bool> logic{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> permType{};
  shared_ptr<long> tid{};
  shared_ptr<string> userName{};

  ListDatabaseUserPermssionsRequest() {}

  explicit ListDatabaseUserPermssionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (permType) {
      res["PermType"] = boost::any(*permType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<string>(boost::any_cast<string>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PermType") != m.end() && !m["PermType"].empty()) {
      permType = make_shared<string>(boost::any_cast<string>(m["PermType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ListDatabaseUserPermssionsRequest() = default;
};
class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail : public Darabonba::Model {
public:
  shared_ptr<string> createDate{};
  shared_ptr<string> expireDate{};
  shared_ptr<string> extraData{};
  shared_ptr<string> originFrom{};
  shared_ptr<string> permType{};
  shared_ptr<string> userAccessId{};

  ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail() {}

  explicit ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (expireDate) {
      res["ExpireDate"] = boost::any(*expireDate);
    }
    if (extraData) {
      res["ExtraData"] = boost::any(*extraData);
    }
    if (originFrom) {
      res["OriginFrom"] = boost::any(*originFrom);
    }
    if (permType) {
      res["PermType"] = boost::any(*permType);
    }
    if (userAccessId) {
      res["UserAccessId"] = boost::any(*userAccessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("ExpireDate") != m.end() && !m["ExpireDate"].empty()) {
      expireDate = make_shared<string>(boost::any_cast<string>(m["ExpireDate"]));
    }
    if (m.find("ExtraData") != m.end() && !m["ExtraData"].empty()) {
      extraData = make_shared<string>(boost::any_cast<string>(m["ExtraData"]));
    }
    if (m.find("OriginFrom") != m.end() && !m["OriginFrom"].empty()) {
      originFrom = make_shared<string>(boost::any_cast<string>(m["OriginFrom"]));
    }
    if (m.find("PermType") != m.end() && !m["PermType"].empty()) {
      permType = make_shared<string>(boost::any_cast<string>(m["PermType"]));
    }
    if (m.find("UserAccessId") != m.end() && !m["UserAccessId"].empty()) {
      userAccessId = make_shared<string>(boost::any_cast<string>(m["UserAccessId"]));
    }
  }


  virtual ~ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail() = default;
};
class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails : public Darabonba::Model {
public:
  shared_ptr<vector<ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail>> permDetail{};

  ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails() {}

  explicit ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (permDetail) {
      vector<boost::any> temp1;
      for(auto item1:*permDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PermDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PermDetail") != m.end() && !m["PermDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["PermDetail"].type()) {
        vector<ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PermDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        permDetail = make_shared<vector<ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail>>(expect1);
      }
    }
  }


  virtual ~ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails() = default;
};
class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> columnName{};
  shared_ptr<string> dbId{};
  shared_ptr<string> dbType{};
  shared_ptr<string> dsType{};
  shared_ptr<string> envType{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> logic{};
  shared_ptr<ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails> permDetails{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> searchName{};
  shared_ptr<string> tableId{};
  shared_ptr<string> tableName{};
  shared_ptr<string> userId{};
  shared_ptr<string> userNickName{};

  ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission() {}

  explicit ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (dsType) {
      res["DsType"] = boost::any(*dsType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (permDetails) {
      res["PermDetails"] = permDetails ? boost::any(permDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userNickName) {
      res["UserNickName"] = boost::any(*userNickName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<string>(boost::any_cast<string>(m["DbId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("DsType") != m.end() && !m["DsType"].empty()) {
      dsType = make_shared<string>(boost::any_cast<string>(m["DsType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("PermDetails") != m.end() && !m["PermDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["PermDetails"].type()) {
        ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PermDetails"]));
        permDetails = make_shared<ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails>(model1);
      }
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserNickName") != m.end() && !m["UserNickName"].empty()) {
      userNickName = make_shared<string>(boost::any_cast<string>(m["UserNickName"]));
    }
  }


  virtual ~ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission() = default;
};
class ListDatabaseUserPermssionsResponseBodyUserPermissions : public Darabonba::Model {
public:
  shared_ptr<vector<ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission>> userPermission{};

  ListDatabaseUserPermssionsResponseBodyUserPermissions() {}

  explicit ListDatabaseUserPermssionsResponseBodyUserPermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userPermission) {
      vector<boost::any> temp1;
      for(auto item1:*userPermission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserPermission"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserPermission") != m.end() && !m["UserPermission"].empty()) {
      if (typeid(vector<boost::any>) == m["UserPermission"].type()) {
        vector<ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserPermission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userPermission = make_shared<vector<ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission>>(expect1);
      }
    }
  }


  virtual ~ListDatabaseUserPermssionsResponseBodyUserPermissions() = default;
};
class ListDatabaseUserPermssionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListDatabaseUserPermssionsResponseBodyUserPermissions> userPermissions{};

  ListDatabaseUserPermssionsResponseBody() {}

  explicit ListDatabaseUserPermssionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userPermissions) {
      res["UserPermissions"] = userPermissions ? boost::any(userPermissions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserPermissions") != m.end() && !m["UserPermissions"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserPermissions"].type()) {
        ListDatabaseUserPermssionsResponseBodyUserPermissions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserPermissions"]));
        userPermissions = make_shared<ListDatabaseUserPermssionsResponseBodyUserPermissions>(model1);
      }
    }
  }


  virtual ~ListDatabaseUserPermssionsResponseBody() = default;
};
class ListDatabaseUserPermssionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatabaseUserPermssionsResponseBody> body{};

  ListDatabaseUserPermssionsResponse() {}

  explicit ListDatabaseUserPermssionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatabaseUserPermssionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatabaseUserPermssionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatabaseUserPermssionsResponse() = default;
};
class ListDatabasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tid{};

  ListDatabasesRequest() {}

  explicit ListDatabasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListDatabasesRequest() = default;
};
class ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerIds{};

  ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList() {}

  explicit ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList() = default;
};
class ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerNames{};

  ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList() {}

  explicit ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList() = default;
};
class ListDatabasesResponseBodyDatabaseListDatabase : public Darabonba::Model {
public:
  shared_ptr<string> catalogName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> dbType{};
  shared_ptr<string> dbaId{};
  shared_ptr<string> dbaName{};
  shared_ptr<string> encoding{};
  shared_ptr<string> envType{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceId{};
  shared_ptr<ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList> ownerIdList{};
  shared_ptr<ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList> ownerNameList{};
  shared_ptr<long> port{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> searchName{};
  shared_ptr<string> sid{};
  shared_ptr<string> state{};

  ListDatabasesResponseBodyDatabaseListDatabase() {}

  explicit ListDatabasesResponseBodyDatabaseListDatabase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (catalogName) {
      res["CatalogName"] = boost::any(*catalogName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (dbaId) {
      res["DbaId"] = boost::any(*dbaId);
    }
    if (dbaName) {
      res["DbaName"] = boost::any(*dbaName);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerIdList) {
      res["OwnerIdList"] = ownerIdList ? boost::any(ownerIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerNameList) {
      res["OwnerNameList"] = ownerNameList ? boost::any(ownerNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CatalogName") != m.end() && !m["CatalogName"].empty()) {
      catalogName = make_shared<string>(boost::any_cast<string>(m["CatalogName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("DbaId") != m.end() && !m["DbaId"].empty()) {
      dbaId = make_shared<string>(boost::any_cast<string>(m["DbaId"]));
    }
    if (m.find("DbaName") != m.end() && !m["DbaName"].empty()) {
      dbaName = make_shared<string>(boost::any_cast<string>(m["DbaName"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerIdList") != m.end() && !m["OwnerIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerIdList"].type()) {
        ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerIdList"]));
        ownerIdList = make_shared<ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList>(model1);
      }
    }
    if (m.find("OwnerNameList") != m.end() && !m["OwnerNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerNameList"].type()) {
        ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerNameList"]));
        ownerNameList = make_shared<ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList>(model1);
      }
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListDatabasesResponseBodyDatabaseListDatabase() = default;
};
class ListDatabasesResponseBodyDatabaseList : public Darabonba::Model {
public:
  shared_ptr<vector<ListDatabasesResponseBodyDatabaseListDatabase>> database{};

  ListDatabasesResponseBodyDatabaseList() {}

  explicit ListDatabasesResponseBodyDatabaseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      vector<boost::any> temp1;
      for(auto item1:*database){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Database"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      if (typeid(vector<boost::any>) == m["Database"].type()) {
        vector<ListDatabasesResponseBodyDatabaseListDatabase> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Database"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatabasesResponseBodyDatabaseListDatabase model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        database = make_shared<vector<ListDatabasesResponseBodyDatabaseListDatabase>>(expect1);
      }
    }
  }


  virtual ~ListDatabasesResponseBodyDatabaseList() = default;
};
class ListDatabasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDatabasesResponseBodyDatabaseList> databaseList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListDatabasesResponseBody() {}

  explicit ListDatabasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseList) {
      res["DatabaseList"] = databaseList ? boost::any(databaseList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseList") != m.end() && !m["DatabaseList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatabaseList"].type()) {
        ListDatabasesResponseBodyDatabaseList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatabaseList"]));
        databaseList = make_shared<ListDatabasesResponseBodyDatabaseList>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDatabasesResponseBody() = default;
};
class ListDatabasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatabasesResponseBody> body{};

  ListDatabasesResponse() {}

  explicit ListDatabasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatabasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatabasesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatabasesResponse() = default;
};
class ListDefaultSLARulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  ListDefaultSLARulesRequest() {}

  explicit ListDefaultSLARulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListDefaultSLARulesRequest() = default;
};
class ListDefaultSLARulesResponseBodySLARuleListSLARule : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> id{};
  shared_ptr<long> intervalMinutes{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> ruleType{};

  ListDefaultSLARulesResponseBodySLARuleListSLARule() {}

  explicit ListDefaultSLARulesResponseBodySLARuleListSLARule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (intervalMinutes) {
      res["IntervalMinutes"] = boost::any(*intervalMinutes);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IntervalMinutes") != m.end() && !m["IntervalMinutes"].empty()) {
      intervalMinutes = make_shared<long>(boost::any_cast<long>(m["IntervalMinutes"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
  }


  virtual ~ListDefaultSLARulesResponseBodySLARuleListSLARule() = default;
};
class ListDefaultSLARulesResponseBodySLARuleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListDefaultSLARulesResponseBodySLARuleListSLARule>> SLARule{};

  ListDefaultSLARulesResponseBodySLARuleList() {}

  explicit ListDefaultSLARulesResponseBodySLARuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SLARule) {
      vector<boost::any> temp1;
      for(auto item1:*SLARule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SLARule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SLARule") != m.end() && !m["SLARule"].empty()) {
      if (typeid(vector<boost::any>) == m["SLARule"].type()) {
        vector<ListDefaultSLARulesResponseBodySLARuleListSLARule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SLARule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDefaultSLARulesResponseBodySLARuleListSLARule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SLARule = make_shared<vector<ListDefaultSLARulesResponseBodySLARuleListSLARule>>(expect1);
      }
    }
  }


  virtual ~ListDefaultSLARulesResponseBodySLARuleList() = default;
};
class ListDefaultSLARulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ListDefaultSLARulesResponseBodySLARuleList> SLARuleList{};
  shared_ptr<bool> success{};

  ListDefaultSLARulesResponseBody() {}

  explicit ListDefaultSLARulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (SLARuleList) {
      res["SLARuleList"] = SLARuleList ? boost::any(SLARuleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SLARuleList") != m.end() && !m["SLARuleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SLARuleList"].type()) {
        ListDefaultSLARulesResponseBodySLARuleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SLARuleList"]));
        SLARuleList = make_shared<ListDefaultSLARulesResponseBodySLARuleList>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDefaultSLARulesResponseBody() = default;
};
class ListDefaultSLARulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDefaultSLARulesResponseBody> body{};

  ListDefaultSLARulesResponse() {}

  explicit ListDefaultSLARulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDefaultSLARulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDefaultSLARulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDefaultSLARulesResponse() = default;
};
class ListDesensitizationRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> funcType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleType{};
  shared_ptr<long> tid{};

  ListDesensitizationRuleRequest() {}

  explicit ListDesensitizationRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (funcType) {
      res["FuncType"] = boost::any(*funcType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FuncType") != m.end() && !m["FuncType"].empty()) {
      funcType = make_shared<string>(boost::any_cast<string>(m["FuncType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListDesensitizationRuleRequest() = default;
};
class ListDesensitizationRuleResponseBodyDesensitizationRuleList : public Darabonba::Model {
public:
  shared_ptr<string> funcParams{};
  shared_ptr<string> funcSample{};
  shared_ptr<string> functionType{};
  shared_ptr<string> lastModifierId{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<long> referenceCount{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleType{};

  ListDesensitizationRuleResponseBodyDesensitizationRuleList() {}

  explicit ListDesensitizationRuleResponseBodyDesensitizationRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (funcParams) {
      res["FuncParams"] = boost::any(*funcParams);
    }
    if (funcSample) {
      res["FuncSample"] = boost::any(*funcSample);
    }
    if (functionType) {
      res["FunctionType"] = boost::any(*functionType);
    }
    if (lastModifierId) {
      res["LastModifierId"] = boost::any(*lastModifierId);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (referenceCount) {
      res["ReferenceCount"] = boost::any(*referenceCount);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FuncParams") != m.end() && !m["FuncParams"].empty()) {
      funcParams = make_shared<string>(boost::any_cast<string>(m["FuncParams"]));
    }
    if (m.find("FuncSample") != m.end() && !m["FuncSample"].empty()) {
      funcSample = make_shared<string>(boost::any_cast<string>(m["FuncSample"]));
    }
    if (m.find("FunctionType") != m.end() && !m["FunctionType"].empty()) {
      functionType = make_shared<string>(boost::any_cast<string>(m["FunctionType"]));
    }
    if (m.find("LastModifierId") != m.end() && !m["LastModifierId"].empty()) {
      lastModifierId = make_shared<string>(boost::any_cast<string>(m["LastModifierId"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("ReferenceCount") != m.end() && !m["ReferenceCount"].empty()) {
      referenceCount = make_shared<long>(boost::any_cast<long>(m["ReferenceCount"]));
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~ListDesensitizationRuleResponseBodyDesensitizationRuleList() = default;
};
class ListDesensitizationRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDesensitizationRuleResponseBodyDesensitizationRuleList>> desensitizationRuleList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListDesensitizationRuleResponseBody() {}

  explicit ListDesensitizationRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desensitizationRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*desensitizationRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DesensitizationRuleList"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesensitizationRuleList") != m.end() && !m["DesensitizationRuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["DesensitizationRuleList"].type()) {
        vector<ListDesensitizationRuleResponseBodyDesensitizationRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DesensitizationRuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDesensitizationRuleResponseBodyDesensitizationRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        desensitizationRuleList = make_shared<vector<ListDesensitizationRuleResponseBodyDesensitizationRuleList>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDesensitizationRuleResponseBody() = default;
};
class ListDesensitizationRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDesensitizationRuleResponseBody> body{};

  ListDesensitizationRuleResponse() {}

  explicit ListDesensitizationRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDesensitizationRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDesensitizationRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ListDesensitizationRuleResponse() = default;
};
class ListEffectiveOrdersRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};

  ListEffectiveOrdersRequest() {}

  explicit ListEffectiveOrdersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListEffectiveOrdersRequest() = default;
};
class ListEffectiveOrdersResponseBodyOrderSummaryOrderList : public Darabonba::Model {
public:
  shared_ptr<string> buyerId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> insNum{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> startTime{};

  ListEffectiveOrdersResponseBodyOrderSummaryOrderList() {}

  explicit ListEffectiveOrdersResponseBodyOrderSummaryOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buyerId) {
      res["BuyerId"] = boost::any(*buyerId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (insNum) {
      res["InsNum"] = boost::any(*insNum);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuyerId") != m.end() && !m["BuyerId"].empty()) {
      buyerId = make_shared<string>(boost::any_cast<string>(m["BuyerId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InsNum") != m.end() && !m["InsNum"].empty()) {
      insNum = make_shared<string>(boost::any_cast<string>(m["InsNum"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListEffectiveOrdersResponseBodyOrderSummaryOrderList() = default;
};
class ListEffectiveOrdersResponseBodyOrderSummary : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> commodityType{};
  shared_ptr<vector<ListEffectiveOrdersResponseBodyOrderSummaryOrderList>> orderList{};
  shared_ptr<long> totalQuota{};
  shared_ptr<string> versionType{};

  ListEffectiveOrdersResponseBodyOrderSummary() {}

  explicit ListEffectiveOrdersResponseBodyOrderSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (commodityType) {
      res["CommodityType"] = boost::any(*commodityType);
    }
    if (orderList) {
      vector<boost::any> temp1;
      for(auto item1:*orderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrderList"] = boost::any(temp1);
    }
    if (totalQuota) {
      res["TotalQuota"] = boost::any(*totalQuota);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CommodityType") != m.end() && !m["CommodityType"].empty()) {
      commodityType = make_shared<string>(boost::any_cast<string>(m["CommodityType"]));
    }
    if (m.find("OrderList") != m.end() && !m["OrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["OrderList"].type()) {
        vector<ListEffectiveOrdersResponseBodyOrderSummaryOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEffectiveOrdersResponseBodyOrderSummaryOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        orderList = make_shared<vector<ListEffectiveOrdersResponseBodyOrderSummaryOrderList>>(expect1);
      }
    }
    if (m.find("TotalQuota") != m.end() && !m["TotalQuota"].empty()) {
      totalQuota = make_shared<long>(boost::any_cast<long>(m["TotalQuota"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~ListEffectiveOrdersResponseBodyOrderSummary() = default;
};
class ListEffectiveOrdersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListEffectiveOrdersResponseBodyOrderSummary>> orderSummary{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListEffectiveOrdersResponseBody() {}

  explicit ListEffectiveOrdersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (orderSummary) {
      vector<boost::any> temp1;
      for(auto item1:*orderSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrderSummary"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("OrderSummary") != m.end() && !m["OrderSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["OrderSummary"].type()) {
        vector<ListEffectiveOrdersResponseBodyOrderSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrderSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEffectiveOrdersResponseBodyOrderSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        orderSummary = make_shared<vector<ListEffectiveOrdersResponseBodyOrderSummary>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListEffectiveOrdersResponseBody() = default;
};
class ListEffectiveOrdersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEffectiveOrdersResponseBody> body{};

  ListEffectiveOrdersResponse() {}

  explicit ListEffectiveOrdersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEffectiveOrdersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEffectiveOrdersResponseBody>(model1);
      }
    }
  }


  virtual ~ListEffectiveOrdersResponse() = default;
};
class ListIndexesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> logic{};
  shared_ptr<string> tableId{};
  shared_ptr<long> tid{};

  ListIndexesRequest() {}

  explicit ListIndexesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListIndexesRequest() = default;
};
class ListIndexesResponseBodyIndexListIndex : public Darabonba::Model {
public:
  shared_ptr<string> indexComment{};
  shared_ptr<string> indexId{};
  shared_ptr<string> indexName{};
  shared_ptr<string> indexType{};
  shared_ptr<string> tableId{};

  ListIndexesResponseBodyIndexListIndex() {}

  explicit ListIndexesResponseBodyIndexListIndex(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexComment) {
      res["IndexComment"] = boost::any(*indexComment);
    }
    if (indexId) {
      res["IndexId"] = boost::any(*indexId);
    }
    if (indexName) {
      res["IndexName"] = boost::any(*indexName);
    }
    if (indexType) {
      res["IndexType"] = boost::any(*indexType);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexComment") != m.end() && !m["IndexComment"].empty()) {
      indexComment = make_shared<string>(boost::any_cast<string>(m["IndexComment"]));
    }
    if (m.find("IndexId") != m.end() && !m["IndexId"].empty()) {
      indexId = make_shared<string>(boost::any_cast<string>(m["IndexId"]));
    }
    if (m.find("IndexName") != m.end() && !m["IndexName"].empty()) {
      indexName = make_shared<string>(boost::any_cast<string>(m["IndexName"]));
    }
    if (m.find("IndexType") != m.end() && !m["IndexType"].empty()) {
      indexType = make_shared<string>(boost::any_cast<string>(m["IndexType"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
  }


  virtual ~ListIndexesResponseBodyIndexListIndex() = default;
};
class ListIndexesResponseBodyIndexList : public Darabonba::Model {
public:
  shared_ptr<vector<ListIndexesResponseBodyIndexListIndex>> index{};

  ListIndexesResponseBodyIndexList() {}

  explicit ListIndexesResponseBodyIndexList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      vector<boost::any> temp1;
      for(auto item1:*index){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Index"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      if (typeid(vector<boost::any>) == m["Index"].type()) {
        vector<ListIndexesResponseBodyIndexListIndex> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Index"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIndexesResponseBodyIndexListIndex model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        index = make_shared<vector<ListIndexesResponseBodyIndexListIndex>>(expect1);
      }
    }
  }


  virtual ~ListIndexesResponseBodyIndexList() = default;
};
class ListIndexesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListIndexesResponseBodyIndexList> indexList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListIndexesResponseBody() {}

  explicit ListIndexesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (indexList) {
      res["IndexList"] = indexList ? boost::any(indexList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("IndexList") != m.end() && !m["IndexList"].empty()) {
      if (typeid(map<string, boost::any>) == m["IndexList"].type()) {
        ListIndexesResponseBodyIndexList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IndexList"]));
        indexList = make_shared<ListIndexesResponseBodyIndexList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListIndexesResponseBody() = default;
};
class ListIndexesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIndexesResponseBody> body{};

  ListIndexesResponse() {}

  explicit ListIndexesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIndexesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIndexesResponseBody>(model1);
      }
    }
  }


  virtual ~ListIndexesResponse() = default;
};
class ListInstanceLoginAuditLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> opUserName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchName{};
  shared_ptr<string> startTime{};
  shared_ptr<long> tid{};

  ListInstanceLoginAuditLogRequest() {}

  explicit ListInstanceLoginAuditLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (opUserName) {
      res["OpUserName"] = boost::any(*opUserName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OpUserName") != m.end() && !m["OpUserName"].empty()) {
      opUserName = make_shared<string>(boost::any_cast<string>(m["OpUserName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListInstanceLoginAuditLogRequest() = default;
};
class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog : public Darabonba::Model {
public:
  shared_ptr<string> dbUser{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> opTime{};
  shared_ptr<string> requestIp{};
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};

  ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog() {}

  explicit ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbUser) {
      res["DbUser"] = boost::any(*dbUser);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (opTime) {
      res["OpTime"] = boost::any(*opTime);
    }
    if (requestIp) {
      res["RequestIp"] = boost::any(*requestIp);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbUser") != m.end() && !m["DbUser"].empty()) {
      dbUser = make_shared<string>(boost::any_cast<string>(m["DbUser"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("OpTime") != m.end() && !m["OpTime"].empty()) {
      opTime = make_shared<string>(boost::any_cast<string>(m["OpTime"]));
    }
    if (m.find("RequestIp") != m.end() && !m["RequestIp"].empty()) {
      requestIp = make_shared<string>(boost::any_cast<string>(m["RequestIp"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog() = default;
};
class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog>> instanceLoginAuditLog{};

  ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList() {}

  explicit ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceLoginAuditLog) {
      vector<boost::any> temp1;
      for(auto item1:*instanceLoginAuditLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceLoginAuditLog"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceLoginAuditLog") != m.end() && !m["InstanceLoginAuditLog"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceLoginAuditLog"].type()) {
        vector<ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceLoginAuditLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceLoginAuditLog = make_shared<vector<ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog>>(expect1);
      }
    }
  }


  virtual ~ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList() = default;
};
class ListInstanceLoginAuditLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList> instanceLoginAuditLogList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListInstanceLoginAuditLogResponseBody() {}

  explicit ListInstanceLoginAuditLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceLoginAuditLogList) {
      res["InstanceLoginAuditLogList"] = instanceLoginAuditLogList ? boost::any(instanceLoginAuditLogList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceLoginAuditLogList") != m.end() && !m["InstanceLoginAuditLogList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceLoginAuditLogList"].type()) {
        ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceLoginAuditLogList"]));
        instanceLoginAuditLogList = make_shared<ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInstanceLoginAuditLogResponseBody() = default;
};
class ListInstanceLoginAuditLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstanceLoginAuditLogResponseBody> body{};

  ListInstanceLoginAuditLogResponse() {}

  explicit ListInstanceLoginAuditLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstanceLoginAuditLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstanceLoginAuditLogResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstanceLoginAuditLogResponse() = default;
};
class ListInstanceUserPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tid{};
  shared_ptr<string> userName{};

  ListInstanceUserPermissionsRequest() {}

  explicit ListInstanceUserPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ListInstanceUserPermissionsRequest() = default;
};
class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail : public Darabonba::Model {
public:
  shared_ptr<string> createDate{};
  shared_ptr<string> expireDate{};
  shared_ptr<string> extraData{};
  shared_ptr<string> originFrom{};
  shared_ptr<string> permType{};
  shared_ptr<string> userAccessId{};

  ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail() {}

  explicit ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (expireDate) {
      res["ExpireDate"] = boost::any(*expireDate);
    }
    if (extraData) {
      res["ExtraData"] = boost::any(*extraData);
    }
    if (originFrom) {
      res["OriginFrom"] = boost::any(*originFrom);
    }
    if (permType) {
      res["PermType"] = boost::any(*permType);
    }
    if (userAccessId) {
      res["UserAccessId"] = boost::any(*userAccessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("ExpireDate") != m.end() && !m["ExpireDate"].empty()) {
      expireDate = make_shared<string>(boost::any_cast<string>(m["ExpireDate"]));
    }
    if (m.find("ExtraData") != m.end() && !m["ExtraData"].empty()) {
      extraData = make_shared<string>(boost::any_cast<string>(m["ExtraData"]));
    }
    if (m.find("OriginFrom") != m.end() && !m["OriginFrom"].empty()) {
      originFrom = make_shared<string>(boost::any_cast<string>(m["OriginFrom"]));
    }
    if (m.find("PermType") != m.end() && !m["PermType"].empty()) {
      permType = make_shared<string>(boost::any_cast<string>(m["PermType"]));
    }
    if (m.find("UserAccessId") != m.end() && !m["UserAccessId"].empty()) {
      userAccessId = make_shared<string>(boost::any_cast<string>(m["UserAccessId"]));
    }
  }


  virtual ~ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail() = default;
};
class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail>> permDetail{};

  ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails() {}

  explicit ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (permDetail) {
      vector<boost::any> temp1;
      for(auto item1:*permDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PermDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PermDetail") != m.end() && !m["PermDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["PermDetail"].type()) {
        vector<ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PermDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        permDetail = make_shared<vector<ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail>>(expect1);
      }
    }
  }


  virtual ~ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails() = default;
};
class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails> permDetails{};
  shared_ptr<string> userId{};
  shared_ptr<string> userNickName{};

  ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission() {}

  explicit ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (permDetails) {
      res["PermDetails"] = permDetails ? boost::any(permDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userNickName) {
      res["UserNickName"] = boost::any(*userNickName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PermDetails") != m.end() && !m["PermDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["PermDetails"].type()) {
        ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PermDetails"]));
        permDetails = make_shared<ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserNickName") != m.end() && !m["UserNickName"].empty()) {
      userNickName = make_shared<string>(boost::any_cast<string>(m["UserNickName"]));
    }
  }


  virtual ~ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission() = default;
};
class ListInstanceUserPermissionsResponseBodyUserPermissions : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission>> userPermission{};

  ListInstanceUserPermissionsResponseBodyUserPermissions() {}

  explicit ListInstanceUserPermissionsResponseBodyUserPermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userPermission) {
      vector<boost::any> temp1;
      for(auto item1:*userPermission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserPermission"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserPermission") != m.end() && !m["UserPermission"].empty()) {
      if (typeid(vector<boost::any>) == m["UserPermission"].type()) {
        vector<ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserPermission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userPermission = make_shared<vector<ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission>>(expect1);
      }
    }
  }


  virtual ~ListInstanceUserPermissionsResponseBodyUserPermissions() = default;
};
class ListInstanceUserPermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListInstanceUserPermissionsResponseBodyUserPermissions> userPermissions{};

  ListInstanceUserPermissionsResponseBody() {}

  explicit ListInstanceUserPermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userPermissions) {
      res["UserPermissions"] = userPermissions ? boost::any(userPermissions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserPermissions") != m.end() && !m["UserPermissions"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserPermissions"].type()) {
        ListInstanceUserPermissionsResponseBodyUserPermissions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserPermissions"]));
        userPermissions = make_shared<ListInstanceUserPermissionsResponseBodyUserPermissions>(model1);
      }
    }
  }


  virtual ~ListInstanceUserPermissionsResponseBody() = default;
};
class ListInstanceUserPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstanceUserPermissionsResponseBody> body{};

  ListInstanceUserPermissionsResponse() {}

  explicit ListInstanceUserPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstanceUserPermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstanceUserPermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstanceUserPermissionsResponse() = default;
};
class ListInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<string> instanceSource{};
  shared_ptr<string> instanceState{};
  shared_ptr<string> netType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<long> tid{};

  ListInstancesRequest() {}

  explicit ListInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (instanceSource) {
      res["InstanceSource"] = boost::any(*instanceSource);
    }
    if (instanceState) {
      res["InstanceState"] = boost::any(*instanceState);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("InstanceSource") != m.end() && !m["InstanceSource"].empty()) {
      instanceSource = make_shared<string>(boost::any_cast<string>(m["InstanceSource"]));
    }
    if (m.find("InstanceState") != m.end() && !m["InstanceState"].empty()) {
      instanceState = make_shared<string>(boost::any_cast<string>(m["InstanceState"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListInstancesRequest() = default;
};
class ListInstancesResponseBodyInstanceListInstanceOwnerIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerIds{};

  ListInstancesResponseBodyInstanceListInstanceOwnerIdList() {}

  explicit ListInstancesResponseBodyInstanceListInstanceOwnerIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListInstancesResponseBodyInstanceListInstanceOwnerIdList() = default;
};
class ListInstancesResponseBodyInstanceListInstanceOwnerNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerNames{};

  ListInstancesResponseBodyInstanceListInstanceOwnerNameList() {}

  explicit ListInstancesResponseBodyInstanceListInstanceOwnerNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListInstancesResponseBodyInstanceListInstanceOwnerNameList() = default;
};
class ListInstancesResponseBodyInstanceListInstanceStandardGroup : public Darabonba::Model {
public:
  shared_ptr<string> groupMode{};
  shared_ptr<string> groupName{};

  ListInstancesResponseBodyInstanceListInstanceStandardGroup() {}

  explicit ListInstancesResponseBodyInstanceListInstanceStandardGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupMode) {
      res["GroupMode"] = boost::any(*groupMode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupMode") != m.end() && !m["GroupMode"].empty()) {
      groupMode = make_shared<string>(boost::any_cast<string>(m["GroupMode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~ListInstancesResponseBodyInstanceListInstanceStandardGroup() = default;
};
class ListInstancesResponseBodyInstanceListInstance : public Darabonba::Model {
public:
  shared_ptr<string> dataLinkName{};
  shared_ptr<string> databasePassword{};
  shared_ptr<string> databaseUser{};
  shared_ptr<string> dbaId{};
  shared_ptr<string> dbaNickName{};
  shared_ptr<long> ddlOnline{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> ecsRegion{};
  shared_ptr<string> envType{};
  shared_ptr<long> exportTimeout{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceAlias{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceSource{};
  shared_ptr<string> instanceType{};
  shared_ptr<ListInstancesResponseBodyInstanceListInstanceOwnerIdList> ownerIdList{};
  shared_ptr<ListInstancesResponseBodyInstanceListInstanceOwnerNameList> ownerNameList{};
  shared_ptr<long> port{};
  shared_ptr<long> queryTimeout{};
  shared_ptr<string> safeRuleId{};
  shared_ptr<bool> sellSitd{};
  shared_ptr<string> sid{};
  shared_ptr<ListInstancesResponseBodyInstanceListInstanceStandardGroup> standardGroup{};
  shared_ptr<string> state{};
  shared_ptr<long> useDsql{};
  shared_ptr<string> vpcId{};

  ListInstancesResponseBodyInstanceListInstance() {}

  explicit ListInstancesResponseBodyInstanceListInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataLinkName) {
      res["DataLinkName"] = boost::any(*dataLinkName);
    }
    if (databasePassword) {
      res["DatabasePassword"] = boost::any(*databasePassword);
    }
    if (databaseUser) {
      res["DatabaseUser"] = boost::any(*databaseUser);
    }
    if (dbaId) {
      res["DbaId"] = boost::any(*dbaId);
    }
    if (dbaNickName) {
      res["DbaNickName"] = boost::any(*dbaNickName);
    }
    if (ddlOnline) {
      res["DdlOnline"] = boost::any(*ddlOnline);
    }
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (ecsRegion) {
      res["EcsRegion"] = boost::any(*ecsRegion);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (exportTimeout) {
      res["ExportTimeout"] = boost::any(*exportTimeout);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (instanceAlias) {
      res["InstanceAlias"] = boost::any(*instanceAlias);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceSource) {
      res["InstanceSource"] = boost::any(*instanceSource);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerIdList) {
      res["OwnerIdList"] = ownerIdList ? boost::any(ownerIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerNameList) {
      res["OwnerNameList"] = ownerNameList ? boost::any(ownerNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (queryTimeout) {
      res["QueryTimeout"] = boost::any(*queryTimeout);
    }
    if (safeRuleId) {
      res["SafeRuleId"] = boost::any(*safeRuleId);
    }
    if (sellSitd) {
      res["SellSitd"] = boost::any(*sellSitd);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (standardGroup) {
      res["StandardGroup"] = standardGroup ? boost::any(standardGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (useDsql) {
      res["UseDsql"] = boost::any(*useDsql);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataLinkName") != m.end() && !m["DataLinkName"].empty()) {
      dataLinkName = make_shared<string>(boost::any_cast<string>(m["DataLinkName"]));
    }
    if (m.find("DatabasePassword") != m.end() && !m["DatabasePassword"].empty()) {
      databasePassword = make_shared<string>(boost::any_cast<string>(m["DatabasePassword"]));
    }
    if (m.find("DatabaseUser") != m.end() && !m["DatabaseUser"].empty()) {
      databaseUser = make_shared<string>(boost::any_cast<string>(m["DatabaseUser"]));
    }
    if (m.find("DbaId") != m.end() && !m["DbaId"].empty()) {
      dbaId = make_shared<string>(boost::any_cast<string>(m["DbaId"]));
    }
    if (m.find("DbaNickName") != m.end() && !m["DbaNickName"].empty()) {
      dbaNickName = make_shared<string>(boost::any_cast<string>(m["DbaNickName"]));
    }
    if (m.find("DdlOnline") != m.end() && !m["DdlOnline"].empty()) {
      ddlOnline = make_shared<long>(boost::any_cast<long>(m["DdlOnline"]));
    }
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("EcsRegion") != m.end() && !m["EcsRegion"].empty()) {
      ecsRegion = make_shared<string>(boost::any_cast<string>(m["EcsRegion"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ExportTimeout") != m.end() && !m["ExportTimeout"].empty()) {
      exportTimeout = make_shared<long>(boost::any_cast<long>(m["ExportTimeout"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("InstanceAlias") != m.end() && !m["InstanceAlias"].empty()) {
      instanceAlias = make_shared<string>(boost::any_cast<string>(m["InstanceAlias"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceSource") != m.end() && !m["InstanceSource"].empty()) {
      instanceSource = make_shared<string>(boost::any_cast<string>(m["InstanceSource"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerIdList") != m.end() && !m["OwnerIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerIdList"].type()) {
        ListInstancesResponseBodyInstanceListInstanceOwnerIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerIdList"]));
        ownerIdList = make_shared<ListInstancesResponseBodyInstanceListInstanceOwnerIdList>(model1);
      }
    }
    if (m.find("OwnerNameList") != m.end() && !m["OwnerNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerNameList"].type()) {
        ListInstancesResponseBodyInstanceListInstanceOwnerNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerNameList"]));
        ownerNameList = make_shared<ListInstancesResponseBodyInstanceListInstanceOwnerNameList>(model1);
      }
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("QueryTimeout") != m.end() && !m["QueryTimeout"].empty()) {
      queryTimeout = make_shared<long>(boost::any_cast<long>(m["QueryTimeout"]));
    }
    if (m.find("SafeRuleId") != m.end() && !m["SafeRuleId"].empty()) {
      safeRuleId = make_shared<string>(boost::any_cast<string>(m["SafeRuleId"]));
    }
    if (m.find("SellSitd") != m.end() && !m["SellSitd"].empty()) {
      sellSitd = make_shared<bool>(boost::any_cast<bool>(m["SellSitd"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("StandardGroup") != m.end() && !m["StandardGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["StandardGroup"].type()) {
        ListInstancesResponseBodyInstanceListInstanceStandardGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StandardGroup"]));
        standardGroup = make_shared<ListInstancesResponseBodyInstanceListInstanceStandardGroup>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UseDsql") != m.end() && !m["UseDsql"].empty()) {
      useDsql = make_shared<long>(boost::any_cast<long>(m["UseDsql"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListInstancesResponseBodyInstanceListInstance() = default;
};
class ListInstancesResponseBodyInstanceList : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesResponseBodyInstanceListInstance>> instance{};

  ListInstancesResponseBodyInstanceList() {}

  explicit ListInstancesResponseBodyInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      vector<boost::any> temp1;
      for(auto item1:*instance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<ListInstancesResponseBodyInstanceListInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyInstanceListInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instance = make_shared<vector<ListInstancesResponseBodyInstanceListInstance>>(expect1);
      }
    }
  }


  virtual ~ListInstancesResponseBodyInstanceList() = default;
};
class ListInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListInstancesResponseBodyInstanceList> instanceList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListInstancesResponseBody() {}

  explicit ListInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceList) {
      res["InstanceList"] = instanceList ? boost::any(instanceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceList"].type()) {
        ListInstancesResponseBodyInstanceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceList"]));
        instanceList = make_shared<ListInstancesResponseBodyInstanceList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInstancesResponseBody() = default;
};
class ListInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstancesResponseBody> body{};

  ListInstancesResponse() {}

  explicit ListInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstancesResponse() = default;
};
class ListLhTaskFlowAndScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<long> spaceId{};
  shared_ptr<long> tid{};
  shared_ptr<long> userId{};

  ListLhTaskFlowAndScenarioRequest() {}

  explicit ListLhTaskFlowAndScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<long>(boost::any_cast<long>(m["SpaceId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~ListLhTaskFlowAndScenarioRequest() = default;
};
class ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag : public Darabonba::Model {
public:
  shared_ptr<bool> canEdit{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorNickName{};
  shared_ptr<string> dagName{};
  shared_ptr<string> dagOwnerId{};
  shared_ptr<string> dagOwnerNickName{};
  shared_ptr<long> dataFlowId{};
  shared_ptr<string> demoId{};
  shared_ptr<long> deployId{};
  shared_ptr<long> id{};
  shared_ptr<bool> isDeleted{};
  shared_ptr<long> latestInstanceStatus{};
  shared_ptr<long> latestInstanceTime{};
  shared_ptr<long> scenarioId{};
  shared_ptr<long> spaceId{};
  shared_ptr<long> status{};

  ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag() {}

  explicit ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canEdit) {
      res["CanEdit"] = boost::any(*canEdit);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorNickName) {
      res["CreatorNickName"] = boost::any(*creatorNickName);
    }
    if (dagName) {
      res["DagName"] = boost::any(*dagName);
    }
    if (dagOwnerId) {
      res["DagOwnerId"] = boost::any(*dagOwnerId);
    }
    if (dagOwnerNickName) {
      res["DagOwnerNickName"] = boost::any(*dagOwnerNickName);
    }
    if (dataFlowId) {
      res["DataFlowId"] = boost::any(*dataFlowId);
    }
    if (demoId) {
      res["DemoId"] = boost::any(*demoId);
    }
    if (deployId) {
      res["DeployId"] = boost::any(*deployId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isDeleted) {
      res["IsDeleted"] = boost::any(*isDeleted);
    }
    if (latestInstanceStatus) {
      res["LatestInstanceStatus"] = boost::any(*latestInstanceStatus);
    }
    if (latestInstanceTime) {
      res["LatestInstanceTime"] = boost::any(*latestInstanceTime);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanEdit") != m.end() && !m["CanEdit"].empty()) {
      canEdit = make_shared<bool>(boost::any_cast<bool>(m["CanEdit"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorNickName") != m.end() && !m["CreatorNickName"].empty()) {
      creatorNickName = make_shared<string>(boost::any_cast<string>(m["CreatorNickName"]));
    }
    if (m.find("DagName") != m.end() && !m["DagName"].empty()) {
      dagName = make_shared<string>(boost::any_cast<string>(m["DagName"]));
    }
    if (m.find("DagOwnerId") != m.end() && !m["DagOwnerId"].empty()) {
      dagOwnerId = make_shared<string>(boost::any_cast<string>(m["DagOwnerId"]));
    }
    if (m.find("DagOwnerNickName") != m.end() && !m["DagOwnerNickName"].empty()) {
      dagOwnerNickName = make_shared<string>(boost::any_cast<string>(m["DagOwnerNickName"]));
    }
    if (m.find("DataFlowId") != m.end() && !m["DataFlowId"].empty()) {
      dataFlowId = make_shared<long>(boost::any_cast<long>(m["DataFlowId"]));
    }
    if (m.find("DemoId") != m.end() && !m["DemoId"].empty()) {
      demoId = make_shared<string>(boost::any_cast<string>(m["DemoId"]));
    }
    if (m.find("DeployId") != m.end() && !m["DeployId"].empty()) {
      deployId = make_shared<long>(boost::any_cast<long>(m["DeployId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsDeleted") != m.end() && !m["IsDeleted"].empty()) {
      isDeleted = make_shared<bool>(boost::any_cast<bool>(m["IsDeleted"]));
    }
    if (m.find("LatestInstanceStatus") != m.end() && !m["LatestInstanceStatus"].empty()) {
      latestInstanceStatus = make_shared<long>(boost::any_cast<long>(m["LatestInstanceStatus"]));
    }
    if (m.find("LatestInstanceTime") != m.end() && !m["LatestInstanceTime"].empty()) {
      latestInstanceTime = make_shared<long>(boost::any_cast<long>(m["LatestInstanceTime"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<long>(boost::any_cast<long>(m["ScenarioId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<long>(boost::any_cast<long>(m["SpaceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag() = default;
};
class ListLhTaskFlowAndScenarioResponseBodyRawDAGList : public Darabonba::Model {
public:
  shared_ptr<vector<ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag>> dag{};

  ListLhTaskFlowAndScenarioResponseBodyRawDAGList() {}

  explicit ListLhTaskFlowAndScenarioResponseBodyRawDAGList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dag) {
      vector<boost::any> temp1;
      for(auto item1:*dag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dag") != m.end() && !m["Dag"].empty()) {
      if (typeid(vector<boost::any>) == m["Dag"].type()) {
        vector<ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dag = make_shared<vector<ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag>>(expect1);
      }
    }
  }


  virtual ~ListLhTaskFlowAndScenarioResponseBodyRawDAGList() = default;
};
class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag : public Darabonba::Model {
public:
  shared_ptr<bool> canEdit{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorNickName{};
  shared_ptr<string> dagName{};
  shared_ptr<string> dagOwnerId{};
  shared_ptr<string> dagOwnerNickName{};
  shared_ptr<long> dataFlowId{};
  shared_ptr<string> demoId{};
  shared_ptr<long> deployId{};
  shared_ptr<long> id{};
  shared_ptr<bool> isDeleted{};
  shared_ptr<long> latestInstanceStatus{};
  shared_ptr<long> latestInstanceTime{};
  shared_ptr<long> scenarioId{};
  shared_ptr<long> spaceId{};
  shared_ptr<long> status{};

  ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag() {}

  explicit ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canEdit) {
      res["CanEdit"] = boost::any(*canEdit);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorNickName) {
      res["CreatorNickName"] = boost::any(*creatorNickName);
    }
    if (dagName) {
      res["DagName"] = boost::any(*dagName);
    }
    if (dagOwnerId) {
      res["DagOwnerId"] = boost::any(*dagOwnerId);
    }
    if (dagOwnerNickName) {
      res["DagOwnerNickName"] = boost::any(*dagOwnerNickName);
    }
    if (dataFlowId) {
      res["DataFlowId"] = boost::any(*dataFlowId);
    }
    if (demoId) {
      res["DemoId"] = boost::any(*demoId);
    }
    if (deployId) {
      res["DeployId"] = boost::any(*deployId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isDeleted) {
      res["IsDeleted"] = boost::any(*isDeleted);
    }
    if (latestInstanceStatus) {
      res["LatestInstanceStatus"] = boost::any(*latestInstanceStatus);
    }
    if (latestInstanceTime) {
      res["LatestInstanceTime"] = boost::any(*latestInstanceTime);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanEdit") != m.end() && !m["CanEdit"].empty()) {
      canEdit = make_shared<bool>(boost::any_cast<bool>(m["CanEdit"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorNickName") != m.end() && !m["CreatorNickName"].empty()) {
      creatorNickName = make_shared<string>(boost::any_cast<string>(m["CreatorNickName"]));
    }
    if (m.find("DagName") != m.end() && !m["DagName"].empty()) {
      dagName = make_shared<string>(boost::any_cast<string>(m["DagName"]));
    }
    if (m.find("DagOwnerId") != m.end() && !m["DagOwnerId"].empty()) {
      dagOwnerId = make_shared<string>(boost::any_cast<string>(m["DagOwnerId"]));
    }
    if (m.find("DagOwnerNickName") != m.end() && !m["DagOwnerNickName"].empty()) {
      dagOwnerNickName = make_shared<string>(boost::any_cast<string>(m["DagOwnerNickName"]));
    }
    if (m.find("DataFlowId") != m.end() && !m["DataFlowId"].empty()) {
      dataFlowId = make_shared<long>(boost::any_cast<long>(m["DataFlowId"]));
    }
    if (m.find("DemoId") != m.end() && !m["DemoId"].empty()) {
      demoId = make_shared<string>(boost::any_cast<string>(m["DemoId"]));
    }
    if (m.find("DeployId") != m.end() && !m["DeployId"].empty()) {
      deployId = make_shared<long>(boost::any_cast<long>(m["DeployId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsDeleted") != m.end() && !m["IsDeleted"].empty()) {
      isDeleted = make_shared<bool>(boost::any_cast<bool>(m["IsDeleted"]));
    }
    if (m.find("LatestInstanceStatus") != m.end() && !m["LatestInstanceStatus"].empty()) {
      latestInstanceStatus = make_shared<long>(boost::any_cast<long>(m["LatestInstanceStatus"]));
    }
    if (m.find("LatestInstanceTime") != m.end() && !m["LatestInstanceTime"].empty()) {
      latestInstanceTime = make_shared<long>(boost::any_cast<long>(m["LatestInstanceTime"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<long>(boost::any_cast<long>(m["ScenarioId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<long>(boost::any_cast<long>(m["SpaceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag() = default;
};
class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList : public Darabonba::Model {
public:
  shared_ptr<vector<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag>> dag{};

  ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList() {}

  explicit ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dag) {
      vector<boost::any> temp1;
      for(auto item1:*dag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dag") != m.end() && !m["Dag"].empty()) {
      if (typeid(vector<boost::any>) == m["Dag"].type()) {
        vector<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dag = make_shared<vector<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag>>(expect1);
      }
    }
  }


  virtual ~ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList() = default;
};
class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario : public Darabonba::Model {
public:
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> scenarioName{};

  ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario() {}

  explicit ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (scenarioName) {
      res["ScenarioName"] = boost::any(*scenarioName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ScenarioName") != m.end() && !m["ScenarioName"].empty()) {
      scenarioName = make_shared<string>(boost::any_cast<string>(m["ScenarioName"]));
    }
  }


  virtual ~ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario() = default;
};
class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG : public Darabonba::Model {
public:
  shared_ptr<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList> dagList{};
  shared_ptr<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario> scenario{};

  ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG() {}

  explicit ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagList) {
      res["DagList"] = dagList ? boost::any(dagList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scenario) {
      res["Scenario"] = scenario ? boost::any(scenario->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagList") != m.end() && !m["DagList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DagList"].type()) {
        ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DagList"]));
        dagList = make_shared<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList>(model1);
      }
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scenario"].type()) {
        ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scenario"]));
        scenario = make_shared<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario>(model1);
      }
    }
  }


  virtual ~ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG() = default;
};
class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList : public Darabonba::Model {
public:
  shared_ptr<vector<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG>> scenarioDAG{};

  ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList() {}

  explicit ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenarioDAG) {
      vector<boost::any> temp1;
      for(auto item1:*scenarioDAG){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScenarioDAG"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScenarioDAG") != m.end() && !m["ScenarioDAG"].empty()) {
      if (typeid(vector<boost::any>) == m["ScenarioDAG"].type()) {
        vector<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScenarioDAG"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scenarioDAG = make_shared<vector<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG>>(expect1);
      }
    }
  }


  virtual ~ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList() = default;
};
class ListLhTaskFlowAndScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListLhTaskFlowAndScenarioResponseBodyRawDAGList> rawDAGList{};
  shared_ptr<string> requestId{};
  shared_ptr<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList> scenarioDAGList{};
  shared_ptr<bool> success{};

  ListLhTaskFlowAndScenarioResponseBody() {}

  explicit ListLhTaskFlowAndScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (rawDAGList) {
      res["RawDAGList"] = rawDAGList ? boost::any(rawDAGList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scenarioDAGList) {
      res["ScenarioDAGList"] = scenarioDAGList ? boost::any(scenarioDAGList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RawDAGList") != m.end() && !m["RawDAGList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RawDAGList"].type()) {
        ListLhTaskFlowAndScenarioResponseBodyRawDAGList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RawDAGList"]));
        rawDAGList = make_shared<ListLhTaskFlowAndScenarioResponseBodyRawDAGList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScenarioDAGList") != m.end() && !m["ScenarioDAGList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScenarioDAGList"].type()) {
        ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScenarioDAGList"]));
        scenarioDAGList = make_shared<ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLhTaskFlowAndScenarioResponseBody() = default;
};
class ListLhTaskFlowAndScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLhTaskFlowAndScenarioResponseBody> body{};

  ListLhTaskFlowAndScenarioResponse() {}

  explicit ListLhTaskFlowAndScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLhTaskFlowAndScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLhTaskFlowAndScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~ListLhTaskFlowAndScenarioResponse() = default;
};
class ListLogicDatabasesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tid{};

  ListLogicDatabasesRequest() {}

  explicit ListLogicDatabasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListLogicDatabasesRequest() = default;
};
class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds : public Darabonba::Model {
public:
  shared_ptr<vector<long>> databaseIds{};

  ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds() {}

  explicit ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseIds) {
      res["DatabaseIds"] = boost::any(*databaseIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseIds") != m.end() && !m["DatabaseIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DatabaseIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DatabaseIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      databaseIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds() = default;
};
class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerIds{};

  ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList() {}

  explicit ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList() = default;
};
class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerNames{};

  ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList() {}

  explicit ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList() = default;
};
class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> databaseId{};
  shared_ptr<ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds> databaseIds{};
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<bool> logic{};
  shared_ptr<ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList> ownerIdList{};
  shared_ptr<ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList> ownerNameList{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> searchName{};

  ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase() {}

  explicit ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (databaseIds) {
      res["DatabaseIds"] = databaseIds ? boost::any(databaseIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (ownerIdList) {
      res["OwnerIdList"] = ownerIdList ? boost::any(ownerIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerNameList) {
      res["OwnerNameList"] = ownerNameList ? boost::any(ownerNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatabaseIds") != m.end() && !m["DatabaseIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatabaseIds"].type()) {
        ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatabaseIds"]));
        databaseIds = make_shared<ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds>(model1);
      }
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("OwnerIdList") != m.end() && !m["OwnerIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerIdList"].type()) {
        ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerIdList"]));
        ownerIdList = make_shared<ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList>(model1);
      }
    }
    if (m.find("OwnerNameList") != m.end() && !m["OwnerNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerNameList"].type()) {
        ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerNameList"]));
        ownerNameList = make_shared<ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList>(model1);
      }
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
  }


  virtual ~ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase() = default;
};
class ListLogicDatabasesResponseBodyLogicDatabaseList : public Darabonba::Model {
public:
  shared_ptr<vector<ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase>> logicDatabase{};

  ListLogicDatabasesResponseBodyLogicDatabaseList() {}

  explicit ListLogicDatabasesResponseBodyLogicDatabaseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicDatabase) {
      vector<boost::any> temp1;
      for(auto item1:*logicDatabase){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogicDatabase"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicDatabase") != m.end() && !m["LogicDatabase"].empty()) {
      if (typeid(vector<boost::any>) == m["LogicDatabase"].type()) {
        vector<ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogicDatabase"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logicDatabase = make_shared<vector<ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase>>(expect1);
      }
    }
  }


  virtual ~ListLogicDatabasesResponseBodyLogicDatabaseList() = default;
};
class ListLogicDatabasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListLogicDatabasesResponseBodyLogicDatabaseList> logicDatabaseList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListLogicDatabasesResponseBody() {}

  explicit ListLogicDatabasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (logicDatabaseList) {
      res["LogicDatabaseList"] = logicDatabaseList ? boost::any(logicDatabaseList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("LogicDatabaseList") != m.end() && !m["LogicDatabaseList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogicDatabaseList"].type()) {
        ListLogicDatabasesResponseBodyLogicDatabaseList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogicDatabaseList"]));
        logicDatabaseList = make_shared<ListLogicDatabasesResponseBodyLogicDatabaseList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLogicDatabasesResponseBody() = default;
};
class ListLogicDatabasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLogicDatabasesResponseBody> body{};

  ListLogicDatabasesResponse() {}

  explicit ListLogicDatabasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLogicDatabasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLogicDatabasesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLogicDatabasesResponse() = default;
};
class ListLogicTableRouteConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> tableId{};
  shared_ptr<long> tid{};

  ListLogicTableRouteConfigRequest() {}

  explicit ListLogicTableRouteConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<long>(boost::any_cast<long>(m["TableId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListLogicTableRouteConfigRequest() = default;
};
class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig : public Darabonba::Model {
public:
  shared_ptr<string> routeExpr{};
  shared_ptr<string> routeKey{};
  shared_ptr<long> tableId{};

  ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig() {}

  explicit ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeExpr) {
      res["RouteExpr"] = boost::any(*routeExpr);
    }
    if (routeKey) {
      res["RouteKey"] = boost::any(*routeKey);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteExpr") != m.end() && !m["RouteExpr"].empty()) {
      routeExpr = make_shared<string>(boost::any_cast<string>(m["RouteExpr"]));
    }
    if (m.find("RouteKey") != m.end() && !m["RouteKey"].empty()) {
      routeKey = make_shared<string>(boost::any_cast<string>(m["RouteKey"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<long>(boost::any_cast<long>(m["TableId"]));
    }
  }


  virtual ~ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig() = default;
};
class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig>> logicTableRouteConfig{};

  ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList() {}

  explicit ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicTableRouteConfig) {
      vector<boost::any> temp1;
      for(auto item1:*logicTableRouteConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogicTableRouteConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicTableRouteConfig") != m.end() && !m["LogicTableRouteConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["LogicTableRouteConfig"].type()) {
        vector<ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogicTableRouteConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logicTableRouteConfig = make_shared<vector<ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig>>(expect1);
      }
    }
  }


  virtual ~ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList() = default;
};
class ListLogicTableRouteConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList> logicTableRouteConfigList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListLogicTableRouteConfigResponseBody() {}

  explicit ListLogicTableRouteConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (logicTableRouteConfigList) {
      res["LogicTableRouteConfigList"] = logicTableRouteConfigList ? boost::any(logicTableRouteConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("LogicTableRouteConfigList") != m.end() && !m["LogicTableRouteConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogicTableRouteConfigList"].type()) {
        ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogicTableRouteConfigList"]));
        logicTableRouteConfigList = make_shared<ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLogicTableRouteConfigResponseBody() = default;
};
class ListLogicTableRouteConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLogicTableRouteConfigResponseBody> body{};

  ListLogicTableRouteConfigResponse() {}

  explicit ListLogicTableRouteConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLogicTableRouteConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLogicTableRouteConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ListLogicTableRouteConfigResponse() = default;
};
class ListLogicTablesRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> returnGuid{};
  shared_ptr<string> searchName{};
  shared_ptr<long> tid{};

  ListLogicTablesRequest() {}

  explicit ListLogicTablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (returnGuid) {
      res["ReturnGuid"] = boost::any(*returnGuid);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ReturnGuid") != m.end() && !m["ReturnGuid"].empty()) {
      returnGuid = make_shared<bool>(boost::any_cast<bool>(m["ReturnGuid"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListLogicTablesRequest() = default;
};
class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerIds{};

  ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList() {}

  explicit ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList() = default;
};
class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerNames{};

  ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList() {}

  explicit ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList() = default;
};
class ListLogicTablesResponseBodyLogicTableListLogicTable : public Darabonba::Model {
public:
  shared_ptr<string> databaseId{};
  shared_ptr<bool> logic{};
  shared_ptr<ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList> ownerIdList{};
  shared_ptr<ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList> ownerNameList{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> tableCount{};
  shared_ptr<string> tableExpr{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> tableId{};
  shared_ptr<string> tableName{};

  ListLogicTablesResponseBodyLogicTableListLogicTable() {}

  explicit ListLogicTablesResponseBodyLogicTableListLogicTable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (ownerIdList) {
      res["OwnerIdList"] = ownerIdList ? boost::any(ownerIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerNameList) {
      res["OwnerNameList"] = ownerNameList ? boost::any(ownerNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (tableCount) {
      res["TableCount"] = boost::any(*tableCount);
    }
    if (tableExpr) {
      res["TableExpr"] = boost::any(*tableExpr);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("OwnerIdList") != m.end() && !m["OwnerIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerIdList"].type()) {
        ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerIdList"]));
        ownerIdList = make_shared<ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList>(model1);
      }
    }
    if (m.find("OwnerNameList") != m.end() && !m["OwnerNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerNameList"].type()) {
        ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerNameList"]));
        ownerNameList = make_shared<ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList>(model1);
      }
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("TableCount") != m.end() && !m["TableCount"].empty()) {
      tableCount = make_shared<string>(boost::any_cast<string>(m["TableCount"]));
    }
    if (m.find("TableExpr") != m.end() && !m["TableExpr"].empty()) {
      tableExpr = make_shared<string>(boost::any_cast<string>(m["TableExpr"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListLogicTablesResponseBodyLogicTableListLogicTable() = default;
};
class ListLogicTablesResponseBodyLogicTableList : public Darabonba::Model {
public:
  shared_ptr<vector<ListLogicTablesResponseBodyLogicTableListLogicTable>> logicTable{};

  ListLogicTablesResponseBodyLogicTableList() {}

  explicit ListLogicTablesResponseBodyLogicTableList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logicTable) {
      vector<boost::any> temp1;
      for(auto item1:*logicTable){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogicTable"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogicTable") != m.end() && !m["LogicTable"].empty()) {
      if (typeid(vector<boost::any>) == m["LogicTable"].type()) {
        vector<ListLogicTablesResponseBodyLogicTableListLogicTable> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogicTable"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLogicTablesResponseBodyLogicTableListLogicTable model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logicTable = make_shared<vector<ListLogicTablesResponseBodyLogicTableListLogicTable>>(expect1);
      }
    }
  }


  virtual ~ListLogicTablesResponseBodyLogicTableList() = default;
};
class ListLogicTablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListLogicTablesResponseBodyLogicTableList> logicTableList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListLogicTablesResponseBody() {}

  explicit ListLogicTablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (logicTableList) {
      res["LogicTableList"] = logicTableList ? boost::any(logicTableList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("LogicTableList") != m.end() && !m["LogicTableList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogicTableList"].type()) {
        ListLogicTablesResponseBodyLogicTableList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogicTableList"]));
        logicTableList = make_shared<ListLogicTablesResponseBodyLogicTableList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLogicTablesResponseBody() = default;
};
class ListLogicTablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLogicTablesResponseBody> body{};

  ListLogicTablesResponse() {}

  explicit ListLogicTablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLogicTablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLogicTablesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLogicTablesResponse() = default;
};
class ListOrdersRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> orderResultType{};
  shared_ptr<string> orderStatus{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> searchContent{};
  shared_ptr<string> searchDateType{};
  shared_ptr<string> startTime{};
  shared_ptr<long> tid{};

  ListOrdersRequest() {}

  explicit ListOrdersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (orderResultType) {
      res["OrderResultType"] = boost::any(*orderResultType);
    }
    if (orderStatus) {
      res["OrderStatus"] = boost::any(*orderStatus);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (searchContent) {
      res["SearchContent"] = boost::any(*searchContent);
    }
    if (searchDateType) {
      res["SearchDateType"] = boost::any(*searchDateType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OrderResultType") != m.end() && !m["OrderResultType"].empty()) {
      orderResultType = make_shared<string>(boost::any_cast<string>(m["OrderResultType"]));
    }
    if (m.find("OrderStatus") != m.end() && !m["OrderStatus"].empty()) {
      orderStatus = make_shared<string>(boost::any_cast<string>(m["OrderStatus"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("SearchContent") != m.end() && !m["SearchContent"].empty()) {
      searchContent = make_shared<string>(boost::any_cast<string>(m["SearchContent"]));
    }
    if (m.find("SearchDateType") != m.end() && !m["SearchDateType"].empty()) {
      searchDateType = make_shared<string>(boost::any_cast<string>(m["SearchDateType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListOrdersRequest() = default;
};
class ListOrdersResponseBodyOrdersOrder : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> committer{};
  shared_ptr<long> committerId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModifyTime{};
  shared_ptr<long> orderId{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> statusDesc{};

  ListOrdersResponseBodyOrdersOrder() {}

  explicit ListOrdersResponseBodyOrdersOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (committer) {
      res["Committer"] = boost::any(*committer);
    }
    if (committerId) {
      res["CommitterId"] = boost::any(*committerId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModifyTime) {
      res["LastModifyTime"] = boost::any(*lastModifyTime);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Committer") != m.end() && !m["Committer"].empty()) {
      committer = make_shared<string>(boost::any_cast<string>(m["Committer"]));
    }
    if (m.find("CommitterId") != m.end() && !m["CommitterId"].empty()) {
      committerId = make_shared<long>(boost::any_cast<long>(m["CommitterId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModifyTime") != m.end() && !m["LastModifyTime"].empty()) {
      lastModifyTime = make_shared<string>(boost::any_cast<string>(m["LastModifyTime"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
  }


  virtual ~ListOrdersResponseBodyOrdersOrder() = default;
};
class ListOrdersResponseBodyOrders : public Darabonba::Model {
public:
  shared_ptr<vector<ListOrdersResponseBodyOrdersOrder>> order{};

  ListOrdersResponseBodyOrders() {}

  explicit ListOrdersResponseBodyOrders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      vector<boost::any> temp1;
      for(auto item1:*order){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Order"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      if (typeid(vector<boost::any>) == m["Order"].type()) {
        vector<ListOrdersResponseBodyOrdersOrder> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Order"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOrdersResponseBodyOrdersOrder model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        order = make_shared<vector<ListOrdersResponseBodyOrdersOrder>>(expect1);
      }
    }
  }


  virtual ~ListOrdersResponseBodyOrders() = default;
};
class ListOrdersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListOrdersResponseBodyOrders> orders{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListOrdersResponseBody() {}

  explicit ListOrdersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (orders) {
      res["Orders"] = orders ? boost::any(orders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Orders") != m.end() && !m["Orders"].empty()) {
      if (typeid(map<string, boost::any>) == m["Orders"].type()) {
        ListOrdersResponseBodyOrders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Orders"]));
        orders = make_shared<ListOrdersResponseBodyOrders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOrdersResponseBody() = default;
};
class ListOrdersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOrdersResponseBody> body{};

  ListOrdersResponse() {}

  explicit ListOrdersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOrdersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOrdersResponseBody>(model1);
      }
    }
  }


  virtual ~ListOrdersResponse() = default;
};
class ListProxiesRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};

  ListProxiesRequest() {}

  explicit ListProxiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListProxiesRequest() = default;
};
class ListProxiesResponseBodyProxyList : public Darabonba::Model {
public:
  shared_ptr<long> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<long> httpsPort{};
  shared_ptr<long> instanceId{};
  shared_ptr<bool> privateEnable{};
  shared_ptr<string> privateHost{};
  shared_ptr<long> protocolPort{};
  shared_ptr<string> protocolType{};
  shared_ptr<long> proxyId{};
  shared_ptr<bool> publicEnable{};
  shared_ptr<string> publicHost{};
  shared_ptr<string> regionId{};

  ListProxiesResponseBodyProxyList() {}

  explicit ListProxiesResponseBodyProxyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (httpsPort) {
      res["HttpsPort"] = boost::any(*httpsPort);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (privateEnable) {
      res["PrivateEnable"] = boost::any(*privateEnable);
    }
    if (privateHost) {
      res["PrivateHost"] = boost::any(*privateHost);
    }
    if (protocolPort) {
      res["ProtocolPort"] = boost::any(*protocolPort);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (proxyId) {
      res["ProxyId"] = boost::any(*proxyId);
    }
    if (publicEnable) {
      res["PublicEnable"] = boost::any(*publicEnable);
    }
    if (publicHost) {
      res["PublicHost"] = boost::any(*publicHost);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("HttpsPort") != m.end() && !m["HttpsPort"].empty()) {
      httpsPort = make_shared<long>(boost::any_cast<long>(m["HttpsPort"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("PrivateEnable") != m.end() && !m["PrivateEnable"].empty()) {
      privateEnable = make_shared<bool>(boost::any_cast<bool>(m["PrivateEnable"]));
    }
    if (m.find("PrivateHost") != m.end() && !m["PrivateHost"].empty()) {
      privateHost = make_shared<string>(boost::any_cast<string>(m["PrivateHost"]));
    }
    if (m.find("ProtocolPort") != m.end() && !m["ProtocolPort"].empty()) {
      protocolPort = make_shared<long>(boost::any_cast<long>(m["ProtocolPort"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<string>(boost::any_cast<string>(m["ProtocolType"]));
    }
    if (m.find("ProxyId") != m.end() && !m["ProxyId"].empty()) {
      proxyId = make_shared<long>(boost::any_cast<long>(m["ProxyId"]));
    }
    if (m.find("PublicEnable") != m.end() && !m["PublicEnable"].empty()) {
      publicEnable = make_shared<bool>(boost::any_cast<bool>(m["PublicEnable"]));
    }
    if (m.find("PublicHost") != m.end() && !m["PublicHost"].empty()) {
      publicHost = make_shared<string>(boost::any_cast<string>(m["PublicHost"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListProxiesResponseBodyProxyList() = default;
};
class ListProxiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListProxiesResponseBodyProxyList>> proxyList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListProxiesResponseBody() {}

  explicit ListProxiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (proxyList) {
      vector<boost::any> temp1;
      for(auto item1:*proxyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProxyList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProxyList") != m.end() && !m["ProxyList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProxyList"].type()) {
        vector<ListProxiesResponseBodyProxyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProxyList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProxiesResponseBodyProxyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proxyList = make_shared<vector<ListProxiesResponseBodyProxyList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListProxiesResponseBody() = default;
};
class ListProxiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProxiesResponseBody> body{};

  ListProxiesResponse() {}

  explicit ListProxiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProxiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProxiesResponseBody>(model1);
      }
    }
  }


  virtual ~ListProxiesResponse() = default;
};
class ListProxyAccessesRequest : public Darabonba::Model {
public:
  shared_ptr<long> proxyId{};
  shared_ptr<long> tid{};

  ListProxyAccessesRequest() {}

  explicit ListProxyAccessesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxyId) {
      res["ProxyId"] = boost::any(*proxyId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxyId") != m.end() && !m["ProxyId"].empty()) {
      proxyId = make_shared<long>(boost::any_cast<long>(m["ProxyId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListProxyAccessesRequest() = default;
};
class ListProxyAccessesResponseBodyProxyAccessList : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> indepAccount{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> originInfo{};
  shared_ptr<long> proxyAccessId{};
  shared_ptr<long> proxyId{};
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userUid{};

  ListProxyAccessesResponseBodyProxyAccessList() {}

  explicit ListProxyAccessesResponseBodyProxyAccessList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (indepAccount) {
      res["IndepAccount"] = boost::any(*indepAccount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (originInfo) {
      res["OriginInfo"] = boost::any(*originInfo);
    }
    if (proxyAccessId) {
      res["ProxyAccessId"] = boost::any(*proxyAccessId);
    }
    if (proxyId) {
      res["ProxyId"] = boost::any(*proxyId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userUid) {
      res["UserUid"] = boost::any(*userUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("IndepAccount") != m.end() && !m["IndepAccount"].empty()) {
      indepAccount = make_shared<string>(boost::any_cast<string>(m["IndepAccount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("OriginInfo") != m.end() && !m["OriginInfo"].empty()) {
      originInfo = make_shared<string>(boost::any_cast<string>(m["OriginInfo"]));
    }
    if (m.find("ProxyAccessId") != m.end() && !m["ProxyAccessId"].empty()) {
      proxyAccessId = make_shared<long>(boost::any_cast<long>(m["ProxyAccessId"]));
    }
    if (m.find("ProxyId") != m.end() && !m["ProxyId"].empty()) {
      proxyId = make_shared<long>(boost::any_cast<long>(m["ProxyId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserUid") != m.end() && !m["UserUid"].empty()) {
      userUid = make_shared<string>(boost::any_cast<string>(m["UserUid"]));
    }
  }


  virtual ~ListProxyAccessesResponseBodyProxyAccessList() = default;
};
class ListProxyAccessesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListProxyAccessesResponseBodyProxyAccessList>> proxyAccessList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListProxyAccessesResponseBody() {}

  explicit ListProxyAccessesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (proxyAccessList) {
      vector<boost::any> temp1;
      for(auto item1:*proxyAccessList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProxyAccessList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProxyAccessList") != m.end() && !m["ProxyAccessList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProxyAccessList"].type()) {
        vector<ListProxyAccessesResponseBodyProxyAccessList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProxyAccessList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProxyAccessesResponseBodyProxyAccessList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proxyAccessList = make_shared<vector<ListProxyAccessesResponseBodyProxyAccessList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListProxyAccessesResponseBody() = default;
};
class ListProxyAccessesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProxyAccessesResponseBody> body{};

  ListProxyAccessesResponse() {}

  explicit ListProxyAccessesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProxyAccessesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProxyAccessesResponseBody>(model1);
      }
    }
  }


  virtual ~ListProxyAccessesResponse() = default;
};
class ListProxySQLExecAuditLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> execState{};
  shared_ptr<string> opUserName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> SQLType{};
  shared_ptr<string> searchName{};
  shared_ptr<long> startTime{};
  shared_ptr<long> tid{};

  ListProxySQLExecAuditLogRequest() {}

  explicit ListProxySQLExecAuditLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (execState) {
      res["ExecState"] = boost::any(*execState);
    }
    if (opUserName) {
      res["OpUserName"] = boost::any(*opUserName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SQLType) {
      res["SQLType"] = boost::any(*SQLType);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExecState") != m.end() && !m["ExecState"].empty()) {
      execState = make_shared<string>(boost::any_cast<string>(m["ExecState"]));
    }
    if (m.find("OpUserName") != m.end() && !m["OpUserName"].empty()) {
      opUserName = make_shared<string>(boost::any_cast<string>(m["OpUserName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SQLType") != m.end() && !m["SQLType"].empty()) {
      SQLType = make_shared<string>(boost::any_cast<string>(m["SQLType"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListProxySQLExecAuditLogRequest() = default;
};
class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog : public Darabonba::Model {
public:
  shared_ptr<long> affectRows{};
  shared_ptr<long> elapsedTime{};
  shared_ptr<string> execState{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> opTime{};
  shared_ptr<string> remark{};
  shared_ptr<string> SQL{};
  shared_ptr<string> SQLType{};
  shared_ptr<string> schemaName{};
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};

  ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog() {}

  explicit ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectRows) {
      res["AffectRows"] = boost::any(*affectRows);
    }
    if (elapsedTime) {
      res["ElapsedTime"] = boost::any(*elapsedTime);
    }
    if (execState) {
      res["ExecState"] = boost::any(*execState);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (opTime) {
      res["OpTime"] = boost::any(*opTime);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (SQL) {
      res["SQL"] = boost::any(*SQL);
    }
    if (SQLType) {
      res["SQLType"] = boost::any(*SQLType);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectRows") != m.end() && !m["AffectRows"].empty()) {
      affectRows = make_shared<long>(boost::any_cast<long>(m["AffectRows"]));
    }
    if (m.find("ElapsedTime") != m.end() && !m["ElapsedTime"].empty()) {
      elapsedTime = make_shared<long>(boost::any_cast<long>(m["ElapsedTime"]));
    }
    if (m.find("ExecState") != m.end() && !m["ExecState"].empty()) {
      execState = make_shared<string>(boost::any_cast<string>(m["ExecState"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("OpTime") != m.end() && !m["OpTime"].empty()) {
      opTime = make_shared<string>(boost::any_cast<string>(m["OpTime"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SQL") != m.end() && !m["SQL"].empty()) {
      SQL = make_shared<string>(boost::any_cast<string>(m["SQL"]));
    }
    if (m.find("SQLType") != m.end() && !m["SQLType"].empty()) {
      SQLType = make_shared<string>(boost::any_cast<string>(m["SQLType"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog() = default;
};
class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList : public Darabonba::Model {
public:
  shared_ptr<vector<ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog>> proxySQLExecAuditLog{};

  ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList() {}

  explicit ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proxySQLExecAuditLog) {
      vector<boost::any> temp1;
      for(auto item1:*proxySQLExecAuditLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProxySQLExecAuditLog"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProxySQLExecAuditLog") != m.end() && !m["ProxySQLExecAuditLog"].empty()) {
      if (typeid(vector<boost::any>) == m["ProxySQLExecAuditLog"].type()) {
        vector<ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProxySQLExecAuditLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proxySQLExecAuditLog = make_shared<vector<ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog>>(expect1);
      }
    }
  }


  virtual ~ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList() = default;
};
class ListProxySQLExecAuditLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList> proxySQLExecAuditLogList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListProxySQLExecAuditLogResponseBody() {}

  explicit ListProxySQLExecAuditLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (proxySQLExecAuditLogList) {
      res["ProxySQLExecAuditLogList"] = proxySQLExecAuditLogList ? boost::any(proxySQLExecAuditLogList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ProxySQLExecAuditLogList") != m.end() && !m["ProxySQLExecAuditLogList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProxySQLExecAuditLogList"].type()) {
        ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProxySQLExecAuditLogList"]));
        proxySQLExecAuditLogList = make_shared<ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListProxySQLExecAuditLogResponseBody() = default;
};
class ListProxySQLExecAuditLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProxySQLExecAuditLogResponseBody> body{};

  ListProxySQLExecAuditLogResponse() {}

  explicit ListProxySQLExecAuditLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProxySQLExecAuditLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProxySQLExecAuditLogResponseBody>(model1);
      }
    }
  }


  virtual ~ListProxySQLExecAuditLogResponse() = default;
};
class ListSLARulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  ListSLARulesRequest() {}

  explicit ListSLARulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListSLARulesRequest() = default;
};
class ListSLARulesResponseBodySLARuleListSLARule : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> id{};
  shared_ptr<long> intervalMinutes{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> ruleType{};

  ListSLARulesResponseBodySLARuleListSLARule() {}

  explicit ListSLARulesResponseBodySLARuleListSLARule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (intervalMinutes) {
      res["IntervalMinutes"] = boost::any(*intervalMinutes);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IntervalMinutes") != m.end() && !m["IntervalMinutes"].empty()) {
      intervalMinutes = make_shared<long>(boost::any_cast<long>(m["IntervalMinutes"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
  }


  virtual ~ListSLARulesResponseBodySLARuleListSLARule() = default;
};
class ListSLARulesResponseBodySLARuleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSLARulesResponseBodySLARuleListSLARule>> SLARule{};

  ListSLARulesResponseBodySLARuleList() {}

  explicit ListSLARulesResponseBodySLARuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SLARule) {
      vector<boost::any> temp1;
      for(auto item1:*SLARule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SLARule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SLARule") != m.end() && !m["SLARule"].empty()) {
      if (typeid(vector<boost::any>) == m["SLARule"].type()) {
        vector<ListSLARulesResponseBodySLARuleListSLARule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SLARule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSLARulesResponseBodySLARuleListSLARule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SLARule = make_shared<vector<ListSLARulesResponseBodySLARuleListSLARule>>(expect1);
      }
    }
  }


  virtual ~ListSLARulesResponseBodySLARuleList() = default;
};
class ListSLARulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ListSLARulesResponseBodySLARuleList> SLARuleList{};
  shared_ptr<bool> success{};

  ListSLARulesResponseBody() {}

  explicit ListSLARulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (SLARuleList) {
      res["SLARuleList"] = SLARuleList ? boost::any(SLARuleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SLARuleList") != m.end() && !m["SLARuleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SLARuleList"].type()) {
        ListSLARulesResponseBodySLARuleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SLARuleList"]));
        SLARuleList = make_shared<ListSLARulesResponseBodySLARuleList>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSLARulesResponseBody() = default;
};
class ListSLARulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSLARulesResponseBody> body{};

  ListSLARulesResponse() {}

  explicit ListSLARulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSLARulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSLARulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSLARulesResponse() = default;
};
class ListSQLExecAuditLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> execState{};
  shared_ptr<string> opUserName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchName{};
  shared_ptr<string> sqlType{};
  shared_ptr<string> startTime{};
  shared_ptr<long> tid{};

  ListSQLExecAuditLogRequest() {}

  explicit ListSQLExecAuditLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (execState) {
      res["ExecState"] = boost::any(*execState);
    }
    if (opUserName) {
      res["OpUserName"] = boost::any(*opUserName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExecState") != m.end() && !m["ExecState"].empty()) {
      execState = make_shared<string>(boost::any_cast<string>(m["ExecState"]));
    }
    if (m.find("OpUserName") != m.end() && !m["OpUserName"].empty()) {
      opUserName = make_shared<string>(boost::any_cast<string>(m["OpUserName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListSQLExecAuditLogRequest() = default;
};
class ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog : public Darabonba::Model {
public:
  shared_ptr<long> affectRows{};
  shared_ptr<long> dbId{};
  shared_ptr<long> elapsedTime{};
  shared_ptr<string> execState{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<bool> logic{};
  shared_ptr<string> opTime{};
  shared_ptr<string> remark{};
  shared_ptr<string> SQL{};
  shared_ptr<string> SQLType{};
  shared_ptr<string> schemaName{};
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};

  ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog() {}

  explicit ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectRows) {
      res["AffectRows"] = boost::any(*affectRows);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (elapsedTime) {
      res["ElapsedTime"] = boost::any(*elapsedTime);
    }
    if (execState) {
      res["ExecState"] = boost::any(*execState);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (opTime) {
      res["OpTime"] = boost::any(*opTime);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (SQL) {
      res["SQL"] = boost::any(*SQL);
    }
    if (SQLType) {
      res["SQLType"] = boost::any(*SQLType);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectRows") != m.end() && !m["AffectRows"].empty()) {
      affectRows = make_shared<long>(boost::any_cast<long>(m["AffectRows"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("ElapsedTime") != m.end() && !m["ElapsedTime"].empty()) {
      elapsedTime = make_shared<long>(boost::any_cast<long>(m["ElapsedTime"]));
    }
    if (m.find("ExecState") != m.end() && !m["ExecState"].empty()) {
      execState = make_shared<string>(boost::any_cast<string>(m["ExecState"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("OpTime") != m.end() && !m["OpTime"].empty()) {
      opTime = make_shared<string>(boost::any_cast<string>(m["OpTime"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SQL") != m.end() && !m["SQL"].empty()) {
      SQL = make_shared<string>(boost::any_cast<string>(m["SQL"]));
    }
    if (m.find("SQLType") != m.end() && !m["SQLType"].empty()) {
      SQLType = make_shared<string>(boost::any_cast<string>(m["SQLType"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog() = default;
};
class ListSQLExecAuditLogResponseBodySQLExecAuditLogList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog>> SQLExecAuditLog{};

  ListSQLExecAuditLogResponseBodySQLExecAuditLogList() {}

  explicit ListSQLExecAuditLogResponseBodySQLExecAuditLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLExecAuditLog) {
      vector<boost::any> temp1;
      for(auto item1:*SQLExecAuditLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SQLExecAuditLog"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLExecAuditLog") != m.end() && !m["SQLExecAuditLog"].empty()) {
      if (typeid(vector<boost::any>) == m["SQLExecAuditLog"].type()) {
        vector<ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SQLExecAuditLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SQLExecAuditLog = make_shared<vector<ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog>>(expect1);
      }
    }
  }


  virtual ~ListSQLExecAuditLogResponseBodySQLExecAuditLogList() = default;
};
class ListSQLExecAuditLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ListSQLExecAuditLogResponseBodySQLExecAuditLogList> SQLExecAuditLogList{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListSQLExecAuditLogResponseBody() {}

  explicit ListSQLExecAuditLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (SQLExecAuditLogList) {
      res["SQLExecAuditLogList"] = SQLExecAuditLogList ? boost::any(SQLExecAuditLogList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SQLExecAuditLogList") != m.end() && !m["SQLExecAuditLogList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SQLExecAuditLogList"].type()) {
        ListSQLExecAuditLogResponseBodySQLExecAuditLogList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SQLExecAuditLogList"]));
        SQLExecAuditLogList = make_shared<ListSQLExecAuditLogResponseBodySQLExecAuditLogList>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSQLExecAuditLogResponseBody() = default;
};
class ListSQLExecAuditLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSQLExecAuditLogResponseBody> body{};

  ListSQLExecAuditLogResponse() {}

  explicit ListSQLExecAuditLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSQLExecAuditLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSQLExecAuditLogResponseBody>(model1);
      }
    }
  }


  virtual ~ListSQLExecAuditLogResponse() = default;
};
class ListSQLReviewOriginSQLRequestOrderActionDetailPage : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListSQLReviewOriginSQLRequestOrderActionDetailPage() {}

  explicit ListSQLReviewOriginSQLRequestOrderActionDetailPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListSQLReviewOriginSQLRequestOrderActionDetailPage() = default;
};
class ListSQLReviewOriginSQLRequestOrderActionDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkStatusResult{};
  shared_ptr<long> fileId{};
  shared_ptr<ListSQLReviewOriginSQLRequestOrderActionDetailPage> page{};
  shared_ptr<string> SQLReviewResult{};

  ListSQLReviewOriginSQLRequestOrderActionDetail() {}

  explicit ListSQLReviewOriginSQLRequestOrderActionDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStatusResult) {
      res["CheckStatusResult"] = boost::any(*checkStatusResult);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (page) {
      res["Page"] = page ? boost::any(page->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (SQLReviewResult) {
      res["SQLReviewResult"] = boost::any(*SQLReviewResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckStatusResult") != m.end() && !m["CheckStatusResult"].empty()) {
      checkStatusResult = make_shared<string>(boost::any_cast<string>(m["CheckStatusResult"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      if (typeid(map<string, boost::any>) == m["Page"].type()) {
        ListSQLReviewOriginSQLRequestOrderActionDetailPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Page"]));
        page = make_shared<ListSQLReviewOriginSQLRequestOrderActionDetailPage>(model1);
      }
    }
    if (m.find("SQLReviewResult") != m.end() && !m["SQLReviewResult"].empty()) {
      SQLReviewResult = make_shared<string>(boost::any_cast<string>(m["SQLReviewResult"]));
    }
  }


  virtual ~ListSQLReviewOriginSQLRequestOrderActionDetail() = default;
};
class ListSQLReviewOriginSQLRequest : public Darabonba::Model {
public:
  shared_ptr<ListSQLReviewOriginSQLRequestOrderActionDetail> orderActionDetail{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  ListSQLReviewOriginSQLRequest() {}

  explicit ListSQLReviewOriginSQLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderActionDetail) {
      res["OrderActionDetail"] = orderActionDetail ? boost::any(orderActionDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderActionDetail") != m.end() && !m["OrderActionDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderActionDetail"].type()) {
        ListSQLReviewOriginSQLRequestOrderActionDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderActionDetail"]));
        orderActionDetail = make_shared<ListSQLReviewOriginSQLRequestOrderActionDetail>(model1);
      }
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListSQLReviewOriginSQLRequest() = default;
};
class ListSQLReviewOriginSQLShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderActionDetailShrink{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  ListSQLReviewOriginSQLShrinkRequest() {}

  explicit ListSQLReviewOriginSQLShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderActionDetailShrink) {
      res["OrderActionDetail"] = boost::any(*orderActionDetailShrink);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderActionDetail") != m.end() && !m["OrderActionDetail"].empty()) {
      orderActionDetailShrink = make_shared<string>(boost::any_cast<string>(m["OrderActionDetail"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListSQLReviewOriginSQLShrinkRequest() = default;
};
class ListSQLReviewOriginSQLResponseBodyOriginSQLList : public Darabonba::Model {
public:
  shared_ptr<string> checkStatus{};
  shared_ptr<string> checkedTime{};
  shared_ptr<long> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> reviewSummary{};
  shared_ptr<string> SQLContent{};
  shared_ptr<long> SQLId{};
  shared_ptr<string> SQLName{};
  shared_ptr<string> SQLReviewQueryKey{};
  shared_ptr<string> sqlHash{};
  shared_ptr<string> statusDesc{};

  ListSQLReviewOriginSQLResponseBodyOriginSQLList() {}

  explicit ListSQLReviewOriginSQLResponseBodyOriginSQLList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStatus) {
      res["CheckStatus"] = boost::any(*checkStatus);
    }
    if (checkedTime) {
      res["CheckedTime"] = boost::any(*checkedTime);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (reviewSummary) {
      res["ReviewSummary"] = boost::any(*reviewSummary);
    }
    if (SQLContent) {
      res["SQLContent"] = boost::any(*SQLContent);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (SQLName) {
      res["SQLName"] = boost::any(*SQLName);
    }
    if (SQLReviewQueryKey) {
      res["SQLReviewQueryKey"] = boost::any(*SQLReviewQueryKey);
    }
    if (sqlHash) {
      res["SqlHash"] = boost::any(*sqlHash);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckStatus") != m.end() && !m["CheckStatus"].empty()) {
      checkStatus = make_shared<string>(boost::any_cast<string>(m["CheckStatus"]));
    }
    if (m.find("CheckedTime") != m.end() && !m["CheckedTime"].empty()) {
      checkedTime = make_shared<string>(boost::any_cast<string>(m["CheckedTime"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("ReviewSummary") != m.end() && !m["ReviewSummary"].empty()) {
      reviewSummary = make_shared<string>(boost::any_cast<string>(m["ReviewSummary"]));
    }
    if (m.find("SQLContent") != m.end() && !m["SQLContent"].empty()) {
      SQLContent = make_shared<string>(boost::any_cast<string>(m["SQLContent"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<long>(boost::any_cast<long>(m["SQLId"]));
    }
    if (m.find("SQLName") != m.end() && !m["SQLName"].empty()) {
      SQLName = make_shared<string>(boost::any_cast<string>(m["SQLName"]));
    }
    if (m.find("SQLReviewQueryKey") != m.end() && !m["SQLReviewQueryKey"].empty()) {
      SQLReviewQueryKey = make_shared<string>(boost::any_cast<string>(m["SQLReviewQueryKey"]));
    }
    if (m.find("SqlHash") != m.end() && !m["SqlHash"].empty()) {
      sqlHash = make_shared<string>(boost::any_cast<string>(m["SqlHash"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
  }


  virtual ~ListSQLReviewOriginSQLResponseBodyOriginSQLList() = default;
};
class ListSQLReviewOriginSQLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<vector<ListSQLReviewOriginSQLResponseBodyOriginSQLList>> originSQLList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListSQLReviewOriginSQLResponseBody() {}

  explicit ListSQLReviewOriginSQLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (originSQLList) {
      vector<boost::any> temp1;
      for(auto item1:*originSQLList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OriginSQLList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("OriginSQLList") != m.end() && !m["OriginSQLList"].empty()) {
      if (typeid(vector<boost::any>) == m["OriginSQLList"].type()) {
        vector<ListSQLReviewOriginSQLResponseBodyOriginSQLList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OriginSQLList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSQLReviewOriginSQLResponseBodyOriginSQLList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        originSQLList = make_shared<vector<ListSQLReviewOriginSQLResponseBodyOriginSQLList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSQLReviewOriginSQLResponseBody() = default;
};
class ListSQLReviewOriginSQLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSQLReviewOriginSQLResponseBody> body{};

  ListSQLReviewOriginSQLResponse() {}

  explicit ListSQLReviewOriginSQLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSQLReviewOriginSQLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSQLReviewOriginSQLResponseBody>(model1);
      }
    }
  }


  virtual ~ListSQLReviewOriginSQLResponse() = default;
};
class ListScenariosRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};

  ListScenariosRequest() {}

  explicit ListScenariosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListScenariosRequest() = default;
};
class ListScenariosResponseBodyScenarioList : public Darabonba::Model {
public:
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> scenarioName{};

  ListScenariosResponseBodyScenarioList() {}

  explicit ListScenariosResponseBodyScenarioList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (scenarioName) {
      res["ScenarioName"] = boost::any(*scenarioName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ScenarioName") != m.end() && !m["ScenarioName"].empty()) {
      scenarioName = make_shared<string>(boost::any_cast<string>(m["ScenarioName"]));
    }
  }


  virtual ~ListScenariosResponseBodyScenarioList() = default;
};
class ListScenariosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListScenariosResponseBodyScenarioList>> scenarioList{};
  shared_ptr<bool> success{};

  ListScenariosResponseBody() {}

  explicit ListScenariosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scenarioList) {
      vector<boost::any> temp1;
      for(auto item1:*scenarioList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScenarioList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScenarioList") != m.end() && !m["ScenarioList"].empty()) {
      if (typeid(vector<boost::any>) == m["ScenarioList"].type()) {
        vector<ListScenariosResponseBodyScenarioList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScenarioList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenariosResponseBodyScenarioList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scenarioList = make_shared<vector<ListScenariosResponseBodyScenarioList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListScenariosResponseBody() = default;
};
class ListScenariosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScenariosResponseBody> body{};

  ListScenariosResponse() {}

  explicit ListScenariosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScenariosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScenariosResponseBody>(model1);
      }
    }
  }


  virtual ~ListScenariosResponse() = default;
};
class ListSensitiveColumnInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> tid{};

  ListSensitiveColumnInfoRequest() {}

  explicit ListSensitiveColumnInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListSensitiveColumnInfoRequest() = default;
};
class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule : public Darabonba::Model {
public:
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};

  ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule() {}

  explicit ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule() = default;
};
class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule : public Darabonba::Model {
public:
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};

  ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule() {}

  explicit ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule() = default;
};
class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule>> semiDesensitizationRule{};

  ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList() {}

  explicit ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (semiDesensitizationRule) {
      vector<boost::any> temp1;
      for(auto item1:*semiDesensitizationRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SemiDesensitizationRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SemiDesensitizationRule") != m.end() && !m["SemiDesensitizationRule"].empty()) {
      if (typeid(vector<boost::any>) == m["SemiDesensitizationRule"].type()) {
        vector<ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SemiDesensitizationRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        semiDesensitizationRule = make_shared<vector<ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule>>(expect1);
      }
    }
  }


  virtual ~ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList() = default;
};
class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn : public Darabonba::Model {
public:
  shared_ptr<string> categoryName{};
  shared_ptr<string> columnName{};
  shared_ptr<ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule> defaultDesensitizationRule{};
  shared_ptr<long> instanceId{};
  shared_ptr<bool> isPlain{};
  shared_ptr<string> sampleData{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> securityLevel{};
  shared_ptr<ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList> semiDesensitizationRuleList{};
  shared_ptr<string> tableName{};
  shared_ptr<string> userSensitivityLevel{};

  ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn() {}

  explicit ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (defaultDesensitizationRule) {
      res["DefaultDesensitizationRule"] = defaultDesensitizationRule ? boost::any(defaultDesensitizationRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isPlain) {
      res["IsPlain"] = boost::any(*isPlain);
    }
    if (sampleData) {
      res["SampleData"] = boost::any(*sampleData);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (securityLevel) {
      res["SecurityLevel"] = boost::any(*securityLevel);
    }
    if (semiDesensitizationRuleList) {
      res["SemiDesensitizationRuleList"] = semiDesensitizationRuleList ? boost::any(semiDesensitizationRuleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (userSensitivityLevel) {
      res["UserSensitivityLevel"] = boost::any(*userSensitivityLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DefaultDesensitizationRule") != m.end() && !m["DefaultDesensitizationRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["DefaultDesensitizationRule"].type()) {
        ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DefaultDesensitizationRule"]));
        defaultDesensitizationRule = make_shared<ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("IsPlain") != m.end() && !m["IsPlain"].empty()) {
      isPlain = make_shared<bool>(boost::any_cast<bool>(m["IsPlain"]));
    }
    if (m.find("SampleData") != m.end() && !m["SampleData"].empty()) {
      sampleData = make_shared<string>(boost::any_cast<string>(m["SampleData"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SecurityLevel") != m.end() && !m["SecurityLevel"].empty()) {
      securityLevel = make_shared<string>(boost::any_cast<string>(m["SecurityLevel"]));
    }
    if (m.find("SemiDesensitizationRuleList") != m.end() && !m["SemiDesensitizationRuleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SemiDesensitizationRuleList"].type()) {
        ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SemiDesensitizationRuleList"]));
        semiDesensitizationRuleList = make_shared<ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList>(model1);
      }
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("UserSensitivityLevel") != m.end() && !m["UserSensitivityLevel"].empty()) {
      userSensitivityLevel = make_shared<string>(boost::any_cast<string>(m["UserSensitivityLevel"]));
    }
  }


  virtual ~ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn() = default;
};
class ListSensitiveColumnInfoResponseBodySensitiveColumnList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn>> sensitiveColumn{};

  ListSensitiveColumnInfoResponseBodySensitiveColumnList() {}

  explicit ListSensitiveColumnInfoResponseBodySensitiveColumnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sensitiveColumn) {
      vector<boost::any> temp1;
      for(auto item1:*sensitiveColumn){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SensitiveColumn"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SensitiveColumn") != m.end() && !m["SensitiveColumn"].empty()) {
      if (typeid(vector<boost::any>) == m["SensitiveColumn"].type()) {
        vector<ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SensitiveColumn"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sensitiveColumn = make_shared<vector<ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn>>(expect1);
      }
    }
  }


  virtual ~ListSensitiveColumnInfoResponseBodySensitiveColumnList() = default;
};
class ListSensitiveColumnInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ListSensitiveColumnInfoResponseBodySensitiveColumnList> sensitiveColumnList{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListSensitiveColumnInfoResponseBody() {}

  explicit ListSensitiveColumnInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sensitiveColumnList) {
      res["SensitiveColumnList"] = sensitiveColumnList ? boost::any(sensitiveColumnList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SensitiveColumnList") != m.end() && !m["SensitiveColumnList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SensitiveColumnList"].type()) {
        ListSensitiveColumnInfoResponseBodySensitiveColumnList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SensitiveColumnList"]));
        sensitiveColumnList = make_shared<ListSensitiveColumnInfoResponseBodySensitiveColumnList>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSensitiveColumnInfoResponseBody() = default;
};
class ListSensitiveColumnInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSensitiveColumnInfoResponseBody> body{};

  ListSensitiveColumnInfoResponse() {}

  explicit ListSensitiveColumnInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSensitiveColumnInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSensitiveColumnInfoResponseBody>(model1);
      }
    }
  }


  virtual ~ListSensitiveColumnInfoResponse() = default;
};
class ListSensitiveColumnsRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<long> dbId{};
  shared_ptr<bool> logic{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> securityLevel{};
  shared_ptr<string> tableName{};
  shared_ptr<long> tid{};

  ListSensitiveColumnsRequest() {}

  explicit ListSensitiveColumnsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (securityLevel) {
      res["SecurityLevel"] = boost::any(*securityLevel);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SecurityLevel") != m.end() && !m["SecurityLevel"].empty()) {
      securityLevel = make_shared<string>(boost::any_cast<string>(m["SecurityLevel"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListSensitiveColumnsRequest() = default;
};
class ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn : public Darabonba::Model {
public:
  shared_ptr<long> columnCount{};
  shared_ptr<string> columnName{};
  shared_ptr<string> functionType{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> securityLevel{};
  shared_ptr<string> tableName{};

  ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn() {}

  explicit ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (functionType) {
      res["FunctionType"] = boost::any(*functionType);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (securityLevel) {
      res["SecurityLevel"] = boost::any(*securityLevel);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("FunctionType") != m.end() && !m["FunctionType"].empty()) {
      functionType = make_shared<string>(boost::any_cast<string>(m["FunctionType"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SecurityLevel") != m.end() && !m["SecurityLevel"].empty()) {
      securityLevel = make_shared<string>(boost::any_cast<string>(m["SecurityLevel"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn() = default;
};
class ListSensitiveColumnsResponseBodySensitiveColumnList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn>> sensitiveColumn{};

  ListSensitiveColumnsResponseBodySensitiveColumnList() {}

  explicit ListSensitiveColumnsResponseBodySensitiveColumnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sensitiveColumn) {
      vector<boost::any> temp1;
      for(auto item1:*sensitiveColumn){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SensitiveColumn"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SensitiveColumn") != m.end() && !m["SensitiveColumn"].empty()) {
      if (typeid(vector<boost::any>) == m["SensitiveColumn"].type()) {
        vector<ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SensitiveColumn"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sensitiveColumn = make_shared<vector<ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn>>(expect1);
      }
    }
  }


  virtual ~ListSensitiveColumnsResponseBodySensitiveColumnList() = default;
};
class ListSensitiveColumnsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ListSensitiveColumnsResponseBodySensitiveColumnList> sensitiveColumnList{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListSensitiveColumnsResponseBody() {}

  explicit ListSensitiveColumnsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sensitiveColumnList) {
      res["SensitiveColumnList"] = sensitiveColumnList ? boost::any(sensitiveColumnList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SensitiveColumnList") != m.end() && !m["SensitiveColumnList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SensitiveColumnList"].type()) {
        ListSensitiveColumnsResponseBodySensitiveColumnList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SensitiveColumnList"]));
        sensitiveColumnList = make_shared<ListSensitiveColumnsResponseBodySensitiveColumnList>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSensitiveColumnsResponseBody() = default;
};
class ListSensitiveColumnsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSensitiveColumnsResponseBody> body{};

  ListSensitiveColumnsResponse() {}

  explicit ListSensitiveColumnsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSensitiveColumnsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSensitiveColumnsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSensitiveColumnsResponse() = default;
};
class ListSensitiveColumnsDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<long> dbId{};
  shared_ptr<bool> logic{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> tid{};

  ListSensitiveColumnsDetailRequest() {}

  explicit ListSensitiveColumnsDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListSensitiveColumnsDetailRequest() = default;
};
class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail : public Darabonba::Model {
public:
  shared_ptr<string> columnDescription{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};
  shared_ptr<long> dbId{};
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<bool> logic{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> searchName{};
  shared_ptr<string> tableName{};

  ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail() {}

  explicit ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnDescription) {
      res["ColumnDescription"] = boost::any(*columnDescription);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnDescription") != m.end() && !m["ColumnDescription"].empty()) {
      columnDescription = make_shared<string>(boost::any_cast<string>(m["ColumnDescription"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail() = default;
};
class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail>> sensitiveColumnsDetail{};

  ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList() {}

  explicit ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sensitiveColumnsDetail) {
      vector<boost::any> temp1;
      for(auto item1:*sensitiveColumnsDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SensitiveColumnsDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SensitiveColumnsDetail") != m.end() && !m["SensitiveColumnsDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["SensitiveColumnsDetail"].type()) {
        vector<ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SensitiveColumnsDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sensitiveColumnsDetail = make_shared<vector<ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail>>(expect1);
      }
    }
  }


  virtual ~ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList() = default;
};
class ListSensitiveColumnsDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList> sensitiveColumnsDetailList{};
  shared_ptr<bool> success{};

  ListSensitiveColumnsDetailResponseBody() {}

  explicit ListSensitiveColumnsDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sensitiveColumnsDetailList) {
      res["SensitiveColumnsDetailList"] = sensitiveColumnsDetailList ? boost::any(sensitiveColumnsDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SensitiveColumnsDetailList") != m.end() && !m["SensitiveColumnsDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SensitiveColumnsDetailList"].type()) {
        ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SensitiveColumnsDetailList"]));
        sensitiveColumnsDetailList = make_shared<ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSensitiveColumnsDetailResponseBody() = default;
};
class ListSensitiveColumnsDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSensitiveColumnsDetailResponseBody> body{};

  ListSensitiveColumnsDetailResponse() {}

  explicit ListSensitiveColumnsDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSensitiveColumnsDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSensitiveColumnsDetailResponseBody>(model1);
      }
    }
  }


  virtual ~ListSensitiveColumnsDetailResponse() = default;
};
class ListSensitiveDataAuditLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> dbName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> opUserName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tableName{};
  shared_ptr<long> tid{};

  ListSensitiveDataAuditLogRequest() {}

  explicit ListSensitiveDataAuditLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (opUserName) {
      res["OpUserName"] = boost::any(*opUserName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("OpUserName") != m.end() && !m["OpUserName"].empty()) {
      opUserName = make_shared<string>(boost::any_cast<string>(m["OpUserName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListSensitiveDataAuditLogRequest() = default;
};
class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> columnPermissionType{};
  shared_ptr<string> desensitizationRule{};
  shared_ptr<string> securityLevel{};
  shared_ptr<string> tableName{};

  ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog() {}

  explicit ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnPermissionType) {
      res["ColumnPermissionType"] = boost::any(*columnPermissionType);
    }
    if (desensitizationRule) {
      res["DesensitizationRule"] = boost::any(*desensitizationRule);
    }
    if (securityLevel) {
      res["SecurityLevel"] = boost::any(*securityLevel);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnPermissionType") != m.end() && !m["ColumnPermissionType"].empty()) {
      columnPermissionType = make_shared<string>(boost::any_cast<string>(m["ColumnPermissionType"]));
    }
    if (m.find("DesensitizationRule") != m.end() && !m["DesensitizationRule"].empty()) {
      desensitizationRule = make_shared<string>(boost::any_cast<string>(m["DesensitizationRule"]));
    }
    if (m.find("SecurityLevel") != m.end() && !m["SecurityLevel"].empty()) {
      securityLevel = make_shared<string>(boost::any_cast<string>(m["SecurityLevel"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog() = default;
};
class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList : public Darabonba::Model {
public:
  shared_ptr<string> dbDisplayName{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> opTime{};
  shared_ptr<vector<ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog>> sensitiveDataLog{};
  shared_ptr<string> targetName{};
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};

  ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList() {}

  explicit ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbDisplayName) {
      res["DbDisplayName"] = boost::any(*dbDisplayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (opTime) {
      res["OpTime"] = boost::any(*opTime);
    }
    if (sensitiveDataLog) {
      vector<boost::any> temp1;
      for(auto item1:*sensitiveDataLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SensitiveDataLog"] = boost::any(temp1);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbDisplayName") != m.end() && !m["DbDisplayName"].empty()) {
      dbDisplayName = make_shared<string>(boost::any_cast<string>(m["DbDisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("OpTime") != m.end() && !m["OpTime"].empty()) {
      opTime = make_shared<string>(boost::any_cast<string>(m["OpTime"]));
    }
    if (m.find("SensitiveDataLog") != m.end() && !m["SensitiveDataLog"].empty()) {
      if (typeid(vector<boost::any>) == m["SensitiveDataLog"].type()) {
        vector<ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SensitiveDataLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sensitiveDataLog = make_shared<vector<ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog>>(expect1);
      }
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList() = default;
};
class ListSensitiveDataAuditLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList>> sensitiveDataAuditLogList{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListSensitiveDataAuditLogResponseBody() {}

  explicit ListSensitiveDataAuditLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sensitiveDataAuditLogList) {
      vector<boost::any> temp1;
      for(auto item1:*sensitiveDataAuditLogList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SensitiveDataAuditLogList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SensitiveDataAuditLogList") != m.end() && !m["SensitiveDataAuditLogList"].empty()) {
      if (typeid(vector<boost::any>) == m["SensitiveDataAuditLogList"].type()) {
        vector<ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SensitiveDataAuditLogList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sensitiveDataAuditLogList = make_shared<vector<ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSensitiveDataAuditLogResponseBody() = default;
};
class ListSensitiveDataAuditLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSensitiveDataAuditLogResponseBody> body{};

  ListSensitiveDataAuditLogResponse() {}

  explicit ListSensitiveDataAuditLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSensitiveDataAuditLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSensitiveDataAuditLogResponseBody>(model1);
      }
    }
  }


  virtual ~ListSensitiveDataAuditLogResponse() = default;
};
class ListSensitivityLevelRequest : public Darabonba::Model {
public:
  shared_ptr<long> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<long> tid{};

  ListSensitivityLevelRequest() {}

  explicit ListSensitivityLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListSensitivityLevelRequest() = default;
};
class ListSensitivityLevelResponseBodySensitivityLevelList : public Darabonba::Model {
public:
  shared_ptr<bool> isPlain{};
  shared_ptr<string> name{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};

  ListSensitivityLevelResponseBodySensitivityLevelList() {}

  explicit ListSensitivityLevelResponseBodySensitivityLevelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPlain) {
      res["IsPlain"] = boost::any(*isPlain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPlain") != m.end() && !m["IsPlain"].empty()) {
      isPlain = make_shared<bool>(boost::any_cast<bool>(m["IsPlain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~ListSensitivityLevelResponseBodySensitivityLevelList() = default;
};
class ListSensitivityLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSensitivityLevelResponseBodySensitivityLevelList>> sensitivityLevelList{};
  shared_ptr<bool> success{};

  ListSensitivityLevelResponseBody() {}

  explicit ListSensitivityLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sensitivityLevelList) {
      vector<boost::any> temp1;
      for(auto item1:*sensitivityLevelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SensitivityLevelList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SensitivityLevelList") != m.end() && !m["SensitivityLevelList"].empty()) {
      if (typeid(vector<boost::any>) == m["SensitivityLevelList"].type()) {
        vector<ListSensitivityLevelResponseBodySensitivityLevelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SensitivityLevelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSensitivityLevelResponseBodySensitivityLevelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sensitivityLevelList = make_shared<vector<ListSensitivityLevelResponseBodySensitivityLevelList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSensitivityLevelResponseBody() = default;
};
class ListSensitivityLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSensitivityLevelResponseBody> body{};

  ListSensitivityLevelResponse() {}

  explicit ListSensitivityLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSensitivityLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSensitivityLevelResponseBody>(model1);
      }
    }
  }


  virtual ~ListSensitivityLevelResponse() = default;
};
class ListStandardGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};

  ListStandardGroupsRequest() {}

  explicit ListStandardGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListStandardGroupsRequest() = default;
};
class ListStandardGroupsResponseBodyStandardGroupList : public Darabonba::Model {
public:
  shared_ptr<string> dbType{};
  shared_ptr<string> description{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupMode{};
  shared_ptr<string> groupName{};
  shared_ptr<long> lastMenderId{};

  ListStandardGroupsResponseBodyStandardGroupList() {}

  explicit ListStandardGroupsResponseBodyStandardGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupMode) {
      res["GroupMode"] = boost::any(*groupMode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lastMenderId) {
      res["LastMenderId"] = boost::any(*lastMenderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupMode") != m.end() && !m["GroupMode"].empty()) {
      groupMode = make_shared<string>(boost::any_cast<string>(m["GroupMode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LastMenderId") != m.end() && !m["LastMenderId"].empty()) {
      lastMenderId = make_shared<long>(boost::any_cast<long>(m["LastMenderId"]));
    }
  }


  virtual ~ListStandardGroupsResponseBodyStandardGroupList() = default;
};
class ListStandardGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListStandardGroupsResponseBodyStandardGroupList>> standardGroupList{};
  shared_ptr<bool> success{};

  ListStandardGroupsResponseBody() {}

  explicit ListStandardGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (standardGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*standardGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StandardGroupList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StandardGroupList") != m.end() && !m["StandardGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["StandardGroupList"].type()) {
        vector<ListStandardGroupsResponseBodyStandardGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StandardGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListStandardGroupsResponseBodyStandardGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        standardGroupList = make_shared<vector<ListStandardGroupsResponseBodyStandardGroupList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListStandardGroupsResponseBody() = default;
};
class ListStandardGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListStandardGroupsResponseBody> body{};

  ListStandardGroupsResponse() {}

  explicit ListStandardGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListStandardGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListStandardGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListStandardGroupsResponse() = default;
};
class ListTablesRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> returnGuid{};
  shared_ptr<string> searchName{};
  shared_ptr<long> tid{};

  ListTablesRequest() {}

  explicit ListTablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (returnGuid) {
      res["ReturnGuid"] = boost::any(*returnGuid);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ReturnGuid") != m.end() && !m["ReturnGuid"].empty()) {
      returnGuid = make_shared<bool>(boost::any_cast<bool>(m["ReturnGuid"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListTablesRequest() = default;
};
class ListTablesResponseBodyTableListTableOwnerIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerIds{};

  ListTablesResponseBodyTableListTableOwnerIdList() {}

  explicit ListTablesResponseBodyTableListTableOwnerIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListTablesResponseBodyTableListTableOwnerIdList() = default;
};
class ListTablesResponseBodyTableListTableOwnerNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerNames{};

  ListTablesResponseBodyTableListTableOwnerNameList() {}

  explicit ListTablesResponseBodyTableListTableOwnerNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListTablesResponseBodyTableListTableOwnerNameList() = default;
};
class ListTablesResponseBodyTableListTable : public Darabonba::Model {
public:
  shared_ptr<string> databaseId{};
  shared_ptr<string> description{};
  shared_ptr<string> encoding{};
  shared_ptr<string> engine{};
  shared_ptr<long> numRows{};
  shared_ptr<ListTablesResponseBodyTableListTableOwnerIdList> ownerIdList{};
  shared_ptr<ListTablesResponseBodyTableListTableOwnerNameList> ownerNameList{};
  shared_ptr<long> storeCapacity{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> tableId{};
  shared_ptr<string> tableName{};
  shared_ptr<string> tableSchemaName{};
  shared_ptr<string> tableType{};

  ListTablesResponseBodyTableListTable() {}

  explicit ListTablesResponseBodyTableListTable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (numRows) {
      res["NumRows"] = boost::any(*numRows);
    }
    if (ownerIdList) {
      res["OwnerIdList"] = ownerIdList ? boost::any(ownerIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerNameList) {
      res["OwnerNameList"] = ownerNameList ? boost::any(ownerNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storeCapacity) {
      res["StoreCapacity"] = boost::any(*storeCapacity);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableSchemaName) {
      res["TableSchemaName"] = boost::any(*tableSchemaName);
    }
    if (tableType) {
      res["TableType"] = boost::any(*tableType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("NumRows") != m.end() && !m["NumRows"].empty()) {
      numRows = make_shared<long>(boost::any_cast<long>(m["NumRows"]));
    }
    if (m.find("OwnerIdList") != m.end() && !m["OwnerIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerIdList"].type()) {
        ListTablesResponseBodyTableListTableOwnerIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerIdList"]));
        ownerIdList = make_shared<ListTablesResponseBodyTableListTableOwnerIdList>(model1);
      }
    }
    if (m.find("OwnerNameList") != m.end() && !m["OwnerNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerNameList"].type()) {
        ListTablesResponseBodyTableListTableOwnerNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerNameList"]));
        ownerNameList = make_shared<ListTablesResponseBodyTableListTableOwnerNameList>(model1);
      }
    }
    if (m.find("StoreCapacity") != m.end() && !m["StoreCapacity"].empty()) {
      storeCapacity = make_shared<long>(boost::any_cast<long>(m["StoreCapacity"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableSchemaName") != m.end() && !m["TableSchemaName"].empty()) {
      tableSchemaName = make_shared<string>(boost::any_cast<string>(m["TableSchemaName"]));
    }
    if (m.find("TableType") != m.end() && !m["TableType"].empty()) {
      tableType = make_shared<string>(boost::any_cast<string>(m["TableType"]));
    }
  }


  virtual ~ListTablesResponseBodyTableListTable() = default;
};
class ListTablesResponseBodyTableList : public Darabonba::Model {
public:
  shared_ptr<vector<ListTablesResponseBodyTableListTable>> table{};

  ListTablesResponseBodyTableList() {}

  explicit ListTablesResponseBodyTableList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (table) {
      vector<boost::any> temp1;
      for(auto item1:*table){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Table"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Table") != m.end() && !m["Table"].empty()) {
      if (typeid(vector<boost::any>) == m["Table"].type()) {
        vector<ListTablesResponseBodyTableListTable> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Table"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTablesResponseBodyTableListTable model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        table = make_shared<vector<ListTablesResponseBodyTableListTable>>(expect1);
      }
    }
  }


  virtual ~ListTablesResponseBodyTableList() = default;
};
class ListTablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListTablesResponseBodyTableList> tableList{};
  shared_ptr<long> totalCount{};

  ListTablesResponseBody() {}

  explicit ListTablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tableList) {
      res["TableList"] = tableList ? boost::any(tableList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TableList") != m.end() && !m["TableList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableList"].type()) {
        ListTablesResponseBodyTableList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableList"]));
        tableList = make_shared<ListTablesResponseBodyTableList>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTablesResponseBody() = default;
};
class ListTablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTablesResponseBody> body{};

  ListTablesResponse() {}

  explicit ListTablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTablesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTablesResponse() = default;
};
class ListTaskFlowRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};

  ListTaskFlowRequest() {}

  explicit ListTaskFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListTaskFlowRequest() = default;
};
class ListTaskFlowResponseBodyTaskFlowListTaskFlow : public Darabonba::Model {
public:
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorNickName{};
  shared_ptr<string> dagOwnerNickName{};
  shared_ptr<long> deployId{};
  shared_ptr<long> id{};
  shared_ptr<long> latestInstanceStatus{};
  shared_ptr<string> latestInstanceTime{};
  shared_ptr<long> status{};

  ListTaskFlowResponseBodyTaskFlowListTaskFlow() {}

  explicit ListTaskFlowResponseBodyTaskFlowListTaskFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorNickName) {
      res["CreatorNickName"] = boost::any(*creatorNickName);
    }
    if (dagOwnerNickName) {
      res["DagOwnerNickName"] = boost::any(*dagOwnerNickName);
    }
    if (deployId) {
      res["DeployId"] = boost::any(*deployId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (latestInstanceStatus) {
      res["LatestInstanceStatus"] = boost::any(*latestInstanceStatus);
    }
    if (latestInstanceTime) {
      res["LatestInstanceTime"] = boost::any(*latestInstanceTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorNickName") != m.end() && !m["CreatorNickName"].empty()) {
      creatorNickName = make_shared<string>(boost::any_cast<string>(m["CreatorNickName"]));
    }
    if (m.find("DagOwnerNickName") != m.end() && !m["DagOwnerNickName"].empty()) {
      dagOwnerNickName = make_shared<string>(boost::any_cast<string>(m["DagOwnerNickName"]));
    }
    if (m.find("DeployId") != m.end() && !m["DeployId"].empty()) {
      deployId = make_shared<long>(boost::any_cast<long>(m["DeployId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LatestInstanceStatus") != m.end() && !m["LatestInstanceStatus"].empty()) {
      latestInstanceStatus = make_shared<long>(boost::any_cast<long>(m["LatestInstanceStatus"]));
    }
    if (m.find("LatestInstanceTime") != m.end() && !m["LatestInstanceTime"].empty()) {
      latestInstanceTime = make_shared<string>(boost::any_cast<string>(m["LatestInstanceTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListTaskFlowResponseBodyTaskFlowListTaskFlow() = default;
};
class ListTaskFlowResponseBodyTaskFlowList : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskFlowResponseBodyTaskFlowListTaskFlow>> taskFlow{};

  ListTaskFlowResponseBodyTaskFlowList() {}

  explicit ListTaskFlowResponseBodyTaskFlowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskFlow) {
      vector<boost::any> temp1;
      for(auto item1:*taskFlow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskFlow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskFlow") != m.end() && !m["TaskFlow"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskFlow"].type()) {
        vector<ListTaskFlowResponseBodyTaskFlowListTaskFlow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskFlow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskFlowResponseBodyTaskFlowListTaskFlow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskFlow = make_shared<vector<ListTaskFlowResponseBodyTaskFlowListTaskFlow>>(expect1);
      }
    }
  }


  virtual ~ListTaskFlowResponseBodyTaskFlowList() = default;
};
class ListTaskFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListTaskFlowResponseBodyTaskFlowList> taskFlowList{};

  ListTaskFlowResponseBody() {}

  explicit ListTaskFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskFlowList) {
      res["TaskFlowList"] = taskFlowList ? boost::any(taskFlowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskFlowList") != m.end() && !m["TaskFlowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskFlowList"].type()) {
        ListTaskFlowResponseBodyTaskFlowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskFlowList"]));
        taskFlowList = make_shared<ListTaskFlowResponseBodyTaskFlowList>(model1);
      }
    }
  }


  virtual ~ListTaskFlowResponseBody() = default;
};
class ListTaskFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskFlowResponseBody> body{};

  ListTaskFlowResponse() {}

  explicit ListTaskFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskFlowResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskFlowResponse() = default;
};
class ListTaskFlowConstantsRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  ListTaskFlowConstantsRequest() {}

  explicit ListTaskFlowConstantsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListTaskFlowConstantsRequest() = default;
};
class ListTaskFlowConstantsResponseBodyDagConstantsDagConstant : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTaskFlowConstantsResponseBodyDagConstantsDagConstant() {}

  explicit ListTaskFlowConstantsResponseBodyDagConstantsDagConstant(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTaskFlowConstantsResponseBodyDagConstantsDagConstant() = default;
};
class ListTaskFlowConstantsResponseBodyDagConstants : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskFlowConstantsResponseBodyDagConstantsDagConstant>> dagConstant{};

  ListTaskFlowConstantsResponseBodyDagConstants() {}

  explicit ListTaskFlowConstantsResponseBodyDagConstants(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagConstant) {
      vector<boost::any> temp1;
      for(auto item1:*dagConstant){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DagConstant"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagConstant") != m.end() && !m["DagConstant"].empty()) {
      if (typeid(vector<boost::any>) == m["DagConstant"].type()) {
        vector<ListTaskFlowConstantsResponseBodyDagConstantsDagConstant> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DagConstant"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskFlowConstantsResponseBodyDagConstantsDagConstant model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dagConstant = make_shared<vector<ListTaskFlowConstantsResponseBodyDagConstantsDagConstant>>(expect1);
      }
    }
  }


  virtual ~ListTaskFlowConstantsResponseBodyDagConstants() = default;
};
class ListTaskFlowConstantsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTaskFlowConstantsResponseBodyDagConstants> dagConstants{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListTaskFlowConstantsResponseBody() {}

  explicit ListTaskFlowConstantsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagConstants) {
      res["DagConstants"] = dagConstants ? boost::any(dagConstants->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagConstants") != m.end() && !m["DagConstants"].empty()) {
      if (typeid(map<string, boost::any>) == m["DagConstants"].type()) {
        ListTaskFlowConstantsResponseBodyDagConstants model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DagConstants"]));
        dagConstants = make_shared<ListTaskFlowConstantsResponseBodyDagConstants>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListTaskFlowConstantsResponseBody() = default;
};
class ListTaskFlowConstantsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskFlowConstantsResponseBody> body{};

  ListTaskFlowConstantsResponse() {}

  explicit ListTaskFlowConstantsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskFlowConstantsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskFlowConstantsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskFlowConstantsResponse() = default;
};
class ListTaskFlowCooperatorsRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  ListTaskFlowCooperatorsRequest() {}

  explicit ListTaskFlowCooperatorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListTaskFlowCooperatorsRequest() = default;
};
class ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<string> loginName{};
  shared_ptr<string> nickName{};
  shared_ptr<string> userId{};

  ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator() {}

  explicit ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator() = default;
};
class ListTaskFlowCooperatorsResponseBodyCooperatorList : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator>> cooperator{};

  ListTaskFlowCooperatorsResponseBodyCooperatorList() {}

  explicit ListTaskFlowCooperatorsResponseBodyCooperatorList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cooperator) {
      vector<boost::any> temp1;
      for(auto item1:*cooperator){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cooperator"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cooperator") != m.end() && !m["Cooperator"].empty()) {
      if (typeid(vector<boost::any>) == m["Cooperator"].type()) {
        vector<ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cooperator"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cooperator = make_shared<vector<ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator>>(expect1);
      }
    }
  }


  virtual ~ListTaskFlowCooperatorsResponseBodyCooperatorList() = default;
};
class ListTaskFlowCooperatorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTaskFlowCooperatorsResponseBodyCooperatorList> cooperatorList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListTaskFlowCooperatorsResponseBody() {}

  explicit ListTaskFlowCooperatorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cooperatorList) {
      res["CooperatorList"] = cooperatorList ? boost::any(cooperatorList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CooperatorList") != m.end() && !m["CooperatorList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CooperatorList"].type()) {
        ListTaskFlowCooperatorsResponseBodyCooperatorList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CooperatorList"]));
        cooperatorList = make_shared<ListTaskFlowCooperatorsResponseBodyCooperatorList>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListTaskFlowCooperatorsResponseBody() = default;
};
class ListTaskFlowCooperatorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskFlowCooperatorsResponseBody> body{};

  ListTaskFlowCooperatorsResponse() {}

  explicit ListTaskFlowCooperatorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskFlowCooperatorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskFlowCooperatorsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskFlowCooperatorsResponse() = default;
};
class ListTaskFlowEdgesByConditionRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> id{};
  shared_ptr<long> nodeEnd{};
  shared_ptr<long> nodeFrom{};
  shared_ptr<long> tid{};

  ListTaskFlowEdgesByConditionRequest() {}

  explicit ListTaskFlowEdgesByConditionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nodeEnd) {
      res["NodeEnd"] = boost::any(*nodeEnd);
    }
    if (nodeFrom) {
      res["NodeFrom"] = boost::any(*nodeFrom);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NodeEnd") != m.end() && !m["NodeEnd"].empty()) {
      nodeEnd = make_shared<long>(boost::any_cast<long>(m["NodeEnd"]));
    }
    if (m.find("NodeFrom") != m.end() && !m["NodeFrom"].empty()) {
      nodeFrom = make_shared<long>(boost::any_cast<long>(m["NodeFrom"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListTaskFlowEdgesByConditionRequest() = default;
};
class ListTaskFlowEdgesByConditionResponseBodyEdgesEdge : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> nodeEnd{};
  shared_ptr<long> nodeFrom{};

  ListTaskFlowEdgesByConditionResponseBodyEdgesEdge() {}

  explicit ListTaskFlowEdgesByConditionResponseBodyEdgesEdge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nodeEnd) {
      res["NodeEnd"] = boost::any(*nodeEnd);
    }
    if (nodeFrom) {
      res["NodeFrom"] = boost::any(*nodeFrom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NodeEnd") != m.end() && !m["NodeEnd"].empty()) {
      nodeEnd = make_shared<long>(boost::any_cast<long>(m["NodeEnd"]));
    }
    if (m.find("NodeFrom") != m.end() && !m["NodeFrom"].empty()) {
      nodeFrom = make_shared<long>(boost::any_cast<long>(m["NodeFrom"]));
    }
  }


  virtual ~ListTaskFlowEdgesByConditionResponseBodyEdgesEdge() = default;
};
class ListTaskFlowEdgesByConditionResponseBodyEdges : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskFlowEdgesByConditionResponseBodyEdgesEdge>> edge{};

  ListTaskFlowEdgesByConditionResponseBodyEdges() {}

  explicit ListTaskFlowEdgesByConditionResponseBodyEdges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edge) {
      vector<boost::any> temp1;
      for(auto item1:*edge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Edge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edge") != m.end() && !m["Edge"].empty()) {
      if (typeid(vector<boost::any>) == m["Edge"].type()) {
        vector<ListTaskFlowEdgesByConditionResponseBodyEdgesEdge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Edge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskFlowEdgesByConditionResponseBodyEdgesEdge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        edge = make_shared<vector<ListTaskFlowEdgesByConditionResponseBodyEdgesEdge>>(expect1);
      }
    }
  }


  virtual ~ListTaskFlowEdgesByConditionResponseBodyEdges() = default;
};
class ListTaskFlowEdgesByConditionResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTaskFlowEdgesByConditionResponseBodyEdges> edges{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListTaskFlowEdgesByConditionResponseBody() {}

  explicit ListTaskFlowEdgesByConditionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edges) {
      res["Edges"] = edges ? boost::any(edges->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edges") != m.end() && !m["Edges"].empty()) {
      if (typeid(map<string, boost::any>) == m["Edges"].type()) {
        ListTaskFlowEdgesByConditionResponseBodyEdges model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Edges"]));
        edges = make_shared<ListTaskFlowEdgesByConditionResponseBodyEdges>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListTaskFlowEdgesByConditionResponseBody() = default;
};
class ListTaskFlowEdgesByConditionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskFlowEdgesByConditionResponseBody> body{};

  ListTaskFlowEdgesByConditionResponse() {}

  explicit ListTaskFlowEdgesByConditionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskFlowEdgesByConditionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskFlowEdgesByConditionResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskFlowEdgesByConditionResponse() = default;
};
class ListTaskFlowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTimeBegin{};
  shared_ptr<string> startTimeEnd{};
  shared_ptr<long> status{};
  shared_ptr<long> tid{};
  shared_ptr<long> triggerType{};
  shared_ptr<bool> useBizDate{};

  ListTaskFlowInstanceRequest() {}

  explicit ListTaskFlowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTimeBegin) {
      res["StartTimeBegin"] = boost::any(*startTimeBegin);
    }
    if (startTimeEnd) {
      res["StartTimeEnd"] = boost::any(*startTimeEnd);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (useBizDate) {
      res["UseBizDate"] = boost::any(*useBizDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTimeBegin") != m.end() && !m["StartTimeBegin"].empty()) {
      startTimeBegin = make_shared<string>(boost::any_cast<string>(m["StartTimeBegin"]));
    }
    if (m.find("StartTimeEnd") != m.end() && !m["StartTimeEnd"].empty()) {
      startTimeEnd = make_shared<string>(boost::any_cast<string>(m["StartTimeEnd"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<long>(boost::any_cast<long>(m["TriggerType"]));
    }
    if (m.find("UseBizDate") != m.end() && !m["UseBizDate"].empty()) {
      useBizDate = make_shared<bool>(boost::any_cast<bool>(m["UseBizDate"]));
    }
  }


  virtual ~ListTaskFlowInstanceRequest() = default;
};
class ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance : public Darabonba::Model {
public:
  shared_ptr<string> businessTime{};
  shared_ptr<string> dagId{};
  shared_ptr<string> dagName{};
  shared_ptr<string> dagVersion{};
  shared_ptr<string> endTime{};
  shared_ptr<long> historyDagId{};
  shared_ptr<long> id{};
  shared_ptr<string> message{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> status{};
  shared_ptr<long> triggerType{};
  shared_ptr<string> startTime{};

  ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance() {}

  explicit ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessTime) {
      res["BusinessTime"] = boost::any(*businessTime);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagName) {
      res["DagName"] = boost::any(*dagName);
    }
    if (dagVersion) {
      res["DagVersion"] = boost::any(*dagVersion);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (historyDagId) {
      res["HistoryDagId"] = boost::any(*historyDagId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessTime") != m.end() && !m["BusinessTime"].empty()) {
      businessTime = make_shared<string>(boost::any_cast<string>(m["BusinessTime"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<string>(boost::any_cast<string>(m["DagId"]));
    }
    if (m.find("DagName") != m.end() && !m["DagName"].empty()) {
      dagName = make_shared<string>(boost::any_cast<string>(m["DagName"]));
    }
    if (m.find("DagVersion") != m.end() && !m["DagVersion"].empty()) {
      dagVersion = make_shared<string>(boost::any_cast<string>(m["DagVersion"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("HistoryDagId") != m.end() && !m["HistoryDagId"].empty()) {
      historyDagId = make_shared<long>(boost::any_cast<long>(m["HistoryDagId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<long>(boost::any_cast<long>(m["TriggerType"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance() = default;
};
class ListTaskFlowInstanceResponseBodyDAGInstanceList : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance>> DAGInstance{};

  ListTaskFlowInstanceResponseBodyDAGInstanceList() {}

  explicit ListTaskFlowInstanceResponseBodyDAGInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DAGInstance) {
      vector<boost::any> temp1;
      for(auto item1:*DAGInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DAGInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DAGInstance") != m.end() && !m["DAGInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["DAGInstance"].type()) {
        vector<ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DAGInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DAGInstance = make_shared<vector<ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance>>(expect1);
      }
    }
  }


  virtual ~ListTaskFlowInstanceResponseBodyDAGInstanceList() = default;
};
class ListTaskFlowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTaskFlowInstanceResponseBodyDAGInstanceList> DAGInstanceList{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListTaskFlowInstanceResponseBody() {}

  explicit ListTaskFlowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DAGInstanceList) {
      res["DAGInstanceList"] = DAGInstanceList ? boost::any(DAGInstanceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DAGInstanceList") != m.end() && !m["DAGInstanceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DAGInstanceList"].type()) {
        ListTaskFlowInstanceResponseBodyDAGInstanceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DAGInstanceList"]));
        DAGInstanceList = make_shared<ListTaskFlowInstanceResponseBodyDAGInstanceList>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTaskFlowInstanceResponseBody() = default;
};
class ListTaskFlowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskFlowInstanceResponseBody> body{};

  ListTaskFlowInstanceResponse() {}

  explicit ListTaskFlowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskFlowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskFlowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskFlowInstanceResponse() = default;
};
class ListTaskFlowTimeVariablesRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  ListTaskFlowTimeVariablesRequest() {}

  explicit ListTaskFlowTimeVariablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListTaskFlowTimeVariablesRequest() = default;
};
class ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> pattern{};

  ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable() {}

  explicit ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
  }


  virtual ~ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable() = default;
};
class ListTaskFlowTimeVariablesResponseBodyTimeVariables : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable>> timeVariable{};

  ListTaskFlowTimeVariablesResponseBodyTimeVariables() {}

  explicit ListTaskFlowTimeVariablesResponseBodyTimeVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeVariable) {
      vector<boost::any> temp1;
      for(auto item1:*timeVariable){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TimeVariable"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeVariable") != m.end() && !m["TimeVariable"].empty()) {
      if (typeid(vector<boost::any>) == m["TimeVariable"].type()) {
        vector<ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TimeVariable"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        timeVariable = make_shared<vector<ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable>>(expect1);
      }
    }
  }


  virtual ~ListTaskFlowTimeVariablesResponseBodyTimeVariables() = default;
};
class ListTaskFlowTimeVariablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListTaskFlowTimeVariablesResponseBodyTimeVariables> timeVariables{};

  ListTaskFlowTimeVariablesResponseBody() {}

  explicit ListTaskFlowTimeVariablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeVariables) {
      res["TimeVariables"] = timeVariables ? boost::any(timeVariables->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeVariables") != m.end() && !m["TimeVariables"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeVariables"].type()) {
        ListTaskFlowTimeVariablesResponseBodyTimeVariables model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeVariables"]));
        timeVariables = make_shared<ListTaskFlowTimeVariablesResponseBodyTimeVariables>(model1);
      }
    }
  }


  virtual ~ListTaskFlowTimeVariablesResponseBody() = default;
};
class ListTaskFlowTimeVariablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskFlowTimeVariablesResponseBody> body{};

  ListTaskFlowTimeVariablesResponse() {}

  explicit ListTaskFlowTimeVariablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskFlowTimeVariablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskFlowTimeVariablesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskFlowTimeVariablesResponse() = default;
};
class ListTaskFlowsByPageRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> dagIdList{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> scenarioId{};
  shared_ptr<string> searchKey{};
  shared_ptr<long> tid{};

  ListTaskFlowsByPageRequest() {}

  explicit ListTaskFlowsByPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagIdList) {
      res["DagIdList"] = boost::any(*dagIdList);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagIdList") != m.end() && !m["DagIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DagIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DagIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      dagIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<long>(boost::any_cast<long>(m["ScenarioId"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListTaskFlowsByPageRequest() = default;
};
class ListTaskFlowsByPageShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dagIdListShrink{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> scenarioId{};
  shared_ptr<string> searchKey{};
  shared_ptr<long> tid{};

  ListTaskFlowsByPageShrinkRequest() {}

  explicit ListTaskFlowsByPageShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagIdListShrink) {
      res["DagIdList"] = boost::any(*dagIdListShrink);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagIdList") != m.end() && !m["DagIdList"].empty()) {
      dagIdListShrink = make_shared<string>(boost::any_cast<string>(m["DagIdList"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<long>(boost::any_cast<long>(m["ScenarioId"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListTaskFlowsByPageShrinkRequest() = default;
};
class ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow : public Darabonba::Model {
public:
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorNickName{};
  shared_ptr<string> cronBeginDate{};
  shared_ptr<string> cronEndDate{};
  shared_ptr<string> cronStr{};
  shared_ptr<bool> cronSwitch{};
  shared_ptr<long> cronType{};
  shared_ptr<string> dagName{};
  shared_ptr<string> dagOwnerId{};
  shared_ptr<string> dagOwnerNickName{};
  shared_ptr<long> deployId{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> latestInstanceStatus{};
  shared_ptr<string> latestInstanceTime{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> scheduleParam{};
  shared_ptr<long> status{};
  shared_ptr<string> timeZoneId{};
  shared_ptr<long> triggerType{};

  ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow() {}

  explicit ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorNickName) {
      res["CreatorNickName"] = boost::any(*creatorNickName);
    }
    if (cronBeginDate) {
      res["CronBeginDate"] = boost::any(*cronBeginDate);
    }
    if (cronEndDate) {
      res["CronEndDate"] = boost::any(*cronEndDate);
    }
    if (cronStr) {
      res["CronStr"] = boost::any(*cronStr);
    }
    if (cronSwitch) {
      res["CronSwitch"] = boost::any(*cronSwitch);
    }
    if (cronType) {
      res["CronType"] = boost::any(*cronType);
    }
    if (dagName) {
      res["DagName"] = boost::any(*dagName);
    }
    if (dagOwnerId) {
      res["DagOwnerId"] = boost::any(*dagOwnerId);
    }
    if (dagOwnerNickName) {
      res["DagOwnerNickName"] = boost::any(*dagOwnerNickName);
    }
    if (deployId) {
      res["DeployId"] = boost::any(*deployId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (latestInstanceStatus) {
      res["LatestInstanceStatus"] = boost::any(*latestInstanceStatus);
    }
    if (latestInstanceTime) {
      res["LatestInstanceTime"] = boost::any(*latestInstanceTime);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (scheduleParam) {
      res["ScheduleParam"] = boost::any(*scheduleParam);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeZoneId) {
      res["TimeZoneId"] = boost::any(*timeZoneId);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorNickName") != m.end() && !m["CreatorNickName"].empty()) {
      creatorNickName = make_shared<string>(boost::any_cast<string>(m["CreatorNickName"]));
    }
    if (m.find("CronBeginDate") != m.end() && !m["CronBeginDate"].empty()) {
      cronBeginDate = make_shared<string>(boost::any_cast<string>(m["CronBeginDate"]));
    }
    if (m.find("CronEndDate") != m.end() && !m["CronEndDate"].empty()) {
      cronEndDate = make_shared<string>(boost::any_cast<string>(m["CronEndDate"]));
    }
    if (m.find("CronStr") != m.end() && !m["CronStr"].empty()) {
      cronStr = make_shared<string>(boost::any_cast<string>(m["CronStr"]));
    }
    if (m.find("CronSwitch") != m.end() && !m["CronSwitch"].empty()) {
      cronSwitch = make_shared<bool>(boost::any_cast<bool>(m["CronSwitch"]));
    }
    if (m.find("CronType") != m.end() && !m["CronType"].empty()) {
      cronType = make_shared<long>(boost::any_cast<long>(m["CronType"]));
    }
    if (m.find("DagName") != m.end() && !m["DagName"].empty()) {
      dagName = make_shared<string>(boost::any_cast<string>(m["DagName"]));
    }
    if (m.find("DagOwnerId") != m.end() && !m["DagOwnerId"].empty()) {
      dagOwnerId = make_shared<string>(boost::any_cast<string>(m["DagOwnerId"]));
    }
    if (m.find("DagOwnerNickName") != m.end() && !m["DagOwnerNickName"].empty()) {
      dagOwnerNickName = make_shared<string>(boost::any_cast<string>(m["DagOwnerNickName"]));
    }
    if (m.find("DeployId") != m.end() && !m["DeployId"].empty()) {
      deployId = make_shared<long>(boost::any_cast<long>(m["DeployId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LatestInstanceStatus") != m.end() && !m["LatestInstanceStatus"].empty()) {
      latestInstanceStatus = make_shared<long>(boost::any_cast<long>(m["LatestInstanceStatus"]));
    }
    if (m.find("LatestInstanceTime") != m.end() && !m["LatestInstanceTime"].empty()) {
      latestInstanceTime = make_shared<string>(boost::any_cast<string>(m["LatestInstanceTime"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("ScheduleParam") != m.end() && !m["ScheduleParam"].empty()) {
      scheduleParam = make_shared<string>(boost::any_cast<string>(m["ScheduleParam"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TimeZoneId") != m.end() && !m["TimeZoneId"].empty()) {
      timeZoneId = make_shared<string>(boost::any_cast<string>(m["TimeZoneId"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<long>(boost::any_cast<long>(m["TriggerType"]));
    }
  }


  virtual ~ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow() = default;
};
class ListTaskFlowsByPageResponseBodyTaskFlowList : public Darabonba::Model {
public:
  shared_ptr<vector<ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow>> taskFlow{};

  ListTaskFlowsByPageResponseBodyTaskFlowList() {}

  explicit ListTaskFlowsByPageResponseBodyTaskFlowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskFlow) {
      vector<boost::any> temp1;
      for(auto item1:*taskFlow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskFlow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskFlow") != m.end() && !m["TaskFlow"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskFlow"].type()) {
        vector<ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskFlow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskFlow = make_shared<vector<ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow>>(expect1);
      }
    }
  }


  virtual ~ListTaskFlowsByPageResponseBodyTaskFlowList() = default;
};
class ListTaskFlowsByPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListTaskFlowsByPageResponseBodyTaskFlowList> taskFlowList{};
  shared_ptr<long> totalCount{};

  ListTaskFlowsByPageResponseBody() {}

  explicit ListTaskFlowsByPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskFlowList) {
      res["TaskFlowList"] = taskFlowList ? boost::any(taskFlowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskFlowList") != m.end() && !m["TaskFlowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskFlowList"].type()) {
        ListTaskFlowsByPageResponseBodyTaskFlowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskFlowList"]));
        taskFlowList = make_shared<ListTaskFlowsByPageResponseBodyTaskFlowList>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTaskFlowsByPageResponseBody() = default;
};
class ListTaskFlowsByPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTaskFlowsByPageResponseBody> body{};

  ListTaskFlowsByPageResponse() {}

  explicit ListTaskFlowsByPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTaskFlowsByPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTaskFlowsByPageResponseBody>(model1);
      }
    }
  }


  virtual ~ListTaskFlowsByPageResponse() = default;
};
class ListTasksInTaskFlowRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  ListTasksInTaskFlowRequest() {}

  explicit ListTasksInTaskFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListTasksInTaskFlowRequest() = default;
};
class ListTasksInTaskFlowResponseBodyTasksTask : public Darabonba::Model {
public:
  shared_ptr<string> graphParam{};
  shared_ptr<string> nodeConfig{};
  shared_ptr<string> nodeContent{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> nodeOutput{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> timeVariables{};

  ListTasksInTaskFlowResponseBodyTasksTask() {}

  explicit ListTasksInTaskFlowResponseBodyTasksTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (graphParam) {
      res["GraphParam"] = boost::any(*graphParam);
    }
    if (nodeConfig) {
      res["NodeConfig"] = boost::any(*nodeConfig);
    }
    if (nodeContent) {
      res["NodeContent"] = boost::any(*nodeContent);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeOutput) {
      res["NodeOutput"] = boost::any(*nodeOutput);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (timeVariables) {
      res["TimeVariables"] = boost::any(*timeVariables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GraphParam") != m.end() && !m["GraphParam"].empty()) {
      graphParam = make_shared<string>(boost::any_cast<string>(m["GraphParam"]));
    }
    if (m.find("NodeConfig") != m.end() && !m["NodeConfig"].empty()) {
      nodeConfig = make_shared<string>(boost::any_cast<string>(m["NodeConfig"]));
    }
    if (m.find("NodeContent") != m.end() && !m["NodeContent"].empty()) {
      nodeContent = make_shared<string>(boost::any_cast<string>(m["NodeContent"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeOutput") != m.end() && !m["NodeOutput"].empty()) {
      nodeOutput = make_shared<string>(boost::any_cast<string>(m["NodeOutput"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("TimeVariables") != m.end() && !m["TimeVariables"].empty()) {
      timeVariables = make_shared<string>(boost::any_cast<string>(m["TimeVariables"]));
    }
  }


  virtual ~ListTasksInTaskFlowResponseBodyTasksTask() = default;
};
class ListTasksInTaskFlowResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<vector<ListTasksInTaskFlowResponseBodyTasksTask>> task{};

  ListTasksInTaskFlowResponseBodyTasks() {}

  explicit ListTasksInTaskFlowResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (task) {
      vector<boost::any> temp1;
      for(auto item1:*task){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Task"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(vector<boost::any>) == m["Task"].type()) {
        vector<ListTasksInTaskFlowResponseBodyTasksTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Task"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTasksInTaskFlowResponseBodyTasksTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        task = make_shared<vector<ListTasksInTaskFlowResponseBodyTasksTask>>(expect1);
      }
    }
  }


  virtual ~ListTasksInTaskFlowResponseBodyTasks() = default;
};
class ListTasksInTaskFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListTasksInTaskFlowResponseBodyTasks> tasks{};

  ListTasksInTaskFlowResponseBody() {}

  explicit ListTasksInTaskFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tasks) {
      res["Tasks"] = tasks ? boost::any(tasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tasks"].type()) {
        ListTasksInTaskFlowResponseBodyTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tasks"]));
        tasks = make_shared<ListTasksInTaskFlowResponseBodyTasks>(model1);
      }
    }
  }


  virtual ~ListTasksInTaskFlowResponseBody() = default;
};
class ListTasksInTaskFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTasksInTaskFlowResponseBody> body{};

  ListTasksInTaskFlowResponse() {}

  explicit ListTasksInTaskFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTasksInTaskFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTasksInTaskFlowResponseBody>(model1);
      }
    }
  }


  virtual ~ListTasksInTaskFlowResponse() = default;
};
class ListUserPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<bool> logic{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> permType{};
  shared_ptr<string> searchKey{};
  shared_ptr<long> tid{};
  shared_ptr<string> userId{};

  ListUserPermissionsRequest() {}

  explicit ListUserPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (permType) {
      res["PermType"] = boost::any(*permType);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PermType") != m.end() && !m["PermType"].empty()) {
      permType = make_shared<string>(boost::any_cast<string>(m["PermType"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListUserPermissionsRequest() = default;
};
class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail : public Darabonba::Model {
public:
  shared_ptr<string> createDate{};
  shared_ptr<string> expireDate{};
  shared_ptr<string> extraData{};
  shared_ptr<string> originFrom{};
  shared_ptr<string> permType{};
  shared_ptr<string> userAccessId{};

  ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail() {}

  explicit ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (expireDate) {
      res["ExpireDate"] = boost::any(*expireDate);
    }
    if (extraData) {
      res["ExtraData"] = boost::any(*extraData);
    }
    if (originFrom) {
      res["OriginFrom"] = boost::any(*originFrom);
    }
    if (permType) {
      res["PermType"] = boost::any(*permType);
    }
    if (userAccessId) {
      res["UserAccessId"] = boost::any(*userAccessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("ExpireDate") != m.end() && !m["ExpireDate"].empty()) {
      expireDate = make_shared<string>(boost::any_cast<string>(m["ExpireDate"]));
    }
    if (m.find("ExtraData") != m.end() && !m["ExtraData"].empty()) {
      extraData = make_shared<string>(boost::any_cast<string>(m["ExtraData"]));
    }
    if (m.find("OriginFrom") != m.end() && !m["OriginFrom"].empty()) {
      originFrom = make_shared<string>(boost::any_cast<string>(m["OriginFrom"]));
    }
    if (m.find("PermType") != m.end() && !m["PermType"].empty()) {
      permType = make_shared<string>(boost::any_cast<string>(m["PermType"]));
    }
    if (m.find("UserAccessId") != m.end() && !m["UserAccessId"].empty()) {
      userAccessId = make_shared<string>(boost::any_cast<string>(m["UserAccessId"]));
    }
  }


  virtual ~ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail() = default;
};
class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails : public Darabonba::Model {
public:
  shared_ptr<vector<ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail>> permDetail{};

  ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails() {}

  explicit ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (permDetail) {
      vector<boost::any> temp1;
      for(auto item1:*permDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PermDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PermDetail") != m.end() && !m["PermDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["PermDetail"].type()) {
        vector<ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PermDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        permDetail = make_shared<vector<ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail>>(expect1);
      }
    }
  }


  virtual ~ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails() = default;
};
class ListUserPermissionsResponseBodyUserPermissionsUserPermission : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> columnName{};
  shared_ptr<string> dbId{};
  shared_ptr<string> dbType{};
  shared_ptr<string> dsType{};
  shared_ptr<string> envType{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> logic{};
  shared_ptr<ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails> permDetails{};
  shared_ptr<long> port{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> searchName{};
  shared_ptr<string> tableId{};
  shared_ptr<string> tableName{};
  shared_ptr<string> userId{};
  shared_ptr<string> userNickName{};

  ListUserPermissionsResponseBodyUserPermissionsUserPermission() {}

  explicit ListUserPermissionsResponseBodyUserPermissionsUserPermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (dsType) {
      res["DsType"] = boost::any(*dsType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (permDetails) {
      res["PermDetails"] = permDetails ? boost::any(permDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userNickName) {
      res["UserNickName"] = boost::any(*userNickName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<string>(boost::any_cast<string>(m["DbId"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("DsType") != m.end() && !m["DsType"].empty()) {
      dsType = make_shared<string>(boost::any_cast<string>(m["DsType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("PermDetails") != m.end() && !m["PermDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["PermDetails"].type()) {
        ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PermDetails"]));
        permDetails = make_shared<ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails>(model1);
      }
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserNickName") != m.end() && !m["UserNickName"].empty()) {
      userNickName = make_shared<string>(boost::any_cast<string>(m["UserNickName"]));
    }
  }


  virtual ~ListUserPermissionsResponseBodyUserPermissionsUserPermission() = default;
};
class ListUserPermissionsResponseBodyUserPermissions : public Darabonba::Model {
public:
  shared_ptr<vector<ListUserPermissionsResponseBodyUserPermissionsUserPermission>> userPermission{};

  ListUserPermissionsResponseBodyUserPermissions() {}

  explicit ListUserPermissionsResponseBodyUserPermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userPermission) {
      vector<boost::any> temp1;
      for(auto item1:*userPermission){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserPermission"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserPermission") != m.end() && !m["UserPermission"].empty()) {
      if (typeid(vector<boost::any>) == m["UserPermission"].type()) {
        vector<ListUserPermissionsResponseBodyUserPermissionsUserPermission> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserPermission"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserPermissionsResponseBodyUserPermissionsUserPermission model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userPermission = make_shared<vector<ListUserPermissionsResponseBodyUserPermissionsUserPermission>>(expect1);
      }
    }
  }


  virtual ~ListUserPermissionsResponseBodyUserPermissions() = default;
};
class ListUserPermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListUserPermissionsResponseBodyUserPermissions> userPermissions{};

  ListUserPermissionsResponseBody() {}

  explicit ListUserPermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userPermissions) {
      res["UserPermissions"] = userPermissions ? boost::any(userPermissions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserPermissions") != m.end() && !m["UserPermissions"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserPermissions"].type()) {
        ListUserPermissionsResponseBodyUserPermissions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserPermissions"]));
        userPermissions = make_shared<ListUserPermissionsResponseBodyUserPermissions>(model1);
      }
    }
  }


  virtual ~ListUserPermissionsResponseBody() = default;
};
class ListUserPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserPermissionsResponseBody> body{};

  ListUserPermissionsResponse() {}

  explicit ListUserPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserPermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserPermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserPermissionsResponse() = default;
};
class ListUserTenantsRequest : public Darabonba::Model {
public:
  shared_ptr<long> tid{};

  ListUserTenantsRequest() {}

  explicit ListUserTenantsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListUserTenantsRequest() = default;
};
class ListUserTenantsResponseBodyTenantList : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> tenantName{};
  shared_ptr<long> tid{};

  ListUserTenantsResponseBodyTenantList() {}

  explicit ListUserTenantsResponseBodyTenantList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListUserTenantsResponseBodyTenantList() = default;
};
class ListUserTenantsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListUserTenantsResponseBodyTenantList>> tenantList{};

  ListUserTenantsResponseBody() {}

  explicit ListUserTenantsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tenantList) {
      vector<boost::any> temp1;
      for(auto item1:*tenantList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TenantList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TenantList") != m.end() && !m["TenantList"].empty()) {
      if (typeid(vector<boost::any>) == m["TenantList"].type()) {
        vector<ListUserTenantsResponseBodyTenantList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TenantList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserTenantsResponseBodyTenantList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenantList = make_shared<vector<ListUserTenantsResponseBodyTenantList>>(expect1);
      }
    }
  }


  virtual ~ListUserTenantsResponseBody() = default;
};
class ListUserTenantsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserTenantsResponseBody> body{};

  ListUserTenantsResponse() {}

  explicit ListUserTenantsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserTenantsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserTenantsResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserTenantsResponse() = default;
};
class ListUsersRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> role{};
  shared_ptr<string> searchKey{};
  shared_ptr<long> tid{};
  shared_ptr<string> userState{};

  ListUsersRequest() {}

  explicit ListUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
  }


  virtual ~ListUsersRequest() = default;
};
class ListUsersResponseBodyUserListUserRoleIdList : public Darabonba::Model {
public:
  shared_ptr<vector<long>> roleIds{};

  ListUsersResponseBodyUserListUserRoleIdList() {}

  explicit ListUsersResponseBodyUserListUserRoleIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleIds) {
      res["RoleIds"] = boost::any(*roleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleIds") != m.end() && !m["RoleIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RoleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      roleIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ListUsersResponseBodyUserListUserRoleIdList() = default;
};
class ListUsersResponseBodyUserListUserRoleNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> roleNames{};

  ListUsersResponseBodyUserListUserRoleNameList() {}

  explicit ListUsersResponseBodyUserListUserRoleNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleNames) {
      res["RoleNames"] = boost::any(*roleNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleNames") != m.end() && !m["RoleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListUsersResponseBodyUserListUserRoleNameList() = default;
};
class ListUsersResponseBodyUserListUser : public Darabonba::Model {
public:
  shared_ptr<long> curExecuteCount{};
  shared_ptr<long> curResultCount{};
  shared_ptr<string> dingRobot{};
  shared_ptr<string> email{};
  shared_ptr<string> lastLoginTime{};
  shared_ptr<long> maxExecuteCount{};
  shared_ptr<long> maxResultCount{};
  shared_ptr<string> mobile{};
  shared_ptr<string> nickName{};
  shared_ptr<string> notificationMode{};
  shared_ptr<string> parentUid{};
  shared_ptr<ListUsersResponseBodyUserListUserRoleIdList> roleIdList{};
  shared_ptr<ListUsersResponseBodyUserListUserRoleNameList> roleNameList{};
  shared_ptr<string> signatureMethod{};
  shared_ptr<string> state{};
  shared_ptr<string> uid{};
  shared_ptr<string> userId{};
  shared_ptr<string> webhook{};

  ListUsersResponseBodyUserListUser() {}

  explicit ListUsersResponseBodyUserListUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (curExecuteCount) {
      res["CurExecuteCount"] = boost::any(*curExecuteCount);
    }
    if (curResultCount) {
      res["CurResultCount"] = boost::any(*curResultCount);
    }
    if (dingRobot) {
      res["DingRobot"] = boost::any(*dingRobot);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (lastLoginTime) {
      res["LastLoginTime"] = boost::any(*lastLoginTime);
    }
    if (maxExecuteCount) {
      res["MaxExecuteCount"] = boost::any(*maxExecuteCount);
    }
    if (maxResultCount) {
      res["MaxResultCount"] = boost::any(*maxResultCount);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (notificationMode) {
      res["NotificationMode"] = boost::any(*notificationMode);
    }
    if (parentUid) {
      res["ParentUid"] = boost::any(*parentUid);
    }
    if (roleIdList) {
      res["RoleIdList"] = roleIdList ? boost::any(roleIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roleNameList) {
      res["RoleNameList"] = roleNameList ? boost::any(roleNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signatureMethod) {
      res["SignatureMethod"] = boost::any(*signatureMethod);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurExecuteCount") != m.end() && !m["CurExecuteCount"].empty()) {
      curExecuteCount = make_shared<long>(boost::any_cast<long>(m["CurExecuteCount"]));
    }
    if (m.find("CurResultCount") != m.end() && !m["CurResultCount"].empty()) {
      curResultCount = make_shared<long>(boost::any_cast<long>(m["CurResultCount"]));
    }
    if (m.find("DingRobot") != m.end() && !m["DingRobot"].empty()) {
      dingRobot = make_shared<string>(boost::any_cast<string>(m["DingRobot"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LastLoginTime") != m.end() && !m["LastLoginTime"].empty()) {
      lastLoginTime = make_shared<string>(boost::any_cast<string>(m["LastLoginTime"]));
    }
    if (m.find("MaxExecuteCount") != m.end() && !m["MaxExecuteCount"].empty()) {
      maxExecuteCount = make_shared<long>(boost::any_cast<long>(m["MaxExecuteCount"]));
    }
    if (m.find("MaxResultCount") != m.end() && !m["MaxResultCount"].empty()) {
      maxResultCount = make_shared<long>(boost::any_cast<long>(m["MaxResultCount"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("NotificationMode") != m.end() && !m["NotificationMode"].empty()) {
      notificationMode = make_shared<string>(boost::any_cast<string>(m["NotificationMode"]));
    }
    if (m.find("ParentUid") != m.end() && !m["ParentUid"].empty()) {
      parentUid = make_shared<string>(boost::any_cast<string>(m["ParentUid"]));
    }
    if (m.find("RoleIdList") != m.end() && !m["RoleIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoleIdList"].type()) {
        ListUsersResponseBodyUserListUserRoleIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoleIdList"]));
        roleIdList = make_shared<ListUsersResponseBodyUserListUserRoleIdList>(model1);
      }
    }
    if (m.find("RoleNameList") != m.end() && !m["RoleNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoleNameList"].type()) {
        ListUsersResponseBodyUserListUserRoleNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoleNameList"]));
        roleNameList = make_shared<ListUsersResponseBodyUserListUserRoleNameList>(model1);
      }
    }
    if (m.find("SignatureMethod") != m.end() && !m["SignatureMethod"].empty()) {
      signatureMethod = make_shared<string>(boost::any_cast<string>(m["SignatureMethod"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~ListUsersResponseBodyUserListUser() = default;
};
class ListUsersResponseBodyUserList : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersResponseBodyUserListUser>> user{};

  ListUsersResponseBodyUserList() {}

  explicit ListUsersResponseBodyUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<ListUsersResponseBodyUserListUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyUserListUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<ListUsersResponseBodyUserListUser>>(expect1);
      }
    }
  }


  virtual ~ListUsersResponseBodyUserList() = default;
};
class ListUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<ListUsersResponseBodyUserList> userList{};

  ListUsersResponseBody() {}

  explicit ListUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userList) {
      res["UserList"] = userList ? boost::any(userList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserList"].type()) {
        ListUsersResponseBodyUserList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserList"]));
        userList = make_shared<ListUsersResponseBodyUserList>(model1);
      }
    }
  }


  virtual ~ListUsersResponseBody() = default;
};
class ListUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUsersResponseBody> body{};

  ListUsersResponse() {}

  explicit ListUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUsersResponse() = default;
};
class ListWorkFlowNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> searchName{};
  shared_ptr<long> tid{};

  ListWorkFlowNodesRequest() {}

  explicit ListWorkFlowNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListWorkFlowNodesRequest() = default;
};
class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser : public Darabonba::Model {
public:
  shared_ptr<string> nickName{};
  shared_ptr<string> realName{};
  shared_ptr<long> userId{};

  ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser() {}

  explicit ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (realName) {
      res["RealName"] = boost::any(*realName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("RealName") != m.end() && !m["RealName"].empty()) {
      realName = make_shared<string>(boost::any_cast<string>(m["RealName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser() = default;
};
class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers : public Darabonba::Model {
public:
  shared_ptr<vector<ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser>> auditUser{};

  ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers() {}

  explicit ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditUser) {
      vector<boost::any> temp1;
      for(auto item1:*auditUser){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuditUser"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditUser") != m.end() && !m["AuditUser"].empty()) {
      if (typeid(vector<boost::any>) == m["AuditUser"].type()) {
        vector<ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuditUser"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        auditUser = make_shared<vector<ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser>>(expect1);
      }
    }
  }


  virtual ~ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers() = default;
};
class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode : public Darabonba::Model {
public:
  shared_ptr<ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers> auditUsers{};
  shared_ptr<string> comment{};
  shared_ptr<long> createUserId{};
  shared_ptr<string> createUserNickName{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> nodeType{};

  ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode() {}

  explicit ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditUsers) {
      res["AuditUsers"] = auditUsers ? boost::any(auditUsers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (createUserNickName) {
      res["CreateUserNickName"] = boost::any(*createUserNickName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditUsers") != m.end() && !m["AuditUsers"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuditUsers"].type()) {
        ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuditUsers"]));
        auditUsers = make_shared<ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers>(model1);
      }
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["CreateUserId"]));
    }
    if (m.find("CreateUserNickName") != m.end() && !m["CreateUserNickName"].empty()) {
      createUserNickName = make_shared<string>(boost::any_cast<string>(m["CreateUserNickName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
  }


  virtual ~ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode() = default;
};
class ListWorkFlowNodesResponseBodyWorkflowNodes : public Darabonba::Model {
public:
  shared_ptr<vector<ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode>> workflowNode{};

  ListWorkFlowNodesResponseBodyWorkflowNodes() {}

  explicit ListWorkFlowNodesResponseBodyWorkflowNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workflowNode) {
      vector<boost::any> temp1;
      for(auto item1:*workflowNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkflowNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkflowNode") != m.end() && !m["WorkflowNode"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkflowNode"].type()) {
        vector<ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkflowNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workflowNode = make_shared<vector<ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode>>(expect1);
      }
    }
  }


  virtual ~ListWorkFlowNodesResponseBodyWorkflowNodes() = default;
};
class ListWorkFlowNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListWorkFlowNodesResponseBodyWorkflowNodes> workflowNodes{};

  ListWorkFlowNodesResponseBody() {}

  explicit ListWorkFlowNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (workflowNodes) {
      res["WorkflowNodes"] = workflowNodes ? boost::any(workflowNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("WorkflowNodes") != m.end() && !m["WorkflowNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkflowNodes"].type()) {
        ListWorkFlowNodesResponseBodyWorkflowNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkflowNodes"]));
        workflowNodes = make_shared<ListWorkFlowNodesResponseBodyWorkflowNodes>(model1);
      }
    }
  }


  virtual ~ListWorkFlowNodesResponseBody() = default;
};
class ListWorkFlowNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkFlowNodesResponseBody> body{};

  ListWorkFlowNodesResponse() {}

  explicit ListWorkFlowNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkFlowNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkFlowNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkFlowNodesResponse() = default;
};
class ListWorkFlowTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> searchName{};
  shared_ptr<long> tid{};

  ListWorkFlowTemplatesRequest() {}

  explicit ListWorkFlowTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ListWorkFlowTemplatesRequest() = default;
};
class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> createUserId{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> position{};
  shared_ptr<long> templateId{};

  ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode() {}

  explicit ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["CreateUserId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode() = default;
};
class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes : public Darabonba::Model {
public:
  shared_ptr<vector<ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode>> workflowNode{};

  ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes() {}

  explicit ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workflowNode) {
      vector<boost::any> temp1;
      for(auto item1:*workflowNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkflowNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkflowNode") != m.end() && !m["WorkflowNode"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkflowNode"].type()) {
        vector<ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkflowNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workflowNode = make_shared<vector<ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode>>(expect1);
      }
    }
  }


  virtual ~ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes() = default;
};
class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> createUserId{};
  shared_ptr<string> enabled{};
  shared_ptr<long> isSystem{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes> workflowNodes{};

  ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate() {}

  explicit ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (isSystem) {
      res["IsSystem"] = boost::any(*isSystem);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (workflowNodes) {
      res["WorkflowNodes"] = workflowNodes ? boost::any(workflowNodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["CreateUserId"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<string>(boost::any_cast<string>(m["Enabled"]));
    }
    if (m.find("IsSystem") != m.end() && !m["IsSystem"].empty()) {
      isSystem = make_shared<long>(boost::any_cast<long>(m["IsSystem"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("WorkflowNodes") != m.end() && !m["WorkflowNodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkflowNodes"].type()) {
        ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkflowNodes"]));
        workflowNodes = make_shared<ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes>(model1);
      }
    }
  }


  virtual ~ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate() = default;
};
class ListWorkFlowTemplatesResponseBodyWorkFlowTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate>> workFlowTemplate{};

  ListWorkFlowTemplatesResponseBodyWorkFlowTemplates() {}

  explicit ListWorkFlowTemplatesResponseBodyWorkFlowTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workFlowTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*workFlowTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkFlowTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkFlowTemplate") != m.end() && !m["WorkFlowTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkFlowTemplate"].type()) {
        vector<ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkFlowTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workFlowTemplate = make_shared<vector<ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate>>(expect1);
      }
    }
  }


  virtual ~ListWorkFlowTemplatesResponseBodyWorkFlowTemplates() = default;
};
class ListWorkFlowTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListWorkFlowTemplatesResponseBodyWorkFlowTemplates> workFlowTemplates{};

  ListWorkFlowTemplatesResponseBody() {}

  explicit ListWorkFlowTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (workFlowTemplates) {
      res["WorkFlowTemplates"] = workFlowTemplates ? boost::any(workFlowTemplates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("WorkFlowTemplates") != m.end() && !m["WorkFlowTemplates"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkFlowTemplates"].type()) {
        ListWorkFlowTemplatesResponseBodyWorkFlowTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkFlowTemplates"]));
        workFlowTemplates = make_shared<ListWorkFlowTemplatesResponseBodyWorkFlowTemplates>(model1);
      }
    }
  }


  virtual ~ListWorkFlowTemplatesResponseBody() = default;
};
class ListWorkFlowTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkFlowTemplatesResponseBody> body{};

  ListWorkFlowTemplatesResponse() {}

  explicit ListWorkFlowTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkFlowTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkFlowTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkFlowTemplatesResponse() = default;
};
class MakeTaskFlowInstanceSuccessRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> dagInstanceId{};
  shared_ptr<long> tid{};

  MakeTaskFlowInstanceSuccessRequest() {}

  explicit MakeTaskFlowInstanceSuccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagInstanceId) {
      res["DagInstanceId"] = boost::any(*dagInstanceId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagInstanceId") != m.end() && !m["DagInstanceId"].empty()) {
      dagInstanceId = make_shared<long>(boost::any_cast<long>(m["DagInstanceId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~MakeTaskFlowInstanceSuccessRequest() = default;
};
class MakeTaskFlowInstanceSuccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  MakeTaskFlowInstanceSuccessResponseBody() {}

  explicit MakeTaskFlowInstanceSuccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MakeTaskFlowInstanceSuccessResponseBody() = default;
};
class MakeTaskFlowInstanceSuccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MakeTaskFlowInstanceSuccessResponseBody> body{};

  MakeTaskFlowInstanceSuccessResponse() {}

  explicit MakeTaskFlowInstanceSuccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MakeTaskFlowInstanceSuccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MakeTaskFlowInstanceSuccessResponseBody>(model1);
      }
    }
  }


  virtual ~MakeTaskFlowInstanceSuccessResponse() = default;
};
class ModifyDataCorrectExecSQLRequest : public Darabonba::Model {
public:
  shared_ptr<string> execSQL{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  ModifyDataCorrectExecSQLRequest() {}

  explicit ModifyDataCorrectExecSQLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (execSQL) {
      res["ExecSQL"] = boost::any(*execSQL);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecSQL") != m.end() && !m["ExecSQL"].empty()) {
      execSQL = make_shared<string>(boost::any_cast<string>(m["ExecSQL"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ModifyDataCorrectExecSQLRequest() = default;
};
class ModifyDataCorrectExecSQLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyDataCorrectExecSQLResponseBody() {}

  explicit ModifyDataCorrectExecSQLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyDataCorrectExecSQLResponseBody() = default;
};
class ModifyDataCorrectExecSQLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDataCorrectExecSQLResponseBody> body{};

  ModifyDataCorrectExecSQLResponse() {}

  explicit ModifyDataCorrectExecSQLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDataCorrectExecSQLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDataCorrectExecSQLResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDataCorrectExecSQLResponse() = default;
};
class ModifyDesensitizationStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<long> dbId{};
  shared_ptr<bool> isDefault{};
  shared_ptr<bool> isLogic{};
  shared_ptr<bool> isReset{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> tid{};

  ModifyDesensitizationStrategyRequest() {}

  explicit ModifyDesensitizationStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (isLogic) {
      res["IsLogic"] = boost::any(*isLogic);
    }
    if (isReset) {
      res["IsReset"] = boost::any(*isReset);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("IsLogic") != m.end() && !m["IsLogic"].empty()) {
      isLogic = make_shared<bool>(boost::any_cast<bool>(m["IsLogic"]));
    }
    if (m.find("IsReset") != m.end() && !m["IsReset"].empty()) {
      isReset = make_shared<bool>(boost::any_cast<bool>(m["IsReset"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ModifyDesensitizationStrategyRequest() = default;
};
class ModifyDesensitizationStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  ModifyDesensitizationStrategyResponseBody() {}

  explicit ModifyDesensitizationStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyDesensitizationStrategyResponseBody() = default;
};
class ModifyDesensitizationStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDesensitizationStrategyResponseBody> body{};

  ModifyDesensitizationStrategyResponse() {}

  explicit ModifyDesensitizationStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDesensitizationStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDesensitizationStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDesensitizationStrategyResponse() = default;
};
class ModifyInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataLinkName{};
  shared_ptr<string> databasePassword{};
  shared_ptr<string> databaseUser{};
  shared_ptr<long> dbaId{};
  shared_ptr<long> ddlOnline{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> ecsRegion{};
  shared_ptr<string> enableSellCommon{};
  shared_ptr<string> enableSellSitd{};
  shared_ptr<string> enableSellStable{};
  shared_ptr<string> enableSellTrust{};
  shared_ptr<string> envType{};
  shared_ptr<long> exportTimeout{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceAlias{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceSource{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> networkType{};
  shared_ptr<long> port{};
  shared_ptr<long> queryTimeout{};
  shared_ptr<string> safeRule{};
  shared_ptr<string> sid{};
  shared_ptr<bool> skipTest{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<long> tid{};
  shared_ptr<long> useDsql{};
  shared_ptr<long> useSsl{};
  shared_ptr<string> vpcId{};

  ModifyInstanceRequest() {}

  explicit ModifyInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataLinkName) {
      res["DataLinkName"] = boost::any(*dataLinkName);
    }
    if (databasePassword) {
      res["DatabasePassword"] = boost::any(*databasePassword);
    }
    if (databaseUser) {
      res["DatabaseUser"] = boost::any(*databaseUser);
    }
    if (dbaId) {
      res["DbaId"] = boost::any(*dbaId);
    }
    if (ddlOnline) {
      res["DdlOnline"] = boost::any(*ddlOnline);
    }
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (ecsRegion) {
      res["EcsRegion"] = boost::any(*ecsRegion);
    }
    if (enableSellCommon) {
      res["EnableSellCommon"] = boost::any(*enableSellCommon);
    }
    if (enableSellSitd) {
      res["EnableSellSitd"] = boost::any(*enableSellSitd);
    }
    if (enableSellStable) {
      res["EnableSellStable"] = boost::any(*enableSellStable);
    }
    if (enableSellTrust) {
      res["EnableSellTrust"] = boost::any(*enableSellTrust);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (exportTimeout) {
      res["ExportTimeout"] = boost::any(*exportTimeout);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (instanceAlias) {
      res["InstanceAlias"] = boost::any(*instanceAlias);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceSource) {
      res["InstanceSource"] = boost::any(*instanceSource);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (queryTimeout) {
      res["QueryTimeout"] = boost::any(*queryTimeout);
    }
    if (safeRule) {
      res["SafeRule"] = boost::any(*safeRule);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (skipTest) {
      res["SkipTest"] = boost::any(*skipTest);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (useDsql) {
      res["UseDsql"] = boost::any(*useDsql);
    }
    if (useSsl) {
      res["UseSsl"] = boost::any(*useSsl);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataLinkName") != m.end() && !m["DataLinkName"].empty()) {
      dataLinkName = make_shared<string>(boost::any_cast<string>(m["DataLinkName"]));
    }
    if (m.find("DatabasePassword") != m.end() && !m["DatabasePassword"].empty()) {
      databasePassword = make_shared<string>(boost::any_cast<string>(m["DatabasePassword"]));
    }
    if (m.find("DatabaseUser") != m.end() && !m["DatabaseUser"].empty()) {
      databaseUser = make_shared<string>(boost::any_cast<string>(m["DatabaseUser"]));
    }
    if (m.find("DbaId") != m.end() && !m["DbaId"].empty()) {
      dbaId = make_shared<long>(boost::any_cast<long>(m["DbaId"]));
    }
    if (m.find("DdlOnline") != m.end() && !m["DdlOnline"].empty()) {
      ddlOnline = make_shared<long>(boost::any_cast<long>(m["DdlOnline"]));
    }
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("EcsRegion") != m.end() && !m["EcsRegion"].empty()) {
      ecsRegion = make_shared<string>(boost::any_cast<string>(m["EcsRegion"]));
    }
    if (m.find("EnableSellCommon") != m.end() && !m["EnableSellCommon"].empty()) {
      enableSellCommon = make_shared<string>(boost::any_cast<string>(m["EnableSellCommon"]));
    }
    if (m.find("EnableSellSitd") != m.end() && !m["EnableSellSitd"].empty()) {
      enableSellSitd = make_shared<string>(boost::any_cast<string>(m["EnableSellSitd"]));
    }
    if (m.find("EnableSellStable") != m.end() && !m["EnableSellStable"].empty()) {
      enableSellStable = make_shared<string>(boost::any_cast<string>(m["EnableSellStable"]));
    }
    if (m.find("EnableSellTrust") != m.end() && !m["EnableSellTrust"].empty()) {
      enableSellTrust = make_shared<string>(boost::any_cast<string>(m["EnableSellTrust"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ExportTimeout") != m.end() && !m["ExportTimeout"].empty()) {
      exportTimeout = make_shared<long>(boost::any_cast<long>(m["ExportTimeout"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("InstanceAlias") != m.end() && !m["InstanceAlias"].empty()) {
      instanceAlias = make_shared<string>(boost::any_cast<string>(m["InstanceAlias"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceSource") != m.end() && !m["InstanceSource"].empty()) {
      instanceSource = make_shared<string>(boost::any_cast<string>(m["InstanceSource"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("QueryTimeout") != m.end() && !m["QueryTimeout"].empty()) {
      queryTimeout = make_shared<long>(boost::any_cast<long>(m["QueryTimeout"]));
    }
    if (m.find("SafeRule") != m.end() && !m["SafeRule"].empty()) {
      safeRule = make_shared<string>(boost::any_cast<string>(m["SafeRule"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("SkipTest") != m.end() && !m["SkipTest"].empty()) {
      skipTest = make_shared<bool>(boost::any_cast<bool>(m["SkipTest"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UseDsql") != m.end() && !m["UseDsql"].empty()) {
      useDsql = make_shared<long>(boost::any_cast<long>(m["UseDsql"]));
    }
    if (m.find("UseSsl") != m.end() && !m["UseSsl"].empty()) {
      useSsl = make_shared<long>(boost::any_cast<long>(m["UseSsl"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ModifyInstanceRequest() = default;
};
class ModifyInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyInstanceResponseBody() {}

  explicit ModifyInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyInstanceResponseBody() = default;
};
class ModifyInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceResponseBody> body{};

  ModifyInstanceResponse() {}

  explicit ModifyInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceResponse() = default;
};
class MoveTaskFlowToScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> scenarioId{};
  shared_ptr<long> tid{};

  MoveTaskFlowToScenarioRequest() {}

  explicit MoveTaskFlowToScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<long>(boost::any_cast<long>(m["ScenarioId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~MoveTaskFlowToScenarioRequest() = default;
};
class MoveTaskFlowToScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  MoveTaskFlowToScenarioResponseBody() {}

  explicit MoveTaskFlowToScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~MoveTaskFlowToScenarioResponseBody() = default;
};
class MoveTaskFlowToScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveTaskFlowToScenarioResponseBody> body{};

  MoveTaskFlowToScenarioResponse() {}

  explicit MoveTaskFlowToScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveTaskFlowToScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveTaskFlowToScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~MoveTaskFlowToScenarioResponse() = default;
};
class OfflineTaskFlowRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  OfflineTaskFlowRequest() {}

  explicit OfflineTaskFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~OfflineTaskFlowRequest() = default;
};
class OfflineTaskFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  OfflineTaskFlowResponseBody() {}

  explicit OfflineTaskFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~OfflineTaskFlowResponseBody() = default;
};
class OfflineTaskFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OfflineTaskFlowResponseBody> body{};

  OfflineTaskFlowResponse() {}

  explicit OfflineTaskFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OfflineTaskFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OfflineTaskFlowResponseBody>(model1);
      }
    }
  }


  virtual ~OfflineTaskFlowResponse() = default;
};
class PauseDataCorrectSQLJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> jobId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};
  shared_ptr<string> type{};

  PauseDataCorrectSQLJobRequest() {}

  explicit PauseDataCorrectSQLJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<long>(boost::any_cast<long>(m["JobId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~PauseDataCorrectSQLJobRequest() = default;
};
class PauseDataCorrectSQLJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PauseDataCorrectSQLJobResponseBody() {}

  explicit PauseDataCorrectSQLJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PauseDataCorrectSQLJobResponseBody() = default;
};
class PauseDataCorrectSQLJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PauseDataCorrectSQLJobResponseBody> body{};

  PauseDataCorrectSQLJobResponse() {}

  explicit PauseDataCorrectSQLJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PauseDataCorrectSQLJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PauseDataCorrectSQLJobResponseBody>(model1);
      }
    }
  }


  virtual ~PauseDataCorrectSQLJobResponse() = default;
};
class PreviewWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  PreviewWorkflowRequest() {}

  explicit PreviewWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~PreviewWorkflowRequest() = default;
};
class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser : public Darabonba::Model {
public:
  shared_ptr<string> nickName{};
  shared_ptr<string> realName{};
  shared_ptr<long> userId{};

  PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser() {}

  explicit PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (realName) {
      res["RealName"] = boost::any(*realName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("RealName") != m.end() && !m["RealName"].empty()) {
      realName = make_shared<string>(boost::any_cast<string>(m["RealName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser() = default;
};
class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList : public Darabonba::Model {
public:
  shared_ptr<vector<PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser>> auditUser{};

  PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList() {}

  explicit PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditUser) {
      vector<boost::any> temp1;
      for(auto item1:*auditUser){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuditUser"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditUser") != m.end() && !m["AuditUser"].empty()) {
      if (typeid(vector<boost::any>) == m["AuditUser"].type()) {
        vector<PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuditUser"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        auditUser = make_shared<vector<PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser>>(expect1);
      }
    }
  }


  virtual ~PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList() = default;
};
class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode : public Darabonba::Model {
public:
  shared_ptr<PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList> auditUserList{};
  shared_ptr<string> comment{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> nodeType{};

  PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode() {}

  explicit PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditUserList) {
      res["AuditUserList"] = auditUserList ? boost::any(auditUserList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditUserList") != m.end() && !m["AuditUserList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuditUserList"].type()) {
        PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuditUserList"]));
        auditUserList = make_shared<PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList>(model1);
      }
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
  }


  virtual ~PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode() = default;
};
class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList : public Darabonba::Model {
public:
  shared_ptr<vector<PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode>> workflowNode{};

  PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList() {}

  explicit PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workflowNode) {
      vector<boost::any> temp1;
      for(auto item1:*workflowNode){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkflowNode"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkflowNode") != m.end() && !m["WorkflowNode"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkflowNode"].type()) {
        vector<PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkflowNode"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workflowNode = make_shared<vector<PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode>>(expect1);
      }
    }
  }


  virtual ~PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList() = default;
};
class PreviewWorkflowResponseBodyWorkflowDetail : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> wfCateName{};
  shared_ptr<PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList> workflowNodeList{};

  PreviewWorkflowResponseBodyWorkflowDetail() {}

  explicit PreviewWorkflowResponseBodyWorkflowDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (wfCateName) {
      res["WfCateName"] = boost::any(*wfCateName);
    }
    if (workflowNodeList) {
      res["WorkflowNodeList"] = workflowNodeList ? boost::any(workflowNodeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("WfCateName") != m.end() && !m["WfCateName"].empty()) {
      wfCateName = make_shared<string>(boost::any_cast<string>(m["WfCateName"]));
    }
    if (m.find("WorkflowNodeList") != m.end() && !m["WorkflowNodeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkflowNodeList"].type()) {
        PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkflowNodeList"]));
        workflowNodeList = make_shared<PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList>(model1);
      }
    }
  }


  virtual ~PreviewWorkflowResponseBodyWorkflowDetail() = default;
};
class PreviewWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<PreviewWorkflowResponseBodyWorkflowDetail> workflowDetail{};

  PreviewWorkflowResponseBody() {}

  explicit PreviewWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (workflowDetail) {
      res["WorkflowDetail"] = workflowDetail ? boost::any(workflowDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("WorkflowDetail") != m.end() && !m["WorkflowDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkflowDetail"].type()) {
        PreviewWorkflowResponseBodyWorkflowDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkflowDetail"]));
        workflowDetail = make_shared<PreviewWorkflowResponseBodyWorkflowDetail>(model1);
      }
    }
  }


  virtual ~PreviewWorkflowResponseBody() = default;
};
class PreviewWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PreviewWorkflowResponseBody> body{};

  PreviewWorkflowResponse() {}

  explicit PreviewWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PreviewWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PreviewWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~PreviewWorkflowResponse() = default;
};
class PublishAndDeployTaskFlowRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};
  shared_ptr<string> versionComments{};

  PublishAndDeployTaskFlowRequest() {}

  explicit PublishAndDeployTaskFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (versionComments) {
      res["VersionComments"] = boost::any(*versionComments);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("VersionComments") != m.end() && !m["VersionComments"].empty()) {
      versionComments = make_shared<string>(boost::any_cast<string>(m["VersionComments"]));
    }
  }


  virtual ~PublishAndDeployTaskFlowRequest() = default;
};
class PublishAndDeployTaskFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> deployId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PublishAndDeployTaskFlowResponseBody() {}

  explicit PublishAndDeployTaskFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployId) {
      res["DeployId"] = boost::any(*deployId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployId") != m.end() && !m["DeployId"].empty()) {
      deployId = make_shared<long>(boost::any_cast<long>(m["DeployId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PublishAndDeployTaskFlowResponseBody() = default;
};
class PublishAndDeployTaskFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishAndDeployTaskFlowResponseBody> body{};

  PublishAndDeployTaskFlowResponse() {}

  explicit PublishAndDeployTaskFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishAndDeployTaskFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishAndDeployTaskFlowResponseBody>(model1);
      }
    }
  }


  virtual ~PublishAndDeployTaskFlowResponse() = default;
};
class QueryDataTrackResultDownloadStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> downloadKeyId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  QueryDataTrackResultDownloadStatusRequest() {}

  explicit QueryDataTrackResultDownloadStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadKeyId) {
      res["DownloadKeyId"] = boost::any(*downloadKeyId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadKeyId") != m.end() && !m["DownloadKeyId"].empty()) {
      downloadKeyId = make_shared<string>(boost::any_cast<string>(m["DownloadKeyId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~QueryDataTrackResultDownloadStatusRequest() = default;
};
class QueryDataTrackResultDownloadStatusResponseBodyStatusResult : public Darabonba::Model {
public:
  shared_ptr<string> downloadStatus{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> statusDesc{};
  shared_ptr<long> totalCount{};

  QueryDataTrackResultDownloadStatusResponseBodyStatusResult() {}

  explicit QueryDataTrackResultDownloadStatusResponseBodyStatusResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadStatus) {
      res["DownloadStatus"] = boost::any(*downloadStatus);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadStatus") != m.end() && !m["DownloadStatus"].empty()) {
      downloadStatus = make_shared<string>(boost::any_cast<string>(m["DownloadStatus"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryDataTrackResultDownloadStatusResponseBodyStatusResult() = default;
};
class QueryDataTrackResultDownloadStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryDataTrackResultDownloadStatusResponseBodyStatusResult> statusResult{};
  shared_ptr<bool> success{};

  QueryDataTrackResultDownloadStatusResponseBody() {}

  explicit QueryDataTrackResultDownloadStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusResult) {
      res["StatusResult"] = statusResult ? boost::any(statusResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusResult") != m.end() && !m["StatusResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatusResult"].type()) {
        QueryDataTrackResultDownloadStatusResponseBodyStatusResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatusResult"]));
        statusResult = make_shared<QueryDataTrackResultDownloadStatusResponseBodyStatusResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryDataTrackResultDownloadStatusResponseBody() = default;
};
class QueryDataTrackResultDownloadStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDataTrackResultDownloadStatusResponseBody> body{};

  QueryDataTrackResultDownloadStatusResponse() {}

  explicit QueryDataTrackResultDownloadStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDataTrackResultDownloadStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDataTrackResultDownloadStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDataTrackResultDownloadStatusResponse() = default;
};
class ReDeployLhDagVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> dagVersion{};
  shared_ptr<long> tid{};

  ReDeployLhDagVersionRequest() {}

  explicit ReDeployLhDagVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagVersion) {
      res["DagVersion"] = boost::any(*dagVersion);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagVersion") != m.end() && !m["DagVersion"].empty()) {
      dagVersion = make_shared<long>(boost::any_cast<long>(m["DagVersion"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ReDeployLhDagVersionRequest() = default;
};
class ReDeployLhDagVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> deployId{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ReDeployLhDagVersionResponseBody() {}

  explicit ReDeployLhDagVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployId) {
      res["DeployId"] = boost::any(*deployId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployId") != m.end() && !m["DeployId"].empty()) {
      deployId = make_shared<long>(boost::any_cast<long>(m["DeployId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReDeployLhDagVersionResponseBody() = default;
};
class ReDeployLhDagVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReDeployLhDagVersionResponseBody> body{};

  ReDeployLhDagVersionResponse() {}

  explicit ReDeployLhDagVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReDeployLhDagVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReDeployLhDagVersionResponseBody>(model1);
      }
    }
  }


  virtual ~ReDeployLhDagVersionResponse() = default;
};
class ReRunTaskFlowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> dagInstanceId{};
  shared_ptr<string> dagVersion{};
  shared_ptr<long> tid{};

  ReRunTaskFlowInstanceRequest() {}

  explicit ReRunTaskFlowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagInstanceId) {
      res["DagInstanceId"] = boost::any(*dagInstanceId);
    }
    if (dagVersion) {
      res["DagVersion"] = boost::any(*dagVersion);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagInstanceId") != m.end() && !m["DagInstanceId"].empty()) {
      dagInstanceId = make_shared<long>(boost::any_cast<long>(m["DagInstanceId"]));
    }
    if (m.find("DagVersion") != m.end() && !m["DagVersion"].empty()) {
      dagVersion = make_shared<string>(boost::any_cast<string>(m["DagVersion"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ReRunTaskFlowInstanceRequest() = default;
};
class ReRunTaskFlowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ReRunTaskFlowInstanceResponseBody() {}

  explicit ReRunTaskFlowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReRunTaskFlowInstanceResponseBody() = default;
};
class ReRunTaskFlowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReRunTaskFlowInstanceResponseBody> body{};

  ReRunTaskFlowInstanceResponse() {}

  explicit ReRunTaskFlowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReRunTaskFlowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReRunTaskFlowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReRunTaskFlowInstanceResponse() = default;
};
class RefundPayAsYouGoOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderId{};
  shared_ptr<long> tid{};

  RefundPayAsYouGoOrderRequest() {}

  explicit RefundPayAsYouGoOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~RefundPayAsYouGoOrderRequest() = default;
};
class RefundPayAsYouGoOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RefundPayAsYouGoOrderResponseBody() {}

  explicit RefundPayAsYouGoOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RefundPayAsYouGoOrderResponseBody() = default;
};
class RefundPayAsYouGoOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefundPayAsYouGoOrderResponseBody> body{};

  RefundPayAsYouGoOrderResponse() {}

  explicit RefundPayAsYouGoOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefundPayAsYouGoOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefundPayAsYouGoOrderResponseBody>(model1);
      }
    }
  }


  virtual ~RefundPayAsYouGoOrderResponse() = default;
};
class RegisterInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataLinkName{};
  shared_ptr<string> databasePassword{};
  shared_ptr<string> databaseUser{};
  shared_ptr<long> dbaUid{};
  shared_ptr<string> dbaUidByString{};
  shared_ptr<long> ddlOnline{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> ecsRegion{};
  shared_ptr<string> enableSellSitd{};
  shared_ptr<string> envType{};
  shared_ptr<long> exportTimeout{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceAlias{};
  shared_ptr<string> instanceSource{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> networkType{};
  shared_ptr<long> port{};
  shared_ptr<long> queryTimeout{};
  shared_ptr<string> safeRule{};
  shared_ptr<string> sid{};
  shared_ptr<bool> skipTest{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<long> tid{};
  shared_ptr<long> useDsql{};
  shared_ptr<string> vpcId{};

  RegisterInstanceRequest() {}

  explicit RegisterInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataLinkName) {
      res["DataLinkName"] = boost::any(*dataLinkName);
    }
    if (databasePassword) {
      res["DatabasePassword"] = boost::any(*databasePassword);
    }
    if (databaseUser) {
      res["DatabaseUser"] = boost::any(*databaseUser);
    }
    if (dbaUid) {
      res["DbaUid"] = boost::any(*dbaUid);
    }
    if (dbaUidByString) {
      res["DbaUidByString"] = boost::any(*dbaUidByString);
    }
    if (ddlOnline) {
      res["DdlOnline"] = boost::any(*ddlOnline);
    }
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (ecsRegion) {
      res["EcsRegion"] = boost::any(*ecsRegion);
    }
    if (enableSellSitd) {
      res["EnableSellSitd"] = boost::any(*enableSellSitd);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (exportTimeout) {
      res["ExportTimeout"] = boost::any(*exportTimeout);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (instanceAlias) {
      res["InstanceAlias"] = boost::any(*instanceAlias);
    }
    if (instanceSource) {
      res["InstanceSource"] = boost::any(*instanceSource);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (queryTimeout) {
      res["QueryTimeout"] = boost::any(*queryTimeout);
    }
    if (safeRule) {
      res["SafeRule"] = boost::any(*safeRule);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (skipTest) {
      res["SkipTest"] = boost::any(*skipTest);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (useDsql) {
      res["UseDsql"] = boost::any(*useDsql);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataLinkName") != m.end() && !m["DataLinkName"].empty()) {
      dataLinkName = make_shared<string>(boost::any_cast<string>(m["DataLinkName"]));
    }
    if (m.find("DatabasePassword") != m.end() && !m["DatabasePassword"].empty()) {
      databasePassword = make_shared<string>(boost::any_cast<string>(m["DatabasePassword"]));
    }
    if (m.find("DatabaseUser") != m.end() && !m["DatabaseUser"].empty()) {
      databaseUser = make_shared<string>(boost::any_cast<string>(m["DatabaseUser"]));
    }
    if (m.find("DbaUid") != m.end() && !m["DbaUid"].empty()) {
      dbaUid = make_shared<long>(boost::any_cast<long>(m["DbaUid"]));
    }
    if (m.find("DbaUidByString") != m.end() && !m["DbaUidByString"].empty()) {
      dbaUidByString = make_shared<string>(boost::any_cast<string>(m["DbaUidByString"]));
    }
    if (m.find("DdlOnline") != m.end() && !m["DdlOnline"].empty()) {
      ddlOnline = make_shared<long>(boost::any_cast<long>(m["DdlOnline"]));
    }
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("EcsRegion") != m.end() && !m["EcsRegion"].empty()) {
      ecsRegion = make_shared<string>(boost::any_cast<string>(m["EcsRegion"]));
    }
    if (m.find("EnableSellSitd") != m.end() && !m["EnableSellSitd"].empty()) {
      enableSellSitd = make_shared<string>(boost::any_cast<string>(m["EnableSellSitd"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ExportTimeout") != m.end() && !m["ExportTimeout"].empty()) {
      exportTimeout = make_shared<long>(boost::any_cast<long>(m["ExportTimeout"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("InstanceAlias") != m.end() && !m["InstanceAlias"].empty()) {
      instanceAlias = make_shared<string>(boost::any_cast<string>(m["InstanceAlias"]));
    }
    if (m.find("InstanceSource") != m.end() && !m["InstanceSource"].empty()) {
      instanceSource = make_shared<string>(boost::any_cast<string>(m["InstanceSource"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("QueryTimeout") != m.end() && !m["QueryTimeout"].empty()) {
      queryTimeout = make_shared<long>(boost::any_cast<long>(m["QueryTimeout"]));
    }
    if (m.find("SafeRule") != m.end() && !m["SafeRule"].empty()) {
      safeRule = make_shared<string>(boost::any_cast<string>(m["SafeRule"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("SkipTest") != m.end() && !m["SkipTest"].empty()) {
      skipTest = make_shared<bool>(boost::any_cast<bool>(m["SkipTest"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UseDsql") != m.end() && !m["UseDsql"].empty()) {
      useDsql = make_shared<long>(boost::any_cast<long>(m["UseDsql"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~RegisterInstanceRequest() = default;
};
class RegisterInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RegisterInstanceResponseBody() {}

  explicit RegisterInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RegisterInstanceResponseBody() = default;
};
class RegisterInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterInstanceResponseBody> body{};

  RegisterInstanceResponse() {}

  explicit RegisterInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterInstanceResponse() = default;
};
class RegisterUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> mobile{};
  shared_ptr<string> roleNames{};
  shared_ptr<long> tid{};
  shared_ptr<string> uid{};
  shared_ptr<string> userNick{};

  RegisterUserRequest() {}

  explicit RegisterUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (roleNames) {
      res["RoleNames"] = boost::any(*roleNames);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userNick) {
      res["UserNick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("RoleNames") != m.end() && !m["RoleNames"].empty()) {
      roleNames = make_shared<string>(boost::any_cast<string>(m["RoleNames"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("UserNick") != m.end() && !m["UserNick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["UserNick"]));
    }
  }


  virtual ~RegisterUserRequest() = default;
};
class RegisterUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RegisterUserResponseBody() {}

  explicit RegisterUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RegisterUserResponseBody() = default;
};
class RegisterUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterUserResponseBody> body{};

  RegisterUserResponse() {}

  explicit RegisterUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterUserResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterUserResponse() = default;
};
class RestartDataCorrectSQLJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> jobId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};
  shared_ptr<string> type{};

  RestartDataCorrectSQLJobRequest() {}

  explicit RestartDataCorrectSQLJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<long>(boost::any_cast<long>(m["JobId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RestartDataCorrectSQLJobRequest() = default;
};
class RestartDataCorrectSQLJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RestartDataCorrectSQLJobResponseBody() {}

  explicit RestartDataCorrectSQLJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RestartDataCorrectSQLJobResponseBody() = default;
};
class RestartDataCorrectSQLJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartDataCorrectSQLJobResponseBody> body{};

  RestartDataCorrectSQLJobResponse() {}

  explicit RestartDataCorrectSQLJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartDataCorrectSQLJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartDataCorrectSQLJobResponseBody>(model1);
      }
    }
  }


  virtual ~RestartDataCorrectSQLJobResponse() = default;
};
class ResumeTaskFlowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> dagInstanceId{};
  shared_ptr<string> dagVersion{};
  shared_ptr<long> tid{};

  ResumeTaskFlowInstanceRequest() {}

  explicit ResumeTaskFlowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagInstanceId) {
      res["DagInstanceId"] = boost::any(*dagInstanceId);
    }
    if (dagVersion) {
      res["DagVersion"] = boost::any(*dagVersion);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagInstanceId") != m.end() && !m["DagInstanceId"].empty()) {
      dagInstanceId = make_shared<long>(boost::any_cast<long>(m["DagInstanceId"]));
    }
    if (m.find("DagVersion") != m.end() && !m["DagVersion"].empty()) {
      dagVersion = make_shared<string>(boost::any_cast<string>(m["DagVersion"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~ResumeTaskFlowInstanceRequest() = default;
};
class ResumeTaskFlowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ResumeTaskFlowInstanceResponseBody() {}

  explicit ResumeTaskFlowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResumeTaskFlowInstanceResponseBody() = default;
};
class ResumeTaskFlowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeTaskFlowInstanceResponseBody> body{};

  ResumeTaskFlowInstanceResponse() {}

  explicit ResumeTaskFlowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeTaskFlowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeTaskFlowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeTaskFlowInstanceResponse() = default;
};
class RetryDataCorrectPreCheckRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  RetryDataCorrectPreCheckRequest() {}

  explicit RetryDataCorrectPreCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~RetryDataCorrectPreCheckRequest() = default;
};
class RetryDataCorrectPreCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RetryDataCorrectPreCheckResponseBody() {}

  explicit RetryDataCorrectPreCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RetryDataCorrectPreCheckResponseBody() = default;
};
class RetryDataCorrectPreCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetryDataCorrectPreCheckResponseBody> body{};

  RetryDataCorrectPreCheckResponse() {}

  explicit RetryDataCorrectPreCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetryDataCorrectPreCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetryDataCorrectPreCheckResponseBody>(model1);
      }
    }
  }


  virtual ~RetryDataCorrectPreCheckResponse() = default;
};
class RevokeTemplateAuthorityRequest : public Darabonba::Model {
public:
  shared_ptr<long> templateId{};
  shared_ptr<long> tid{};
  shared_ptr<string> userIds{};

  RevokeTemplateAuthorityRequest() {}

  explicit RevokeTemplateAuthorityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIds = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~RevokeTemplateAuthorityRequest() = default;
};
class RevokeTemplateAuthorityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  RevokeTemplateAuthorityResponseBody() {}

  explicit RevokeTemplateAuthorityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RevokeTemplateAuthorityResponseBody() = default;
};
class RevokeTemplateAuthorityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeTemplateAuthorityResponseBody> body{};

  RevokeTemplateAuthorityResponse() {}

  explicit RevokeTemplateAuthorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeTemplateAuthorityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeTemplateAuthorityResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeTemplateAuthorityResponse() = default;
};
class RevokeUserPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbId{};
  shared_ptr<string> dsType{};
  shared_ptr<long> instanceId{};
  shared_ptr<bool> logic{};
  shared_ptr<string> permTypes{};
  shared_ptr<string> tableId{};
  shared_ptr<string> tableName{};
  shared_ptr<long> tid{};
  shared_ptr<string> userAccessId{};
  shared_ptr<string> userId{};

  RevokeUserPermissionRequest() {}

  explicit RevokeUserPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (dsType) {
      res["DsType"] = boost::any(*dsType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (permTypes) {
      res["PermTypes"] = boost::any(*permTypes);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (userAccessId) {
      res["UserAccessId"] = boost::any(*userAccessId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<string>(boost::any_cast<string>(m["DbId"]));
    }
    if (m.find("DsType") != m.end() && !m["DsType"].empty()) {
      dsType = make_shared<string>(boost::any_cast<string>(m["DsType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("PermTypes") != m.end() && !m["PermTypes"].empty()) {
      permTypes = make_shared<string>(boost::any_cast<string>(m["PermTypes"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UserAccessId") != m.end() && !m["UserAccessId"].empty()) {
      userAccessId = make_shared<string>(boost::any_cast<string>(m["UserAccessId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RevokeUserPermissionRequest() = default;
};
class RevokeUserPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RevokeUserPermissionResponseBody() {}

  explicit RevokeUserPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RevokeUserPermissionResponseBody() = default;
};
class RevokeUserPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeUserPermissionResponseBody> body{};

  RevokeUserPermissionResponse() {}

  explicit RevokeUserPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeUserPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeUserPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeUserPermissionResponse() = default;
};
class SearchDataTrackResultRequestColumnFilter : public Darabonba::Model {
public:
  shared_ptr<string> betweenEnd{};
  shared_ptr<string> betweenStart{};
  shared_ptr<string> columnName{};
  shared_ptr<vector<string>> inList{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  SearchDataTrackResultRequestColumnFilter() {}

  explicit SearchDataTrackResultRequestColumnFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (betweenEnd) {
      res["BetweenEnd"] = boost::any(*betweenEnd);
    }
    if (betweenStart) {
      res["BetweenStart"] = boost::any(*betweenStart);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (inList) {
      res["InList"] = boost::any(*inList);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BetweenEnd") != m.end() && !m["BetweenEnd"].empty()) {
      betweenEnd = make_shared<string>(boost::any_cast<string>(m["BetweenEnd"]));
    }
    if (m.find("BetweenStart") != m.end() && !m["BetweenStart"].empty()) {
      betweenStart = make_shared<string>(boost::any_cast<string>(m["BetweenStart"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("InList") != m.end() && !m["InList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      inList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SearchDataTrackResultRequestColumnFilter() = default;
};
class SearchDataTrackResultRequest : public Darabonba::Model {
public:
  shared_ptr<SearchDataTrackResultRequestColumnFilter> columnFilter{};
  shared_ptr<string> filterEndTime{};
  shared_ptr<string> filterStartTime{};
  shared_ptr<vector<string>> filterTableList{};
  shared_ptr<vector<string>> filterTypeList{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  SearchDataTrackResultRequest() {}

  explicit SearchDataTrackResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnFilter) {
      res["ColumnFilter"] = columnFilter ? boost::any(columnFilter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterEndTime) {
      res["FilterEndTime"] = boost::any(*filterEndTime);
    }
    if (filterStartTime) {
      res["FilterStartTime"] = boost::any(*filterStartTime);
    }
    if (filterTableList) {
      res["FilterTableList"] = boost::any(*filterTableList);
    }
    if (filterTypeList) {
      res["FilterTypeList"] = boost::any(*filterTypeList);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnFilter") != m.end() && !m["ColumnFilter"].empty()) {
      if (typeid(map<string, boost::any>) == m["ColumnFilter"].type()) {
        SearchDataTrackResultRequestColumnFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ColumnFilter"]));
        columnFilter = make_shared<SearchDataTrackResultRequestColumnFilter>(model1);
      }
    }
    if (m.find("FilterEndTime") != m.end() && !m["FilterEndTime"].empty()) {
      filterEndTime = make_shared<string>(boost::any_cast<string>(m["FilterEndTime"]));
    }
    if (m.find("FilterStartTime") != m.end() && !m["FilterStartTime"].empty()) {
      filterStartTime = make_shared<string>(boost::any_cast<string>(m["FilterStartTime"]));
    }
    if (m.find("FilterTableList") != m.end() && !m["FilterTableList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterTableList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterTableList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterTableList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FilterTypeList") != m.end() && !m["FilterTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~SearchDataTrackResultRequest() = default;
};
class SearchDataTrackResultShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnFilterShrink{};
  shared_ptr<string> filterEndTime{};
  shared_ptr<string> filterStartTime{};
  shared_ptr<string> filterTableListShrink{};
  shared_ptr<string> filterTypeListShrink{};
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  SearchDataTrackResultShrinkRequest() {}

  explicit SearchDataTrackResultShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnFilterShrink) {
      res["ColumnFilter"] = boost::any(*columnFilterShrink);
    }
    if (filterEndTime) {
      res["FilterEndTime"] = boost::any(*filterEndTime);
    }
    if (filterStartTime) {
      res["FilterStartTime"] = boost::any(*filterStartTime);
    }
    if (filterTableListShrink) {
      res["FilterTableList"] = boost::any(*filterTableListShrink);
    }
    if (filterTypeListShrink) {
      res["FilterTypeList"] = boost::any(*filterTypeListShrink);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnFilter") != m.end() && !m["ColumnFilter"].empty()) {
      columnFilterShrink = make_shared<string>(boost::any_cast<string>(m["ColumnFilter"]));
    }
    if (m.find("FilterEndTime") != m.end() && !m["FilterEndTime"].empty()) {
      filterEndTime = make_shared<string>(boost::any_cast<string>(m["FilterEndTime"]));
    }
    if (m.find("FilterStartTime") != m.end() && !m["FilterStartTime"].empty()) {
      filterStartTime = make_shared<string>(boost::any_cast<string>(m["FilterStartTime"]));
    }
    if (m.find("FilterTableList") != m.end() && !m["FilterTableList"].empty()) {
      filterTableListShrink = make_shared<string>(boost::any_cast<string>(m["FilterTableList"]));
    }
    if (m.find("FilterTypeList") != m.end() && !m["FilterTypeList"].empty()) {
      filterTypeListShrink = make_shared<string>(boost::any_cast<string>(m["FilterTypeList"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~SearchDataTrackResultShrinkRequest() = default;
};
class SearchDataTrackResultResponseBodyTrackResultEventList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dataAfter{};
  shared_ptr<vector<string>> dataBefore{};
  shared_ptr<long> eventId{};
  shared_ptr<long> eventLength{};
  shared_ptr<string> eventTimestamp{};
  shared_ptr<string> eventType{};
  shared_ptr<string> rollSQL{};

  SearchDataTrackResultResponseBodyTrackResultEventList() {}

  explicit SearchDataTrackResultResponseBodyTrackResultEventList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataAfter) {
      res["DataAfter"] = boost::any(*dataAfter);
    }
    if (dataBefore) {
      res["DataBefore"] = boost::any(*dataBefore);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventLength) {
      res["EventLength"] = boost::any(*eventLength);
    }
    if (eventTimestamp) {
      res["EventTimestamp"] = boost::any(*eventTimestamp);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (rollSQL) {
      res["RollSQL"] = boost::any(*rollSQL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataAfter") != m.end() && !m["DataAfter"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataAfter"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataAfter"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataAfter = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataBefore") != m.end() && !m["DataBefore"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataBefore"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataBefore"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataBefore = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<long>(boost::any_cast<long>(m["EventId"]));
    }
    if (m.find("EventLength") != m.end() && !m["EventLength"].empty()) {
      eventLength = make_shared<long>(boost::any_cast<long>(m["EventLength"]));
    }
    if (m.find("EventTimestamp") != m.end() && !m["EventTimestamp"].empty()) {
      eventTimestamp = make_shared<string>(boost::any_cast<string>(m["EventTimestamp"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("RollSQL") != m.end() && !m["RollSQL"].empty()) {
      rollSQL = make_shared<string>(boost::any_cast<string>(m["RollSQL"]));
    }
  }


  virtual ~SearchDataTrackResultResponseBodyTrackResultEventList() = default;
};
class SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<long> columnPosition{};
  shared_ptr<string> columnType{};
  shared_ptr<bool> fictive{};

  SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns() {}

  explicit SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnPosition) {
      res["ColumnPosition"] = boost::any(*columnPosition);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (fictive) {
      res["Fictive"] = boost::any(*fictive);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnPosition") != m.end() && !m["ColumnPosition"].empty()) {
      columnPosition = make_shared<long>(boost::any_cast<long>(m["ColumnPosition"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("Fictive") != m.end() && !m["Fictive"].empty()) {
      fictive = make_shared<bool>(boost::any_cast<bool>(m["Fictive"]));
    }
  }


  virtual ~SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns() = default;
};
class SearchDataTrackResultResponseBodyTrackResultTableInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns>> columns{};
  shared_ptr<string> description{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> tableName{};

  SearchDataTrackResultResponseBodyTrackResultTableInfoList() {}

  explicit SearchDataTrackResultResponseBodyTrackResultTableInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~SearchDataTrackResultResponseBodyTrackResultTableInfoList() = default;
};
class SearchDataTrackResultResponseBodyTrackResult : public Darabonba::Model {
public:
  shared_ptr<vector<SearchDataTrackResultResponseBodyTrackResultEventList>> eventList{};
  shared_ptr<vector<SearchDataTrackResultResponseBodyTrackResultTableInfoList>> tableInfoList{};
  shared_ptr<long> totalCount{};

  SearchDataTrackResultResponseBodyTrackResult() {}

  explicit SearchDataTrackResultResponseBodyTrackResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventList) {
      vector<boost::any> temp1;
      for(auto item1:*eventList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventList"] = boost::any(temp1);
    }
    if (tableInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*tableInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableInfoList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventList") != m.end() && !m["EventList"].empty()) {
      if (typeid(vector<boost::any>) == m["EventList"].type()) {
        vector<SearchDataTrackResultResponseBodyTrackResultEventList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchDataTrackResultResponseBodyTrackResultEventList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventList = make_shared<vector<SearchDataTrackResultResponseBodyTrackResultEventList>>(expect1);
      }
    }
    if (m.find("TableInfoList") != m.end() && !m["TableInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableInfoList"].type()) {
        vector<SearchDataTrackResultResponseBodyTrackResultTableInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchDataTrackResultResponseBodyTrackResultTableInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableInfoList = make_shared<vector<SearchDataTrackResultResponseBodyTrackResultTableInfoList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchDataTrackResultResponseBodyTrackResult() = default;
};
class SearchDataTrackResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<SearchDataTrackResultResponseBodyTrackResult> trackResult{};

  SearchDataTrackResultResponseBody() {}

  explicit SearchDataTrackResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (trackResult) {
      res["TrackResult"] = trackResult ? boost::any(trackResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TrackResult") != m.end() && !m["TrackResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrackResult"].type()) {
        SearchDataTrackResultResponseBodyTrackResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrackResult"]));
        trackResult = make_shared<SearchDataTrackResultResponseBodyTrackResult>(model1);
      }
    }
  }


  virtual ~SearchDataTrackResultResponseBody() = default;
};
class SearchDataTrackResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchDataTrackResultResponseBody> body{};

  SearchDataTrackResultResponse() {}

  explicit SearchDataTrackResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchDataTrackResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchDataTrackResultResponseBody>(model1);
      }
    }
  }


  virtual ~SearchDataTrackResultResponse() = default;
};
class SearchDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> searchRange{};
  shared_ptr<string> searchTarget{};
  shared_ptr<long> tid{};

  SearchDatabaseRequest() {}

  explicit SearchDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (searchRange) {
      res["SearchRange"] = boost::any(*searchRange);
    }
    if (searchTarget) {
      res["SearchTarget"] = boost::any(*searchTarget);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SearchRange") != m.end() && !m["SearchRange"].empty()) {
      searchRange = make_shared<string>(boost::any_cast<string>(m["SearchRange"]));
    }
    if (m.find("SearchTarget") != m.end() && !m["SearchTarget"].empty()) {
      searchTarget = make_shared<string>(boost::any_cast<string>(m["SearchTarget"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~SearchDatabaseRequest() = default;
};
class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerIds{};

  SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList() {}

  explicit SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList() = default;
};
class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerNames{};

  SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList() {}

  explicit SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList() = default;
};
class SearchDatabaseResponseBodySearchDatabaseListSearchDatabase : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> catalogName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> datalinkName{};
  shared_ptr<string> dbType{};
  shared_ptr<string> dbaId{};
  shared_ptr<string> encoding{};
  shared_ptr<string> envType{};
  shared_ptr<string> host{};
  shared_ptr<bool> logic{};
  shared_ptr<SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList> ownerIdList{};
  shared_ptr<SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList> ownerNameList{};
  shared_ptr<long> port{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> searchName{};
  shared_ptr<string> sid{};

  SearchDatabaseResponseBodySearchDatabaseListSearchDatabase() {}

  explicit SearchDatabaseResponseBodySearchDatabaseListSearchDatabase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (catalogName) {
      res["CatalogName"] = boost::any(*catalogName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (datalinkName) {
      res["DatalinkName"] = boost::any(*datalinkName);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (dbaId) {
      res["DbaId"] = boost::any(*dbaId);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (ownerIdList) {
      res["OwnerIdList"] = ownerIdList ? boost::any(ownerIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerNameList) {
      res["OwnerNameList"] = ownerNameList ? boost::any(ownerNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (searchName) {
      res["SearchName"] = boost::any(*searchName);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("CatalogName") != m.end() && !m["CatalogName"].empty()) {
      catalogName = make_shared<string>(boost::any_cast<string>(m["CatalogName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatalinkName") != m.end() && !m["DatalinkName"].empty()) {
      datalinkName = make_shared<string>(boost::any_cast<string>(m["DatalinkName"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("DbaId") != m.end() && !m["DbaId"].empty()) {
      dbaId = make_shared<string>(boost::any_cast<string>(m["DbaId"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("OwnerIdList") != m.end() && !m["OwnerIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerIdList"].type()) {
        SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerIdList"]));
        ownerIdList = make_shared<SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList>(model1);
      }
    }
    if (m.find("OwnerNameList") != m.end() && !m["OwnerNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerNameList"].type()) {
        SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerNameList"]));
        ownerNameList = make_shared<SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList>(model1);
      }
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("SearchName") != m.end() && !m["SearchName"].empty()) {
      searchName = make_shared<string>(boost::any_cast<string>(m["SearchName"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
  }


  virtual ~SearchDatabaseResponseBodySearchDatabaseListSearchDatabase() = default;
};
class SearchDatabaseResponseBodySearchDatabaseList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchDatabaseResponseBodySearchDatabaseListSearchDatabase>> searchDatabase{};

  SearchDatabaseResponseBodySearchDatabaseList() {}

  explicit SearchDatabaseResponseBodySearchDatabaseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchDatabase) {
      vector<boost::any> temp1;
      for(auto item1:*searchDatabase){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchDatabase"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchDatabase") != m.end() && !m["SearchDatabase"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchDatabase"].type()) {
        vector<SearchDatabaseResponseBodySearchDatabaseListSearchDatabase> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchDatabase"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchDatabaseResponseBodySearchDatabaseListSearchDatabase model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchDatabase = make_shared<vector<SearchDatabaseResponseBodySearchDatabaseListSearchDatabase>>(expect1);
      }
    }
  }


  virtual ~SearchDatabaseResponseBodySearchDatabaseList() = default;
};
class SearchDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<SearchDatabaseResponseBodySearchDatabaseList> searchDatabaseList{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  SearchDatabaseResponseBody() {}

  explicit SearchDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (searchDatabaseList) {
      res["SearchDatabaseList"] = searchDatabaseList ? boost::any(searchDatabaseList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SearchDatabaseList") != m.end() && !m["SearchDatabaseList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchDatabaseList"].type()) {
        SearchDatabaseResponseBodySearchDatabaseList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchDatabaseList"]));
        searchDatabaseList = make_shared<SearchDatabaseResponseBodySearchDatabaseList>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchDatabaseResponseBody() = default;
};
class SearchDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchDatabaseResponseBody> body{};

  SearchDatabaseResponse() {}

  explicit SearchDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~SearchDatabaseResponse() = default;
};
class SearchTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbType{};
  shared_ptr<string> envType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> returnGuid{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> searchRange{};
  shared_ptr<string> searchTarget{};
  shared_ptr<long> tid{};

  SearchTableRequest() {}

  explicit SearchTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (returnGuid) {
      res["ReturnGuid"] = boost::any(*returnGuid);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (searchRange) {
      res["SearchRange"] = boost::any(*searchRange);
    }
    if (searchTarget) {
      res["SearchTarget"] = boost::any(*searchTarget);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ReturnGuid") != m.end() && !m["ReturnGuid"].empty()) {
      returnGuid = make_shared<bool>(boost::any_cast<bool>(m["ReturnGuid"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SearchRange") != m.end() && !m["SearchRange"].empty()) {
      searchRange = make_shared<string>(boost::any_cast<string>(m["SearchRange"]));
    }
    if (m.find("SearchTarget") != m.end() && !m["SearchTarget"].empty()) {
      searchTarget = make_shared<string>(boost::any_cast<string>(m["SearchTarget"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~SearchTableRequest() = default;
};
class SearchTableResponseBodySearchTableListSearchTableOwnerIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerIds{};

  SearchTableResponseBodySearchTableListSearchTableOwnerIdList() {}

  explicit SearchTableResponseBodySearchTableListSearchTableOwnerIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SearchTableResponseBodySearchTableListSearchTableOwnerIdList() = default;
};
class SearchTableResponseBodySearchTableListSearchTableOwnerNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ownerNames{};

  SearchTableResponseBodySearchTableListSearchTableOwnerNameList() {}

  explicit SearchTableResponseBodySearchTableListSearchTableOwnerNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerNames) {
      res["OwnerNames"] = boost::any(*ownerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerNames") != m.end() && !m["OwnerNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SearchTableResponseBodySearchTableListSearchTableOwnerNameList() = default;
};
class SearchTableResponseBodySearchTableListSearchTable : public Darabonba::Model {
public:
  shared_ptr<string> DBSearchName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> dbName{};
  shared_ptr<string> dbType{};
  shared_ptr<string> description{};
  shared_ptr<string> encoding{};
  shared_ptr<string> engine{};
  shared_ptr<string> envType{};
  shared_ptr<bool> logic{};
  shared_ptr<SearchTableResponseBodySearchTableListSearchTableOwnerIdList> ownerIdList{};
  shared_ptr<SearchTableResponseBodySearchTableListSearchTableOwnerNameList> ownerNameList{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> tableId{};
  shared_ptr<string> tableName{};
  shared_ptr<string> tableSchemaName{};

  SearchTableResponseBodySearchTableListSearchTable() {}

  explicit SearchTableResponseBodySearchTableListSearchTable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBSearchName) {
      res["DBSearchName"] = boost::any(*DBSearchName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (ownerIdList) {
      res["OwnerIdList"] = ownerIdList ? boost::any(ownerIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerNameList) {
      res["OwnerNameList"] = ownerNameList ? boost::any(ownerNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableSchemaName) {
      res["TableSchemaName"] = boost::any(*tableSchemaName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBSearchName") != m.end() && !m["DBSearchName"].empty()) {
      DBSearchName = make_shared<string>(boost::any_cast<string>(m["DBSearchName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("OwnerIdList") != m.end() && !m["OwnerIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerIdList"].type()) {
        SearchTableResponseBodySearchTableListSearchTableOwnerIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerIdList"]));
        ownerIdList = make_shared<SearchTableResponseBodySearchTableListSearchTableOwnerIdList>(model1);
      }
    }
    if (m.find("OwnerNameList") != m.end() && !m["OwnerNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OwnerNameList"].type()) {
        SearchTableResponseBodySearchTableListSearchTableOwnerNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OwnerNameList"]));
        ownerNameList = make_shared<SearchTableResponseBodySearchTableListSearchTableOwnerNameList>(model1);
      }
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableSchemaName") != m.end() && !m["TableSchemaName"].empty()) {
      tableSchemaName = make_shared<string>(boost::any_cast<string>(m["TableSchemaName"]));
    }
  }


  virtual ~SearchTableResponseBodySearchTableListSearchTable() = default;
};
class SearchTableResponseBodySearchTableList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchTableResponseBodySearchTableListSearchTable>> searchTable{};

  SearchTableResponseBodySearchTableList() {}

  explicit SearchTableResponseBodySearchTableList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchTable) {
      vector<boost::any> temp1;
      for(auto item1:*searchTable){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchTable"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchTable") != m.end() && !m["SearchTable"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchTable"].type()) {
        vector<SearchTableResponseBodySearchTableListSearchTable> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchTable"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTableResponseBodySearchTableListSearchTable model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchTable = make_shared<vector<SearchTableResponseBodySearchTableListSearchTable>>(expect1);
      }
    }
  }


  virtual ~SearchTableResponseBodySearchTableList() = default;
};
class SearchTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<SearchTableResponseBodySearchTableList> searchTableList{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  SearchTableResponseBody() {}

  explicit SearchTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (searchTableList) {
      res["SearchTableList"] = searchTableList ? boost::any(searchTableList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SearchTableList") != m.end() && !m["SearchTableList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchTableList"].type()) {
        SearchTableResponseBodySearchTableList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchTableList"]));
        searchTableList = make_shared<SearchTableResponseBodySearchTableList>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchTableResponseBody() = default;
};
class SearchTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTableResponseBody> body{};

  SearchTableResponse() {}

  explicit SearchTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTableResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTableResponse() = default;
};
class SetOwnersRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerIds{};
  shared_ptr<string> ownerType{};
  shared_ptr<string> resourceId{};
  shared_ptr<long> tid{};

  SetOwnersRequest() {}

  explicit SetOwnersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerIds) {
      res["OwnerIds"] = boost::any(*ownerIds);
    }
    if (ownerType) {
      res["OwnerType"] = boost::any(*ownerType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerIds") != m.end() && !m["OwnerIds"].empty()) {
      ownerIds = make_shared<string>(boost::any_cast<string>(m["OwnerIds"]));
    }
    if (m.find("OwnerType") != m.end() && !m["OwnerType"].empty()) {
      ownerType = make_shared<string>(boost::any_cast<string>(m["OwnerType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~SetOwnersRequest() = default;
};
class SetOwnersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetOwnersResponseBody() {}

  explicit SetOwnersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetOwnersResponseBody() = default;
};
class SetOwnersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetOwnersResponseBody> body{};

  SetOwnersResponse() {}

  explicit SetOwnersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetOwnersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetOwnersResponseBody>(model1);
      }
    }
  }


  virtual ~SetOwnersResponse() = default;
};
class SkipDataCorrectRowCheckRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> reason{};
  shared_ptr<long> tid{};

  SkipDataCorrectRowCheckRequest() {}

  explicit SkipDataCorrectRowCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~SkipDataCorrectRowCheckRequest() = default;
};
class SkipDataCorrectRowCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SkipDataCorrectRowCheckResponseBody() {}

  explicit SkipDataCorrectRowCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SkipDataCorrectRowCheckResponseBody() = default;
};
class SkipDataCorrectRowCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SkipDataCorrectRowCheckResponseBody> body{};

  SkipDataCorrectRowCheckResponse() {}

  explicit SkipDataCorrectRowCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SkipDataCorrectRowCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SkipDataCorrectRowCheckResponseBody>(model1);
      }
    }
  }


  virtual ~SkipDataCorrectRowCheckResponse() = default;
};
class StopTaskFlowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> dagInstanceId{};
  shared_ptr<long> tid{};

  StopTaskFlowInstanceRequest() {}

  explicit StopTaskFlowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagInstanceId) {
      res["DagInstanceId"] = boost::any(*dagInstanceId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagInstanceId") != m.end() && !m["DagInstanceId"].empty()) {
      dagInstanceId = make_shared<long>(boost::any_cast<long>(m["DagInstanceId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~StopTaskFlowInstanceRequest() = default;
};
class StopTaskFlowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopTaskFlowInstanceResponseBody() {}

  explicit StopTaskFlowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StopTaskFlowInstanceResponseBody() = default;
};
class StopTaskFlowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopTaskFlowInstanceResponseBody> body{};

  StopTaskFlowInstanceResponse() {}

  explicit StopTaskFlowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopTaskFlowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopTaskFlowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StopTaskFlowInstanceResponse() = default;
};
class SubmitOrderApprovalRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  SubmitOrderApprovalRequest() {}

  explicit SubmitOrderApprovalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~SubmitOrderApprovalRequest() = default;
};
class SubmitOrderApprovalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitOrderApprovalResponseBody() {}

  explicit SubmitOrderApprovalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitOrderApprovalResponseBody() = default;
};
class SubmitOrderApprovalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitOrderApprovalResponseBody> body{};

  SubmitOrderApprovalResponse() {}

  explicit SubmitOrderApprovalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitOrderApprovalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitOrderApprovalResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitOrderApprovalResponse() = default;
};
class SubmitStructSyncOrderApprovalRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> tid{};

  SubmitStructSyncOrderApprovalRequest() {}

  explicit SubmitStructSyncOrderApprovalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~SubmitStructSyncOrderApprovalRequest() = default;
};
class SubmitStructSyncOrderApprovalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> workflowInstanceId{};

  SubmitStructSyncOrderApprovalResponseBody() {}

  explicit SubmitStructSyncOrderApprovalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (workflowInstanceId) {
      res["WorkflowInstanceId"] = boost::any(*workflowInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("WorkflowInstanceId") != m.end() && !m["WorkflowInstanceId"].empty()) {
      workflowInstanceId = make_shared<long>(boost::any_cast<long>(m["WorkflowInstanceId"]));
    }
  }


  virtual ~SubmitStructSyncOrderApprovalResponseBody() = default;
};
class SubmitStructSyncOrderApprovalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitStructSyncOrderApprovalResponseBody> body{};

  SubmitStructSyncOrderApprovalResponse() {}

  explicit SubmitStructSyncOrderApprovalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitStructSyncOrderApprovalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitStructSyncOrderApprovalResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitStructSyncOrderApprovalResponse() = default;
};
class SuspendTaskFlowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> dagInstanceId{};
  shared_ptr<long> tid{};

  SuspendTaskFlowInstanceRequest() {}

  explicit SuspendTaskFlowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagInstanceId) {
      res["DagInstanceId"] = boost::any(*dagInstanceId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagInstanceId") != m.end() && !m["DagInstanceId"].empty()) {
      dagInstanceId = make_shared<long>(boost::any_cast<long>(m["DagInstanceId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~SuspendTaskFlowInstanceRequest() = default;
};
class SuspendTaskFlowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SuspendTaskFlowInstanceResponseBody() {}

  explicit SuspendTaskFlowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SuspendTaskFlowInstanceResponseBody() = default;
};
class SuspendTaskFlowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendTaskFlowInstanceResponseBody> body{};

  SuspendTaskFlowInstanceResponse() {}

  explicit SuspendTaskFlowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendTaskFlowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendTaskFlowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendTaskFlowInstanceResponse() = default;
};
class SyncDatabaseMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbId{};
  shared_ptr<bool> logic{};
  shared_ptr<long> tid{};

  SyncDatabaseMetaRequest() {}

  explicit SyncDatabaseMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (logic) {
      res["Logic"] = boost::any(*logic);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<string>(boost::any_cast<string>(m["DbId"]));
    }
    if (m.find("Logic") != m.end() && !m["Logic"].empty()) {
      logic = make_shared<bool>(boost::any_cast<bool>(m["Logic"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~SyncDatabaseMetaRequest() = default;
};
class SyncDatabaseMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SyncDatabaseMetaResponseBody() {}

  explicit SyncDatabaseMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SyncDatabaseMetaResponseBody() = default;
};
class SyncDatabaseMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncDatabaseMetaResponseBody> body{};

  SyncDatabaseMetaResponse() {}

  explicit SyncDatabaseMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncDatabaseMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncDatabaseMetaResponseBody>(model1);
      }
    }
  }


  virtual ~SyncDatabaseMetaResponse() = default;
};
class SyncInstanceMetaRequest : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreTable{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> tid{};

  SyncInstanceMetaRequest() {}

  explicit SyncInstanceMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreTable) {
      res["IgnoreTable"] = boost::any(*ignoreTable);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreTable") != m.end() && !m["IgnoreTable"].empty()) {
      ignoreTable = make_shared<bool>(boost::any_cast<bool>(m["IgnoreTable"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~SyncInstanceMetaRequest() = default;
};
class SyncInstanceMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SyncInstanceMetaResponseBody() {}

  explicit SyncInstanceMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SyncInstanceMetaResponseBody() = default;
};
class SyncInstanceMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncInstanceMetaResponseBody> body{};

  SyncInstanceMetaResponse() {}

  explicit SyncInstanceMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncInstanceMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncInstanceMetaResponseBody>(model1);
      }
    }
  }


  virtual ~SyncInstanceMetaResponse() = default;
};
class UpdateAuthorityTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> templateId{};
  shared_ptr<long> tid{};

  UpdateAuthorityTemplateRequest() {}

  explicit UpdateAuthorityTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateAuthorityTemplateRequest() = default;
};
class UpdateAuthorityTemplateResponseBodyAuthorityTemplateView : public Darabonba::Model {
public:
  shared_ptr<long> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> templateId{};

  UpdateAuthorityTemplateResponseBodyAuthorityTemplateView() {}

  explicit UpdateAuthorityTemplateResponseBodyAuthorityTemplateView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~UpdateAuthorityTemplateResponseBodyAuthorityTemplateView() = default;
};
class UpdateAuthorityTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateAuthorityTemplateResponseBodyAuthorityTemplateView> authorityTemplateView{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> tid{};

  UpdateAuthorityTemplateResponseBody() {}

  explicit UpdateAuthorityTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorityTemplateView) {
      res["AuthorityTemplateView"] = authorityTemplateView ? boost::any(authorityTemplateView->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorityTemplateView") != m.end() && !m["AuthorityTemplateView"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorityTemplateView"].type()) {
        UpdateAuthorityTemplateResponseBodyAuthorityTemplateView model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorityTemplateView"]));
        authorityTemplateView = make_shared<UpdateAuthorityTemplateResponseBodyAuthorityTemplateView>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateAuthorityTemplateResponseBody() = default;
};
class UpdateAuthorityTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAuthorityTemplateResponseBody> body{};

  UpdateAuthorityTemplateResponse() {}

  explicit UpdateAuthorityTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAuthorityTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAuthorityTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAuthorityTemplateResponse() = default;
};
class UpdateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataLinkName{};
  shared_ptr<string> databasePassword{};
  shared_ptr<string> databaseUser{};
  shared_ptr<string> dbaId{};
  shared_ptr<long> ddlOnline{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> ecsRegion{};
  shared_ptr<string> enableSellSitd{};
  shared_ptr<string> envType{};
  shared_ptr<long> exportTimeout{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceAlias{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceSource{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> port{};
  shared_ptr<long> queryTimeout{};
  shared_ptr<string> safeRuleId{};
  shared_ptr<string> sid{};
  shared_ptr<bool> skipTest{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<long> tid{};
  shared_ptr<long> useDsql{};
  shared_ptr<string> vpcId{};

  UpdateInstanceRequest() {}

  explicit UpdateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataLinkName) {
      res["DataLinkName"] = boost::any(*dataLinkName);
    }
    if (databasePassword) {
      res["DatabasePassword"] = boost::any(*databasePassword);
    }
    if (databaseUser) {
      res["DatabaseUser"] = boost::any(*databaseUser);
    }
    if (dbaId) {
      res["DbaId"] = boost::any(*dbaId);
    }
    if (ddlOnline) {
      res["DdlOnline"] = boost::any(*ddlOnline);
    }
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (ecsRegion) {
      res["EcsRegion"] = boost::any(*ecsRegion);
    }
    if (enableSellSitd) {
      res["EnableSellSitd"] = boost::any(*enableSellSitd);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (exportTimeout) {
      res["ExportTimeout"] = boost::any(*exportTimeout);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (instanceAlias) {
      res["InstanceAlias"] = boost::any(*instanceAlias);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceSource) {
      res["InstanceSource"] = boost::any(*instanceSource);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (queryTimeout) {
      res["QueryTimeout"] = boost::any(*queryTimeout);
    }
    if (safeRuleId) {
      res["SafeRuleId"] = boost::any(*safeRuleId);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (skipTest) {
      res["SkipTest"] = boost::any(*skipTest);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (useDsql) {
      res["UseDsql"] = boost::any(*useDsql);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataLinkName") != m.end() && !m["DataLinkName"].empty()) {
      dataLinkName = make_shared<string>(boost::any_cast<string>(m["DataLinkName"]));
    }
    if (m.find("DatabasePassword") != m.end() && !m["DatabasePassword"].empty()) {
      databasePassword = make_shared<string>(boost::any_cast<string>(m["DatabasePassword"]));
    }
    if (m.find("DatabaseUser") != m.end() && !m["DatabaseUser"].empty()) {
      databaseUser = make_shared<string>(boost::any_cast<string>(m["DatabaseUser"]));
    }
    if (m.find("DbaId") != m.end() && !m["DbaId"].empty()) {
      dbaId = make_shared<string>(boost::any_cast<string>(m["DbaId"]));
    }
    if (m.find("DdlOnline") != m.end() && !m["DdlOnline"].empty()) {
      ddlOnline = make_shared<long>(boost::any_cast<long>(m["DdlOnline"]));
    }
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("EcsRegion") != m.end() && !m["EcsRegion"].empty()) {
      ecsRegion = make_shared<string>(boost::any_cast<string>(m["EcsRegion"]));
    }
    if (m.find("EnableSellSitd") != m.end() && !m["EnableSellSitd"].empty()) {
      enableSellSitd = make_shared<string>(boost::any_cast<string>(m["EnableSellSitd"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("ExportTimeout") != m.end() && !m["ExportTimeout"].empty()) {
      exportTimeout = make_shared<long>(boost::any_cast<long>(m["ExportTimeout"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("InstanceAlias") != m.end() && !m["InstanceAlias"].empty()) {
      instanceAlias = make_shared<string>(boost::any_cast<string>(m["InstanceAlias"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceSource") != m.end() && !m["InstanceSource"].empty()) {
      instanceSource = make_shared<string>(boost::any_cast<string>(m["InstanceSource"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("QueryTimeout") != m.end() && !m["QueryTimeout"].empty()) {
      queryTimeout = make_shared<long>(boost::any_cast<long>(m["QueryTimeout"]));
    }
    if (m.find("SafeRuleId") != m.end() && !m["SafeRuleId"].empty()) {
      safeRuleId = make_shared<string>(boost::any_cast<string>(m["SafeRuleId"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("SkipTest") != m.end() && !m["SkipTest"].empty()) {
      skipTest = make_shared<bool>(boost::any_cast<bool>(m["SkipTest"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("UseDsql") != m.end() && !m["UseDsql"].empty()) {
      useDsql = make_shared<long>(boost::any_cast<long>(m["UseDsql"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~UpdateInstanceRequest() = default;
};
class UpdateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateInstanceResponseBody() {}

  explicit UpdateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateInstanceResponseBody() = default;
};
class UpdateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateInstanceResponseBody> body{};

  UpdateInstanceResponse() {}

  explicit UpdateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateInstanceResponse() = default;
};
class UpdateSLARulesRequestSlaRuleList : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> intervalMinutes{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> type{};

  UpdateSLARulesRequestSlaRuleList() {}

  explicit UpdateSLARulesRequestSlaRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (intervalMinutes) {
      res["IntervalMinutes"] = boost::any(*intervalMinutes);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("IntervalMinutes") != m.end() && !m["IntervalMinutes"].empty()) {
      intervalMinutes = make_shared<long>(boost::any_cast<long>(m["IntervalMinutes"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~UpdateSLARulesRequestSlaRuleList() = default;
};
class UpdateSLARulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<vector<UpdateSLARulesRequestSlaRuleList>> slaRuleList{};
  shared_ptr<long> tid{};

  UpdateSLARulesRequest() {}

  explicit UpdateSLARulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (slaRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*slaRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlaRuleList"] = boost::any(temp1);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("SlaRuleList") != m.end() && !m["SlaRuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["SlaRuleList"].type()) {
        vector<UpdateSLARulesRequestSlaRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlaRuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSLARulesRequestSlaRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slaRuleList = make_shared<vector<UpdateSLARulesRequestSlaRuleList>>(expect1);
      }
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateSLARulesRequest() = default;
};
class UpdateSLARulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> slaRuleListShrink{};
  shared_ptr<long> tid{};

  UpdateSLARulesShrinkRequest() {}

  explicit UpdateSLARulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (slaRuleListShrink) {
      res["SlaRuleList"] = boost::any(*slaRuleListShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("SlaRuleList") != m.end() && !m["SlaRuleList"].empty()) {
      slaRuleListShrink = make_shared<string>(boost::any_cast<string>(m["SlaRuleList"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateSLARulesShrinkRequest() = default;
};
class UpdateSLARulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateSLARulesResponseBody() {}

  explicit UpdateSLARulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateSLARulesResponseBody() = default;
};
class UpdateSLARulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSLARulesResponseBody> body{};

  UpdateSLARulesResponse() {}

  explicit UpdateSLARulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSLARulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSLARulesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSLARulesResponse() = default;
};
class UpdateScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> scenarioName{};
  shared_ptr<long> tid{};

  UpdateScenarioRequest() {}

  explicit UpdateScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (scenarioName) {
      res["ScenarioName"] = boost::any(*scenarioName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("ScenarioName") != m.end() && !m["ScenarioName"].empty()) {
      scenarioName = make_shared<string>(boost::any_cast<string>(m["ScenarioName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateScenarioRequest() = default;
};
class UpdateScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateScenarioResponseBody() {}

  explicit UpdateScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateScenarioResponseBody() = default;
};
class UpdateScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateScenarioResponseBody> body{};

  UpdateScenarioResponse() {}

  explicit UpdateScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateScenarioResponse() = default;
};
class UpdateStandardGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> tid{};

  UpdateStandardGroupRequest() {}

  explicit UpdateStandardGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateStandardGroupRequest() = default;
};
class UpdateStandardGroupResponseBodyStandardGroup : public Darabonba::Model {
public:
  shared_ptr<string> dbType{};
  shared_ptr<string> description{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupMode{};
  shared_ptr<string> groupName{};
  shared_ptr<long> lastMenderId{};

  UpdateStandardGroupResponseBodyStandardGroup() {}

  explicit UpdateStandardGroupResponseBodyStandardGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupMode) {
      res["GroupMode"] = boost::any(*groupMode);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lastMenderId) {
      res["LastMenderId"] = boost::any(*lastMenderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupMode") != m.end() && !m["GroupMode"].empty()) {
      groupMode = make_shared<string>(boost::any_cast<string>(m["GroupMode"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LastMenderId") != m.end() && !m["LastMenderId"].empty()) {
      lastMenderId = make_shared<long>(boost::any_cast<long>(m["LastMenderId"]));
    }
  }


  virtual ~UpdateStandardGroupResponseBodyStandardGroup() = default;
};
class UpdateStandardGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateStandardGroupResponseBodyStandardGroup> standardGroup{};
  shared_ptr<bool> success{};

  UpdateStandardGroupResponseBody() {}

  explicit UpdateStandardGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (standardGroup) {
      res["StandardGroup"] = standardGroup ? boost::any(standardGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StandardGroup") != m.end() && !m["StandardGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["StandardGroup"].type()) {
        UpdateStandardGroupResponseBodyStandardGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StandardGroup"]));
        standardGroup = make_shared<UpdateStandardGroupResponseBodyStandardGroup>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateStandardGroupResponseBody() = default;
};
class UpdateStandardGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateStandardGroupResponseBody> body{};

  UpdateStandardGroupResponse() {}

  explicit UpdateStandardGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateStandardGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateStandardGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateStandardGroupResponse() = default;
};
class UpdateTaskConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeConfig{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> tid{};

  UpdateTaskConfigRequest() {}

  explicit UpdateTaskConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeConfig) {
      res["NodeConfig"] = boost::any(*nodeConfig);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeConfig") != m.end() && !m["NodeConfig"].empty()) {
      nodeConfig = make_shared<string>(boost::any_cast<string>(m["NodeConfig"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskConfigRequest() = default;
};
class UpdateTaskConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskConfigResponseBody() {}

  explicit UpdateTaskConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskConfigResponseBody() = default;
};
class UpdateTaskConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskConfigResponseBody> body{};

  UpdateTaskConfigResponse() {}

  explicit UpdateTaskConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskConfigResponse() = default;
};
class UpdateTaskContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeContent{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> tid{};

  UpdateTaskContentRequest() {}

  explicit UpdateTaskContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeContent) {
      res["NodeContent"] = boost::any(*nodeContent);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeContent") != m.end() && !m["NodeContent"].empty()) {
      nodeContent = make_shared<string>(boost::any_cast<string>(m["NodeContent"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskContentRequest() = default;
};
class UpdateTaskContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskContentResponseBody() {}

  explicit UpdateTaskContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskContentResponseBody() = default;
};
class UpdateTaskContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskContentResponseBody> body{};

  UpdateTaskContentResponse() {}

  explicit UpdateTaskContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskContentResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskContentResponse() = default;
};
class UpdateTaskFlowConstantsRequestDagConstants : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateTaskFlowConstantsRequestDagConstants() {}

  explicit UpdateTaskFlowConstantsRequestDagConstants(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateTaskFlowConstantsRequestDagConstants() = default;
};
class UpdateTaskFlowConstantsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTaskFlowConstantsRequestDagConstants>> dagConstants{};
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  UpdateTaskFlowConstantsRequest() {}

  explicit UpdateTaskFlowConstantsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagConstants) {
      vector<boost::any> temp1;
      for(auto item1:*dagConstants){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DagConstants"] = boost::any(temp1);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagConstants") != m.end() && !m["DagConstants"].empty()) {
      if (typeid(vector<boost::any>) == m["DagConstants"].type()) {
        vector<UpdateTaskFlowConstantsRequestDagConstants> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DagConstants"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskFlowConstantsRequestDagConstants model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dagConstants = make_shared<vector<UpdateTaskFlowConstantsRequestDagConstants>>(expect1);
      }
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskFlowConstantsRequest() = default;
};
class UpdateTaskFlowConstantsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dagConstantsShrink{};
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  UpdateTaskFlowConstantsShrinkRequest() {}

  explicit UpdateTaskFlowConstantsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagConstantsShrink) {
      res["DagConstants"] = boost::any(*dagConstantsShrink);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagConstants") != m.end() && !m["DagConstants"].empty()) {
      dagConstantsShrink = make_shared<string>(boost::any_cast<string>(m["DagConstants"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskFlowConstantsShrinkRequest() = default;
};
class UpdateTaskFlowConstantsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskFlowConstantsResponseBody() {}

  explicit UpdateTaskFlowConstantsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskFlowConstantsResponseBody() = default;
};
class UpdateTaskFlowConstantsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskFlowConstantsResponseBody> body{};

  UpdateTaskFlowConstantsResponse() {}

  explicit UpdateTaskFlowConstantsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskFlowConstantsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskFlowConstantsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskFlowConstantsResponse() = default;
};
class UpdateTaskFlowCooperatorsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cooperatorIds{};
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  UpdateTaskFlowCooperatorsRequest() {}

  explicit UpdateTaskFlowCooperatorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cooperatorIds) {
      res["CooperatorIds"] = boost::any(*cooperatorIds);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CooperatorIds") != m.end() && !m["CooperatorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CooperatorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CooperatorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cooperatorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskFlowCooperatorsRequest() = default;
};
class UpdateTaskFlowCooperatorsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cooperatorIdsShrink{};
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};

  UpdateTaskFlowCooperatorsShrinkRequest() {}

  explicit UpdateTaskFlowCooperatorsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cooperatorIdsShrink) {
      res["CooperatorIds"] = boost::any(*cooperatorIdsShrink);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CooperatorIds") != m.end() && !m["CooperatorIds"].empty()) {
      cooperatorIdsShrink = make_shared<string>(boost::any_cast<string>(m["CooperatorIds"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskFlowCooperatorsShrinkRequest() = default;
};
class UpdateTaskFlowCooperatorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskFlowCooperatorsResponseBody() {}

  explicit UpdateTaskFlowCooperatorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskFlowCooperatorsResponseBody() = default;
};
class UpdateTaskFlowCooperatorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskFlowCooperatorsResponseBody> body{};

  UpdateTaskFlowCooperatorsResponse() {}

  explicit UpdateTaskFlowCooperatorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskFlowCooperatorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskFlowCooperatorsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskFlowCooperatorsResponse() = default;
};
class UpdateTaskFlowEdgesRequestEdges : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> nodeEnd{};
  shared_ptr<long> nodeFrom{};

  UpdateTaskFlowEdgesRequestEdges() {}

  explicit UpdateTaskFlowEdgesRequestEdges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nodeEnd) {
      res["NodeEnd"] = boost::any(*nodeEnd);
    }
    if (nodeFrom) {
      res["NodeFrom"] = boost::any(*nodeFrom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NodeEnd") != m.end() && !m["NodeEnd"].empty()) {
      nodeEnd = make_shared<long>(boost::any_cast<long>(m["NodeEnd"]));
    }
    if (m.find("NodeFrom") != m.end() && !m["NodeFrom"].empty()) {
      nodeFrom = make_shared<long>(boost::any_cast<long>(m["NodeFrom"]));
    }
  }


  virtual ~UpdateTaskFlowEdgesRequestEdges() = default;
};
class UpdateTaskFlowEdgesRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<vector<UpdateTaskFlowEdgesRequestEdges>> edges{};
  shared_ptr<long> tid{};

  UpdateTaskFlowEdgesRequest() {}

  explicit UpdateTaskFlowEdgesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (edges) {
      vector<boost::any> temp1;
      for(auto item1:*edges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Edges"] = boost::any(temp1);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Edges") != m.end() && !m["Edges"].empty()) {
      if (typeid(vector<boost::any>) == m["Edges"].type()) {
        vector<UpdateTaskFlowEdgesRequestEdges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Edges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskFlowEdgesRequestEdges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        edges = make_shared<vector<UpdateTaskFlowEdgesRequestEdges>>(expect1);
      }
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskFlowEdgesRequest() = default;
};
class UpdateTaskFlowEdgesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> edgesShrink{};
  shared_ptr<long> tid{};

  UpdateTaskFlowEdgesShrinkRequest() {}

  explicit UpdateTaskFlowEdgesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (edgesShrink) {
      res["Edges"] = boost::any(*edgesShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Edges") != m.end() && !m["Edges"].empty()) {
      edgesShrink = make_shared<string>(boost::any_cast<string>(m["Edges"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskFlowEdgesShrinkRequest() = default;
};
class UpdateTaskFlowEdgesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskFlowEdgesResponseBody() {}

  explicit UpdateTaskFlowEdgesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskFlowEdgesResponseBody() = default;
};
class UpdateTaskFlowEdgesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskFlowEdgesResponseBody> body{};

  UpdateTaskFlowEdgesResponse() {}

  explicit UpdateTaskFlowEdgesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskFlowEdgesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskFlowEdgesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskFlowEdgesResponse() = default;
};
class UpdateTaskFlowNameAndDescRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> dagName{};
  shared_ptr<string> description{};
  shared_ptr<long> tid{};

  UpdateTaskFlowNameAndDescRequest() {}

  explicit UpdateTaskFlowNameAndDescRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagName) {
      res["DagName"] = boost::any(*dagName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagName") != m.end() && !m["DagName"].empty()) {
      dagName = make_shared<string>(boost::any_cast<string>(m["DagName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskFlowNameAndDescRequest() = default;
};
class UpdateTaskFlowNameAndDescResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskFlowNameAndDescResponseBody() {}

  explicit UpdateTaskFlowNameAndDescResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskFlowNameAndDescResponseBody() = default;
};
class UpdateTaskFlowNameAndDescResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskFlowNameAndDescResponseBody> body{};

  UpdateTaskFlowNameAndDescResponse() {}

  explicit UpdateTaskFlowNameAndDescResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskFlowNameAndDescResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskFlowNameAndDescResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskFlowNameAndDescResponse() = default;
};
class UpdateTaskFlowNotificationRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<bool> dagNotificationFail{};
  shared_ptr<bool> dagNotificationSla{};
  shared_ptr<bool> dagNotificationSuccess{};
  shared_ptr<long> tid{};

  UpdateTaskFlowNotificationRequest() {}

  explicit UpdateTaskFlowNotificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dagNotificationFail) {
      res["DagNotificationFail"] = boost::any(*dagNotificationFail);
    }
    if (dagNotificationSla) {
      res["DagNotificationSla"] = boost::any(*dagNotificationSla);
    }
    if (dagNotificationSuccess) {
      res["DagNotificationSuccess"] = boost::any(*dagNotificationSuccess);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("DagNotificationFail") != m.end() && !m["DagNotificationFail"].empty()) {
      dagNotificationFail = make_shared<bool>(boost::any_cast<bool>(m["DagNotificationFail"]));
    }
    if (m.find("DagNotificationSla") != m.end() && !m["DagNotificationSla"].empty()) {
      dagNotificationSla = make_shared<bool>(boost::any_cast<bool>(m["DagNotificationSla"]));
    }
    if (m.find("DagNotificationSuccess") != m.end() && !m["DagNotificationSuccess"].empty()) {
      dagNotificationSuccess = make_shared<bool>(boost::any_cast<bool>(m["DagNotificationSuccess"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskFlowNotificationRequest() = default;
};
class UpdateTaskFlowNotificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskFlowNotificationResponseBody() {}

  explicit UpdateTaskFlowNotificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskFlowNotificationResponseBody() = default;
};
class UpdateTaskFlowNotificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskFlowNotificationResponseBody> body{};

  UpdateTaskFlowNotificationResponse() {}

  explicit UpdateTaskFlowNotificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskFlowNotificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskFlowNotificationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskFlowNotificationResponse() = default;
};
class UpdateTaskFlowOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> newOwnerId{};
  shared_ptr<long> tid{};

  UpdateTaskFlowOwnerRequest() {}

  explicit UpdateTaskFlowOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (newOwnerId) {
      res["NewOwnerId"] = boost::any(*newOwnerId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("NewOwnerId") != m.end() && !m["NewOwnerId"].empty()) {
      newOwnerId = make_shared<string>(boost::any_cast<string>(m["NewOwnerId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskFlowOwnerRequest() = default;
};
class UpdateTaskFlowOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskFlowOwnerResponseBody() {}

  explicit UpdateTaskFlowOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskFlowOwnerResponseBody() = default;
};
class UpdateTaskFlowOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskFlowOwnerResponseBody> body{};

  UpdateTaskFlowOwnerResponse() {}

  explicit UpdateTaskFlowOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskFlowOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskFlowOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskFlowOwnerResponse() = default;
};
class UpdateTaskFlowRelationsRequestEdges : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> nodeEnd{};
  shared_ptr<long> nodeFrom{};

  UpdateTaskFlowRelationsRequestEdges() {}

  explicit UpdateTaskFlowRelationsRequestEdges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nodeEnd) {
      res["NodeEnd"] = boost::any(*nodeEnd);
    }
    if (nodeFrom) {
      res["NodeFrom"] = boost::any(*nodeFrom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NodeEnd") != m.end() && !m["NodeEnd"].empty()) {
      nodeEnd = make_shared<long>(boost::any_cast<long>(m["NodeEnd"]));
    }
    if (m.find("NodeFrom") != m.end() && !m["NodeFrom"].empty()) {
      nodeFrom = make_shared<long>(boost::any_cast<long>(m["NodeFrom"]));
    }
  }


  virtual ~UpdateTaskFlowRelationsRequestEdges() = default;
};
class UpdateTaskFlowRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<vector<UpdateTaskFlowRelationsRequestEdges>> edges{};
  shared_ptr<long> tid{};

  UpdateTaskFlowRelationsRequest() {}

  explicit UpdateTaskFlowRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (edges) {
      vector<boost::any> temp1;
      for(auto item1:*edges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Edges"] = boost::any(temp1);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Edges") != m.end() && !m["Edges"].empty()) {
      if (typeid(vector<boost::any>) == m["Edges"].type()) {
        vector<UpdateTaskFlowRelationsRequestEdges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Edges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTaskFlowRelationsRequestEdges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        edges = make_shared<vector<UpdateTaskFlowRelationsRequestEdges>>(expect1);
      }
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskFlowRelationsRequest() = default;
};
class UpdateTaskFlowRelationsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> edgesShrink{};
  shared_ptr<long> tid{};

  UpdateTaskFlowRelationsShrinkRequest() {}

  explicit UpdateTaskFlowRelationsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (edgesShrink) {
      res["Edges"] = boost::any(*edgesShrink);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Edges") != m.end() && !m["Edges"].empty()) {
      edgesShrink = make_shared<string>(boost::any_cast<string>(m["Edges"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskFlowRelationsShrinkRequest() = default;
};
class UpdateTaskFlowRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskFlowRelationsResponseBody() {}

  explicit UpdateTaskFlowRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskFlowRelationsResponseBody() = default;
};
class UpdateTaskFlowRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskFlowRelationsResponseBody> body{};

  UpdateTaskFlowRelationsResponse() {}

  explicit UpdateTaskFlowRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskFlowRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskFlowRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskFlowRelationsResponse() = default;
};
class UpdateTaskFlowScheduleRequest : public Darabonba::Model {
public:
  shared_ptr<string> cronBeginDate{};
  shared_ptr<string> cronEndDate{};
  shared_ptr<string> cronStr{};
  shared_ptr<string> cronType{};
  shared_ptr<long> dagId{};
  shared_ptr<string> scheduleParam{};
  shared_ptr<bool> scheduleSwitch{};
  shared_ptr<long> tid{};
  shared_ptr<string> timeZoneId{};
  shared_ptr<string> triggerType{};

  UpdateTaskFlowScheduleRequest() {}

  explicit UpdateTaskFlowScheduleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronBeginDate) {
      res["CronBeginDate"] = boost::any(*cronBeginDate);
    }
    if (cronEndDate) {
      res["CronEndDate"] = boost::any(*cronEndDate);
    }
    if (cronStr) {
      res["CronStr"] = boost::any(*cronStr);
    }
    if (cronType) {
      res["CronType"] = boost::any(*cronType);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (scheduleParam) {
      res["ScheduleParam"] = boost::any(*scheduleParam);
    }
    if (scheduleSwitch) {
      res["ScheduleSwitch"] = boost::any(*scheduleSwitch);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (timeZoneId) {
      res["TimeZoneId"] = boost::any(*timeZoneId);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CronBeginDate") != m.end() && !m["CronBeginDate"].empty()) {
      cronBeginDate = make_shared<string>(boost::any_cast<string>(m["CronBeginDate"]));
    }
    if (m.find("CronEndDate") != m.end() && !m["CronEndDate"].empty()) {
      cronEndDate = make_shared<string>(boost::any_cast<string>(m["CronEndDate"]));
    }
    if (m.find("CronStr") != m.end() && !m["CronStr"].empty()) {
      cronStr = make_shared<string>(boost::any_cast<string>(m["CronStr"]));
    }
    if (m.find("CronType") != m.end() && !m["CronType"].empty()) {
      cronType = make_shared<string>(boost::any_cast<string>(m["CronType"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("ScheduleParam") != m.end() && !m["ScheduleParam"].empty()) {
      scheduleParam = make_shared<string>(boost::any_cast<string>(m["ScheduleParam"]));
    }
    if (m.find("ScheduleSwitch") != m.end() && !m["ScheduleSwitch"].empty()) {
      scheduleSwitch = make_shared<bool>(boost::any_cast<bool>(m["ScheduleSwitch"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("TimeZoneId") != m.end() && !m["TimeZoneId"].empty()) {
      timeZoneId = make_shared<string>(boost::any_cast<string>(m["TimeZoneId"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~UpdateTaskFlowScheduleRequest() = default;
};
class UpdateTaskFlowScheduleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskFlowScheduleResponseBody() {}

  explicit UpdateTaskFlowScheduleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskFlowScheduleResponseBody() = default;
};
class UpdateTaskFlowScheduleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskFlowScheduleResponseBody> body{};

  UpdateTaskFlowScheduleResponse() {}

  explicit UpdateTaskFlowScheduleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskFlowScheduleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskFlowScheduleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskFlowScheduleResponse() = default;
};
class UpdateTaskFlowTimeVariablesRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<long> tid{};
  shared_ptr<string> timeVariables{};

  UpdateTaskFlowTimeVariablesRequest() {}

  explicit UpdateTaskFlowTimeVariablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (timeVariables) {
      res["TimeVariables"] = boost::any(*timeVariables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("TimeVariables") != m.end() && !m["TimeVariables"].empty()) {
      timeVariables = make_shared<string>(boost::any_cast<string>(m["TimeVariables"]));
    }
  }


  virtual ~UpdateTaskFlowTimeVariablesRequest() = default;
};
class UpdateTaskFlowTimeVariablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskFlowTimeVariablesResponseBody() {}

  explicit UpdateTaskFlowTimeVariablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskFlowTimeVariablesResponseBody() = default;
};
class UpdateTaskFlowTimeVariablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskFlowTimeVariablesResponseBody> body{};

  UpdateTaskFlowTimeVariablesResponse() {}

  explicit UpdateTaskFlowTimeVariablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskFlowTimeVariablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskFlowTimeVariablesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskFlowTimeVariablesResponse() = default;
};
class UpdateTaskNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> tid{};

  UpdateTaskNameRequest() {}

  explicit UpdateTaskNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskNameRequest() = default;
};
class UpdateTaskNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskNameResponseBody() {}

  explicit UpdateTaskNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskNameResponseBody() = default;
};
class UpdateTaskNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskNameResponseBody> body{};

  UpdateTaskNameResponse() {}

  explicit UpdateTaskNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskNameResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskNameResponse() = default;
};
class UpdateTaskOutputRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeOutput{};
  shared_ptr<long> tid{};

  UpdateTaskOutputRequest() {}

  explicit UpdateTaskOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeOutput) {
      res["NodeOutput"] = boost::any(*nodeOutput);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeOutput") != m.end() && !m["NodeOutput"].empty()) {
      nodeOutput = make_shared<string>(boost::any_cast<string>(m["NodeOutput"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
  }


  virtual ~UpdateTaskOutputRequest() = default;
};
class UpdateTaskOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskOutputResponseBody() {}

  explicit UpdateTaskOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskOutputResponseBody() = default;
};
class UpdateTaskOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskOutputResponseBody> body{};

  UpdateTaskOutputResponse() {}

  explicit UpdateTaskOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskOutputResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskOutputResponse() = default;
};
class UpdateTaskTimeVariablesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<long> tid{};
  shared_ptr<string> timeVariables{};

  UpdateTaskTimeVariablesRequest() {}

  explicit UpdateTaskTimeVariablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (timeVariables) {
      res["TimeVariables"] = boost::any(*timeVariables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("TimeVariables") != m.end() && !m["TimeVariables"].empty()) {
      timeVariables = make_shared<string>(boost::any_cast<string>(m["TimeVariables"]));
    }
  }


  virtual ~UpdateTaskTimeVariablesRequest() = default;
};
class UpdateTaskTimeVariablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTaskTimeVariablesResponseBody() {}

  explicit UpdateTaskTimeVariablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTaskTimeVariablesResponseBody() = default;
};
class UpdateTaskTimeVariablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTaskTimeVariablesResponseBody> body{};

  UpdateTaskTimeVariablesResponse() {}

  explicit UpdateTaskTimeVariablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTaskTimeVariablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTaskTimeVariablesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTaskTimeVariablesResponse() = default;
};
class UpdateUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxExecuteCount{};
  shared_ptr<long> maxResultCount{};
  shared_ptr<string> mobile{};
  shared_ptr<string> roleNames{};
  shared_ptr<long> tid{};
  shared_ptr<long> uid{};
  shared_ptr<string> userNick{};

  UpdateUserRequest() {}

  explicit UpdateUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxExecuteCount) {
      res["MaxExecuteCount"] = boost::any(*maxExecuteCount);
    }
    if (maxResultCount) {
      res["MaxResultCount"] = boost::any(*maxResultCount);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (roleNames) {
      res["RoleNames"] = boost::any(*roleNames);
    }
    if (tid) {
      res["Tid"] = boost::any(*tid);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (userNick) {
      res["UserNick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxExecuteCount") != m.end() && !m["MaxExecuteCount"].empty()) {
      maxExecuteCount = make_shared<long>(boost::any_cast<long>(m["MaxExecuteCount"]));
    }
    if (m.find("MaxResultCount") != m.end() && !m["MaxResultCount"].empty()) {
      maxResultCount = make_shared<long>(boost::any_cast<long>(m["MaxResultCount"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("RoleNames") != m.end() && !m["RoleNames"].empty()) {
      roleNames = make_shared<string>(boost::any_cast<string>(m["RoleNames"]));
    }
    if (m.find("Tid") != m.end() && !m["Tid"].empty()) {
      tid = make_shared<long>(boost::any_cast<long>(m["Tid"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<long>(boost::any_cast<long>(m["Uid"]));
    }
    if (m.find("UserNick") != m.end() && !m["UserNick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["UserNick"]));
    }
  }


  virtual ~UpdateUserRequest() = default;
};
class UpdateUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateUserResponseBody() {}

  explicit UpdateUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateUserResponseBody() = default;
};
class UpdateUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUserResponseBody> body{};

  UpdateUserResponse() {}

  explicit UpdateUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddDesensitizationRuleResponse addDesensitizationRuleWithOptions(shared_ptr<AddDesensitizationRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDesensitizationRuleResponse addDesensitizationRule(shared_ptr<AddDesensitizationRuleRequest> request);
  AddInstanceResponse addInstanceWithOptions(shared_ptr<AddInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddInstanceResponse addInstance(shared_ptr<AddInstanceRequest> request);
  AddLhMembersResponse addLhMembersWithOptions(shared_ptr<AddLhMembersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLhMembersResponse addLhMembers(shared_ptr<AddLhMembersRequest> request);
  AddLogicTableRouteConfigResponse addLogicTableRouteConfigWithOptions(shared_ptr<AddLogicTableRouteConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddLogicTableRouteConfigResponse addLogicTableRouteConfig(shared_ptr<AddLogicTableRouteConfigRequest> request);
  AddTaskFlowEdgesResponse addTaskFlowEdgesWithOptions(shared_ptr<AddTaskFlowEdgesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTaskFlowEdgesResponse addTaskFlowEdges(shared_ptr<AddTaskFlowEdgesRequest> request);
  AnalyzeSQLLineageResponse analyzeSQLLineageWithOptions(shared_ptr<AnalyzeSQLLineageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AnalyzeSQLLineageResponse analyzeSQLLineage(shared_ptr<AnalyzeSQLLineageRequest> request);
  ApproveOrderResponse approveOrderWithOptions(shared_ptr<ApproveOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApproveOrderResponse approveOrder(shared_ptr<ApproveOrderRequest> request);
  BackFillResponse backFillWithOptions(shared_ptr<BackFillRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BackFillResponse backFill(shared_ptr<BackFillRequest> request);
  BuyPayAsYouGoOrderResponse buyPayAsYouGoOrderWithOptions(shared_ptr<BuyPayAsYouGoOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BuyPayAsYouGoOrderResponse buyPayAsYouGoOrder(shared_ptr<BuyPayAsYouGoOrderRequest> request);
  ChangeColumnSecLevelResponse changeColumnSecLevelWithOptions(shared_ptr<ChangeColumnSecLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeColumnSecLevelResponse changeColumnSecLevel(shared_ptr<ChangeColumnSecLevelRequest> request);
  ChangeColumnSecurityLevelResponse changeColumnSecurityLevelWithOptions(shared_ptr<ChangeColumnSecurityLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeColumnSecurityLevelResponse changeColumnSecurityLevel(shared_ptr<ChangeColumnSecurityLevelRequest> request);
  ChangeLhDagOwnerResponse changeLhDagOwnerWithOptions(shared_ptr<ChangeLhDagOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeLhDagOwnerResponse changeLhDagOwner(shared_ptr<ChangeLhDagOwnerRequest> request);
  CloseOrderResponse closeOrderWithOptions(shared_ptr<CloseOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseOrderResponse closeOrder(shared_ptr<CloseOrderRequest> request);
  CreateAuthorityTemplateResponse createAuthorityTemplateWithOptions(shared_ptr<CreateAuthorityTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAuthorityTemplateResponse createAuthorityTemplate(shared_ptr<CreateAuthorityTemplateRequest> request);
  CreateDataArchiveOrderResponse createDataArchiveOrderWithOptions(shared_ptr<CreateDataArchiveOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataArchiveOrderResponse createDataArchiveOrder(shared_ptr<CreateDataArchiveOrderRequest> request);
  CreateDataCorrectOrderResponse createDataCorrectOrderWithOptions(shared_ptr<CreateDataCorrectOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataCorrectOrderResponse createDataCorrectOrder(shared_ptr<CreateDataCorrectOrderRequest> request);
  CreateDataCronClearOrderResponse createDataCronClearOrderWithOptions(shared_ptr<CreateDataCronClearOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataCronClearOrderResponse createDataCronClearOrder(shared_ptr<CreateDataCronClearOrderRequest> request);
  CreateDataExportOrderResponse createDataExportOrderWithOptions(shared_ptr<CreateDataExportOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataExportOrderResponse createDataExportOrder(shared_ptr<CreateDataExportOrderRequest> request);
  CreateDataImportOrderResponse createDataImportOrderWithOptions(shared_ptr<CreateDataImportOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataImportOrderResponse createDataImportOrder(shared_ptr<CreateDataImportOrderRequest> request);
  CreateDataTrackOrderResponse createDataTrackOrderWithOptions(shared_ptr<CreateDataTrackOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataTrackOrderResponse createDataTrackOrder(shared_ptr<CreateDataTrackOrderRequest> request);
  CreateDatabaseExportOrderResponse createDatabaseExportOrderWithOptions(shared_ptr<CreateDatabaseExportOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDatabaseExportOrderResponse createDatabaseExportOrder(shared_ptr<CreateDatabaseExportOrderRequest> request);
  CreateFreeLockCorrectOrderResponse createFreeLockCorrectOrderWithOptions(shared_ptr<CreateFreeLockCorrectOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFreeLockCorrectOrderResponse createFreeLockCorrectOrder(shared_ptr<CreateFreeLockCorrectOrderRequest> request);
  CreateLakeHouseSpaceResponse createLakeHouseSpaceWithOptions(shared_ptr<CreateLakeHouseSpaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLakeHouseSpaceResponse createLakeHouseSpace(shared_ptr<CreateLakeHouseSpaceRequest> request);
  CreateLogicDatabaseResponse createLogicDatabaseWithOptions(shared_ptr<CreateLogicDatabaseRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLogicDatabaseResponse createLogicDatabase(shared_ptr<CreateLogicDatabaseRequest> request);
  CreateOrderResponse createOrderWithOptions(shared_ptr<CreateOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrderResponse createOrder(shared_ptr<CreateOrderRequest> request);
  CreateProcCorrectOrderResponse createProcCorrectOrderWithOptions(shared_ptr<CreateProcCorrectOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProcCorrectOrderResponse createProcCorrectOrder(shared_ptr<CreateProcCorrectOrderRequest> request);
  CreateProxyResponse createProxyWithOptions(shared_ptr<CreateProxyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProxyResponse createProxy(shared_ptr<CreateProxyRequest> request);
  CreateProxyAccessResponse createProxyAccessWithOptions(shared_ptr<CreateProxyAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProxyAccessResponse createProxyAccess(shared_ptr<CreateProxyAccessRequest> request);
  CreatePublishGroupTaskResponse createPublishGroupTaskWithOptions(shared_ptr<CreatePublishGroupTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePublishGroupTaskResponse createPublishGroupTask(shared_ptr<CreatePublishGroupTaskRequest> request);
  CreateSQLReviewOrderResponse createSQLReviewOrderWithOptions(shared_ptr<CreateSQLReviewOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSQLReviewOrderResponse createSQLReviewOrder(shared_ptr<CreateSQLReviewOrderRequest> request);
  CreateScenarioResponse createScenarioWithOptions(shared_ptr<CreateScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScenarioResponse createScenario(shared_ptr<CreateScenarioRequest> request);
  CreateStandardGroupResponse createStandardGroupWithOptions(shared_ptr<CreateStandardGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateStandardGroupResponse createStandardGroup(shared_ptr<CreateStandardGroupRequest> request);
  CreateStructSyncOrderResponse createStructSyncOrderWithOptions(shared_ptr<CreateStructSyncOrderRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateStructSyncOrderResponse createStructSyncOrder(shared_ptr<CreateStructSyncOrderRequest> request);
  CreateTaskResponse createTaskWithOptions(shared_ptr<CreateTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTaskResponse createTask(shared_ptr<CreateTaskRequest> request);
  CreateTaskFlowResponse createTaskFlowWithOptions(shared_ptr<CreateTaskFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTaskFlowResponse createTaskFlow(shared_ptr<CreateTaskFlowRequest> request);
  CreateUploadFileJobResponse createUploadFileJobWithOptions(shared_ptr<CreateUploadFileJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUploadFileJobResponse createUploadFileJob(shared_ptr<CreateUploadFileJobRequest> request);
  CreateUploadOSSFileJobResponse createUploadOSSFileJobWithOptions(shared_ptr<CreateUploadOSSFileJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUploadOSSFileJobResponse createUploadOSSFileJob(shared_ptr<CreateUploadOSSFileJobRequest> request);
  DeleteAuthorityTemplateResponse deleteAuthorityTemplateWithOptions(shared_ptr<DeleteAuthorityTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAuthorityTemplateResponse deleteAuthorityTemplate(shared_ptr<DeleteAuthorityTemplateRequest> request);
  DeleteInstanceResponse deleteInstanceWithOptions(shared_ptr<DeleteInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstanceResponse deleteInstance(shared_ptr<DeleteInstanceRequest> request);
  DeleteLakeHouseSpaceResponse deleteLakeHouseSpaceWithOptions(shared_ptr<DeleteLakeHouseSpaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLakeHouseSpaceResponse deleteLakeHouseSpace(shared_ptr<DeleteLakeHouseSpaceRequest> request);
  DeleteLhMembersResponse deleteLhMembersWithOptions(shared_ptr<DeleteLhMembersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLhMembersResponse deleteLhMembers(shared_ptr<DeleteLhMembersRequest> request);
  DeleteLogicDatabaseResponse deleteLogicDatabaseWithOptions(shared_ptr<DeleteLogicDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLogicDatabaseResponse deleteLogicDatabase(shared_ptr<DeleteLogicDatabaseRequest> request);
  DeleteLogicTableRouteConfigResponse deleteLogicTableRouteConfigWithOptions(shared_ptr<DeleteLogicTableRouteConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLogicTableRouteConfigResponse deleteLogicTableRouteConfig(shared_ptr<DeleteLogicTableRouteConfigRequest> request);
  DeleteProxyResponse deleteProxyWithOptions(shared_ptr<DeleteProxyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProxyResponse deleteProxy(shared_ptr<DeleteProxyRequest> request);
  DeleteProxyAccessResponse deleteProxyAccessWithOptions(shared_ptr<DeleteProxyAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProxyAccessResponse deleteProxyAccess(shared_ptr<DeleteProxyAccessRequest> request);
  DeleteScenarioResponse deleteScenarioWithOptions(shared_ptr<DeleteScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScenarioResponse deleteScenario(shared_ptr<DeleteScenarioRequest> request);
  DeleteStandardGroupResponse deleteStandardGroupWithOptions(shared_ptr<DeleteStandardGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStandardGroupResponse deleteStandardGroup(shared_ptr<DeleteStandardGroupRequest> request);
  DeleteTaskResponse deleteTaskWithOptions(shared_ptr<DeleteTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTaskResponse deleteTask(shared_ptr<DeleteTaskRequest> request);
  DeleteTaskFlowResponse deleteTaskFlowWithOptions(shared_ptr<DeleteTaskFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTaskFlowResponse deleteTaskFlow(shared_ptr<DeleteTaskFlowRequest> request);
  DeleteTaskFlowEdgesByConditionResponse deleteTaskFlowEdgesByConditionWithOptions(shared_ptr<DeleteTaskFlowEdgesByConditionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTaskFlowEdgesByConditionResponse deleteTaskFlowEdgesByCondition(shared_ptr<DeleteTaskFlowEdgesByConditionRequest> request);
  DeleteUserResponse deleteUserWithOptions(shared_ptr<DeleteUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserResponse deleteUser(shared_ptr<DeleteUserRequest> request);
  DisableUserResponse disableUserWithOptions(shared_ptr<DisableUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableUserResponse disableUser(shared_ptr<DisableUserRequest> request);
  DownloadDataTrackResultResponse downloadDataTrackResultWithOptions(shared_ptr<DownloadDataTrackResultRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadDataTrackResultResponse downloadDataTrackResult(shared_ptr<DownloadDataTrackResultRequest> request);
  EditLogicDatabaseResponse editLogicDatabaseWithOptions(shared_ptr<EditLogicDatabaseRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EditLogicDatabaseResponse editLogicDatabase(shared_ptr<EditLogicDatabaseRequest> request);
  EnableUserResponse enableUserWithOptions(shared_ptr<EnableUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableUserResponse enableUser(shared_ptr<EnableUserRequest> request);
  ExecuteDataCorrectResponse executeDataCorrectWithOptions(shared_ptr<ExecuteDataCorrectRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteDataCorrectResponse executeDataCorrect(shared_ptr<ExecuteDataCorrectRequest> request);
  ExecuteDataExportResponse executeDataExportWithOptions(shared_ptr<ExecuteDataExportRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteDataExportResponse executeDataExport(shared_ptr<ExecuteDataExportRequest> request);
  ExecuteScriptResponse executeScriptWithOptions(shared_ptr<ExecuteScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteScriptResponse executeScript(shared_ptr<ExecuteScriptRequest> request);
  ExecuteStructSyncResponse executeStructSyncWithOptions(shared_ptr<ExecuteStructSyncRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteStructSyncResponse executeStructSync(shared_ptr<ExecuteStructSyncRequest> request);
  GetApprovalDetailResponse getApprovalDetailWithOptions(shared_ptr<GetApprovalDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApprovalDetailResponse getApprovalDetail(shared_ptr<GetApprovalDetailRequest> request);
  GetAuthorityTemplateResponse getAuthorityTemplateWithOptions(shared_ptr<GetAuthorityTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAuthorityTemplateResponse getAuthorityTemplate(shared_ptr<GetAuthorityTemplateRequest> request);
  GetAuthorityTemplateItemResponse getAuthorityTemplateItemWithOptions(shared_ptr<GetAuthorityTemplateItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAuthorityTemplateItemResponse getAuthorityTemplateItem(shared_ptr<GetAuthorityTemplateItemRequest> request);
  GetClassificationTemplateResponse getClassificationTemplateWithOptions(shared_ptr<GetClassificationTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClassificationTemplateResponse getClassificationTemplate(shared_ptr<GetClassificationTemplateRequest> request);
  GetDBTaskSQLJobLogResponse getDBTaskSQLJobLogWithOptions(shared_ptr<GetDBTaskSQLJobLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDBTaskSQLJobLogResponse getDBTaskSQLJobLog(shared_ptr<GetDBTaskSQLJobLogRequest> request);
  GetDBTopologyResponse getDBTopologyWithOptions(shared_ptr<GetDBTopologyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDBTopologyResponse getDBTopology(shared_ptr<GetDBTopologyRequest> request);
  GetDataArchiveCountResponse getDataArchiveCountWithOptions(shared_ptr<GetDataArchiveCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataArchiveCountResponse getDataArchiveCount(shared_ptr<GetDataArchiveCountRequest> request);
  GetDataArchiveOrderDetailResponse getDataArchiveOrderDetailWithOptions(shared_ptr<GetDataArchiveOrderDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataArchiveOrderDetailResponse getDataArchiveOrderDetail(shared_ptr<GetDataArchiveOrderDetailRequest> request);
  GetDataCorrectBackupFilesResponse getDataCorrectBackupFilesWithOptions(shared_ptr<GetDataCorrectBackupFilesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataCorrectBackupFilesResponse getDataCorrectBackupFiles(shared_ptr<GetDataCorrectBackupFilesRequest> request);
  GetDataCorrectOrderDetailResponse getDataCorrectOrderDetailWithOptions(shared_ptr<GetDataCorrectOrderDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataCorrectOrderDetailResponse getDataCorrectOrderDetail(shared_ptr<GetDataCorrectOrderDetailRequest> request);
  GetDataCorrectRollbackFileResponse getDataCorrectRollbackFileWithOptions(shared_ptr<GetDataCorrectRollbackFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataCorrectRollbackFileResponse getDataCorrectRollbackFile(shared_ptr<GetDataCorrectRollbackFileRequest> request);
  GetDataCorrectSQLFileResponse getDataCorrectSQLFileWithOptions(shared_ptr<GetDataCorrectSQLFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataCorrectSQLFileResponse getDataCorrectSQLFile(shared_ptr<GetDataCorrectSQLFileRequest> request);
  GetDataCorrectTaskDetailResponse getDataCorrectTaskDetailWithOptions(shared_ptr<GetDataCorrectTaskDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataCorrectTaskDetailResponse getDataCorrectTaskDetail(shared_ptr<GetDataCorrectTaskDetailRequest> request);
  GetDataCronClearConfigResponse getDataCronClearConfigWithOptions(shared_ptr<GetDataCronClearConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataCronClearConfigResponse getDataCronClearConfig(shared_ptr<GetDataCronClearConfigRequest> request);
  GetDataCronClearTaskDetailListResponse getDataCronClearTaskDetailListWithOptions(shared_ptr<GetDataCronClearTaskDetailListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataCronClearTaskDetailListResponse getDataCronClearTaskDetailList(shared_ptr<GetDataCronClearTaskDetailListRequest> request);
  GetDataExportDownloadURLResponse getDataExportDownloadURLWithOptions(shared_ptr<GetDataExportDownloadURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataExportDownloadURLResponse getDataExportDownloadURL(shared_ptr<GetDataExportDownloadURLRequest> request);
  GetDataExportOrderDetailResponse getDataExportOrderDetailWithOptions(shared_ptr<GetDataExportOrderDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataExportOrderDetailResponse getDataExportOrderDetail(shared_ptr<GetDataExportOrderDetailRequest> request);
  GetDataExportPreCheckDetailResponse getDataExportPreCheckDetailWithOptions(shared_ptr<GetDataExportPreCheckDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataExportPreCheckDetailResponse getDataExportPreCheckDetail(shared_ptr<GetDataExportPreCheckDetailRequest> request);
  GetDataImportSQLResponse getDataImportSQLWithOptions(shared_ptr<GetDataImportSQLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataImportSQLResponse getDataImportSQL(shared_ptr<GetDataImportSQLRequest> request);
  GetDataTrackJobDegreeResponse getDataTrackJobDegreeWithOptions(shared_ptr<GetDataTrackJobDegreeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataTrackJobDegreeResponse getDataTrackJobDegree(shared_ptr<GetDataTrackJobDegreeRequest> request);
  GetDataTrackJobTableMetaResponse getDataTrackJobTableMetaWithOptions(shared_ptr<GetDataTrackJobTableMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataTrackJobTableMetaResponse getDataTrackJobTableMeta(shared_ptr<GetDataTrackJobTableMetaRequest> request);
  GetDataTrackOrderDetailResponse getDataTrackOrderDetailWithOptions(shared_ptr<GetDataTrackOrderDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataTrackOrderDetailResponse getDataTrackOrderDetail(shared_ptr<GetDataTrackOrderDetailRequest> request);
  GetDatabaseResponse getDatabaseWithOptions(shared_ptr<GetDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDatabaseResponse getDatabase(shared_ptr<GetDatabaseRequest> request);
  GetDatabaseExportOrderDetailResponse getDatabaseExportOrderDetailWithOptions(shared_ptr<GetDatabaseExportOrderDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDatabaseExportOrderDetailResponse getDatabaseExportOrderDetail(shared_ptr<GetDatabaseExportOrderDetailRequest> request);
  GetDbExportDownloadURLResponse getDbExportDownloadURLWithOptions(shared_ptr<GetDbExportDownloadURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDbExportDownloadURLResponse getDbExportDownloadURL(shared_ptr<GetDbExportDownloadURLRequest> request);
  GetInstanceResponse getInstanceWithOptions(shared_ptr<GetInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceResponse getInstance(shared_ptr<GetInstanceRequest> request);
  GetIntervalLimitOfSLAResponse getIntervalLimitOfSLAWithOptions(shared_ptr<GetIntervalLimitOfSLARequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIntervalLimitOfSLAResponse getIntervalLimitOfSLA(shared_ptr<GetIntervalLimitOfSLARequest> request);
  GetLhSpaceByNameResponse getLhSpaceByNameWithOptions(shared_ptr<GetLhSpaceByNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLhSpaceByNameResponse getLhSpaceByName(shared_ptr<GetLhSpaceByNameRequest> request);
  GetLogicDatabaseResponse getLogicDatabaseWithOptions(shared_ptr<GetLogicDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLogicDatabaseResponse getLogicDatabase(shared_ptr<GetLogicDatabaseRequest> request);
  GetMetaTableColumnResponse getMetaTableColumnWithOptions(shared_ptr<GetMetaTableColumnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableColumnResponse getMetaTableColumn(shared_ptr<GetMetaTableColumnRequest> request);
  GetMetaTableDetailInfoResponse getMetaTableDetailInfoWithOptions(shared_ptr<GetMetaTableDetailInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableDetailInfoResponse getMetaTableDetailInfo(shared_ptr<GetMetaTableDetailInfoRequest> request);
  GetOnlineDDLProgressResponse getOnlineDDLProgressWithOptions(shared_ptr<GetOnlineDDLProgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOnlineDDLProgressResponse getOnlineDDLProgress(shared_ptr<GetOnlineDDLProgressRequest> request);
  GetOpLogResponse getOpLogWithOptions(shared_ptr<GetOpLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOpLogResponse getOpLog(shared_ptr<GetOpLogRequest> request);
  GetOrderAttachmentFileResponse getOrderAttachmentFileWithOptions(shared_ptr<GetOrderAttachmentFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOrderAttachmentFileResponse getOrderAttachmentFile(shared_ptr<GetOrderAttachmentFileRequest> request);
  GetOrderBaseInfoResponse getOrderBaseInfoWithOptions(shared_ptr<GetOrderBaseInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOrderBaseInfoResponse getOrderBaseInfo(shared_ptr<GetOrderBaseInfoRequest> request);
  GetOwnerApplyOrderDetailResponse getOwnerApplyOrderDetailWithOptions(shared_ptr<GetOwnerApplyOrderDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOwnerApplyOrderDetailResponse getOwnerApplyOrderDetail(shared_ptr<GetOwnerApplyOrderDetailRequest> request);
  GetPagedInstanceResponse getPagedInstanceWithOptions(shared_ptr<GetPagedInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPagedInstanceResponse getPagedInstance(shared_ptr<GetPagedInstanceRequest> request);
  GetPermApplyOrderDetailResponse getPermApplyOrderDetailWithOptions(shared_ptr<GetPermApplyOrderDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPermApplyOrderDetailResponse getPermApplyOrderDetail(shared_ptr<GetPermApplyOrderDetailRequest> request);
  GetPhysicalDatabaseResponse getPhysicalDatabaseWithOptions(shared_ptr<GetPhysicalDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPhysicalDatabaseResponse getPhysicalDatabase(shared_ptr<GetPhysicalDatabaseRequest> request);
  GetProxyResponse getProxyWithOptions(shared_ptr<GetProxyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProxyResponse getProxy(shared_ptr<GetProxyRequest> request);
  GetProxyAccessResponse getProxyAccessWithOptions(shared_ptr<GetProxyAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProxyAccessResponse getProxyAccess(shared_ptr<GetProxyAccessRequest> request);
  GetRuleNumLimitOfSLAResponse getRuleNumLimitOfSLAWithOptions(shared_ptr<GetRuleNumLimitOfSLARequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRuleNumLimitOfSLAResponse getRuleNumLimitOfSLA(shared_ptr<GetRuleNumLimitOfSLARequest> request);
  GetSQLReviewCheckResultStatusResponse getSQLReviewCheckResultStatusWithOptions(shared_ptr<GetSQLReviewCheckResultStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSQLReviewCheckResultStatusResponse getSQLReviewCheckResultStatus(shared_ptr<GetSQLReviewCheckResultStatusRequest> request);
  GetSQLReviewOptimizeDetailResponse getSQLReviewOptimizeDetailWithOptions(shared_ptr<GetSQLReviewOptimizeDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSQLReviewOptimizeDetailResponse getSQLReviewOptimizeDetail(shared_ptr<GetSQLReviewOptimizeDetailRequest> request);
  GetStandardGroupResponse getStandardGroupWithOptions(shared_ptr<GetStandardGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetStandardGroupResponse getStandardGroup(shared_ptr<GetStandardGroupRequest> request);
  GetStructSyncExecSqlDetailResponse getStructSyncExecSqlDetailWithOptions(shared_ptr<GetStructSyncExecSqlDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetStructSyncExecSqlDetailResponse getStructSyncExecSqlDetail(shared_ptr<GetStructSyncExecSqlDetailRequest> request);
  GetStructSyncJobAnalyzeResultResponse getStructSyncJobAnalyzeResultWithOptions(shared_ptr<GetStructSyncJobAnalyzeResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetStructSyncJobAnalyzeResultResponse getStructSyncJobAnalyzeResult(shared_ptr<GetStructSyncJobAnalyzeResultRequest> request);
  GetStructSyncJobDetailResponse getStructSyncJobDetailWithOptions(shared_ptr<GetStructSyncJobDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetStructSyncJobDetailResponse getStructSyncJobDetail(shared_ptr<GetStructSyncJobDetailRequest> request);
  GetStructSyncOrderDetailResponse getStructSyncOrderDetailWithOptions(shared_ptr<GetStructSyncOrderDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetStructSyncOrderDetailResponse getStructSyncOrderDetail(shared_ptr<GetStructSyncOrderDetailRequest> request);
  GetTableDBTopologyResponse getTableDBTopologyWithOptions(shared_ptr<GetTableDBTopologyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTableDBTopologyResponse getTableDBTopology(shared_ptr<GetTableDBTopologyRequest> request);
  GetTableTopologyResponse getTableTopologyWithOptions(shared_ptr<GetTableTopologyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTableTopologyResponse getTableTopology(shared_ptr<GetTableTopologyRequest> request);
  GetTaskResponse getTaskWithOptions(shared_ptr<GetTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskResponse getTask(shared_ptr<GetTaskRequest> request);
  GetTaskFlowGraphResponse getTaskFlowGraphWithOptions(shared_ptr<GetTaskFlowGraphRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskFlowGraphResponse getTaskFlowGraph(shared_ptr<GetTaskFlowGraphRequest> request);
  GetTaskFlowNotificationResponse getTaskFlowNotificationWithOptions(shared_ptr<GetTaskFlowNotificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskFlowNotificationResponse getTaskFlowNotification(shared_ptr<GetTaskFlowNotificationRequest> request);
  GetTaskInstanceRelationResponse getTaskInstanceRelationWithOptions(shared_ptr<GetTaskInstanceRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskInstanceRelationResponse getTaskInstanceRelation(shared_ptr<GetTaskInstanceRelationRequest> request);
  GetUserResponse getUserWithOptions(shared_ptr<GetUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserResponse getUser(shared_ptr<GetUserRequest> request);
  GetUserActiveTenantResponse getUserActiveTenantWithOptions(shared_ptr<GetUserActiveTenantRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserActiveTenantResponse getUserActiveTenant(shared_ptr<GetUserActiveTenantRequest> request);
  GetUserUploadFileJobResponse getUserUploadFileJobWithOptions(shared_ptr<GetUserUploadFileJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserUploadFileJobResponse getUserUploadFileJob(shared_ptr<GetUserUploadFileJobRequest> request);
  GrantTemplateAuthorityResponse grantTemplateAuthorityWithOptions(shared_ptr<GrantTemplateAuthorityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantTemplateAuthorityResponse grantTemplateAuthority(shared_ptr<GrantTemplateAuthorityRequest> request);
  GrantUserPermissionResponse grantUserPermissionWithOptions(shared_ptr<GrantUserPermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantUserPermissionResponse grantUserPermission(shared_ptr<GrantUserPermissionRequest> request);
  InspectProxyAccessSecretResponse inspectProxyAccessSecretWithOptions(shared_ptr<InspectProxyAccessSecretRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InspectProxyAccessSecretResponse inspectProxyAccessSecret(shared_ptr<InspectProxyAccessSecretRequest> request);
  ListAuthorityTemplateResponse listAuthorityTemplateWithOptions(shared_ptr<ListAuthorityTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAuthorityTemplateResponse listAuthorityTemplate(shared_ptr<ListAuthorityTemplateRequest> request);
  ListClassificationTemplatesResponse listClassificationTemplatesWithOptions(shared_ptr<ListClassificationTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClassificationTemplatesResponse listClassificationTemplates(shared_ptr<ListClassificationTemplatesRequest> request);
  ListColumnsResponse listColumnsWithOptions(shared_ptr<ListColumnsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListColumnsResponse listColumns(shared_ptr<ListColumnsRequest> request);
  ListDAGVersionsResponse listDAGVersionsWithOptions(shared_ptr<ListDAGVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDAGVersionsResponse listDAGVersions(shared_ptr<ListDAGVersionsRequest> request);
  ListDBTaskSQLJobResponse listDBTaskSQLJobWithOptions(shared_ptr<ListDBTaskSQLJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDBTaskSQLJobResponse listDBTaskSQLJob(shared_ptr<ListDBTaskSQLJobRequest> request);
  ListDBTaskSQLJobDetailResponse listDBTaskSQLJobDetailWithOptions(shared_ptr<ListDBTaskSQLJobDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDBTaskSQLJobDetailResponse listDBTaskSQLJobDetail(shared_ptr<ListDBTaskSQLJobDetailRequest> request);
  ListDDLPublishRecordsResponse listDDLPublishRecordsWithOptions(shared_ptr<ListDDLPublishRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDDLPublishRecordsResponse listDDLPublishRecords(shared_ptr<ListDDLPublishRecordsRequest> request);
  ListDataCorrectPreCheckDBResponse listDataCorrectPreCheckDBWithOptions(shared_ptr<ListDataCorrectPreCheckDBRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataCorrectPreCheckDBResponse listDataCorrectPreCheckDB(shared_ptr<ListDataCorrectPreCheckDBRequest> request);
  ListDataCorrectPreCheckSQLResponse listDataCorrectPreCheckSQLWithOptions(shared_ptr<ListDataCorrectPreCheckSQLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataCorrectPreCheckSQLResponse listDataCorrectPreCheckSQL(shared_ptr<ListDataCorrectPreCheckSQLRequest> request);
  ListDataImportSQLPreCheckDetailResponse listDataImportSQLPreCheckDetailWithOptions(shared_ptr<ListDataImportSQLPreCheckDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataImportSQLPreCheckDetailResponse listDataImportSQLPreCheckDetail(shared_ptr<ListDataImportSQLPreCheckDetailRequest> request);
  ListDataImportSQLTypeResponse listDataImportSQLTypeWithOptions(shared_ptr<ListDataImportSQLTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataImportSQLTypeResponse listDataImportSQLType(shared_ptr<ListDataImportSQLTypeRequest> request);
  ListDatabaseUserPermssionsResponse listDatabaseUserPermssionsWithOptions(shared_ptr<ListDatabaseUserPermssionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatabaseUserPermssionsResponse listDatabaseUserPermssions(shared_ptr<ListDatabaseUserPermssionsRequest> request);
  ListDatabasesResponse listDatabasesWithOptions(shared_ptr<ListDatabasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatabasesResponse listDatabases(shared_ptr<ListDatabasesRequest> request);
  ListDefaultSLARulesResponse listDefaultSLARulesWithOptions(shared_ptr<ListDefaultSLARulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDefaultSLARulesResponse listDefaultSLARules(shared_ptr<ListDefaultSLARulesRequest> request);
  ListDesensitizationRuleResponse listDesensitizationRuleWithOptions(shared_ptr<ListDesensitizationRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDesensitizationRuleResponse listDesensitizationRule(shared_ptr<ListDesensitizationRuleRequest> request);
  ListEffectiveOrdersResponse listEffectiveOrdersWithOptions(shared_ptr<ListEffectiveOrdersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEffectiveOrdersResponse listEffectiveOrders(shared_ptr<ListEffectiveOrdersRequest> request);
  ListIndexesResponse listIndexesWithOptions(shared_ptr<ListIndexesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIndexesResponse listIndexes(shared_ptr<ListIndexesRequest> request);
  ListInstanceLoginAuditLogResponse listInstanceLoginAuditLogWithOptions(shared_ptr<ListInstanceLoginAuditLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceLoginAuditLogResponse listInstanceLoginAuditLog(shared_ptr<ListInstanceLoginAuditLogRequest> request);
  ListInstanceUserPermissionsResponse listInstanceUserPermissionsWithOptions(shared_ptr<ListInstanceUserPermissionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceUserPermissionsResponse listInstanceUserPermissions(shared_ptr<ListInstanceUserPermissionsRequest> request);
  ListInstancesResponse listInstancesWithOptions(shared_ptr<ListInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesResponse listInstances(shared_ptr<ListInstancesRequest> request);
  ListLhTaskFlowAndScenarioResponse listLhTaskFlowAndScenarioWithOptions(shared_ptr<ListLhTaskFlowAndScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLhTaskFlowAndScenarioResponse listLhTaskFlowAndScenario(shared_ptr<ListLhTaskFlowAndScenarioRequest> request);
  ListLogicDatabasesResponse listLogicDatabasesWithOptions(shared_ptr<ListLogicDatabasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLogicDatabasesResponse listLogicDatabases(shared_ptr<ListLogicDatabasesRequest> request);
  ListLogicTableRouteConfigResponse listLogicTableRouteConfigWithOptions(shared_ptr<ListLogicTableRouteConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLogicTableRouteConfigResponse listLogicTableRouteConfig(shared_ptr<ListLogicTableRouteConfigRequest> request);
  ListLogicTablesResponse listLogicTablesWithOptions(shared_ptr<ListLogicTablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLogicTablesResponse listLogicTables(shared_ptr<ListLogicTablesRequest> request);
  ListOrdersResponse listOrdersWithOptions(shared_ptr<ListOrdersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOrdersResponse listOrders(shared_ptr<ListOrdersRequest> request);
  ListProxiesResponse listProxiesWithOptions(shared_ptr<ListProxiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProxiesResponse listProxies(shared_ptr<ListProxiesRequest> request);
  ListProxyAccessesResponse listProxyAccessesWithOptions(shared_ptr<ListProxyAccessesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProxyAccessesResponse listProxyAccesses(shared_ptr<ListProxyAccessesRequest> request);
  ListProxySQLExecAuditLogResponse listProxySQLExecAuditLogWithOptions(shared_ptr<ListProxySQLExecAuditLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProxySQLExecAuditLogResponse listProxySQLExecAuditLog(shared_ptr<ListProxySQLExecAuditLogRequest> request);
  ListSLARulesResponse listSLARulesWithOptions(shared_ptr<ListSLARulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSLARulesResponse listSLARules(shared_ptr<ListSLARulesRequest> request);
  ListSQLExecAuditLogResponse listSQLExecAuditLogWithOptions(shared_ptr<ListSQLExecAuditLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSQLExecAuditLogResponse listSQLExecAuditLog(shared_ptr<ListSQLExecAuditLogRequest> request);
  ListSQLReviewOriginSQLResponse listSQLReviewOriginSQLWithOptions(shared_ptr<ListSQLReviewOriginSQLRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSQLReviewOriginSQLResponse listSQLReviewOriginSQL(shared_ptr<ListSQLReviewOriginSQLRequest> request);
  ListScenariosResponse listScenariosWithOptions(shared_ptr<ListScenariosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScenariosResponse listScenarios(shared_ptr<ListScenariosRequest> request);
  ListSensitiveColumnInfoResponse listSensitiveColumnInfoWithOptions(shared_ptr<ListSensitiveColumnInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSensitiveColumnInfoResponse listSensitiveColumnInfo(shared_ptr<ListSensitiveColumnInfoRequest> request);
  ListSensitiveColumnsResponse listSensitiveColumnsWithOptions(shared_ptr<ListSensitiveColumnsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSensitiveColumnsResponse listSensitiveColumns(shared_ptr<ListSensitiveColumnsRequest> request);
  ListSensitiveColumnsDetailResponse listSensitiveColumnsDetailWithOptions(shared_ptr<ListSensitiveColumnsDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSensitiveColumnsDetailResponse listSensitiveColumnsDetail(shared_ptr<ListSensitiveColumnsDetailRequest> request);
  ListSensitiveDataAuditLogResponse listSensitiveDataAuditLogWithOptions(shared_ptr<ListSensitiveDataAuditLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSensitiveDataAuditLogResponse listSensitiveDataAuditLog(shared_ptr<ListSensitiveDataAuditLogRequest> request);
  ListSensitivityLevelResponse listSensitivityLevelWithOptions(shared_ptr<ListSensitivityLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSensitivityLevelResponse listSensitivityLevel(shared_ptr<ListSensitivityLevelRequest> request);
  ListStandardGroupsResponse listStandardGroupsWithOptions(shared_ptr<ListStandardGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListStandardGroupsResponse listStandardGroups(shared_ptr<ListStandardGroupsRequest> request);
  ListTablesResponse listTablesWithOptions(shared_ptr<ListTablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTablesResponse listTables(shared_ptr<ListTablesRequest> request);
  ListTaskFlowResponse listTaskFlowWithOptions(shared_ptr<ListTaskFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskFlowResponse listTaskFlow(shared_ptr<ListTaskFlowRequest> request);
  ListTaskFlowConstantsResponse listTaskFlowConstantsWithOptions(shared_ptr<ListTaskFlowConstantsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskFlowConstantsResponse listTaskFlowConstants(shared_ptr<ListTaskFlowConstantsRequest> request);
  ListTaskFlowCooperatorsResponse listTaskFlowCooperatorsWithOptions(shared_ptr<ListTaskFlowCooperatorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskFlowCooperatorsResponse listTaskFlowCooperators(shared_ptr<ListTaskFlowCooperatorsRequest> request);
  ListTaskFlowEdgesByConditionResponse listTaskFlowEdgesByConditionWithOptions(shared_ptr<ListTaskFlowEdgesByConditionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskFlowEdgesByConditionResponse listTaskFlowEdgesByCondition(shared_ptr<ListTaskFlowEdgesByConditionRequest> request);
  ListTaskFlowInstanceResponse listTaskFlowInstanceWithOptions(shared_ptr<ListTaskFlowInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskFlowInstanceResponse listTaskFlowInstance(shared_ptr<ListTaskFlowInstanceRequest> request);
  ListTaskFlowTimeVariablesResponse listTaskFlowTimeVariablesWithOptions(shared_ptr<ListTaskFlowTimeVariablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskFlowTimeVariablesResponse listTaskFlowTimeVariables(shared_ptr<ListTaskFlowTimeVariablesRequest> request);
  ListTaskFlowsByPageResponse listTaskFlowsByPageWithOptions(shared_ptr<ListTaskFlowsByPageRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTaskFlowsByPageResponse listTaskFlowsByPage(shared_ptr<ListTaskFlowsByPageRequest> request);
  ListTasksInTaskFlowResponse listTasksInTaskFlowWithOptions(shared_ptr<ListTasksInTaskFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTasksInTaskFlowResponse listTasksInTaskFlow(shared_ptr<ListTasksInTaskFlowRequest> request);
  ListUserPermissionsResponse listUserPermissionsWithOptions(shared_ptr<ListUserPermissionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserPermissionsResponse listUserPermissions(shared_ptr<ListUserPermissionsRequest> request);
  ListUserTenantsResponse listUserTenantsWithOptions(shared_ptr<ListUserTenantsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserTenantsResponse listUserTenants(shared_ptr<ListUserTenantsRequest> request);
  ListUsersResponse listUsersWithOptions(shared_ptr<ListUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUsersResponse listUsers(shared_ptr<ListUsersRequest> request);
  ListWorkFlowNodesResponse listWorkFlowNodesWithOptions(shared_ptr<ListWorkFlowNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkFlowNodesResponse listWorkFlowNodes(shared_ptr<ListWorkFlowNodesRequest> request);
  ListWorkFlowTemplatesResponse listWorkFlowTemplatesWithOptions(shared_ptr<ListWorkFlowTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkFlowTemplatesResponse listWorkFlowTemplates(shared_ptr<ListWorkFlowTemplatesRequest> request);
  MakeTaskFlowInstanceSuccessResponse makeTaskFlowInstanceSuccessWithOptions(shared_ptr<MakeTaskFlowInstanceSuccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MakeTaskFlowInstanceSuccessResponse makeTaskFlowInstanceSuccess(shared_ptr<MakeTaskFlowInstanceSuccessRequest> request);
  ModifyDataCorrectExecSQLResponse modifyDataCorrectExecSQLWithOptions(shared_ptr<ModifyDataCorrectExecSQLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDataCorrectExecSQLResponse modifyDataCorrectExecSQL(shared_ptr<ModifyDataCorrectExecSQLRequest> request);
  ModifyDesensitizationStrategyResponse modifyDesensitizationStrategyWithOptions(shared_ptr<ModifyDesensitizationStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDesensitizationStrategyResponse modifyDesensitizationStrategy(shared_ptr<ModifyDesensitizationStrategyRequest> request);
  ModifyInstanceResponse modifyInstanceWithOptions(shared_ptr<ModifyInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceResponse modifyInstance(shared_ptr<ModifyInstanceRequest> request);
  MoveTaskFlowToScenarioResponse moveTaskFlowToScenarioWithOptions(shared_ptr<MoveTaskFlowToScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveTaskFlowToScenarioResponse moveTaskFlowToScenario(shared_ptr<MoveTaskFlowToScenarioRequest> request);
  OfflineTaskFlowResponse offlineTaskFlowWithOptions(shared_ptr<OfflineTaskFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OfflineTaskFlowResponse offlineTaskFlow(shared_ptr<OfflineTaskFlowRequest> request);
  PauseDataCorrectSQLJobResponse pauseDataCorrectSQLJobWithOptions(shared_ptr<PauseDataCorrectSQLJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PauseDataCorrectSQLJobResponse pauseDataCorrectSQLJob(shared_ptr<PauseDataCorrectSQLJobRequest> request);
  PreviewWorkflowResponse previewWorkflowWithOptions(shared_ptr<PreviewWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PreviewWorkflowResponse previewWorkflow(shared_ptr<PreviewWorkflowRequest> request);
  PublishAndDeployTaskFlowResponse publishAndDeployTaskFlowWithOptions(shared_ptr<PublishAndDeployTaskFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishAndDeployTaskFlowResponse publishAndDeployTaskFlow(shared_ptr<PublishAndDeployTaskFlowRequest> request);
  QueryDataTrackResultDownloadStatusResponse queryDataTrackResultDownloadStatusWithOptions(shared_ptr<QueryDataTrackResultDownloadStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDataTrackResultDownloadStatusResponse queryDataTrackResultDownloadStatus(shared_ptr<QueryDataTrackResultDownloadStatusRequest> request);
  ReDeployLhDagVersionResponse reDeployLhDagVersionWithOptions(shared_ptr<ReDeployLhDagVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReDeployLhDagVersionResponse reDeployLhDagVersion(shared_ptr<ReDeployLhDagVersionRequest> request);
  ReRunTaskFlowInstanceResponse reRunTaskFlowInstanceWithOptions(shared_ptr<ReRunTaskFlowInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReRunTaskFlowInstanceResponse reRunTaskFlowInstance(shared_ptr<ReRunTaskFlowInstanceRequest> request);
  RefundPayAsYouGoOrderResponse refundPayAsYouGoOrderWithOptions(shared_ptr<RefundPayAsYouGoOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefundPayAsYouGoOrderResponse refundPayAsYouGoOrder(shared_ptr<RefundPayAsYouGoOrderRequest> request);
  RegisterInstanceResponse registerInstanceWithOptions(shared_ptr<RegisterInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterInstanceResponse registerInstance(shared_ptr<RegisterInstanceRequest> request);
  RegisterUserResponse registerUserWithOptions(shared_ptr<RegisterUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterUserResponse registerUser(shared_ptr<RegisterUserRequest> request);
  RestartDataCorrectSQLJobResponse restartDataCorrectSQLJobWithOptions(shared_ptr<RestartDataCorrectSQLJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartDataCorrectSQLJobResponse restartDataCorrectSQLJob(shared_ptr<RestartDataCorrectSQLJobRequest> request);
  ResumeTaskFlowInstanceResponse resumeTaskFlowInstanceWithOptions(shared_ptr<ResumeTaskFlowInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeTaskFlowInstanceResponse resumeTaskFlowInstance(shared_ptr<ResumeTaskFlowInstanceRequest> request);
  RetryDataCorrectPreCheckResponse retryDataCorrectPreCheckWithOptions(shared_ptr<RetryDataCorrectPreCheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetryDataCorrectPreCheckResponse retryDataCorrectPreCheck(shared_ptr<RetryDataCorrectPreCheckRequest> request);
  RevokeTemplateAuthorityResponse revokeTemplateAuthorityWithOptions(shared_ptr<RevokeTemplateAuthorityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeTemplateAuthorityResponse revokeTemplateAuthority(shared_ptr<RevokeTemplateAuthorityRequest> request);
  RevokeUserPermissionResponse revokeUserPermissionWithOptions(shared_ptr<RevokeUserPermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeUserPermissionResponse revokeUserPermission(shared_ptr<RevokeUserPermissionRequest> request);
  SearchDataTrackResultResponse searchDataTrackResultWithOptions(shared_ptr<SearchDataTrackResultRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchDataTrackResultResponse searchDataTrackResult(shared_ptr<SearchDataTrackResultRequest> request);
  SearchDatabaseResponse searchDatabaseWithOptions(shared_ptr<SearchDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchDatabaseResponse searchDatabase(shared_ptr<SearchDatabaseRequest> request);
  SearchTableResponse searchTableWithOptions(shared_ptr<SearchTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTableResponse searchTable(shared_ptr<SearchTableRequest> request);
  SetOwnersResponse setOwnersWithOptions(shared_ptr<SetOwnersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetOwnersResponse setOwners(shared_ptr<SetOwnersRequest> request);
  SkipDataCorrectRowCheckResponse skipDataCorrectRowCheckWithOptions(shared_ptr<SkipDataCorrectRowCheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SkipDataCorrectRowCheckResponse skipDataCorrectRowCheck(shared_ptr<SkipDataCorrectRowCheckRequest> request);
  StopTaskFlowInstanceResponse stopTaskFlowInstanceWithOptions(shared_ptr<StopTaskFlowInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopTaskFlowInstanceResponse stopTaskFlowInstance(shared_ptr<StopTaskFlowInstanceRequest> request);
  SubmitOrderApprovalResponse submitOrderApprovalWithOptions(shared_ptr<SubmitOrderApprovalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitOrderApprovalResponse submitOrderApproval(shared_ptr<SubmitOrderApprovalRequest> request);
  SubmitStructSyncOrderApprovalResponse submitStructSyncOrderApprovalWithOptions(shared_ptr<SubmitStructSyncOrderApprovalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitStructSyncOrderApprovalResponse submitStructSyncOrderApproval(shared_ptr<SubmitStructSyncOrderApprovalRequest> request);
  SuspendTaskFlowInstanceResponse suspendTaskFlowInstanceWithOptions(shared_ptr<SuspendTaskFlowInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendTaskFlowInstanceResponse suspendTaskFlowInstance(shared_ptr<SuspendTaskFlowInstanceRequest> request);
  SyncDatabaseMetaResponse syncDatabaseMetaWithOptions(shared_ptr<SyncDatabaseMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncDatabaseMetaResponse syncDatabaseMeta(shared_ptr<SyncDatabaseMetaRequest> request);
  SyncInstanceMetaResponse syncInstanceMetaWithOptions(shared_ptr<SyncInstanceMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncInstanceMetaResponse syncInstanceMeta(shared_ptr<SyncInstanceMetaRequest> request);
  UpdateAuthorityTemplateResponse updateAuthorityTemplateWithOptions(shared_ptr<UpdateAuthorityTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAuthorityTemplateResponse updateAuthorityTemplate(shared_ptr<UpdateAuthorityTemplateRequest> request);
  UpdateInstanceResponse updateInstanceWithOptions(shared_ptr<UpdateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateInstanceResponse updateInstance(shared_ptr<UpdateInstanceRequest> request);
  UpdateSLARulesResponse updateSLARulesWithOptions(shared_ptr<UpdateSLARulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSLARulesResponse updateSLARules(shared_ptr<UpdateSLARulesRequest> request);
  UpdateScenarioResponse updateScenarioWithOptions(shared_ptr<UpdateScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateScenarioResponse updateScenario(shared_ptr<UpdateScenarioRequest> request);
  UpdateStandardGroupResponse updateStandardGroupWithOptions(shared_ptr<UpdateStandardGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateStandardGroupResponse updateStandardGroup(shared_ptr<UpdateStandardGroupRequest> request);
  UpdateTaskConfigResponse updateTaskConfigWithOptions(shared_ptr<UpdateTaskConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskConfigResponse updateTaskConfig(shared_ptr<UpdateTaskConfigRequest> request);
  UpdateTaskContentResponse updateTaskContentWithOptions(shared_ptr<UpdateTaskContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskContentResponse updateTaskContent(shared_ptr<UpdateTaskContentRequest> request);
  UpdateTaskFlowConstantsResponse updateTaskFlowConstantsWithOptions(shared_ptr<UpdateTaskFlowConstantsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskFlowConstantsResponse updateTaskFlowConstants(shared_ptr<UpdateTaskFlowConstantsRequest> request);
  UpdateTaskFlowCooperatorsResponse updateTaskFlowCooperatorsWithOptions(shared_ptr<UpdateTaskFlowCooperatorsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskFlowCooperatorsResponse updateTaskFlowCooperators(shared_ptr<UpdateTaskFlowCooperatorsRequest> request);
  UpdateTaskFlowEdgesResponse updateTaskFlowEdgesWithOptions(shared_ptr<UpdateTaskFlowEdgesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskFlowEdgesResponse updateTaskFlowEdges(shared_ptr<UpdateTaskFlowEdgesRequest> request);
  UpdateTaskFlowNameAndDescResponse updateTaskFlowNameAndDescWithOptions(shared_ptr<UpdateTaskFlowNameAndDescRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskFlowNameAndDescResponse updateTaskFlowNameAndDesc(shared_ptr<UpdateTaskFlowNameAndDescRequest> request);
  UpdateTaskFlowNotificationResponse updateTaskFlowNotificationWithOptions(shared_ptr<UpdateTaskFlowNotificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskFlowNotificationResponse updateTaskFlowNotification(shared_ptr<UpdateTaskFlowNotificationRequest> request);
  UpdateTaskFlowOwnerResponse updateTaskFlowOwnerWithOptions(shared_ptr<UpdateTaskFlowOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskFlowOwnerResponse updateTaskFlowOwner(shared_ptr<UpdateTaskFlowOwnerRequest> request);
  UpdateTaskFlowRelationsResponse updateTaskFlowRelationsWithOptions(shared_ptr<UpdateTaskFlowRelationsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskFlowRelationsResponse updateTaskFlowRelations(shared_ptr<UpdateTaskFlowRelationsRequest> request);
  UpdateTaskFlowScheduleResponse updateTaskFlowScheduleWithOptions(shared_ptr<UpdateTaskFlowScheduleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskFlowScheduleResponse updateTaskFlowSchedule(shared_ptr<UpdateTaskFlowScheduleRequest> request);
  UpdateTaskFlowTimeVariablesResponse updateTaskFlowTimeVariablesWithOptions(shared_ptr<UpdateTaskFlowTimeVariablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskFlowTimeVariablesResponse updateTaskFlowTimeVariables(shared_ptr<UpdateTaskFlowTimeVariablesRequest> request);
  UpdateTaskNameResponse updateTaskNameWithOptions(shared_ptr<UpdateTaskNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskNameResponse updateTaskName(shared_ptr<UpdateTaskNameRequest> request);
  UpdateTaskOutputResponse updateTaskOutputWithOptions(shared_ptr<UpdateTaskOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskOutputResponse updateTaskOutput(shared_ptr<UpdateTaskOutputRequest> request);
  UpdateTaskTimeVariablesResponse updateTaskTimeVariablesWithOptions(shared_ptr<UpdateTaskTimeVariablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTaskTimeVariablesResponse updateTaskTimeVariables(shared_ptr<UpdateTaskTimeVariablesRequest> request);
  UpdateUserResponse updateUserWithOptions(shared_ptr<UpdateUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserResponse updateUser(shared_ptr<UpdateUserRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Dms-enterprise20181101

#endif
